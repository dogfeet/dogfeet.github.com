<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-06-10T03:43:59Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <entry>
    <title><![CDATA[ nodejs: node-fibers ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-fibers.html" />
    <updated>2012-06-09T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-fibers.html</id>
    <content type="html">
<![CDATA[
<p>JavaScript는 <a href="/articles/2012/coroutine.html">Coroutine</a>을 지원하지 않기 때문에 외부 모듈이 필요하다. 이 글에서는 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>로 node에서 Coroutine을 어떻게 응용해야 할지 알아본다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-fibers/puton-fiber.jpg" alt="fiberware" title="" /></p>

<p>(from <a href='http://www.fiberbaya.blogspot.kr/'><a href='http://www.fiberbaya.blogspot.kr/'>http://www.fiberbaya.blogspot.kr/</a></a>)</p>

<h2>node-fibers</h2>

<p>nodejs에 포함돼지도 않았고 안정성도 검증돼지 않았지만 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>를 사용하면 Coroutine 뿐만아니라 JavaScript에는 없는 sleep()이라든지 Generator라든지를 만들어 쓸 수 있다.</p>

<p>공식 페이지에 소개된 sleep()을 구현하는 코드를 보자.</p>

<pre><code>var Fiber = require('fibers');

function sleep(ms) {
    var fiber = Fiber.current;
    setTimeout(function() {
        fiber.run(); //ms후에 다시 깨운다.
    }, ms);
    Fiber.yield(); //여기서 멈추고
}

Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
console.log('back in main');
</code></pre>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>는 강력한 도구지만 실제 힘을 발휘하려면 gevent같은 게 필요하다. 기존 API를 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>을 적용해서 다시 구현할 수는 없다.</p>

<h3>멍키 패칭하고 싶다.</h3>

<p>Python에서는 gevent를 사용하면 IO api와 thread api를 모두 멍키 패칭해주므로 투명하게 Coroutine으로 코드의 가독성을 높일 수 있었다. 하지만, node에서는 쉽지 않다. JavaScript는 플랫폼 전반에 CPS 스타일이 뼛속까지 녹아 있어서 멍키 패칭할 동기 API가 부족하다. 예를 들어, 파일 IO에는(fs 모듈) <code>xxxSync</code> 메소드가 갖춰져 있지만, 소켓 IO에는(net 모듈) 없다.</p>

<p>다시 말해서 gevent 방식이 더 낫다고 생각하지만:</p>

<p>1) 멍키 패칭할 <code>xxxSync</code> 메소드가 필요하고<br />2) 멍키 패칭을 구현한 모듈도 필요하고<br />3) 그러려면 node-fiber가 정식으로 node에 포함되든 JavaScript 표준에 Coroutine이 도입되든 안정성과 지원도 필요하고<br />4) 주렁주렁...궁시렁궁시렁...</p>

<p>gevent의 아이디어를 그대로 node에서 사용할 수는 없다.</p>

<p>멍키 패칭이든 뭐든 기존 API를 Coroutine에서 사용할 수 있도록 해주는 도우미가 필요한데, <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에는 Future라는 게 있다. Future는 Node의 비동기 API를 감싸서(wrap) Cotoutine을 사용할 수 있게 해준다.</p>

<h3>ls.js</h3>

<p>다음 예제는 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에서 Future를 설명하는데 보여주는 것이다. fs.readdir과 fs.stat를 감싸서 순차적으로 사용하는 것을 볼 수 있다:</p>

<pre><code>var Future = require('fibers/future'), wait = Future.wait;
var fs = require('fs');

// This wraps existing functions assuming the last argument of the passed
// function is a callback. The new functions created immediately return a
// future and the future will resolve when the callback is called (which
// happens behind the scenes).
var readdir = Future.wrap(fs.readdir);
var stat = Future.wrap(fs.stat);

Fiber(function() {
    // Get a list of files in the directory
    var fileNames = readdir('.').wait();
    console.log('Found '+ fileNames.length+ ' files');

    // Stat each file
    var stats = [];
    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        stats.push(stat(fileNames[ii]));
    }
    wait(stats);

    // Print file size
    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        console.log(fileNames[ii]+ ': '+ stats[ii].get().size);
    }
}).run();
</code></pre>

<p>이 코드를 CPS 스타일의 코드로 바꾸면 다음과 같다:</p>

<pre><code>var fs = require('fs');

fs.readdir('.', function(err, fileNames){
    console.log('Found '+ fileNames.length+ ' files');

    // Stat each file
    fileNames.forEach(function(fileName){
        fs.stat( fileName, function(err, stat){
            console.log( fileName + ': '+ stat.size);
        });
    });
});
</code></pre>

<p>이 예제에서 알 수 있듯이 node에서는 CPS 스타일을 사용하는 게 더 낫다. 언어에서 <a href="/articles/2012/coroutine.html">Coroutine</a>을 정식 지원하는 것도 아니고 API도 준비돼 있지 않다. 환경이 준비됐다고 가정하고 스케쥴링을 목적으로 하는 것이라면 Coroutine이 더 낫다고 볼 수 있지만 적어도 아직은 node에서 CPS가 더 나을지도...</p>

<p>아무튼 <code>for</code>문을 <code>forEach</code>로 바꿀 수밖에 없다. 예를 들어 다음과 같은 코드는 ii 값이 변하기 때문에 동작하지 않는다:</p>

<pre><code>    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        fs.stat( fileName[ii], function(err, stat){
            console.log( fileName[ii] + ': '+ stat.size);
        });
    }
</code></pre>

<p>JavaScript의 가장 큰 문제는 매일매일 단련해야 한다는 것 같다. 하루라도 안 하면 잊어버려서 꼭 다음번에 삽질한다.</p>

<h3>Future</h3>

<p>Future는 Node API 컨벤션이 일정한 것을 이용한다. node API는 <code>api(..., callback(err, ...))</code> 형식으로 돼 있기 때문에 이점을 이용한다. callback()으로 결과가 반환될 때까지 yield()시켰다가 callback()이 호출돼서 api 결과를 알게 되면 다시 resume 시킨다.</p>

<p>이 내용은 다음과 같이 생각하면 된다. 다음과 같은 코드를 추상화시킨 것이 future라고 생각하면 된다:</p>

<pre><code>function future_wrap(){
    fiber = fiber.current;

    api(..., callback(err, data){
        fiber.run();
    });

    Fiber.yield();
}
</code></pre>

<p>그러니까 (직접 구현해보지 않았지만) 자체제작 api를 만든다면 표준 컨벤션을 지켜서 구현해야 Future를 사용할 수 있고 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>도 사용하기 쉽다. 아예 api를 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에 의존하게 하여도 되지만 권하고 싶지 않다.</p>

<p>실제 Future.wrap() 코드를 보면 아예 api를 감싸버린다:</p>

<pre><code>Future.wrap = function(fn, idx) {
    idx = idx === undefined ? fn.length - 1 : idx;
    return function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length &gt; idx) {
            throw new Error('function expects no more than '+ idx+ ' arguments');
        }
        var future = new Future;
        args[idx] = future.resolver();
        fn.apply(this, args);
        return future;
    };
};
</code></pre>

<p>resolver()가 api 콜백인데 다음과 같이 생겼다:</p>

<pre><code>resolver: function() {
    return function(err, val) {
        if (err) {
            this.throw(err);
        } else {
            this.return(val);
        }
    }.bind(this);
}
</code></pre>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>의 future.js 코드는 흥미롭다. 분석해보면 재밌을 거로 생각하지만 공부했던 것을 잊어버려서(게을러서) 나중으로 미뤄야겠다.</p>

<p>지구가 멸망하기 전에 <code>Secrets of the JavaScript Ninja</code>가 출간되는 날이 오면 그때나 다시 공부하고 분석해봐야겠다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ iamport: python ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/iamport-python.html" />
    <updated>2012-06-01T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/iamport-python.html</id>
    <content type="html">
<![CDATA[
<p>포트가 열렸는지 확인하는 프로그램을 작성했다. 100개쯤되는 포트를 확인해보라고 해서 만들었는데, 이 참에 gevent를 적용해보았다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/iamport/iamport.jpg" alt="iamport" title="" /></p>

<p>(from <a href='http://www.portofamsterdam.com/'><a href='http://www.portofamsterdam.com/'>http://www.portofamsterdam.com/</a></a>)</p>

<p>주 플랫폼이 Java라서 예전엔 이런일을 groovy로 했었는데 python이 훨씬 쉽다.</p>

<h2>iamport</h2>

<p>다음은 포트가 열렸는지 순차적으로 확인하는 프로그램이다.</p>

<pre><code>#!/usr/bin/env python

import socket
import sys
import time
import re

def tryToConnect( argv ):
    ip=argv[0]
    port=int(argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )

    try:
        sock.connect( (ip, port) )
    except:
        print ip, port

    sock.close()

if __name__ == '__main__':

    stime=time.time()

    file = open(sys.argv[1])

    jobs = []

    while True:
        line = file.readline()

        if not line:
            break

        opts = re.split('\s*', line)

        if len(opts) &gt; 2:
            job = tryToConnect( opts )
            jobs.append( job )
        else:
            print opts[0]

    file.close()

    etime=time.time()

    print 'elapsed %f' % (etime - stime)
</code></pre>

<p>테스트할 포트 목록은 다음과 같은 파일을 파라미터로 넘겨주면 된다:</p>

<pre><code>127.0.0.1       22
127.0.0.1       21
168.126.63.1    18
18.18.18.18     18
18.18.18.18
74.125.235.180  80
</code></pre>

<p>그러면 입력 값이 잘못 됐거나 열리지 않는, 아무튼 예외가 발생하는 것만 출력한다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport.py port_scan 
127.0.0.1 22
127.0.0.1 21
168.126.63.1 18
18.18.18.18 18
18.18.18.18
elapsed 42.215497
</code></pre>

<p>100개 정도에 한번 해봤는데 27분 걸렸다.</p>

<h2>Coroutine</h2>

<p><a href="/articles/2012/coroutine.html">Coroutine</a>은 정말 유용하다. Python이 처음이라면 다음과 같은 글을 읽는 것이 도움이 된다.</p>

<ul>
<li><a href="http://blog.dahlia.pe.kr/articles/2009/09/15/python-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EB%B0%98%EB%B3%B5%EC%9E%90%EC%9D%98-%EB%A7%88%EB%B2%95">Python 제너레이터+반복자의 마법</a></li>
<li><a href="http://pyengine.blogspot.com/2011/07/python-coroutine-1.html">파이썬 코루틴 (python coroutine) - 1</a></li>
<li><a href="http://pyengine.blogspot.com/2011/07/python-coroutine-2.html">파이썬 코루틴 (python coroutine) - 2</a></li>
</ul>

<h2>gevent</h2>

<p>gevent를 이해하려면 eventlet을 알아봐야 하고:</p>

<ul>
<li><a href="http://ricanet.com/new/view.php?id=blog/111007">greenlet은 어떻게 구현했을까?</a></li>
<li><a href="http://blog.gevent.org/2010/02/27/why-gevent/">Comparing gevent to eventlet</a></li>
</ul>

<p>gevent의 적용은 너무 쉽다. 사실 세 줄만 바꿔주면 된다:</p>

<ol>
<li>멍키패칭으로 io api를 비동기+코루틴 방식의 구현체로 바꿔주고.</li>
<li>job들을 등록(spawn)하고서</li>
<li>join으로 다 끝나길 기다리면 된다(테스트는 안해봤지만 join이 호출될때 job이 실제로 시작하는 것 같다).</li>
</ol>

<h3>gevent 버전의 iamport</h3>

<p>아무리 내가 python을 잘 모른다지만 너무 간단하다. 눈이 의심스러울 정도로 간단하다.</p>

<pre><code>#!/usr/bin/env python

import socket
import sys
import time
import re
import gevent
import gevent.monkey

def tryToConnect( argv ):
    ip=argv[0]
    port=int(argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )

    try:
        sock.connect( (ip, port) )
    except:
        print ip, port

    sock.close()

if __name__ == '__main__':

    stime=time.time()

    #멍키패칭
    gevent.monkey.patch_all()

    file = open(sys.argv[1])

    jobs = []

    while True:
        line = file.readline()

        if not line:
            break

        opts = re.split('\s*', line)

        if len(opts) &gt; 2:
            #job을 spawn
            job = gevent.spawn(tryToConnect, opts )
            jobs.append( job )
        else:
            print opts[0]

    file.close()

    #spawn한 job이 모두 종료할 때까지 join
    gevent.joinall( jobs )

    etime=time.time()

    print 'elapsed %f' % (etime - stime)
</code></pre>

<p>27분 걸렸던게 27초만에 끝났다. 만세.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Coroutine ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/coroutine.html" />
    <updated>2012-05-26T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/coroutine.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="http://en.wikipedia.org/wiki/Coroutine">Wikipedia의 Coroutine</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/coroutine/source-code.png" alt="coroutine-python" title="" /></p>

<h2>Coroutine</h2>

<p>Coroutine은 컴퓨터 프로그램에서 엔트리 포인트가 여러 개인 Subroutine이다. 그래서 어디서든지 잠시 멈췄다가 다시 이어서 실행할 수 있다. Coroutine은 <a href="http://en.wikipedia.org/wiki/Cooperative_multitasking#Cooperative_multitasking.2Ftime-sharing">cooperative task</a>, <a href="http://en.wikipedia.org/wiki/Iterator">iterator</a>, <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">infinite list</a> and <a href="http://en.wikipedia.org/wiki/Pipeline_" title="software">pipe</a> 같은 것을 구현하기에 좋다.</p>

<p>"Coroutine"이라는 용어는 Melvin Conway가 1963년에 자신의 논문에서 처음 사용했다.</p>

<h2>Subroutine과 비교</h2>

<p>"Subroutine은 Coroutine 중 한 종류에 불과하다" - Donald Knuth]. Subroutine은 한번 실행하면 다 마칠 때까지 계속 실행되고 한번 호출할 때 한번 리턴한다. Coroutine도 이와 비슷하지만, Yield라는 것으로 빠져나오거나 다른 Coroutine을 호출해서 다시 해당 Coroutine이 하던 일을 이어서 할 수 있다.</p>

<p>그리고 Yield 없이 간단하게 Coroutine을 구현할 수도 있다.</p>

<p>언어를 개발할 때 Subroutine을 구현하려면 Subroutine을 실행하기 전에 스택을 하나 만들어야 한다. 하지만, Coroutine은 다른 Coroutine을 호출할 수 있어서 Continuation을 가지고 구현하는 것이 제일 좋다. Continuation은 스택이 여러 개 필요하기 때문에 보통 가비지컬렉터가 있는 언어에서 구현한다. 스택을 캐시해두거나 미리 할당하는 방식으로 좀 쉽게 Coroutine을 구현할 수 있다.</p>

<p>Coroutine이 얼마나 유용한지 보여 줄 수 있는 예제를 하나 보여주겠다. 소비자-생산자 관계인 Coroutine이 두 개 있다고 가정한다. 한쪽은 아이템을 생성해서 큐에 넣고 다른 쪽은 큐에서 아이템을 꺼내서 사용한다. 그리고 한꺼번에 아이템을 추가하거나 삭제해서 성능을 최적화할 수 있다. 이 내용을 코드로 구현하면 다음과 같다:</p>

<pre><code>var q := new queue

coroutine produce
    loop
        while q is not full
            create some new items
            add the items to q
        yield to consume

coroutine consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield to produce
</code></pre>

<p>큐가 다 차거나 다 비워지면 yield 명령어로 컨트롤를 다른 Coroutine에 양보한다. 그러면 그 Coroutine이 바로 시작한다.</p>

<p>이 예제는 멀티 Thread를 설명할 때 사용하는 예제랑 비슷하게 생겼지만, Thread를 두 개 만들지 않는다: 루틴이 돌다가 yield 구문을 만나면 다른 루틴으로 바로 점프한다.</p>

<h2>Coroutine과 Generator</h2>

<p>Generator도 Subroutine보다 넓은(generalisation) 개념이지만 Generator를 처음 볼 땐 Coroutine보다 후져 보인다. Generator는 기본적으로 Iterator 코드를 단순화할 목적으로 사용하기 때문에 Generator의 yield 구문은 다른 Coroutine으로 점프하는 게 아니라 호출한 상위 루틴으로 값을 넘겨준다. 하지만, Generator로 Coroutine을 구현할 수 있다. Generator를 호출하는 상위 루틴을 'Dispatcher'로(엄밀히 말하자면 <a href="http://en.wikipedia.org/wiki/Trampoline_" title="computing">Trampoline</a>) 구현하면 되는데 한 Generator가 반환한 토큰으로 다른 Generator를 실행한다.</p>

<pre><code>var q := new queue

generator produce
    loop
        while q is not full
            create some new items
            add the items to q
        yield consume

generator consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield produce

subroutine dispatcher
    var d := new dictionary(generator → iterator)
    d[produce] := start produce
    d[consume] := start consume
    var current := produce
    loop
        current := next d[current]
</code></pre>

<p>언어 차원에서 Coroutine을 지원하는 것도 많지만, native Coroutine이 없는 언어에서는 이렇게 많이들 구현한다. 예를 들어, Python 2.5 이전 버전에서는 이와 같은 방법을 사용했다.</p>

<h2>Coroutine의 용도</h2>

<p>Coroutine은 다음과 같은 것을 구현할 때 유용하다:</p>

<ul>
<li>Subroutine 하나로 구현하는 State-Machine에 유용하다.
이 머신의 State는 프로시저의 entry/exit point로 결정한다. 이렇게 하면 좀 더 가독성 높은 코드가 된다.</li>
<li>Concurrency에서 사용하는 Actor 모델에 유용하다. Actor마다 프로시저가 하나 있다(이 프로시저는 다시 여러 개로 나뉜다). 각 Actor는 스스로 스케쥴러에 컨트롤을 반환한다. 그래서 선점형 멀티태스킹 시스템처럼 차례로 실행된다.</li>
<li>Generator는 IO 처리나 자료구조를 Traverse하는 코드에 유용하다.</li>
</ul>

<h2>Coroutine을 지원하는 언어들</h2>

<p>Aikido, AngelScript, BCPL, Pascal, BETA, C#, ChucK, D, Dynamic C, Erlang, F#, Factor, GameMonkey, Go, Haskell, High Level Assembly, JavaScript(since 1.7), Icon, Io, Limbo, Lua, Lucid, µC++, MiniD, Modula-2, Nemerle, Perl(Perl 5 with Coro, Perl 6 native[citation needed]), Prolog, Python(since 2.5), Ruby, Sather, Scheme, Self, Simula-67, Squirrel, 스택less Python, SuperCollider, Tcl(since 8.6), urbiscript</p>

<p>Continuation으로도 Coroutine을 구현할 수 있어서 Continuation을 지원하는 언어라면 Coroutine은 쉽게 구현할 수 있다.</p>

<h2>Coroutine 대용으로 쓸 수 있는 것.</h2>

<p>Coroutine은 원래 assembly 수준 기술이지만 일부 high-level 언어에서만 지원한다. Coroutine을 지원하는 언어는 Simula나 Modula-2가 처음이었고 최근에는 Lua나 Go에서도 지원한다.</p>

<p>2003년 당시에는 C나 그 파생언어들이 인기가 높았다. 하지만, 그 언어들은 언어 자체나 표준 라이브러리에서 Coroutine을 지원하지 않았다. Subroutine이 스택을 사용하기 때문에 어려웠다.</p>

<p>그런 이유로 Coroutine 자체는 구현하기 어렵지 않은데도 쓸 수가 없었다. 이렇게 Coroutine을 못 쓸 때는 State 변수나 플래그 같은 것의 조합으로 내부 상태를 관리하는 Subroutine을 만들어 쓸 수 있다. State 변수가 어떠냐에 따라서 전혀 다른 코드가 수행되는 것을 이용하는 것이다. 아니면 복잡한 switch 구문을 많이 써서 explicit state machine을 만드는 방법도 있다. 그렇지만, 이런 방법은 만들기도 어렵고 관리하기도 어렵다.</p>

<p>Thread는 많이 사용하는 언어에서 Coroutine 대용으로 사용한다. Thread는 동시성(simultaneously)이라는 여러 코드가 동시에 실행할 수 있는 기능을 제공한다. C 환경이나 Native로 Thread를 지원하는 다른 언어에서 널리 쓰인다. 많은 프로그래머가 알고 있고, 구현체도 매우 많고, 문서도 넘쳐나고, 지원도 잘된다. 하지만, Thread는 어려운 문제를 다루고 있어서 좀 더 강력하지만 복잡한 내용을 배워야 한다. 그래서 상대적으로 배우기 어렵다. Coroutine은 별로 알아야 할 게 없다. Thread를 사용하는 것은 소 잡는 칼로 닭 잡는 격이다.</p>

<p>Thread와 Coroutine의 가장 중요한 차이는 Thread는 선점형 스케쥴링이지만 Coroutine은 아니라는 것이다. Thread는 아무 데서나 스케쥴이 변경되고 Concurrent하게 실행한다. Thread를 사용하면 Locking할 때 조심해야 한다. 반대로 Coroutine은 스케줄이 변경되는 곳이 정해져 있고 Concurrent하게 실행되지 않는다. Coroutine은 전체적으로 locking이 필요 없다. 보통 이 특징은 event-driven이나 비동기 방식을 설명할 때도 장점으로 설명하는 특징이다.</p>

<p>그리고 Fiber라는 게 있어서 Coroutine을 구현해 쓸 수 있다. 하지만, Thread와 비교하면 Fiber를 지원하는 시스템은 별로 없다.</p>

<h3>.NET 프레임웤에서 fiber로 Coroutine 구현하기</h3>

<p>.NET 프레임웤 2.0을 개발하면서 Microsoft는 fiber기반 스케줄링을 다룰 수 있도록 CLR(Common Langauge Runtime) 호스팅 API의 설계를 확장했다. 이것은 SQL 서버의 fiber-mode를 사용할 수 있도록 하기 위함이다. 릴리즈할 때에는 시간 제약사항(constraints) 때문에 타스크 스위칭을 지원하는 ICLRTask:SwitchOut을 제거했다. 그래서 타스크를 스위칭에 필요한 fiber API는 현재 .NET 프레임웤에서는 사용할 수 없다.</p>

<h3>Mono에서의 Coroutine</h3>

<p>Mono CLR은 Continuation을 지원하기 때문에 coroutine을 만들 수 있다.</p>

<h3>Java에서의 Coroutine</h3>

<p>Java는 추상화 때문에 Coroutine을 구현하기 어려운데도 구현체가 네 가지나 된다. JVM에서 불가능한 것은 아니다.</p>

<ul>
<li>JVM 수정 버전들. Native로 Coroutine을 지원하도록 JVM을 Patch할 수 있다. Da Vinci JVM에는 해당 패치가 있다.</li>
<li>바이트코드 수정 버전들. Coroutine은 Java 바이트코드를 수정해서 구현할 수도 있다. 컴파일할 때 수정할 수도 있고 실행할 때 수정할 수도 있다. <a href="http://code.google.com/p/coroutines/">Java Coroutine</a> 프로젝트가 있다.</li>
<li>JNI로 구현. 해당 플랫폼용으로 구현된 C 라이브러리로 JVM에서 Coroutine을 사용한다.</li>
<li>Thread를 이용. 무겁디무거운(heavywight) 쓰레드로 Coroutine 라이브러리를 구현할 수도 있다. 성능은 JVM의 Thread 구현체에 따라 다르다.</li>
</ul>

<h3>C에서의 Coroutine</h3>

<p>다양한 시도가 있었는데 구현 정도가 다르다. C에서는 Subroutine과 마크로를 사용해서 Coroutine을 구현한다. 이 방법으로 구현한 것 중에서는 Simon Tatham이 구현한 것이 좋다. Tatham은 주석에서 이 방법의 한계를 잘 설명한다. 이 방법은 아직 논쟁`의 여지가 남아 있지만, 코드를 작성하기도 쉽고, 읽기도 쉽고, 관리하기도 쉽다. Tatham이 말하길 "물론, 이 방법은 책에서 말하는 코딩 규칙에 어긋난다. 하지만, 모든 코딩 규칙은 알고리즘의 명확성을 대가로 문법적 명확성을 얻는 방법들이다. 이 방법을 사용하자고 사장에게 말하면 사장는 분명히 그 직원을 건물 밖으로 드래그해버리라고 경비에게 소리칠 것이다"</p>

<p>Coroutine을 구현하는 좀 더 믿음직한 방법이 있는데, 대신 이식성이 떨어지고 특정 프로세서에서만 사용할 수 있다. 어셈블리 수준에서 Coroutine 컨텍스트를 저장했다가 다시 복원하는 기능이 있는 프로세서에서만 사용할 수 있다. 표준 C 라이브러리에는 setjmp와 longjmp 함수가 있어서 Coroutine 비슷하게 구현할 수 있다. 그런데 Harbison과 Steele은 "setjmp와 longjmp 함수로 구현하는 것은 매우 어렵다고 알려져 있다. 프로그래머는 setjmp와 longjmp에 대해 어떠한 가정도 하지 말하야 한다"라고 말한다. Harbison과 Steele이 말한 주의 사항과 제약 사항들은 무엇을 의미하는 걸까? setjmp와 longjmp를 사용해서 Coroutine을 구현했다 한들 다른 환경으로 옮기면 작동하지 않는다. 더욱 나쁜 것은 잘못 구현한 것들도 적지 않다. setjmp/longjmp는 실제로 스택 하나로 구현하는 거라서 제대로 된 Coroutine을 구현할 수 없다. 스택이 하나뿐이기 때문에 엉뚱한 Coroutine이 스택에 있는 변수를 수정해 버릴 수 있다.</p>

<p>그래서 C에서 스택기반 Coroutine을 구현하려면 스택을 만들고 점프할 수 있는 기능이 필요하다. 세 번째는 특정 머신에서만 동작하는 C로(machine-specific C) 작성하는 방법이다. 이 방법은 Coroutine용 컨텍스트가 지원돼야 한다. POSIX나 <a href="http://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%9C%A0%EB%8B%89%EC%8A%A4_%EA%B7%9C%EA%B2%A9">Single UNIX Specification</a>의 C 라이브러리에는 getcontext, setcontext, makecontext, swapcontext같은 루틴이 있다. setcontext류 함수들은 setjmp/longjmp 함수보다 상당히 강력하다. 하지만, 표준을 준수하는 구현체는 흔치않다. 이 방법의 최대 단점은 Coroutine의 스택 크기가 고정돼 있다는 것이다. 그래서 실행 중에 스택 크기는 커지지 않는다. 그래서 사람들은 스택 오버플로우를 예방하는 차원에서 처음부터 너무 큰 스택을 할당하는 경향이 있다.</p>

<p>표준 라이브러리의 한계 때문에 사람들은 직접 Coroutine 라이브리를 만들어 사용한다. Russ Cox가 만든 libtask라는 게 있는데 꽤 좋다. Native C 라이브러리에 context 함수가 있으면 그냥 그걸 사용하고 그게 아니면 자체적으로 구현한 ARM, PowerPC, Sparc, x86용 라이브러리를 사용한다. 그 외 살펴볼 만한 라이브러리로 libpcl, coro, lthread, libCoroutine, libconcurrency, libcoro가 있다.</p>

<h3>C++에서의 Coroutine</h3>

<ul>
<li>Boost.Coroutine - Giovanni P. Deretta는 "Google Summer of Code 2006" 프로젝트로 이 라이브러리를 만들었다. 이 포터블한 Coroutine 라이브러리는 boost와 C++ 템플릿을 사용해서 만들었다. Boost.Coroutine은 아직 마무리되지 않았고 boost 공식 라이브러리가 아니므로 문서는 boost 싸이트가 아닌 다른 곳에서 호스팅하고 있다.</li>
<li>Mordor - Mozy는 2010년에 C++ Coroutine 라이브러리를 만들었다. 비동기 I/O를 사용하는 순차(sequential) 프로그래밍 모델처럼 사용할 수 있게 하였다.</li>
</ul>

<h3>C#에서의 Coroutine</h3>

<ul>
<li>MindTouch Dream - MindTouch Dream REST 프레임웤은 C# 2.0의 iterator 패턴으로 구현한 Coroutine이 들어 있다.</li>
<li>Caliburn - WPF용 Caliburn 스크린 패턴 프레임웤은 C# 2.0의 iterator를 사용해서 UI 프로그래밍과 비동기 씨나리오를 좀 더 쉽게 구현할 수 있게 하였다.</li>
<li>Power Threading Library - Jeffrey Richter가 만든 Power Threading Library에는 AsyncEnumerator라는 게 있다. 그래서 Coroutine 기반으로 비동기 프로그래밍을 쉽게 할 수 있다.</li>
<li>Sevletat Pieces - Yevhen Bobrov가 만든 Servelat Pieces 프로젝트는 Silverlight WCF 서비스에 비동기를 투명하게(transparent asynchrony) 제공하고 동기 콜을 비동기적으로 호출하는 방법도 제공한다.</li>
<li><a href="http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx">13</a> - .NET 프레임웤은 2.0+ 부터 자체적으로 iterator 패턴과 yield 키워드로 coroutine을 제공한다. </li>
</ul>

<h3>Python에서의 Coroutine</h3>

<ul>
<li><a href="http://www.python.org/peps/pep-0342.html">PEP 342</a> - Pythone 2.5에 확장된 Generator를 기반으로 Coroutine 같은 기능을 구현하기 쉬워졌다.</li>
<li><a href="http://codespeak.net/py/0.9.2/greenlet.html">Greenlets</a></li>
<li><a href="http://www.async.com.br/projects/kiwi/api/kiwi.tasklet.html">kiwi tasklets</a></li>
<li><a href="http://pypi.python.org/pypi/multitask">multitask</a></li>
<li><a href="http://chiral.j4cbo.com/trac">chiral</a></li>
<li><a href="http://code.google.com/p/cogen">cogen</a></li>
<li><a href="http://www.kamaelia.org/">Kamaelia</a></li>
<li><a href="https://github.com/ironport/shrapnel/">Shrapnel</a></li>
</ul>

<h3>Ruby에서의 Coroutine</h3>

<ul>
<li>Ruby 1.9은 fiber로 구현한 Coroutine을 지원한다.</li>
<li><a href="http://liber.sourceforge.net/coroutines.rb">Marc De Scheemaecker가 만든 것도 있다</a></li>
</ul>

<h3>Perl에서의 Coroutine</h3>

<ul>
<li><a href="http://search.cpan.org/dist/Coro/">Coro</a></li>
</ul>

<p>Perl 6 부터 Coroutine을 지원한다.</p>

<h3>Smalltalk에서의 Coroutine</h3>

<p>Smalltalk에서는 실행 스택이 First-class citizen이기 때문에 VM이 지원이나 다른 라이브러리 필요없이 Coroutine을 구현할 수 있다.</p>

<h3>Scheme에서의 Coroutine</h3>

<p>Since Scheme provides full support for continuations, the implementation of coroutines is nearly trivial, requiring only that a queue of continuations be maintained.</p>

<h3>Delphi에서의 Coroutine</h3>

<ul>
<li>Bart van der Werf가 만든 <a href="http://www.festra.com/wwwboard/messages/12899.html">Coroutine 함수</a>가 있는데 정말 작고 좋다.</li>
<li>Sergey Antonov는 <a href="http://hallvards.blogspot.com/2007/10/sergey-antonov-implements-yield-for.html">C# Yield를 델파이에서 구현했다</a>.</li>
</ul>

<h3>assembly에서의 Coroutine</h3>

<p>(이 부분은 이해할 수 없군요)</p>

<p>Machine-dependent assembly languages often provide direct methods for coroutine execution. For example, in MACRO-11, the assembly language of the PDP-11 family of minicomputers, the “classic” coroutine switch is effected by the instruction "JSR PC,@(SP)+" (which assembles as octal "004736") which jumps to the address popped from the stack and pushes the current (i.e that of the next) instruction address onto the stack. On VAXen (in Macro-32) the comparable instruction is "JSB @(SP)+" (which assembles as hex "9E 16" as the assembler shows it (with in effect bytes reversed). Even on a Motorola 6809 there is the instruction "JSR [,S++]", which assembles as (hex) "AD F1"; note the "++", as 2 bytes (of address) are popped from the stack. This instruction is much used in the (standard) 'monitor' Assist 09.</p>

<p>Simply calling back the routine whose address is on the top of the stack, does not, of course, exhaust the possibilities in assembly language(s)!</p>

<h2>See also</h2>

<ul>
<li>Unix pipes – 프로그램끼리 통신하는 데 사용하는 pipe도 Coroutine의 한 종류다.</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ dogfeet-flavored-markdown ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/dogfeet-flavored-markdown.html" />
    <updated>2012-05-19T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/dogfeet-flavored-markdown.html</id>
    <content type="html">
<![CDATA[
<p>'dogfeet-flavored-markdown'은 Markdown에서 Twitter처럼 <code>@mention</code>, <code>#hash</code>와 같은 표현을 사용하고 싶어서 'github-flavored-markdown'을 수정했다.</p>

<p>아이디어를 정리하고 자료 조사를 끝낸건 3개월 전인데 게으름이 봄바람을 타고와 늦어 졌다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/dogfeet-flavored-markdown/keyboard.png" alt="keyboard" title="" /></p>

<p>이 글을 읽기 전에 <a href="http://github.github.com/github-flavored-markdown/">GitHub의 GitHub-Flavored-Markdown 설명서</a>를 읽어 보는 것이 좋다.</p>

<h2>github-flavored-markdown</h2>

<p>github-flavored-markdown은 다음과 같은 표현을 지원한다.</p>

<pre><code>* SHA: be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a>
* #Num: #1
* User/#Num: mojombo#1
* User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a>
</code></pre>

<p>하지만 실제로 작동하는 것은 '사용자/저장소' 패턴이 명시된 다음의 두 경우 뿐이다:</p>

<ul>
<li>User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a></li>
<li>User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a></li>
</ul>

<p>나머지 패턴도 동작하게 하려면 '사용자/저장소' 정보가 필요하다. github-flavored-markdown의 용법은 다음과 같은데 인자로 '사용자/저장소'를 넘겨줄 수 있다:</p>

<pre><code>var ghm = require("github-flavored-markdown")
ghm.parse("I **love** GHM.\n\n#2", "isaacs/npm")
// returns:
// '&lt;p&gt;I &lt;strong&gt;love&lt;/strong&gt; GHM.  '+
// '&lt;a href=\'<a href='http://github.com/isaacs/npm/issues/#issue/2\'&gt;#2&lt;/a&gt;&lt;/p&gt'><a href='http://github.com/isaacs/npm/issues/#issue/2\'&gt;#2&lt;/a&gt;&lt;/p&gt'>http://github.com/isaacs/npm/issues/#issue/2\'&gt;#2&lt;/a&gt;&lt;/p&gt</a></a>;'
</code></pre>

<p>그러면 나머지 패턴도 해당 저장소에 대한 GitHub 링크가 생성된다:</p>

<ul>
<li>SHA: be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2</li>
<li>User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2</li>
<li><a href="/site/tagmap.html#Num">#Num</a>: <a href="/site/tagmap.html#1">#1</a></li>
<li>User/#Num: mojombo#1</li>
</ul>

<p>하지만 custom 하게 수정이 필요하고, 특히 [Docpad][]의 Markdown 을 수정해서 하드코딩하거나 이 정보를 설정할 수 있도록 수정해야 한다.</p>

<h2>dogfeet-flavored-markdown</h2>

<p>dogfeet-flavored-markdown(이하 DFM)은 DFM에서 '사용자/저장소' 정보가 필요한 나머지 패턴은 삭제했다. 그래서 다음과 같은 패턴만 사용할 수 있다:</p>

<ul>
<li>User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a></li>
<li>User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a></li>
</ul>

<p>대신 <code>@mention</code>과 <code>#hash</code>를 추가 했다. 정확한 패턴은 다음과 같다:</p>

<ul>
<li>mention - <code>(^|[ \t]+)@([a-zA-Z0-9]+)</code></li>
<li>hash - <code>(^|[ \t]+)#([ㄱ-ㅎ가-힣a-zA-Z0-9]+)</code></li>
</ul>

<p>다시 말해서 줄 처음에 시작하는 <code>@mention</code>이나 앞에 공백(space, tab)문자가 있는 것만 인식한다.</p>

<p>이 규칙이 중요할 때가 있는데, <code>#</code>으로 Heading을 표현하는 Markdown에서 중요하다. 줄 맨앞에서 <code>#Heading</code>이라고 표현하면 DFM가 처리하는 것이 아니라 showdown 엔진이 처리하기 때문에 링크가 생성되지 않고 <code>&lt;h1&gt;Heading&lt;/h1&gt;</code>이라고 해석된다. 이 것은 해석하는 순서의 문제다.</p>

<p>그리고 <code>&lt;code&gt;</code> 블럭과 <code>&lt;a&gt;</code> 블럭에 있는 것은 무시한다. 간단히 말하면 <code>@mention</code>과 <a href="https://twitter.com/#!/mention">@mention</a>의 차이이고 <a href="http://twitter.com"><a href="https://twitter.com/#!/twitter">@twitter</a></a>와 <a href="https://twitter.com/#!/twitter">@twitter</a> 의 차이다. 원문은 다음과 같다:</p>

<pre><code>그리고 `&lt;code&gt;` 블럭과 `&lt;a&gt;` 블럭에 있는 것은 무시한다. 간단히 말하면 `@mention`과 @mention의 차이이고 [@twitter](<a href='http://twitter.com)와'><a href='http://twitter.com)와'>http://twitter.com)와</a></a> @twitter 의 차이다. 원문은 다음과 같다:
</code></pre>

<h3>예제</h3>

<p>이 것은 코드 블럭이 아니라 잘 된다:</p>

<ul>
<li>User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2</li>
<li>User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a></li>
<li><a href="/site/tagmap.html#Num">#Num</a>: <a href="/site/tagmap.html#1">#1</a></li>
<li>User/#Num: mojombo#1</li>
<li>User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a>, <code><a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a></code></li>
<li><a href="https://twitter.com/#!/pismute">@pismute</a></li>
<li><a href="/site/tagmap.html#EveryoneIsBeautiful">#EveryoneIsBeautiful</a> <code>, #EveryoneIsBeautiful,#EveryoneIsBeautiful</code></li>
<li><a href="/site/tagmap.html#한글">#한글</a> <code>, #한글,#한글</code></li>
</ul>

<p>(이글에서는 <code>#hash</code>는 Twitter가 아니라 이 블로그의 tagmap 페이지로 연결된다.)</p>

<p>다음은 코드 블럭이라 DFM은 동작하지 않는다. 하지만 GFM의 것은 코드 블럭의 것도 처리한다. 다시 말하지만 GFM의 것은 코드 블럭에서도 링크를 생성 하지만 Dogfeet에서 추가한 <code>@mention</code>과  <code>#hash</code>는 코드 블럭에서는 링크를 생성하지 않는다:</p>

<pre><code>* SHA: be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a>
* #Num: #1
* User/#Num: mojombo#1
* User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a>, `<a href='http://github.com/mojombo/god/issues/#issue/1'><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></a>`
* @pismute
* #EveryoneIsBeautiful `, #EveryoneIsBeautiful,#EveryoneIsBeautiful`
* #한글 `, #한글,#한글`
</code></pre>

<h3>Coding</h3>

<p>기본적으로 내장된 템플릿은 twitter로 연결된다. 그래서 <code>@mention</code>과 <code>#hash</code>를 클릭하면 twitter로 연결된다. 하지만 바꿀 수 있다.</p>

<pre><code>var templates={
  '@': function(key){ return ['@@', key].join(''); }
  , '#': function(key){ return ['##', key].join(''); }
}
var dfm = require("dogfeet-flavored-markdown");
gfm.parse("I **love** @DFM. #DFM", {templates:templates});
// returns:
// '&lt;p&gt;I &lt;strong&gt;love&lt;/strong&gt; @@DFM. ##DFM'
</code></pre>

<h3>설치</h3>

<p>이 모듈은 npmjs.org에 올릴 계획이 없다. 그러니 다음과 같이 설치해야 한다.</p>

<pre><code>npm install git://github.com/dogfeet/dogfeet-flavored-markdown.git#master
</code></pre>

<h2>Docpad Plugin</h2>

<p>Docpad Plugin을 만들어서 이 블로그에 했다. 다음은 Docpad Plugin이다:</p>

<pre><code># Export Plugin
module.exports = (BasePlugin) -&gt;
    # Define Plugin
    class DogdownPlugin extends BasePlugin
        # Plugin name
        name: 'dogdown'

        # Plugin priority
        priority: 700 

        templates:
            '@': ( key ) -&gt;
                ['&lt;a href="<a href='https://twitter.com/#!/'><a href='https://twitter.com/#!/'>https://twitter.com/#!/</a></a>', key, '"&gt;@', key, '&lt;/a&gt;'].join('')
                #['&lt;a href="<a href='https://github.com/'><a href='https://github.com/'>https://github.com/</a></a>', key, '"&gt;@', key, '&lt;/a&gt;'].join('')
            '#': ( key ) -&gt;
                ['&lt;a href="/site/tagmap.html#', key, '"&gt;#', key, '&lt;/a&gt;'].join('')

        # Render some content
        render: (opts,next) -&gt;
            # Prepare
            {inExtension,outExtension,templateData,content} = opts

            # Check our extensions
            if inExtension in ['md','markdown'] and outExtension is 'html'
                # Requires
                markdown = require('dogfeet-flavored-markdown')

                # Render
                opts.content = markdown.parse( content, { templates:@templates } ) 

            # Done, return back to DocPad
            return next()
</code></pre>

<p>templates을 수정해서 단순히 링크를 생성하는 것외에 통계나 문서의 메타 정보도 구할 수 있지만 그리하진 않았다.</p>

<h2>마치며</h2>

<p>이 모듈의 <a href="https://github.com/dogfeet/dogfeet-flavored-markdown">저장소</a>에 올려 두었다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: modules ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-modules.html" />
    <updated>2012-05-12T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-modules.html</id>
    <content type="html">
<![CDATA[
<p>읽고, 또 읽고, 또 읽어도 자꾸 까먹는다. 그래서 이번에는 번역을 해보기로 했다. 이 글은 nodejs의 <a href="http://nodejs.org/api/modules.html">modules</a>을 번역한 거다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-modules/hat-girl.jpg" alt="hat-girl" title="" /></p>

<p>('<a href="http://uniquenoun.tumblr.com/post/21839174721">모자라는 아이</a>' - Jiye Park, 2012)</p>

<p>이 글의 원문의 SHA값은 <code>1d5b6f2</code>이다. 나중에 버전이 바뀌었을 때 추적하기 위해 남긴다. 헷갈릴 수도 있으니, 번역하기 시작한 시점의 nodejs 안정 버전은 <code>v0.6.14</code>이다.</p>

<p><a href="https://twitter.com/#!/outsideris">@outsideris</a> 님이 node 번역 프로젝트를 시작하셨습니다. 그래서 그 저장소로 옮겼습니다. 이 글의 최신 버전은 <a href="https://github.com/outsideris/node">그쪽</a>에서 확인하세요.</p>

<h2>Modules</h2>

<!--
    Stability: 5 - Locked
-->

<!--name=module-->

<p>매우 간단하게 모듈을 로딩할 수 있다. 노드에서는 파일 하나가 모듈 하나다. 예를 들어 <code>foo.js</code> 파일에서 같은 디렉토리에 있는 <code>circle.js</code>를 로드하는 것을 살펴보자.</p>

<p><code>foo.js</code>:</p>

<pre><code>var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));
</code></pre>

<p><code>circle.js</code>:</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre>

<p><code>circle.js</code> 모듈은 <code>area()</code>와 <code>circumference()</code>를 Export했다. 뭔가 Export하려면 해당 객체를 <code>exports</code> 객체에 할당한다. <code>exports</code>는 Export하기 위해 사용하는 객체다.</p>

<p>로컬 변수는 모듈 외부에 노출되지 않는다(private). 이 예제에서 <code>PI</code>는 <code>circle.js</code>에서만 사용할 수 있는 private 변수다.</p>

<p>이 모듈 시스템은 <code>module</code>이라는 모듈에 구현했다.</p>

<h3>Cycles</h3>

<!--type=misc-->

<p>두 모듈이 <code>require()</code> 함수로 서로 참조할 때는 한쪽 모듈은 아직 완전히 로딩하지 못한 미완성 모듈을 그냥 반환한다.</p>

<p>이게 무슨 소리냐 하면:</p>

<p><code>a.js</code>:</p>

<pre><code>console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');
</code></pre>

<p><code>b.js</code>:</p>

<pre><code>console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');
</code></pre>

<p><code>main.js</code>:</p>

<pre><code>console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);
</code></pre>

<p><code>main.js</code>는 <code>a.js</code>를 로드하고, <code>a.js</code>는 <code>b.js</code>를 로드한다. 여기서 <code>b.js</code>는 다시 <code>a.js</code>를 로드하려고 한다. 무한 루프가 생기지 않도록 아직 미완성인 <code>a.js</code>의 exports 객체를 <code>b.js</code>에 반환해 버린다. 그리고 <code>b.js</code>가 완성되면 <code>a.js</code>에 반환된다.</p>

<p><code>main.js</code>이 두 모듈을 로드할 때는 이미 둘 다 완성됐다. 이 프로그램의 실행 결과는 다음과 같다:</p>

<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre>

<p>그러니까 꼭 모듈을 서로 참조하게 하여야 하면 계획을 잘 짜야 한다.</p>

<h3>Core Modules</h3>

<!--type=misc-->

<p>Node 모듈 중에서는 바이너리로 컴파일해야 하는 모듈이 있다. 코어 모듈은 이 문서 곳곳에서 설명한다.</p>

<p>코어 모듈은 Node 소스코드의 <code>lib/</code> 폴더에 들어 있다.</p>

<p>모듈을 require하면 항상 코어 모듈이 먼저 로드된다. 예를 들어, <code>require('http')</code>로 로드될 것 같은 파일이 있어도 Node에 들어 있는 HTTP 모듈이 반환된다.</p>

<h3>File Modules</h3>

<!--type=misc-->

<p>입력한 이름으로 파일을 못 찾으면 Node는 그 이름에 <code>.js</code>, <code>.json</code>, <code>.node</code>를 붙이고 해당 파일이 있는지 찾는다.</p>

<p><code>.js</code> 파일은 JavaScript 텍스트 파일로 Interpret하고 <code>.json</code>은 JSON 텍스트 파일로 Interpret한다. 그리고 <code>.node</code> 파일은 컴파일한 addon 모듈이라서 <code>dlopen</code>으로 로드한다.</p>

<p>모듈을 절대 경로로 찾을 때는 모듈 이름을 <code>'/'</code>로 시작하면 된다. 예를 들어, <code>require('home/marco/foo.js')</code>는 <code>/home/marco/foo.js</code> 파일을 로드한다.</p>

<p>모듈을 상대 경로로 찾으려면 모듈 이름이 <code>'./'</code>로 시작하면 된다. 즉, <code>foo.js</code>라는 파일에서 <code>require('./circle')</code>라고 호출하면 같은 디렉토리에 있는 <code>circle.js</code>를 로드한다.</p>

<p>'/'이나 './'로 시작하지 않으면 그냥 파일이 아니라 코어 모듈이나 <code>node_modules</code> 폴더에 있는 모듈을 찾는다.</p>

<p>모듈을 찾지 못하면 <code>require()</code>는 Error를 던진다. 이 에러의 code 프로퍼티의 값은 <code>'MODULE_NOT_FOUND'</code>이다.<br />(역주 - 어떻게 확인해봐야 할지 모르겠다. 아무튼, <a href="http://git.io/dmzSGw">참고1</a>, <a href="http://git.io/haOtcQ">참고2</a> )</p>

<h3>Loading from <code>node_modules</code> Folders</h3>

<!--type=misc-->

<p><code>require()</code>에 넘어온 모듈 ID가 네이티브 모듈을 가리키는 것도 아니고, 그 모듈 ID가 <code>'/'</code>, <code>'./'</code>, <code>'../'</code>로 시작하지도 않으면 Node는 그 모듈의 상위 디렉토리에서 찾기 시작한다. 상위 디렉토리에 있는 <code>/node_modules</code>에서 해당 모듈을 찾는다.</p>

<p>만약 못 찾으면 상위상위 디렉토리에서 찾고, 그래도 못 찾으면 상위상위상위 디렉토리에서 찾는다. 루트 디렉토리에 다다를 때까지 계속 찾는다.</p>

<p>예를 들어, <code>'home/ry/projects/foo.js'</code>라는 파일에서 <code>requre('bar.js')</code>라고 호출하면 다음과 같은 순서로 모듈을 찾는다:</p>

<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>

<p>그래서 해당 프로그램만의 의존성을 독립적으로 관리할 수 있다. 다른 프로그램에 영향을 끼치지 않는다.</p>

<h3>Folders as Modules</h3>

<!--type=misc-->

<p>모듈을 폴더로 관리하면 프로그램과 라이브러리를 묶음으로 관리할 수 있어 편리하다. 마치 한 파일로 된 모듈처럼 취급한다. 모듈이 폴더일 때 <code>require()</code>는 세 가지 방법으로 모듈을 찾는다.</p>

<p>프로그램 폴더에 <code>package.json</code> 파일을 만들고 main 모듈이 무엇인지 적는다:</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }
</code></pre>

<p>이 파일이 <code>./some-library</code>라는 폴더에 있다고 하고, <code>require('./some-library')</code>를 호출하면 <code>./some-library/lib/some-library.js</code>를 찾아 로드한다.</p>

<p>Node가 package.json을 읽고 사용하기 때문에 이런 게 가능하다.</p>

<p>그 디렉토리에 package.json 파일이 없으면 Node는 <code>index.js</code>나 <code>index.node</code> 파일을 찾는다. package.json 파일이 없으면 <code>require('./some-library')</code>는 다음과 같은 파일을 로드한다:</p>

<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>

<h3>Caching</h3>

<!--type=misc-->

<p>한 번 로드한 모듈은 계속 캐싱한다. 그래서 <code>require('foo')</code>을 여러 번 호출해도 계속 같은 객체를 반환한다. 단, `require('foo')가 계속 같은 파일을 로드할 때만 그렇다.</p>

<p><code>require('foo')</code>를 여러 번 호출해도 해당 모듈 코드는 단 한 번만 호출된다. 그리고 아직 미완성인 객체가 반환될 수 있다는 점까지 더하면 특정 모듈이 서로 의존하고 있어도 성공적으로 로드되는 마법이 이루어진다.</p>

<p>어떤 코드가 꼭 여러 번 호출돼야 하면 함수 자체를 Export하고 그 함수를 여러 번 호출하라.</p>

<h4>Module Caching Caveats</h4>

<!--type=misc-->

<p>모듈은 찾은(resolved) 파일 이름을 키로 캐싱한다. <code>node_modules</code> 폴더에서 로딩하는 것이기 때문에 같은 require 코드라도 호출하는 위치에 따라 찾은 파일이 다를 수 있다. 즉, <code>require('foo')</code>가 다른 파일을 찾아낸다면 다른 객체를 리턴한다.</p>

<h3>The <code>module</code> Object</h3>

<!-- type=var -->

<!-- name=module -->

<ul>
<li>{Object}</li>
</ul>

<p>모듈에서 <code>module</code> 변수는 해당 모듈 객체를 가리킨다. 특히 <code>module.exports</code>는 <code>exports</code>와 같은 객체를 가리킨다. <code>module</code>은 글로벌 변수가 아니라 모듈마다 다른 객체를 가리키는 로컬 변수다.</p>

<h4>module.exports</h4>

<ul>
<li>{Object}</li>
</ul>

<p><code>exports</code> 객체는 Module 시스템이 자동으로 만들어 준다. Export하려는 객체를 <code>module.exports</code>에 할당해서 직접 만든 객체가 반환되게 할 수도 있다. <code>.js</code>라는 모듈을 만들어 보자:</p>

<pre><code>var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);
</code></pre>

<p>이 모듈은 다음과 같이 사용한다:</p>

<pre><code>var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});
</code></pre>

<p><code>module.exports</code>에 할당하는 것은 바로 실행되도록 해야 한다. 콜백으로 할당문이 실행되는 것을 미루면 뜻대로 동작하지 않는다. 다음과 같이 하지 마라:</p>

<p>x.js:</p>

<pre><code>setTimeout(function() {
  module.exports = { a: "hello" };
}, 0);
</code></pre>

<p>y.js:</p>

<pre><code>var x = require('./x');
console.log(x.a);
</code></pre>

<h4>module.require(id)</h4>

<ul>
<li><code>id</code> {String}</li>
<li>Return: {Object} <code>exports</code> from the resolved module</li>
</ul>

<p><code>module.require</code> 메소드로 모듈을 로드하면 해당 모듈에서 require()를 호출하는 것처럼 모듈을 로드한다.</p>

<p>이 메소드를 호출하려면 일단 <code>module</code> 객체의 레퍼런스를 얻어야 한다. <code>module</code> 객체의 레퍼런스는 해당 모듈에서만 접근할 수 있고 <code>require()</code>는 <code>module</code>이 아니라 <code>exports</code>를 리턴하기 때문에 해당 모듈에서 module 객체의 레퍼런스를 직접 리턴해야 한다.</p>

<h4>module.id</h4>

<ul>
<li>{String}</li>
</ul>

<p>모듈 ID인데 보통은 모듈 파일의 전체 경로를 사용한다.</p>

<h4>module.filename</h4>

<ul>
<li>{String}</li>
</ul>

<p>모듈 파일의 전체 경로(fully resolved filename).</p>

<h4>module.loaded</h4>

<ul>
<li>{Boolean}</li>
</ul>

<p>모듈이 로드하고 있는 중인지 다 로드했는지를 나타낸다.</p>

<h4>module.parent</h4>

<ul>
<li>{Module Object}</li>
</ul>

<p>모듈을 require한 모듈을 가리킨다.</p>

<h4>module.children</h4>

<ul>
<li>{Array}</li>
</ul>

<p>모듈이 require한 모듈 객체를 가리킨다.</p>

<h3>All Together...</h3>

<!-- type=misc -->

<p><code>require()</code>로 모듈을 찾을 때 정확한 파일 경로가 궁금하면 <code>require.resolve()</code> 함수로 얻어온다.</p>

<p>require.resolve가 정확히 어떻게 동작하는지 슈도 코드로 살펴보자. 이 슈도 코드는 여태까지 설명한 것을 모두 합쳐 놓은 것이다:</p>

<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS
</code></pre>

<h3>Loading from the global folders</h3>

<!-- type=misc -->

<p>Node는 모듈을 못 찾으면 환경변수 <code>NODE_PATH</code>에 등록된 경로에서도 찾는다. 절대경로를 <code>NODE_PATH</code>에 할당하면 되는데 콜론(<code>:</code>)으로 구분해서 절대경로를 여러 개 등록할 수 있다(주의: 윈도우는 세미콜론(<code>;</code>)으로 구분한다).</p>

<p>그리고 Node는 다른 디렉토리에서도 찾는다:</p>

<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>

<p><code>$HOME</code>은 사용자의 홈 디렉토리이고 <code>$PREFIX</code>는 노드가 설치된 디렉토리를 말한다.</p>

<p>왜 그런지 말하자면 길다. 무엇보다 <code>node_modules</code> 폴더를 이용해 모듈을 로컬에 설치하는 것이 좋다. 이 방법이 속도도 더 빠르고 더 안전하다.</p>

<h3>Accessing the main module</h3>

<!-- type=misc -->

<p>node로 어떤 파일을 실행하면 <code>require.main</code>은 그 파일의 <code>module</code> 객체를 가리킨다. 그래서 Node로 파일을 직접 실행한 건지 아닌지 알 수 있다:</p>

<pre><code>require.main === module
</code></pre>

<p><code>foo.js</code>라는 파일에 이런 게 들어 있다고 하자. 이 구문의 결과는 <code>node foo.js</code>로 실행하면 <code>true</code>이고 <code>require('./foo')</code>로 실행하면 <code>false</code>가 된다.</p>

<p><code>module</code>에는 <code>filename</code> 프로퍼티가 있어서(<code>__filename</code>과 같은 값이다) <code>require.main.filename</code>의 값을 확인하면 처음 실행한 파일을 무엇인지 알 수 있다.</p>

<h3>Addenda: Package Manager Tips</h3>

<!-- type=misc -->

<p><code>require()</code> 함수는 웬만한 디렉토리면 어디에서나 사용할 수 있다. <code>dpkg</code>, <code>rpm</code> 같은 패키지 매니저처럼 <code>npm</code>도 네이티브 Node 패키지를 아무런 수정 없이 빌드하게 할 수 있다.</p>

<p>모듈은 <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>에 설치하는 것을 권장한다. 어떤 패키지의 어떤 버전이 설치됐는지 한 눈에 알 수 있어 좋다.</p>

<p>패키지는 다른 패키지에 의존할 수도 있다. 예를 들어 <code>foo</code> 패키지를 설치하려면 <code>bar</code> 패키지도 설치해야 한다. 그것도 특정 버전의 <code>bar</code> 패키지가 설치돼야 한다. 그리고 <code>bar</code> 패키지도 다른 패키지에 의존할 수 있는데 충돌이 있거나 서로(cycle) 의존할 수도 있다.</p>

<p>Node는 로드할 모듈을 찾을 때 <code>node_modules</code> 폴더에서 필요한 모듈을 찾는다. 그중에 심볼릭 링크가 있으면 그 링크가 가리키는 모듈도 잘 찾는다. 다음과 같이 모듈을 찾는 매커니즘은 매우 간단하다:</p>

<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - 버전이  1.2.3인 <code>foo</code> 패키지</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - <code>foo</code>가 의존하는 <code>bar</code> 패키지</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - <code>/usr/lib/node/bar/4.3.2/</code>에 대한 심볼릭 링크</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - <code>bar</code>가 의존하는 패키지에 대한 심볼릭 링크</li>
</ul>

<p>그리고 상호 참조나 의존성 충돌이 있어도 모듈을 사용할 수만 있으면 잘 로드한다.</p>

<p><code>foo</code> 패키지에서 <code>require('bar')</code>라고 하면 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>가 가리키는 모듈을 가져온다. 또 그 <code>bar</code> 패키지에서 <code>require('quux')</code>라고 호출하면 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>가 가리키는 모듈을 가져온다.</p>

<p>최적화된 방법으로 모듈을 찾는 방법이 있는데 <code>/usr/lib/node</code> 디렉토리가 아니라 <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>에 모듈을 넣는다. 그러면 Node는 <code>/usr/node_modules</code>이나 <code>/node_modules</code>에서는 모듈을 찾지 않는다.</p>

<p><code>/usr/lib/node_modules</code> 폴더를 환경 변수 <code>$NODE_PATH</code>에 넣으면 Node REPL에서도 모듈을 사용할 수 있다. <code>require()</code>를 호출한 파일이 있는 곳에서부터 상대경로로 <code>node_modules</code> 폴더에 있는 모듈을 찾기 때문에 패키지는 그 <code>node_modules</code> 폴더 중 한 곳에 넣으면 된다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: npm config ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-npm-config.html" />
    <updated>2012-05-04T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-npm-config.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="http://npmjs.org/doc/config.html">npm config</a>를 정리한 글이다. npm이 설정을 관리하는 부분은 꽤 재미있다. npm 설정을 바꿀 일은 아직 없어서 몰랐는데 꽤 꼼꼼하게 설계했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/npm/npm-config.png" alt="npm-config" title="" /></p>

<h2>config</h2>

<p>npm은 설정하는 방법이 여섯 가지나 있고 우선순위는 다음과 같다:</p>

<ul>
<li>Command Line Flags</li>
<li>Environment Variables</li>
<li>Per-user config file</li>
<li>Global config file</li>
<li>Built-in config file</li>
<li>Default Configs</li>
</ul>

<h3>Command Line Flags</h3>

<p>CLI에서 <code>--foo bar</code>라고 사용하면 <code>foo</code>라는 변수에 값이 <code>"bar"</code>라고 설정된다. 그리고 <code>--</code>는 CLI 파서에게 flag 처리는 인제 그만 한다고 말하는 것이다. <code>--flag</code>처럼 단독으로 사용하는 파라미터는 명령어 끝에 사용하고 <code>true</code> 값이 할당된다.</p>

<h3>Environment Variables</h3>

<p><code>npm_config_</code>로 시작하는 환경변수도 npm 설정으로 사용된다. 예를 들어, <code>npm_config_foo=bar</code>라는 환경변수를 정의하면 npm에서 <code>foo</code> 설정의 값을 <code>bar</code>라고 설정하는 것과 같다. 환경변수에 값이 없으면 npm은 해당 설정의 값을 <code>true</code>라고 해석한다. 대소문자를 구분하지 않기 때문에 <code>NPM_CONFIG_FOO=bar</code>와 <code>npm_config_foo=bar</code>는 같다.</p>

<h3>Per-user config file</h3>

<p><code>$HOME/.npmrc</code>(파일의 위치는 <code>userconfig</code> 파라미터로 바꿀 수 있으며 위 방법(CLI 파라미터, 환경변수)으로 설정할 수 있다.)</p>

<p>이 파일은 ini 형식이라서 <code>key = value</code>라고 설정한다.</p>

<h3>Global config file</h3>

<p><code>$PREFIX/etc/npmrc</code>(파일의 위치는 <code>globalconfig</code> 파라미터로 바꿀 수 있고 위 방법(CLI 파라미터, 환경변수, userconfig)으로 설정한다.)</p>

<p>이 파일도 ini 형식이다.</p>

<h3>Built-in config file</h3>

<p><code>path/to/npm/itself/npmrc</code></p>

<p>이 파일은 "빌트인"이라 수정할 수 없다. npm 스크립트에 들어 있는 <code>./configure</code> 스크립트로 값을 설정할 수 있다. 이 파일은 기본 값을 변경해야 하는 배포 관리자를 위한 것이고 표준과 일관성을 지키며 수정해야 한다.</p>

<p>그러니까 회사에서 회사에 맞는 설정(회사의 registry를 기본 registry로 한다든가 하는)을 직원에게 배포할 때 이 설정을 바꾼 npm을 만들어서 배포하면 되겠다.</p>

<h3>Default Configs</h3>

<p>npm 내부에 박혀있는 것으로 파라미터가 어디에도 설정되지 않으면 사용하는 기본값이다. 이것은 그냥 하드코딩된 것으로 생각하면 된다.</p>

<h2>명령어</h2>

<p>config 명령어가 있는데 <code>git config</code>랑 비슷하다.</p>

<h3>set</h3>

<pre><code>npm config set key value
</code></pre>

<p>key, value를 설정한다.</p>

<p>value를 생략하면 "true"로 설정된다.</p>

<h3>get</h3>

<pre><code>npm config get key
</code></pre>

<p>stdout에 설정 값을 보여준다.</p>

<h3>list</h3>

<pre><code>npm config list
</code></pre>

<p>npm 설정 목록을 보여준다.</p>

<h3>delete</h3>

<pre><code>npm config delete key
</code></pre>

<p>모든 설정 파일에서 key를 삭제한다.</p>

<h3>edit</h3>

<pre><code>npm config edit
</code></pre>

<p>설정을 편집기에서 수정하도록 편집기를 열어준다. <code>--global</code> flag를 주면 global 설정 파일이 열린다.</p>

<h2>단축 파라미터</h2>

<p>사용할 수 있는 단축 파라미터들:</p>

<ul>
<li><code>-v</code>: <code>--version</code></li>
<li><code>-h</code>, <code>-?</code>, <code>--help</code>, <code>-H</code>: <code>--usage</code></li>
<li><code>-s</code>, <code>--silent</code>: <code>--loglevel silent</code></li>
<li><code>-q</code>, <code>--quiet</code>: <code>--loglevel warn</code></li>
<li><code>-d</code>: <code>--loglevel info</code></li>
<li><code>-dd</code>, <code>--verbose</code>: <code>--loglevel verbose</code></li>
<li><code>-ddd</code>: <code>--loglevel silly</code></li>
<li><code>-g</code>: <code>--global</code></li>
<li><code>-l</code>: <code>--long</code></li>
<li><code>-m</code>: <code>--message</code></li>
<li><code>-p</code>, <code>--porcelain</code>: <code>--parseable</code></li>
<li><code>-reg</code>: <code>--registry</code></li>
<li><code>-v</code>: <code>--version</code></li>
<li><code>-f</code>: <code>--force</code></li>
<li><code>-l</code>: <code>--long</code></li>
<li><code>-desc</code>: <code>--description</code></li>
<li><code>-S</code>: <code>--save</code></li>
<li><code>-y</code>: <code>--yes</code></li>
<li><code>-n</code>: <code>--yes false</code></li>
<li><code>ll</code> and <code>la</code> commands: <code>ls --long</code></li>
</ul>

<p>파라미터를 입력하다 말아도 특정 파라미터로 판단할 수만 있으면(resolve unambiguously) 해당 파라미터로 사용한다:</p>

<pre><code>npm ls --par
# same as:
npm ls --parseable
</code></pre>

<p>단축 파라미터는 여러 개를 붙여 사용해도 된다. 예를 들어:</p>

<pre><code>npm ls -gpld
# same as:
npm ls --global --parseable --long --loglevel info
</code></pre>

<h2>Per-Package Config Settings</h2>

<p>npm script를 사용할 때만 적용되는 설정도 할 수 있다. package.json의 "config" 설정은 "scripts" 설명을 이용할 때 적용된다. 다음과 같으면:</p>

<pre><code>{ "name" : "foo"
, "config" : { "port" : "8080" }
, "scripts" : { "start" : "node server.js" } }
</code></pre>

<p><code>npm start</code>를 실행시킬 때 config 설정이 적용된다. 하지만, 다른 곳에 설정할 수도 있다. <code>&lt;name&gt;[@&lt;version&gt;]:&lt;key&gt;</code>처럼 정의하면 된다. 이 pacakge.json을 사용하는 server.js가 다음과 같으면:</p>

<pre><code>http.createServer(...).listen(process.env.npm_package_config_port)
</code></pre>

<p>다음과 같이 바꿀 수 있다:</p>

<pre><code>npm config set foo:port 80
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ 프로그래머 관점에서의 바둑 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/the-game-of-go_a-programmers-perspective.html" />
    <updated>2012-05-01T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/the-game-of-go_a-programmers-perspective.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 Louis Chatriot이 자신의 블로그에 쓴 <a href="http://needforair.com/blog/2012/04/18/game-of-go/">The Game of Go: A Programmer's Perspective</a>를 번역한 것이다.</p>

<p>AI 프로그래머가 바라 봤을 때 바둑은 매우 흥미로운 게임이다. 컴퓨터가 실력 좋은 바둑 기사를 이기는게 매우 어렵고, 많은 연구자가 이 문제에 도전하기 때문이다. 모순적이게도 랜덤하게 돌을 놓는 것이 컴퓨터에겐 더 좋은 전략이다.</p>

<p><a href="http://www.flickr.com/photos/obli/322662164/" title="COPA EMBAJADOR DE COREA 2006 by oblivionz, on Flickr"><img src="http://farm1.staticflickr.com/134/322662164_0260e91add.jpg" width="250" height="166" alt="COPA EMBAJADOR DE COREA 2006"></a><br />by <a href="http://www.flickr.com/photos/obli/">oblivionz</a></p>

<h2>바둑: 엄청나게 간단한 개요</h2>

<p>바둑은 아시아에선 대중적인 게임이지만 서양에는 많이 알려지지 않았다. 바둑은 체스와 비슷하게 두 명이서 차례를 바꿔가며 바둑판에 돌을 놓는 전략게임이다. 체스와 바둑이 완전 다른 점은 두 개 정도있다.</p>

<ul>
<li>바둑에선 바둑판이 비어있는 상태로 시작하고 차례를 바꿔가며 돌을 놓는다. 반면 체스는 말을 놓고 시작하며 상대편의 말을 쓰러트려야 하는 게임이다.</li>
<li>게임 <a href="http://senseis.xmp.net/?RulesOfGoIntroductory">규칙</a>은 체스보다 바둑이 더 간단하다. 체스는 6개의 다른 말이 있지만, 바둑은 한 종류의 돌만 놓으면 된다.</li>
</ul>

<p><a href="http://senseis.xmp.net/?RulesOfGoIntroductory">여기</a>에서 배울 수 있고 <a href="http://www.gokgs.com/">여기</a>에서 바둑을 둘 수 있으니 확인해보라고 하고 싶다.</p>

<h2>체스와의 복잡도 비교</h2>

<p>규칙이 단순할지라도 좋은 바둑 프로그램을 만드는것은 매우 어렵다고 증명되어있다. 정말로 가장 뛰어난 체스 프로그램은 가장 뛰어난 체스 플레이어를 이기는게 가능했다. 1997년에 딥 블루가 게리 카스파로프(Gary Kasparov)를 이겼다. 하지만 가장 뛰어난 바둑 프로그램은 그냥 강한 아마추어에게 참패했다. 그리고 강한 아마추어는 프로 기사보다 엄청 약하다. 이런 일이 가능한 것에는 세가지 주된 이유가 있다.</p>

<ul>
<li><strong>게임-트리 복잡도</strong> : 체스에는 <a href="http://en.wikipedia.org/wiki/Shannon_number">10^123개의 게임</a>이 있다. 바둑에 있어서는 <a href="http://en.wikipedia.org/wiki/Go_and_mathematics">여러 추정치</a>가 나올 수 있지만, <a href="http://www.usgo.org/resources/topten.html">미국 바둑 협회 계산으로는 10^700개의 가능한 게임</a>이 있다고 한다. 바둑에는 플레이어에게 주어진 턴이 더 많고(평균적으로 200 대 50) 각각의 턴에서 돌을 놓을 수 있는 경우의 수(350 대 50)가 바둑이 더 많기에 바둑의 게임 수가 더 많다.</li>
<li><strong><a href="http://en.wikipedia.org/wiki/Evaluation_function">훌륭한 휴리스틱의 부족</a></strong> : 체스 프로그램은 어떤 행동이 다른 행동보다 좋은 것인지 꽤나 빠르고 정확하게 판단할 수 있다. 반대로 바둑에 대해선 아직 좋은 휴리스틱이 발견되지 않았다.</li>
<li><strong>패턴 인식</strong> : 뛰어난 바둑 기사라는건 판에 놓여진 돌이 만드는 모양을 인식하는 것에 달려있다. 게임을 하는 도중에 컴퓨터가 그 모양을 인식 하기엔 너무 많은 시간이 든다. <a href="http://curiosity.discovery.com/question/humans-better-than-computers">사람은 컴퓨터보다 훨씬 빠르다.</a></li>
</ul>

<h2>지금까지의 바둑 프로그램을 넘어설 핵심 아이디어</h2>

<p>바둑 알고리즘 연구가 흥미로운 이유가 이런 복잡도가 있기 때문이다. 우리는 몇 년전 스팩타클한 성능 향상을 보인 <a href="http://www.lri.fr/~teytaud/mogo.html">MoGo</a>라는 이름이 프로그램을 보았다. MoGo의 핵심 아이디어는 이렇다.</p>

<ul>
<li><strong>랜덤 게임을 이용한 위치 선정</strong> : 역설적이게도 지금까지 알아낸 돌을 놓을 위치를 알아내는 최고의 방법은 현재 상태에서 시작해 각각의 선수가 바둑판에 랜덤으로 돌을 놓는 수많은 경기를 진행해 보는것 이다. 바둑판 위, 한 위치의 점수는 단순히 랜덤 게임들이 이긴 확률이다.</li>
<li>브랜칭 팩터(각 턴마다 가능한 행동-돌을 놓는 등-의 경우의 수)를 줄이기 위해 <strong>'<a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit</a> 알고리즘'를 이용</strong>한다. 목표는 탐색(새로운 행동을 하는 것)과 개척(이미 알고 있는 행동 중에 최적의 하나를 찾아내는 것) 사이에 트레이드 오프를 최적화 하는 것이다. 컴퓨터는 처음에 가능한 모든 행동에 대해 사전 확률 분포를 만든다. 이 분포에 따라 하나를 고르고 그에 상응하는 위치를 기반으로 랜덤 게임을 돌린다. 그리고 결과를 이용해 그 행동에 대한 확률을 업데이트한다. 그리고 업데이트된 분포를 이용해 다음 가능한 수를 선택한다. 그렇게 계속 해나간다.</li>
<li><strong>작은 전문 지식을 이용</strong> : 'multi-armed bandit'에서 쓰이는 사전 분포는 적은 노력으로 멍청한 행동을 피하는 용도로 사용한다. 게임을 시작하면 고전적인 시작 위치를 선호한다. 그리고 랜덤 게임을 하는데 사실 이 랜덤 게임은 완전한 랜덤이 아니다. 간단한 패턴에 따라 특정 행동들은 제거하기 때문이다. 그렇게 몇가지를 제거한다 해도 전문 지식은 탐사 알고리즘 부분의 정말 작은 상처 하나에 불과하다.</li>
<li><strong>병렬화</strong> : MoGo같은 프로그램은 컴퓨터 클러스터에서 더 나은 성능을 보인다. 랜덤 게임 부분이 여러개의 CPU에서 돌 수 있기 때문이다. <a href="http://en.wikipedia.org/wiki/Amdahl's_law">성능 향상</a>은 약 8배 정도이다.</li>
<li><strong>강화된 학습</strong> : MoGo는 게임을 진행하는 동안이나 랜덤 게임을 진행하는 동안 계속 학습한다. 잘못된 결과를 가져오는 행동을 했을때 그 행동에 더 작은 확률을 부여한다.</li>
</ul>

<p><a href="http://www.pleinsud.u-psud.fr/specialR2008/en/12_GOthique.pdf">이 글</a>에 MoGo에 대해 더 많은 자료가 있다.</p>

<h2>현재 컴퓨터의 성능</h2>

<p>오늘날 바둑 프로그램은 조그마한 게임 판에서 프로 바둑 기사를 이기고 잘하는 아마추어 기사를 정식 바둑판에서 이기는 수준이다. 이건 굉장한 성과이지만 정식 바둑판에서 프로 바둑 기사를 상대하기 까지는 너무 먼 여정이 남아있다.</p>

<p><em>난 그리 실력이 좋지 않을지 모르겠지만, 스스로 바둑 플레이어라고 말한다. 2008년에 컴퓨터 공학 연구실에 인턴으로 있을 때, 한 2달 정도 MoGo를 사용했었다.<br />이 글을 검토해준 <a href="http://www.linkedin.com/pub/arpad-rimmel/b/9a7/847">Arpad Rimmel</a>에게 감사의 말을 전한다. 그는 박사과정을 지내는 중 3년 정도 MoGo를 사용했다.</em></p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ J언어 배우기 - 제 3장: 함수 정의하기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/learning-j-chapter3.html" />
    <updated>2012-04-30T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/learning-j-chapter3.html</id>
    <content type="html">
<![CDATA[
<p>Roger Stokes이 쓴 <a href="http://www.jsoftware.com/docs/help701/learning/contents.htm">Learning J</a> 의 chapter 3:Defining Functions를 번역/정리했다. 이전 챕터들은 본 사이트에서 <a href="/site/tagmap.html#j언어">J언어 태그</a>로 검색해 볼 수 있다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/learning_j_chapter3/jcode.png" alt="j code" title="" /></p>

<p>J에는 많은 내장 함수가 있다. 우리는 그 중 몇 가지를 살펴보았다.(<code>*</code>나 <code>+</code>같은 것들) 이번 섹션에서는 이 내장함수를 조합해 원하는 함수를 정의하는 여러 방법을 배운다.</p>

<h2>3.1 이름짓기</h2>

<p>함수를 정의하는 가장 간단한 방법은 그냥 원하는 내장 함수에 이름을 부여하는 것이다. 정의는 할당 함수를 이용해서 한다. 예를 들어서 아래의 <code>square</code>함수는 내장 함수인 <code>*:</code>를 이용하는 것과 똑같다.</p>

<pre><code>   square =: *:

   square 1 2 3 4
1 4 9 16
</code></pre>

<p>우리가 지은 이름이 더 기억하기 쉽거나 해서 그게 좋다면 새로운 이름을 사용한다. 같은 내장 함수에 다른 두 개의 이름을 부여할 수도 있다. 하나는 모나딕용으로, 다른 하나는 다이아딕 용으로.</p>

<pre><code>   Ceiling =: &gt;.
   Max     =: &gt;.
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Ceiling 1.7</tt></td>
<td><tt>3 Max 4</tt></td>
</tr><tr valign="TOP">
<td><tt>2</tt></td>
<td><tt>4</tt></td>
</tr></tbody></table>

<h2>3.2 삽입하기</h2>

<p>표현식 <code>+/ 2 3 4</code>는 의미가 <code>2 + 3 + 4</code>와 같고 비슷하게 <code>*/ 2 3 4</code>는 <code>2 * 3 * 4</code>와 같다. 이제 이 함수에 <code>sum</code>이라는 이름을 붙여보자.</p>

<pre><code>   sum =: + /

   sum 2 3 4
9
</code></pre>

<p><code>sum =: +/</code>라는 코드를 보면 <code>+/</code>가 이 자체로 함수를 표현하는 표현식임을 알 수 있다.<br /><code>+/</code>는 "Insert"(<code>/</code>)가 함수 <code>+</code>에 적용되어 리스트를 합치는 함수가 되었다 라고 말한다.</p>

<p>즉, <code>/</code>은 그 자체로 함수의 한 종류이다. 이 함수는 왼쪽에 인자 하나를 받는다. 그 인자도 함수고 계산 결과도 함수다.</p>

<h2>3.3 용어: 동사, 연산자, 부사</h2>

<p>우리는 두 종류의 함수를 봤다. 첫째로 "일반적인" 함수다. 숫자를 계산해서 숫자를 내뱉는 <code>+</code>나 <code>*</code>같은 함수. J에서는 이런 것들을 "동사"라고 한다. 둘째로 함수를 계산해서 함수를 내뱉는 <code>/</code>같은 함수이다. 이런 종류의 함수를 다른 종류의 함수와는 구별하여 "연산자"라고 한다. </p>

<p>하나의 인자를 받는 연산자는 "부사"라고 한다. 부사는 항상 왼쪽에 하나의 인자를 받는다. 그래서 표현식 <code>+ /</code>에서 부사 <code>/</code>는 동사 <code>+</code>에 적용되어서 리스트를 더하는 동사가 만들어진다.</p>

<p>용어는 영어구문에서 따왔다. 동사는 물건의 행동을 묘사하고 부사는 동사의 의미를 변한다.</p>

<h2>3.4 교환하기(Commuting)</h2>

<p>부사 <code>/</code>말고 다른것도 보자. 부사 <code>~</code>는 왼쪽과 오른쪽의 인자를 서로 바꾸는 기능이 있다.</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>'a' , 'b'</tt></td>
<td><tt>'a' ,~ 'b'</tt></td>
</tr><tr valign="TOP">
<td><tt>ab</tt></td>
<td><tt>ba</tt></td>
</tr></tbody></table>

<p>다이아드 함수 <code>f</code>와 그 인자 <code>x</code>, <code>y</code>에 대해서 <code>~</code>의 구조는 다음과 같다.</p>

<pre><code>         x f~ y      는   y f x   이다
</code></pre>

<p>또 다른 예로 동사 <code>|</code>를 기억하는가? <code>2|7</code>은 "7 mod 2"와 같다. 이제 mod함수를 정의 할 차례이다.</p>

<pre><code>   mod =: | ~
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>7 mod 2</tt></td>
<td><tt>2 | 7</tt></td>
</tr><tr valign="TOP">
<td><tt>1</tt></td>
<td><tt>1</tt></td>
</tr></tbody></table>

<p>그림을 한번 그려보자. 우선 함수 f에 인자 y를 적용해 <code>f y</code>의 결과를 반환하는 다이어그램이 있다. 이 다이어그램에서 함수 f는 사각형으로 그리고 인자가 어떻게 흘러서 결과가 나타나는지 화살표로 나타낸다. 각각의 화살표에는 표현식이 쓰여있다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag01.gif" alt="monadic" title="" /></p>

<p>아래에 다이아딕 함수 f에 인자 x, y를 적용해 <code>x f y</code>가 만들어지는 다이어그램이 있다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag02.gif" alt="dyadic" title="" /></p>

<p>이것이 함수 <code>f~</code>에 대한 다이어그램이다. 상자 안에 함수 f가 있고 인자가 서로 엇갈려서 들어가는 그림으로 나타냈다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag03.gif" alt="~" title="" /></p>

<h2>3.5 묶기(Bonding)</h2>

<p>double이라는 동사를 정의해야한다고 가정해보자. <code>double x</code>는 <code>x * 2</code>를 뜻한다. 즉 double은 "곱하기 2"이다. 아래와 같이 정의할 수 있다.</p>

<pre><code>   double =: * &amp; 2

   double 3
6
</code></pre>

<p>우리는 <code>*</code>를 두 인자중 한 인자를 미리 정해놓고(이 경우엔 2) 그걸 마치 모나드 처럼 써서 <code>*</code>를 다이아드로 사용했다. <code>&amp;</code> 연산자는 함수와 값을 묶어놓는 역할을 한다. f가 다이아딕 함수이고 k가 f의 오른쪽 인자라면 다음과 같은 구조를 가진다.</p>

<pre><code>        (f &amp; k) y    은    y f k   이다.
</code></pre>

<p>오른쪽 인자말고 왼쪽 인자를 고정하고 싶다면 아래와 같이 쓸 수 있다.</p>

<pre><code>        (k &amp; f)  y   은    k f y   이다
</code></pre>

<p>예를 들어서 물건 값의 10% 세금은 계산해야 한다고 하자. 그러면 세액을 계산하는 함수는 다음과 같다.</p>

<pre><code>   tax =: 0.10 &amp; *

   tax 50
5
</code></pre>

<p>아래에 <code>k&amp;f</code>함수의 다이어그램이 있다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag04.gif" alt="bond" title="" /></p>

<h2>3.6 용어: 접속사와 동사</h2>

<p>표현식 <code>*&amp;2</code>는 <code>&amp;</code> 연산자는 두 인자(동사 <code>*</code>와 숫자 2)를 받는 함수이며 그 결과로 "doubling"이라는 동사를 만들어낸다.<br /><code>&amp;</code>와 같은 두 인자를 취하는 "연산자"를 J에서는 "접속사"라고 한다. 이는 두 인자를 묶어주기 때문이다. 반면에 부사는 하나의 인자만을 가지는 연산자이다.</p>

<p>J의 모든 함수는 내장 함수이건 사용자 정의 함수이건 반드시 4종류 중 하나이다. 모나딕 동사, 다이아딕 동사, 부사, 접속사가 그것이다. 같은 심볼이지만 다른 의미를 가지는 동사는 두 개의 다른 동사로 간주한다. 예를 들면 <code>-</code>는 모나딕으로는 "negation"이고 다이아딕으로는 "subtraction"이다.</p>

<p>J의 모든 표현식은 어떤 타입을 가진 값이다. 그리고 함수가 아닌 모든 값은 데이터이다.(정확히는 이전 섹션에서 본 배열이다)</p>

<p>J에서 데이터 값, 즉 배열은 "명사"라고 부른다. 이는 영어의 구문과 비슷하다. 이젠 어떤 것이 동사가 아닌 것을 강조하기 위해서 그것을 명사라 부르고, 어떤 차원을 가지고 있다는걸 강조하기 위해서 그것을 배열이라 부른다.</p>

<h2>3.7 함수의 합성(composition)</h2>

<p>이런 영어 표현을 생각해보자. "the sum of the squares of the numbers 1 2 3" 이건 <code>1+4+9</code> 또는 <code>14</code>이다. 우리가 앞에서 sum과 square동사를 정의 했으니 J로는 다음과 같이 쓸 수 있다.</p>

<pre><code>   sum square 1 2 3
14
</code></pre>

<p>sum과 square를 합성하여 하나의 "sum-of-the-squares"함수를 만들 수도 있다.</p>

<pre><code>   sumsq =: sum @: square

   sumsq 1 2 3
14
</code></pre>

<p>심볼 <code>@:</code>(at colon)은 "composition(합성)" 연산자다. f와 g가 동사이고 y라는 인자가 있을때 이 연산자의 구조는 다음과 같다.</p>

<pre><code>       (f @: g) y    는  f (g y)  이다.
</code></pre>

<p>아래에는 이 구조에 대한 다이어그램이다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag05.gif" alt="composition" title="" /></p>

<p>이 시점에서 독자분들은 동사를 합성할 때 왜 간단하게 <code>f g</code>라고 쓰지 않고 <code>f @: g</code>라고 쓰는지 궁금할 것이다. 간단히 말하자면 <code>f g</code>은 또 다른 의미이다. 이건 곧 나온다.</p>

<p>합성에 대한 다른 예는 화씨를 섭씨로 바꾸는 것이다. 32를 빼는 함수 s와 5%9를 곱하는 함수 m을 합성해보자.</p>

<pre><code>   s       =: - &amp; 32
   m       =: * &amp; (5%9)
   convert =: m @: s
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>s 212</tt></td>
<td><tt>m s 212</tt></td>
<td><tt>convert 212</tt></td>
</tr><tr valign="TOP">
<td><tt>180</tt></td>
<td><tt>100</tt></td>
<td><tt>100</tt></td>
</tr></tbody></table>

<p>이 예제는 이름있는 함수의 합성을 잘 보여준다. 다음과 같이 함수의 표현식 자체를 합성 할 수도 있다.</p>

<pre><code>   conv =: (* &amp; (5%9)) @: (- &amp; 32) 
   conv 212
100
</code></pre>

<p>합성한 함수에 이름을 주지 않고서도 인자를 적용시켜 사용할 수 있다.</p>

<pre><code>   (* &amp; (5%9)) @: (- &amp; 32)  212
100
</code></pre>

<p>위 예제들로 모나드와 모나드를 합성한 것을 보였다. 다음 예제는 다이아드를 합성한 것이다. 일반적인 구조는 다음과 같다.</p>

<pre><code>           x (f @: g) y   은    f (x g y)   이다.
</code></pre>

<p>예를 들어서 아이템 몇 개를 구매한 총 금액은 각 아이템의 가격에 개 수를 곱하고 곱한 값을 더하면 알 수 있다. 아래를 보자.</p>

<pre><code>   P =:  2 3        NB. 가격
   Q =:  1 100      NB. 개 수

   total =: sum @: *
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>P</tt></td>
<td><tt>Q</tt></td>
<td><tt>P*Q</tt></td>
<td><tt>sum P * Q</tt></td>
<td><tt>P total Q</tt></td>
</tr><tr valign="TOP">
<td><tt>2 3</tt></td>
<td><tt>1 100</tt></td>
<td><tt>2 300</tt></td>
<td><tt>302</tt></td>
<td><tt>302</tt></td>
</tr></tbody></table>

<p>합성에 대해서 더 알고 싶으면 8장을 보라.</p>

<h2>3.8 동사의 연결(Trains of Verbs)</h2>

<p>"no pain, no gain"이라는 문구를 아는가. 이것은 압축되고 요약된 관용적 표현이다. 이런 말은 문법적 구조에는 맞지 않지만 제법 알아들을 수 있다. (메인 동사가 없으므로 문장이 아니다) J에는 이와 비슷하게 함수를 몇 개 연결해서 특정한 의미가 되도록 하는 표기법이 있다. 아래에 그 방법이 나온다.</p>

<h3>3.8.1 훅(Hooks)</h3>

<p>위에서 정의했던 세금을 계산하는 동사를 다시 가져오자. 이 동사에서 세율은 10%였다. </p>

<pre><code>   tax =: 0.10 &amp; *
</code></pre>

<p>지불해야 하는 금액은 물건 가격 더하기 세금이다. 지불해야 하는 금액을 계산하는 동사는 다음과 같이 작성 할 수 있다.</p>

<pre><code>   payable =: + tax
</code></pre>

<p>만약 물건 가격이 50달러 라면, 아래와 같이 계산할 수 있다.</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>tax 50</tt></td>
<td><tt>50 + tax 50</tt></td>
<td><tt>payable 50</tt></td>
</tr><tr valign="TOP">
<td><tt>5</tt></td>
<td><tt>55</tt></td>
<td><tt>55</tt></td>
</tr></tbody></table>

<p><code>payable =: + tax</code>라는 정의를 보면 <code>+</code>동사 다음에 곧바로 <code>tax</code>가 온다. 이 시퀀스는 할당 연산자 오른쪽에 위치함으로써 분리되어있다.(isolated) 이렇게 분리된 동사의 시퀀스를 "train"이라고 부르고 동사 2개의 train을 "hook"(훅)이라고 부른다.</p>

<p>두 개의 동사를 괄호 안에 넣어 분리시켜 훅의 형태로 사용할 수 있다.</p>

<pre><code>   (+ tax) 50
55
</code></pre>

<p>f가 다이아드, g가 모나드이고 y라는 어떤 인자가 있을때 훅의 일반적인 구조는 다음과 같다. </p>

<pre><code>        (f g) y       는   y f (g y)   이다.
</code></pre>

<p>이 구조를 다이어그램으로 나타내면 다음과 같다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag06.gif" alt="hook" title="" /></p>

<p>또다른 예로 인자로 들어온 수의 정수 부분을 계산하는 동사인 <code>&lt;.</code>("floor")를 이용해보자. 숫자가 정수인지 아닌지 검사를 하려면 그 숫자가 정수부와 같은지 검사한다. "equal-to-its-floor"라는 의미를 가진 이 동사는 <code>= &lt;.</code>라는 훅으로 정의할 수 있다.</p>

<pre><code>   wholenumber  =:  = &lt;.
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>y =: 3 2.7</tt></td>
<td><tt>&lt;. y</tt></td>
<td><tt>y = &lt;. y</tt></td>
<td><tt>wholenumber y</tt></td>
</tr><tr valign="TOP">
<td><tt>3 2.7</tt></td>
<td><tt>3 2</tt></td>
<td><tt>1 0</tt></td>
<td><tt>1 0</tt></td>
</tr></tbody></table>

<h3>3.8.2 포크(Forks)</h3>

<p>숫자 리스트 L의 산술 평균은 L의 합을 L의 아이템 개 수로 나눈 것이다.(아이템 개 수를 세는 모나딕 동사인 <code>#</code>는 기억하고 있겠지?)</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>L =: 3 5 7 9</tt></td>
<td><tt>sum L</tt></td>
<td><tt># L</tt></td>
<td><tt>(sum L) % (# L)</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5 7 9</tt></td>
<td><tt>24</tt></td>
<td><tt>4</tt></td>
<td><tt>6</tt></td>
</tr></tbody></table>

<p>합을 아이템 개 수로 나누기 계산을 하는 동사는 세가지 동사의 시퀀스로 나타낼 수 있다. <code>sum</code> 다음에 <code>%</code>다음에 <code>#</code>가 오면 된다.</p>

<pre><code>   mean =: sum % #

   mean L
6
</code></pre>

<p>세 동사의 분리된 시퀀스는 "fork(포크)"라고 한다. 임의의 인자 y에 대해서 f가 모나드이고 g가 다이아드이고 h가 모나드일 때 다음과 같은 일반적인 구조를 지닌다.</p>

<pre><code>        (f g h) y     는   (f y) g (h y)   이다.
</code></pre>

<p>이 구조를 다이어그램으로 나타내면 아래와 같다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag06.gif" alt="hook" title="" /></p>

<p>포크에 대한 다른 예로는 숫자 리스트의 범위를 구하는 것이 있다. 숫자 리스트의 범위는 리스트에서 가장 작은 수와 가장 큰 수를 구하는 것이다. 이는 최소, 최대를 구하는 동사 중간에 콤마 동사를 넣어 포크하면 된다.</p>

<p>리스트에서 가장 큰 수를 구하는 함수 <code>&gt;./</code>와 가장 작은 수를 구하는 함수 <code>&lt;./</code>는 1장에서 배웠다.</p>

<pre><code>   range =: &lt;./  ,  &gt;./
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>L</tt></td>
<td><tt>range L</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5 7 9</tt></td>
<td><tt>3 9</tt></td>
</tr></tbody></table>

<p>훅과 포크는 동사의 시퀀스이다. 이는 동사의 "trains" 라고도 말한다. trains에 대해 더 많은 정보를 알려면 제 9장을 참고하라.</p>

<h2>3.9 다 집어넣고 보자(Putting Things Together)</h2>

<p>이제까지 배운 것들 중 몇가지를 섞어서 좀 더 커다란 예제를 만들어보자<br />어떤걸 만들꺼냐면, 숫자 리스트를 보여주고 각 숫자가 전체에서 몇 퍼센트를 차지하는지 보여주는 간단한 표를 만들 예정이다.</p>

<p>어떤걸 만들어야 하는지 명확히 하기 위해 우선 완성된 예제를 먼저 보자. 아래에 설명 할 것이기 때문에 당장에 이 모든걸 알 필요는 없다. 그냥 아래 6라인의 코드를 보고 어떤 동사가 정의되어 있는지 살펴보자.</p>

<pre><code>   percent  =: (100 &amp; *) @: (% +/)
   round    =: &lt;. @: (+&amp;0.5)
   comp     =: round @: percent
   br       =: ,.  ;  (,. @: comp)
   tr       =: ('Data';'Percentages') &amp; ,
   display  =: (2 2 &amp; $) @: tr @: br
</code></pre>

<p>간단한 데이터로 시작해보자.</p>

<pre><code>   data =: 3 5
</code></pre>

<p>이 데이터를 이용하면 <code>display</code>동사는 각 숫자와 그 숫자의 퍼센트를 표현할 것이다. 아래 표를 보자면, 3은 8에서 38%를 차지한다.</p>

<pre><code>   display data
+----+-----------+
|Data|Percentages|
+----+-----------+
|3   |38         |
|5   |63         |
+----+-----------+
</code></pre>

<p><code>percent</code>동사는 훅 <code>% +/</code>으로 전체 수에서 각각의 수를 나누고 각각에 100을 곱해서 퍼센트를 계산해낸다. 아래에 <code>percent</code>의 정의를 다시 쓸테니 위로 스크롤 하지 않아도 된다.</p>

<pre><code>   percent  =: (100 &amp; *) @: (% +/)
</code></pre>

<p>이를 사용해보자.</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>+/ data</tt></td>
<td><tt>data % +/ data</tt></td>
<td><tt>(% +/) data</tt></td>
<td><tt>percent data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>8</tt></td>
<td><tt>0.375 0.625</tt></td>
<td><tt>0.375 0.625</tt></td>
<td><tt>37.5 62.5</tt></td>
</tr></tbody></table>

<p>퍼센트 값을 반올림하자. 반올림은 각 값에 0.5를 더하고 "floor"(<code>&lt;.</code>)를 이용해 정수 부분만을 취한다. 이런 일을 하는 동사 <code>round</code>는 아래와 같이 정의한다.</p>

<pre><code>   round    =: &lt;. @: (+&amp;0.5)
</code></pre>

<p>그러면 화면에 표시할 값을 계산하는 동사는 다음과 같다.</p>

<pre><code>   comp     =: round @: percent
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>comp data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>38 63</tt></td>
</tr></tbody></table>

<p>이제 테이블에 데이터와 퍼센트로 계산된 값을 표현해야 한다. 리스트를 하나의 열(column)을 만들기 위해선 동사 <code>,.</code>를 사용할 수 있다.("Ravel Items"라고 부른다)</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>,. data</tt></td>
<td><tt>,. comp data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>3<br>
5</tt></td>
<td><tt>38<br>
63</tt></td>
</tr></tbody></table>

<p>테이블의 아래쪽 행을 만들기 위해 <code>br</code> 이라는 동사를 정의한다. 이 동사는 데이타와 계산된 값을 열(column)로 링크하는 포크이다.(포크는 위에서 정의했듯이 세 동사의 시퀀스이다.)</p>

<pre><code>   br  =: ,.  ;  (,. @: comp)
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>br data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>+-+--+<br>
|3|38|<br>
|5|63|<br>
+-+--+</tt></td>
</tr></tbody></table>

<p>테이블의 위쪽 행(컬럼 헤딩)은 간단하게 만들 수 있다. 아래쪽 행은 두 박스의 리스트이다. 우리가 그 앞에 두 개의 박스를 더 붙이면 박스가 4개인 리스트가 된다. 동사 <code>tr</code>이 그 작업을 한다.</p>

<pre><code>   tr  =: ('Data';'Percentages') &amp; ,
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>br data</tt></td>
<td><tt>tr br data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>+-+--+<br>
|3|38|<br>
|5|63|<br>
+-+--+</tt></td>
<td><tt>+----+-----------+-+--+<br>
|Data|Percentages|3|38|<br>
|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|5|63|<br>
+----+-----------+-+--+</tt></td>
</tr></tbody></table>

<p>남은건 박스 4개의 리스트를 2행 2열의 테이블로 만드는 것이다.</p>

<pre><code>   (2 2 &amp; $)  tr br data
+----+-----------+
|Data|Percentages|
+----+-----------+
|3   |38         |
|5   |63         |
+----+-----------+
</code></pre>

<p>이걸 다 합하면,</p>

<pre><code>   display =: (2 2 &amp; $) @: tr @: br

   display data
+----+-----------+
|Data|Percentages|
+----+-----------+
|3   |38         |
|5   |63         |
+----+-----------+
</code></pre>

<p>이렇게 된다.</p>

<p><code>display</code>동사는 두 부분으로 나눈다. 반올림된 퍼센트 값을 계산하는 <code>comp</code>함수와 화면에 결과를 표시하는 나머지 부분이 그것이다. <code>comp</code>함수를 바꾸어 다른 함수를 사용하면 그 함수의 계산 결과를 표 형태로 표시한다. <code>comp</code>를 제곱근을 계산하는 <code>%:</code>함수로 바꿔보자.</p>

<pre><code>   comp =: %:
</code></pre>

<p>동사 <code>tr</code>에 있는 표의 컬럼 헤딩도 알맞게 수정해야한다.</p>

<pre><code>   tr   =: ('Numbers';'Square Roots') &amp; ,

   display 1 4 9 16
+-------+------------+
|Numbers|Square Roots|
+-------+------------+
| 1     |1           |
| 4     |2           |
| 9     |3           |
|16     |4           |
+-------+------------+
</code></pre>

<p>J의 몇몇 특징적인 기능(묶기, 합성, 훅, 포크)을 이용해서 조그마한 J프로그램을 작성해보았다. 모든 J 프로그램과 마찬가지로 이 프로그램은 이걸 작성하는 많은 방법중에 하나일 뿐이다.<br />이 장에서 우리는 함수를 정의하는 방법을 배웠다. 함수는 두 종류가 있다. 동사와 연산자. 지금까지 우리는 동사의 정의하는 것을 보았다. 다음 장에서는 동사를 정의하는 다른 방법을 알아 볼 것이다. 그리고 제 13장에서는 연산자를 정의하는 방법을 배운다.</p>

<p>이렇게 제 3장이 끝났다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: git-svn ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-svn.html" />
    <updated>2012-04-28T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-svn.html</id>
    <content type="html">
<![CDATA[
<p>Progit 8장에 설명된 'git-svn'에서 쓸만한 명령어를 정리했다. svn server + git client 같이 오묘한 조합은 사용하고 싶지 않았는데, 너무 불편해서 못살겠다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-svn/et.jpg" alt="et" title="" /></p>

<p>GitHub는 <a href="http://hg-git.github.com/">git server + hg client</a>, <a href="https://github.com/blog/966-improved-subversion-client-support">git server + svn client</a> 조합도 만들었는데 쓰는 사람이 있을까?</p>

<h2>주요 명령어 정리</h2>

<p>SVN 처럼 로그를 보거나 등등의 기능이 많지만, 어차피 안 쓸 것 같아서 정리하지 않는다. SVN을 Git으로 마이그레이션할 때 필요한 명령어도 정리하지 않았다.</p>

<h3>clone:</h3>

<pre><code>git svn clone url -s
</code></pre>

<p>-s는 표준레이아웃인 <code>trunk, branches, tags</code>를 사용한다는 의미다. 표준레이아웃을 사용하지 않으면 <code>-T trunk -b branches -t tags</code>라고 직접 알려주면 된다.</p>

<p>trunk, branches, tags는 모두 Git 브랜치로 만들어진다. trunk와 branches는 같은 이름으로 만들어지지만, tags는 앞에 <code>tags/</code>라고 붙는다.</p>

<p>progit 책에 나오는 <code><a href='http://progit-example.googlecode.com/svn/'><a href='http://progit-example.googlecode.com/svn/'>http://progit-example.googlecode.com/svn/</a></a></code>을 적용해보면 다음과 같이 만들어진다:</p>

<pre><code>└─▪ git br -av
* master                        5925d95 Support HP C++ on Tru64.
  remotes/my-calc-branch        a52ad75 created a branch
  remotes/tags/2.0.2            fd8e73e Tag release 2.0.2.
  remotes/tags/release-2.0.1    60feb5c Tag the 2.0.1 release.
  remotes/tags/release-2.0.2    85bac46 Set version to 2.0.2 in release branch.
  remotes/tags/release-2.0.2rc1 168051e Update version number in 2.0.2rc1 release branch.
  remotes/trunk                 5925d95 Support HP C++ on Tru64
</code></pre>

<p>SVN 브랜치는 당연히 Git 브랜치로 만들어지지만 SVN의 tag도 Git의 브랜치로 만들어진다.</p>

<h3>fetch:</h3>

<p><code>git fetch</code>에 대응되는 명령어:</p>

<pre><code>git svn fetch
</code></pre>

<p>trunk가 master로 자동으로 Fast-Forward Merge 됐으면 좋겠다. </p>

<p><code>git-svn</code> 프로젝트이면 trunk를 master로 Fast-Forware Merge하도록 <a href="https://github.com/pismute/git-tles">git-ff</a>를 수정했다. 이 브랜치만 Merge한다. svn에서 브랜치를 쓰고 싶지 않다.</p>

<h3>push:</h3>

<p><code>git push</code>에 대응하는 명령어:</p>

<pre><code>git svn dcommit
</code></pre>

<p>svn은 히스토리가 평평하니까 이것만 주의하면 된다.</p>

<h3>annotate:</h3>

<p>어떤 놈이 잘못 고쳤는지 찾아보는 명령어:</p>

<pre><code>git svn blame [FILE] 
</code></pre>

<h3>.gitignore:</h3>

<p><code>.gitignore</code>를 만들어 넣으면 svn 서버에 Push된다. 다른 사람 몰래 혼자 쓰고 싶으면 <code>.git/info/exclude</code>에 만들면된다. <code>.gitignore</code>랑 똑같고 해당 저장소에만 적용되며 Push할 수 없다:</p>

<pre><code>git svn show-ignore &gt; .git/info/exclude
</code></pre>

<h2>Merge</h2>

<p>SVN의 히스토리는 항상 일직선이기 때문에 SVN에 Push할 브랜치는 항상 Fast-Forward로 Merge해야 한다. 그렇지 않으면 알아서 펴주기 때문에 히스토리 모양이 원하는 모양이랑 다를 수 있다.</p>

<h2>브랜치</h2>

<p>SVN의 히스토리는 항상 평평하다. 브랜치 별로 히스토리가 다르게 관리하는 것이 아니라 한 히스토리에서 trunk. branches, tags를 모두 관리한다. 이점을 꼭 기억해야 한다.</p>

<p>SVN 브랜치는 항상 Long-Running 브랜치로 사용한다. Topic 브랜치는 git-svn이 아니라 그냥 git을 사용할 때와 다를 바 없다. 단지 SVN 브랜치를 Tracking하는 Long-Running 브랜치에 Merge할 때 쫙 펴주기만 하면 된다.</p>

<p>문제는 SVN 브랜치를 Git에서 서로 Merge하는 데 있다. 그냥 Fetch해서 평평한 히스토리를 유지하면서 Push하는 것이 아니라 SVN 브랜치를 Git에서 Merge하면 어떨까? 이제 이걸 알아보자.</p>

<h3>일단 SVN 저장소를 하나 준비하고</h3>

<p>일단 SVN 저장소를 하나 준비하고:</p>

<p><img src="/articles/2012/git-svn/svn-repository.png" alt="svn-repository.png" title="" /></p>

<p>Git으로 클론한다. 클론하고 나서 <code>git branch -av</code>를 하면 다음과 같다:</p>

<pre><code>* master             92a713a from trunk
  remotes/dogfeet    e5334ef Add from dogfeet
  remotes/tags/1.0.0 2ec86a0 tag 1.0.0
  remotes/trunk      92a713a from trunk
</code></pre>

<p>master는 remotes/trunk를 트랙킹하고 SVN 브랜치인 'dogfeet'과 SVN 태그인 '1.0.0'이 Git에서는 모두 브랜치로 만들어진다. 그리고 원래 리모트 트래킹 브랜치는 <code>remotes/origin/master</code> 같은 패턴으로 이름 지어지는데 리모트 없이 <code>remotes/trunk</code> 형식으로 이름 지어진다.</p>

<p>SVN 히스토리:</p>

<p><img src="/articles/2012/git-svn/history.png" alt="history.png" title="" /></p>

<p>master 히스토리:</p>

<pre><code>* 92a713a - (HEAD, trunk, master) from trunk (2 hours ago)
* 12bf5f1 - Initial structure. (2 hours ago)
</code></pre>

<p>dogfeet 히스토리:</p>

<pre><code>* e5334ef - (dogfeet) Add from dogfeet (2 hours ago)
* 86cdd49 - branch dogfeet (2 hours ago)
* 92a713a - (HEAD, trunk, master) from trunk (2 hours ago)
* 12bf5f1 - Initial structure. (2 hours ago)
</code></pre>

<h3>이제 Git에서 커밋을 하나씩하고</h3>

<p>master에 커밋을 하나 하고:</p>

<pre><code>* 4c549fb - (master) Add from_git_master (4 minutes ago)
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>dogfeet에도 커밋을 하나 하고:</p>

<pre><code>* 904a4c0 - (HEAD, local_dogfeet) Add from_git_dogfeet (70 seconds ago)
* e5334ef - (dogfeet) Add from dogfeet (23 hours ago)
* 86cdd49 - branch dogfeet (23 hours ago)
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>dogfeet을 master에 Merge한다:</p>

<pre><code>*   8365b59 - (HEAD, master) Merge branch 'local_dogfeet' (2 seconds ago)
|\  
| * 904a4c0 - (local_dogfeet) Add from_git_dogfeet (2 minutes ago)
| * e5334ef - (dogfeet) Add from dogfeet (23 hours ago)
| * 86cdd49 - branch dogfeet (23 hours ago)
* | 4c549fb - Add from_git_master (5 minutes ago)
|/  
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>이걸 SVN에 Push하면 SVN 히스토리는 다음과 같아진다:</p>

<p><img src="/articles/2012/git-svn/history-after-merge.png" alt="history-after-merge.png" title="" /></p>

<p>그러니까 이렇게 Merge 커밋이 있는 히스토리를 SVN에 Push하면 히스토리가 순서가 보장되지 않는다. 히스토리 순서를 보장하려면 Fast-Forward Merge로 펴놓고 Push해야 한다.</p>

<p>그렇다고 Rebase를 해서 Fast-Forward Merge를 하면 같은 커밋이 두 번 들어가게 될 수도 있으니 절대로 SVN에 올라간 커밋은 Rebase하면 안된다. 그러니까 SVN에 Push한 커밋을 Rebase할 바엔 그냥 Merge Commit을 남기는 게 낫다고 볼 수 있다.</p>

<h3>브랜치 결론.</h3>

<p>SVN 세상에서는 히스트리가 항상 평평하고 브랜치도 디렉토리로 관리한다. 그러니까 이점을 명확히 이해하고 있어야 혼란스럽지 않다.</p>

<p>SVN의 브랜치를 Git에서 Merge하는 것은 사실 조금 위험하다. Merge Commit 있는 Git 히스토리를 SVN에 Push하면 커밋 순서는 보장되지 않을 것이고 그렇다고 SVN에 이미 커밋된 것을 Rebase할 수도 없다. 하지만 Topic 브랜치를 만들어 작업하고 히스토리를 평평하게 펴서 SVN에 Push하면 쓸만하다.</p>

<p>그리고 SVN 히스토리가 망가질 수 있다는 단점은 지나친 기우일 수 있다. 오픈 소스 프로젝트라면 히스토리를 더럽히는 것이 당연히 부끄럽겠지만, 원래 커밋 메시지도 없는 히스토리라면 그냥 커밋 몇 개 더 만들어도 괜찮지 않을까? 취미로 하는 프로젝트를 빼고 난 아직 한번도 히스토리에 정성을 쏳는(이라고 쓰고 커밋 메시지를 잘 남기는 이라고 읽는다) 프로젝트를 해보지 못했다.</p>]]>
    </content>
  </entry>
</feed>
