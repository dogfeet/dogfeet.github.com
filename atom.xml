<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title><![CDATA[ 개발새발 ]]></title><link href="http://dogfeet.github.com/atom.xml" rel="self" /><link href="http://dogfeet.github.com" /><updated>2012-08-20T21:36:23.988Z</updated><id>http://dogfeet.github.com</id><author><name>changwoo-park.html.md</name><email>pismute@gmail.com</email></author><author><name>sean-lee.html.md</name><email>sean@weaveus.com</email></author><author><name>yongjae-choi.html.md</name><email>mage@weaveus.com</email></author><entry><title><![CDATA[ Meteor: Learn Meteor Fundamentals and Best Practices ]]></title><link href="http://dogfeet.github.com/articles/2012/meteor-fundametals-and-best-practices.html" /><updated>2012-08-18T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/meteor-fundametals-and-best-practices.html</id><content type="html"><![CDATA[
<p>이 글은 <a href="https://twitter.com/agscala">@agscala</a>의 <a href="http://andrewscala.com/meteor/">Learn Meteor Fundamentals and Best Practices</a>를 번역한 것이다. <a href="http://meteor.com/">Meteor</a>를 처음 접할 때 좋은 것 같아 번역하였다. <a href="http://docs.meteor.com/">Meter 공식 문서</a>는 아직 설명이 부족해 어렵다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/meteor-fundametals-and-best-practices/agscala.jpeg" alt="" title="" /> <strong>Andrew Scala</strong></p>

<h2>Introduction</h2>

<p>이 새롭고 기괴한 <a href="http://meteor.com/">Meteor</a>가 어떻게 동작하는지 알고 싶어 왔는가? 그레이트, 제대로 왔다. 내가 Meteor 프로젝트가 어떻게 생겼는지 보여주고 Meteor 애플리케이션을 만들 때 꼭 기억해야 하는 비법(Best Practices)을 알려 주겠다.</p>

<h2>What is Meteor?</h2>

<p>Meteor에서는 적은 코드로도 엄청난 양의 동적 페이지가 시전된다(create). Meteor는 아직 Beta이고 이 글을 쓰는 시점에서 Meteor는 <code>preview 0.3.8</code> 버전에 불과하다. 그러니 이 글의 내용이 동작하지 않더라도 쫄지 말자.</p>

<p>Meteor는 <a href="http://nodejs.org/">Node.js</a>에서 Javascript로 만들었다. 그래서 우리가 만드는 Meteor 앱도 Javascript로 만들어야 한다. Javascript 공력이 부족하면 <a href="http://bonsaiden.github.com/JavaScript-Garden/ko/">Javascript Garden</a>을 보라. Javscript 내공을 증진하는데 매우 좋다.</p>

<p>Meteor는 <a href="http://www.mongodb.org/">MongoDB</a>를 사용해서 데이터를 저장한다. Meteor는 MongoDB를 직접 쓰지 않고 Minimongo라는 인터페이스를 사용한다. Minimongo는 MongoDB 인터페이스를 많이 지원하지만, 아직 전부 지원하지 못한다. MongoDB가 정확히 어떻게 동작하는지 알 필요는 없지만 적어도 Meteor의 <a href="http://docs.meteor.com/#collections">컬랙션 문서</a>는 보는 게 좋다. 어떻게 해야 하는지 알려준다.</p>

<p>메테오는 현재 <a href="http://handlebarsjs.com/">handlebars</a>을 템플릿 엔진으로 사용한다. 아직은 handlebars밖에 사용할 수 없지만, 조만간에 다른 문파의 템플릿 엔진도 사용할 수 있는 날이 올 것이다.</p>

<p>어찌 됐건 우리는 계속 웹사이트를 만들고 있을 테니 HTML과 CSS의 고수도 돼야 한다.</p>

<h2>The Basics</h2>

<p>Meteor 프로젝트는 대부분 Javascript 파일로 구성된다. 프로젝트 디렉토리 중 아무 데나 <code>*.js</code> 파일을 두면 Meteor가 자동으로 로드해서 실행한다. Meteor 프로젝트에 있는 모든 Javascript 파일은 서버와 클라이언트에 모두 배포된다(꼭 그런 것은 아니고 제외하는 방법이 있다). 이것은 Meteor의 절대 무공(really cool) 중에 하나다. 우리는 모든 것을 Javascript로 개발하고 코드를 한 번만 시전해도(write) 서버와 클라이언트 양쪽에서 사용할 수 있다.</p>

<p>또 다른 Meteor만의 독문 무공으로 <code>*.less</code> 파일을 프로젝트 디렉토리 중 어디엔가 두면 Meteor가 자동으로 컴파일하고 클라이언트에 전송해서 페이지에 포함한다.</p>

<p>그것뿐만 아니라 Meteor 서버 코드와 클라이언트 코드를 구분하는 방법도 제공한다. <code>Meteor.is_server</code>와 <code>Meteor.is_client</code> 플래그로 구분할 수 있다.</p>

<p>다음은 서버코드와 클라이언트 코드를 구분하는 예제다. 브라우저의 Javascript 콘솔에 "Hi. I'm CLIENT"이라는 로그가 찍히고 Meteor 서버에는 "Hi. I'm SERVER"라고 출력된다.</p>

<pre><code class="dfm javascript">// This function is available on both the client and the server.
var greet = function(name) {
    console.log("Hi. I'm " + name);
}

// Everything in here is only run on the server.
if(Meteor.is_server) {
    greet("SERVER");
}

// Everything in here is only run on the client.
if(Meteor.is_client) {
    greet("CLIENT");
}
</code></pre>

<p>정말 간단하다. 클라이언트와 서버는 코드를 공유하기 쉬워서 재사용성을 극대화할 수 있고 개발 시간이 극적으로 줄어든다.</p>

<h2>Project Structure</h2>

<p>클라이언트와 서버랑 공유하지 않는 코드가 많으면 어떻게 할까. 가문의 독문(private) 알고리즘이 있으면 서버에서만 실행돼야 하고 절대 다른 사람이 보면 안 되니까 클라이언트에 전송되면 안 된다. Meteor는 서버와 클라이언트 코드를 구분하는 "특별" 디렉토리가 두 개 있다. <code>[project_root]/client/</code>와 <code>[project_root]/server/</code>가 그것이다. server 디렉토리에 있는 Javascript는 클라이언트에 전송되지 않고 서버에서만 실행된다. 반대로 client 디렉토리에 있는 코드는 클라이언트에서만 실행된다. <code>Meteor.is_client</code>와 <code>Meteor.is_server</code>를 안 써도 되기 때문에 매우 편리하다. 그냥 코드를 client 디렉토리에 넣으면 클라이언트 코드가 된다.</p>

<p>파일이 어떻게 로드되는지 알려면 다른 것보다 일단 프로젝트 구조를 알아야 한다. 파일이 두 개 있을 때 어떤 파일이 먼저 로드될까? 다음과 같은 순서로 Javascript 파일을 로드한다.</p>

<ol>
<li><code>[project_root]/lib</code>의 파일이 먼저 로드된다. 라이브러리는 이 디렉토리에 넣는다.</li>
<li>디렉토리 깊이로 파일을 정렬해서 로드한다. 디렉토리 깊이가 깊은 게 먼저 로드된다.</li>
<li>파일은 알파벳 순으로 정렬한다.</li>
<li><code>main.*</code> 파일은 마지막에 로드한다. 다른 스크립트와 라이브러리가 모두 로드되고 나서 로드돼야 하는 코드에 적합하다.</li>
</ol>

<p>Meteor에는 client/sever 코드를 구분하고 로드 순서를 관리하는데 몇 가지 중요한 디렉토리가 있다:</p>

<ul>
<li><code>[project_root]/lib/</code> - 이 디렉토리에 있는 파일은 client/server 코드가 시작하기 전에 로드된다.</li>
<li><code>[project_root]/client/</code> - 이 디렉토리에 있는 파일은 클라이언트인 브라우저에만 전송되고 서버에서는 실행할 수 없다.</li>
<li><code>[project_root]/server/</code> - 서버에서만 실행하고 클라이언트에 전송하지 않을 파일은 이 디렉토리에 넣는다.</li>
<li><code>[project_root]/public/</code> - 정적 파일은 이 디렉토리에 넣는다. image.jpg를 이 디렉토리에 넣고 바로 html에서 사용한다.</li>
<li><code>[project_root]/.meteor/</code> - Meteor는 사용하는 모듈이 무었인지 등등의 프로젝트 관리 정보를 여기에 둔다. <strong>개발자가 직접 이 디렉토리를 건드리지 않아도 된다</strong>.</li>
</ul>

<h2>Reactivity</h2>

<p>Meteor는 데이터가 변경되면 화면에 다시 반영해야 하는 노력을 줄여 준다. "Reactive" 데이터 소스와 컨텍스트를 사용해서 구현한다. Reactive 컨텍스트는 Reactive 데이터 소스를 사용하고 필요하면 다시 실행되는 함수다. 처음에는 이 말을 받아들이는 게 쉽지 않을 것이다. 다음 예제가 명백하게 해줄 것이다.</p>

<p>다음은 html 페이지, <code>cool_dude</code>라는 이름의 Meteor <a href="http://docs.meteor.com/#templates">템플릿</a>, 클라이언트 Javascript 함수다. 이 Javascript 함수는 템플릿을 렌더링하는 데 필요한 <code>name</code>의 값을 리턴한다.</p>

<pre><code class="dfm html">&lt;html&gt;
  &lt;head&gt;
  &lt;/head&gt;
  &lt;body&gt;
    {{&gt; cool_dude }}
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="dfm html">&lt;template name="cool_dude"&gt;
  &lt;p class="important"&gt;{{ name }} sure is one cool dude!&lt;/p&gt;
&lt;/template&gt;
</code></pre>

<pre><code class="dfm javascript">// On the client:
Template.cool_dude.name = function() {
    return "Andrew Scala";
};
</code></pre>

<p>페이지를 렌더링하면 "Andrew Scala sure is one cool dude!"라고 출력된다. 뭐, 참말이다.</p>

<p>템플릿은 Reactive 컨텍스트다. 템플릿을 렌더링할 때 Reactive 데이터 소스를 사용하면 그 데이터 소스가 변경될 때 다시 렌더링한다. 클라이언트의 <code>Session</code> 객체는 Reactive 데이터 소스다. 클라이언트 <code>Session</code> 객체는 키-밸류 형태로 클라이언트에 정보를 저장한다. 그리고 페이지가 새로 고쳐지면 날아간다.</p>

<p>Reactive 데이터 소스를 사용해서 템플릿 컨텍스트를 변경해보자:</p>

<pre><code class="dfm javascript">// When the app starts,
// associate the key "username" with the string "Andrew Scala"
Meteor.startup(function() {
    Session.set("username", "Andrew Scala");
});

Template.cool_dude.name = function() {
    return Session.get("username");
};
</code></pre>

<p>템플릿은 Session에 있는 <code>"username"</code>의 값을 가져다가 템플릿 변수 <code>name</code>에 넣는다. 이제 Reactive 컨텍스트에 Reactive 데이터 소스가 있는 상태가 됐다. Session의 <code>"username"</code> 값이 변하면 템플릿은 새 값을 이용해서 자동으로 다시 렌더링힌다. <code>"username"</code> 값을 바꿔보자:</p>

<pre><code class="dfm javascript">Session.set("username", "Bill Murray");
</code></pre>

<p>이 함수를 호출하자마자(어디서 호출하던 위치는 상관없다) 페이지는 "Bill Murray sure is one cool dude!"로 변경된다. 뭐, 이 말도 참말이다.</p>

<p>Reactive 컨텍스트와 데이터 소스가 궁금하면 Meteor의 <a href="http://docs.meteor.com/#reactivity">Reactivity 문서</a>를 봐라.</p>

<h2>Publish/Subscribe</h2>

<p><strong><em>Note:</em></strong> 프로젝트 루트 디렉토리에서 <code>$ meteor remove autopublish</code>를 꼭 실행해야 한다. Meteor는 기본적으로 모든 데이터를 Publish하는데 이 것은 사파의 사술이다(poor practice).</p>

<p>서버는 클라이언트가 사용할 데이터를 Publish하고 클라이언트는 그 데이터를 Subscribe한다. 처음부터 서버가 데이터를 Publish하고 클라이언트가 Subscribe하는 관계를 이해하긴 어렵다. </p>

<p>경험에 의하면 **</p>

<p>채팅 프로그램이라면 클라이언트는 자기가 참여 중인 채널에서만 메시지를 받아야지 다른 체널의 메시지를 받지 않아야 한다. 사용자 정보도 마찬가지다.</p>

<p>다음 예제는 좀 엉성하다. 클라이언트는 데이터베이스의 모든 메시지를 받는다:</p>

<pre><code class="dfm javascript">var Messages = new Meteor.Collection("messages");

if(Meteor.is_server) {
    Meteor.publish("messages", function() {
        return Messages.find({});
    });
}

if(Meteor.is_client) {
    Meteor.subscribe("messages");
}
</code></pre>

<p>클라이언트는 이제 <code>Messages.find({})</code>를 호출해서 데이터베이스의 모든 메시지를 볼 수 있다. 저질(Bad).</p>

<p>(역주, 클라이언트에서 실행하는 find()는 서버에 요청하지 않고 Minimongo 캐시에서 찾는다. 그러니까, 서버에서 Publish한 데이터는 자동으로 로컬에 캐시되고, 클라이언트에서 find()를 실행하면 그 캐시에서 찾는 구조다. )</p>

<p>Subscribe할 때 파라미터를 명시하면 이 문제를 해결할 수 있다. 모든 메시지에 대해서 Subscribe하는 것이 아니라 실질적으로 필요한 것만 Subscribe한다. <code>"cool_people_channel"</code> 채널에 있는 메시지만 받게 고쳐보자:</p>

<pre><code class="dfm javascript">var Messages = new Meteor.Collection("messages");

if(Meteor.is_server) {
    Meteor.publish("messages", function(channel_name) {
        return Messages.find({channel: channel_name});
    });
}

if(Meteor.is_client) {
    Meteor.subscribe("messages", "cool_people_channel");
}
</code></pre>

<p>이제 클라이언트가 연결하고 메시지를 가져올 때 <code>"cool_people_channel"</code> 채널에 있는 것만 가져온다.</p>

<p><code>"cool_people_channel"</code> 채널에 있는 메시지만 보는 것으로는 충분하지 않다. 다른 채널의 메시지도 이용할 수 있어야 한다. Meteor의 "Reactivity" 이용하면 Session 값에 따라서 동적으로 Subscibe하도록 만들 수 있다.</p>

<pre><code class="dfm javascript">var Messages = new Meteor.Collection("messages");

if(Meteor.is_server) {
    Meteor.publish("messages", function(channel_name) {
        return Messages.find({channel: channel_name});
    });
}

if(Meteor.is_client) {
    Session.set("current_channel", "cool_people_channel");

    Meteor.autosubscribe(function() {
        Meteor.subscribe("messages", Session.get("current_channel"));
    });
}
</code></pre>

<p><a href="http://docs.meteor.com/#Meteor_autosubscribe">Meteor.autosubscribe</a>는 Reactive 컨텍스트다. 그래서 그 안에서 사용한 Reactive 데이터 소스가 변경되면 다시 실행된다. <code>"current_channel"</code>라는 Session 변수에 무슨 채널인지 저장하고 있고 그 값이 바뀌면 Subscription은 갱신되고 다른 메시지도 받게 된다. 만약 사용자가 "breakfast talk"라는 채널로 바꾸려면 <code>Session.set("current_channel", "breakfast_talk")</code>라고 실행해주면 된다. 그러면 autosubscribe의 Reactive 컨텍스트 함수가 다시 실행돼서 이제는 "breakfast_talk" 채널의 메시지를 보게 된다.</p>

<p>클라이언트에 컬렉션을 전부 Publish해야 할 때도 있을 수도 있는데 정말 그게 필요한지 한 번 더 생각해보길 바란다. 그리고 컬렉션의 도큐먼트를 전부 전송하기보다 특정 필드만 전송하는 게 더 낫다.</p>

<h2>Server Methods</h2>

<p>클라이언트에서는 데이터베이스에 있는 데이터를 읽어오는 것 말고는 아무것도 하지 않는 것이 좋다. 그러면 클라이언트는 정보를 어떻게 저장해야 할지 궁금해진다. Meteor 서버의 <a href="http://docs.meteor.com/#methods_header">Method</a>를 사용해서 이 문제를 해결한다. 데이터를 수정하는 것과 같이 위험한 일은 꼭 Method를 이용한다. 서버에 함수를 정의하고 나서 클라이언트에서 그 함수를 호출해서 리턴 값을 받는다. 이게 핵심 아이디어다. 그러면 클라이언트에서는 그 함수가 어떻게 구현됐는지 알 수 없고 다른 방법으로 데이터를 수정하지도 않는다. 그리고 서버는 잘 동작할 것이다.</p>

<p>서버 코드에 <code>create_user</code>라는 Method를 만든다. 이 Method는 데이터베이스에 사용자를 추가하는 Method이고 사용자 이름을 아규먼트로 받는다. 사용자를 추가하고 나중에 도큐먼트를 가져올 수 있도록 도큐먼트 ID를 반환한다. </p>

<pre><code class="dfm javascript">if(Meteor.is_server) {
    Meteor.methods({
        create_user: function(username) {
            console.log("CREATING USER");
            var USER_id = Users.insert({name: username});
            return user_id;
        },
    });
}

// Remember, the client's browser only ever sees the code below:
if(Meteor.is_client) {
    var username = "Andrew Scala";

    Meteor.call("create_user", username, function(error, user_id) {
        Session.set("user_id", user_id);
    });
}
</code></pre>

<p>이 예제에서, <code>user_id</code>를 받아서 클라이언트 Session에 넣는다. 그러면 user_id를 사용하는 템플릿은 자동으로 업데이트된다.</p>

<h2>Protecting your data</h2>

<p>클라이언트 앱에서 Javascript 콘솔을 열고 <strong>데이터베이스 쿼리를 실행할 수 있다</strong>. 이것은 정말 구리다. Meteor 앱에 접속해서 콘솔을 열고 <code>Users.remove({})</code>라고 실행하면 사용자 데이터가 전부 날아간다.</p>

<p>언젠가는 Meteor가 뭔가 해결책을 제시하겠지만, 지금은 그렇다. 다음은 Meteor의 <a href="http://madewith.meteor.com">madewith</a> 사이트의 [소스][<a href='https://github.com/Meteor/madewith]에서'>https://github.com/Meteor/madewith]에서</a> 발췌한 것이다. 이 코드는 클라이언트에서 insert/update/remote 할 수 없게 한다. 다음 코드를 서버 쪽 아무 데나 넣으면 된다:</p>

<pre><code class="dfm javascript">// Relies on underscore.js. In your project directory:
// $ meteor add underscore
Meteor.startup(function() {
    var collections = ['collection_name_1', 'collection_name_2'];

    _.each(collections, function(collection) {
        _.each(['insert', 'update', 'remove'], function(method) {
            Meteor.default_server.method_handlers['/' + collection + '/' + method] = function() {};
        });
    });
});
</code></pre>

<h2>Stay Tuned</h2>

<p>이것으로 Meteor 앱을 만들 준비가 다 됐을까? 기다려라. 두 번째 글, Meteor 앱을 완성하는 방법에 대한 비급을 기대하시라.</p>

<p>이 글이 도움됐는지 알려주면 감사하겠다.</p>

<p>Cheers,</p>

<p>Andrew Scala</p>]]>
</content></entry><entry><title><![CDATA[ Git: Rebase는 언제 어떻게 해야 할까? ]]></title><link href="http://dogfeet.github.com/articles/2012/git-merge-rebase.html" /><updated>2012-08-12T00:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/git-merge-rebase.html</id><content type="html"><![CDATA[
<p>처음에는 Rebase를 왜 해야 하고 언제 어떻게 해야 하는지 좀 헷갈린다. 헷갈리는 이유는 정답이 없고 미묘함이 있어서인데 그래도 대략적인 가이드가 있으면 좋겠다 싶어서 정리해보았다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-merge-rebase/git-rebase.jpeg" alt="git-" title="" /></p>

<h2>Social Coding Platform</h2>

<p>svn이나 다른 VCS 도구 말고 git을 사용해야 하는 이유는 커뮤니케이션이다. 개발이라는 작업은 혼자 하는 게 아니라서 코드를 공유하고, 리뷰하고, 피드백을 받아야 하는데 Git으로 하면 일이 좀 쉬워진다(Git이 쉽다는 것은 아니다).</p>

<p>git과 github의 인기는 VCS 본연의 기능뿐만 아니라 커뮤니케이션을 원활하게 할 수 있는 플랫폼이 함께 필요하다는 것을 보여준다. git은 소스관리에도 뛰어난 도구지만 그게 Git만의 장점은 아니다.</p>

<p>git은 단순히 VCS가 아니다. 소스관리뿐만 아니라 커뮤니케이션에 필요한 모든 것이 들어 있다. 특히 코드를 공유하는 것은 정말 끝내 준다. Git 이외에 필요한 도구가 별로 없다. 나는 히스토리를 엉망으로 관리하는 프로젝트을 살펴보고자 gitx를 가끔 사용하고 차이를 살펴보고자 diffmerge를 아주 가끔 사용한다. 정말 아주 가끔이다. 한 달에 한 번도 실행하지 않는다.</p>

<p>그 외에는 항상 콘솔에서 작업한다. git은 아직도 발전 중이고 코드를 쉽게 공유하는 방법이 계속 통합될 것으로 생각한다. git에는 정말 필요한 모든 것이 통합되고 있어서 언젠가 git으로 문자 메시지로 코드를 보낼 수 있는 날이 올지도 모른다는 상상을 하고 있다.</p>

<h2>배려</h2>

<p>동료는 그녀와 같다. 배려 없이 초대에 응하는 그녀는 없다. 최대한 친절을 베풀어야 그녀를 내 저장소로 초대할 수 있다. 공포를 조장하거나 무턱대고 돈만 살포해서는 진심을 이끌어 낼 수 없다. 스스로 응할 때까지 배려하고 인내해야 한다.</p>

<p>코드는 당연히 잘 짜야 한다. 버그는 없을수록 좋고, 주석은 간략하고 명확해야 하고, 변수나 함수이름, 파일이나 디렉토리 구조나 이름 등등…. 중요하지 않은 것이 없다. 좋은 글에는 좋은 문장도 많은 법이다.</p>

<p>git도 마찬가지다. 변수 이름을 잘 짓듯이 브랜치 이름도 잘 지어야 한다. 커밋 메시지도 표준 포멧에 따라 잘 지어야 한다. 그리고 히스토리도 예쁘게 만들어야 한다.</p>

<h2>Merge vs Rebase</h2>

<p>Rebase는 히스토리를 단장하는 데 필요하다. 나 혼자 쓰는 저장소에서도 Rebase가 없으면 지저분해서 히스토리를 읽을 수가 없다.</p>

<p>잘 정리한 히스토리를 엿보고 싶다면 <a href="https://github.com/isaacs/npm/">npm 저장소</a>를 구경해보는 것이 좋다. <a href="https://twitter.com/izs">@izs</a>님은 완전 git타쿠:</p>

<p><img src="/articles/2012/git-merge-rebase/npm-history.png" alt="npm-history" title="" /></p>

<p>히스토리가 정말 보기 좋다. github의 'pull request'도 사용하지 않고 죄다 손으로 Merge하는 것 같다.</p>

<h3>커밋 vs Merge 커밋</h3>

<p>Merge와 Rebase를 살펴보기 전에 커밋부터 다시 살펴보자.</p>

<p>커밋은 의미의 단위다. 지금 하는 일을 적당하게 한 조각으로 나눠서 커밋한다. 10줄, 100줄처럼 정량적인 단위가 아니다. 고기를 사듯이 '커밋 한 근 주세요.'라고 말할 수 없다. <strong>커밋 하나는 의미 하나다</strong>.</p>

<p>커밋 하나하나에도 의미가 있지만 어떤 모듈을 개발한다면 여러 개를 하나로 묶어서 처리할 필요도 있다. 그러니까 여러 개의 커밋을 묶음으로 표현할 수 있는 커밋이 필요하다. 그게 Merge 커밋이다. <strong>Merge 커밋은 일종의 커밋 묶음이다</strong></p>

<p>npm 저장소에 <a href="https://twitter.com/izs">@izs</a>님이 만들어 놓은 Merge 커밋을 보자:</p>

<p><img src="/articles/2012/git-merge-rebase/npm-gyp-history.png" alt="npm-gyp-history" title="" /></p>

<p><code>1ecd0eb</code>는 gyp를 구현한 커밋들을 묶어 놓은 Merge 커밋이다. gyp 브랜치를 만들어 gyp를 구현하고 master 브랜치로 Merge했다.</p>

<p>Merge 커밋은 사실 커밋 묶음 나타내는 것이 아니다. 보통 커밋은 Parent가 하나인데 Merge 커밋은 Parent가 여러 개다. 하지만, Parent가 여러 개인 점을 이용해서 커밋 묶음으로 다룰 수 있다:</p>

<p><img src="/articles/2012/git-merge-rebase/git-merge.png" alt="git-merge" title="" /></p>

<p>C6는 Merge 커밋으로 Parent가 두 개다. </p>

<p>Merge 커밋을 Reset하면 관련 커밋이 전부 Reset된다:</p>

<p><img src="/articles/2012/git-merge-rebase/git-reset.png" alt="git-reset" title="" /></p>

<p><code>C3</code>와 <code>C5</code>가 같이 Reset되기 때문에 master 입장에서는 커밋 묶음이 Reset된 것이다.</p>

<p>npm 저장소에서 master 브랜치가 Merge 커밋인 <code>1ecd0eb</code>를 가리키는 상태에서 'HEAD~1'으로 Reset하면 gyp 브랜치가 통째로 Reset된다. 그래서 master는 <code>c4eb2fd</code>를 가리킨다.</p>

<h2>Merge vs Rebase</h2>

<p>다음과 같은 브랜치를 Merge, Rebase해보고 그 결과를 비교해보자:</p>

<p><img src="/articles/2012/git-merge-rebase/orig.png" alt="orig" title="" /></p>

<p><code>git merge iss1</code> 명령으로 iss1를 Merge한다. 노란색인 C1은 Merge Base이다:</p>

<p><img src="/articles/2012/git-merge-rebase/merge1.png" alt="merge1" title="" /></p>

<p><code>git merge iss2</code> 명령으로 iss2를 Merge한다:</p>

<p><img src="/articles/2012/git-merge-rebase/merge2.png" alt="merge2" title="" /></p>

<p><code>git merge iss3</code> 명령으로 iss3를 Merge한다:</p>

<p><img src="/articles/2012/git-merge-rebase/merge3.png" alt="merge3" title="" /></p>

<p>iss1, iss2, iss3를 Merge 했다. C9, C10, C11은 Merge 커밋이다. 이 그림에서는 히스토리가 복잡하지 않다고 생각할 수 있지만, 이정도 되는 내용도 콘솔에서 보면 헷갈린다. 한눈에 들어오지 않는다. 이제 Rebase 후 Merge해보자.</p>

<p>헷갈릴 수 있으니 원본 브랜치를 다시 한번 보고:</p>

<p><img src="/articles/2012/git-merge-rebase/orig.png" alt="orig" title="" /></p>

<p><code>git checkout iss1</code>과 <code>git rebase master</code>를 차례대로 실행해서 Rebase한다 그러면 Merge Base가 <code>C1</code>이 아니라 <code>C4</code>가 된다:</p>

<p><img src="/articles/2012/git-merge-rebase/rebase1.png" alt="rebase1" title="" /></p>

<p><code>git checkout master</code>과 <code>git merge iss1</code>를 차례대로 실행해서 Merge한다. Rebase를 하면 항상 Fast-Forward Merge가 가능해진다. 하지만, 무턱대고 Fast-Forward Merge를 하는 것이 아니라 앞서 얘기했듯이 커밋을 묶음으로 관리하고 싶지 않을 때만 Fast-Forward Merge한다. 이 경우는 커밋이 하나이므로 그냥 Fast-Forward Merge한다:</p>

<p><img src="/articles/2012/git-merge-rebase/rebase1-merge.png" alt="rebase1-merge" title="" /></p>

<p><code>git checkout iss2</code>과 <code>git rebase master</code>를 차례대로 실행해서 Rebase한다 그러면 Merge Base가 <code>C3</code>가 아니라 <code>C2'</code>가 된다:</p>

<p><img src="/articles/2012/git-merge-rebase/rebase2.png" alt="rebase2" title="" /></p>

<p><code>git checkout master</code>과 <code>git merge --no-ff iss2</code>를 차례대로 실행해서 Merge한다. <code>--no-ff</code> 옵션은 강제로 Merge 커밋을 남기려고 주는 것이다. iss2 브랜치는 커밋이 두 개고 이 커밋은 iss2를 처리한 결과이므로 커밋 묶음으로 처리하는 것이 낫다(물론, 내용상 --no-ff 옵션을 주는 게 틀릴 수도 있다.):</p>

<p><img src="/articles/2012/git-merge-rebase/rebase2-merge.png" alt="rebase2-merge" title="" /></p>

<p><code>git checkout iss3</code>과 <code>git rebase master</code>를 차례대로 실행해서 Rebase한다 그러면 Merge Base가 <code>C3</code>에서 <code>C9</code>이 된다:</p>

<p><img src="/articles/2012/git-merge-rebase/rebase3.png" alt="rebase3" title="" /></p>

<p><code>git checkout master</code>과 <code>git merge --no-ff iss3</code>를 차례대로 실행해서 Merge한다:</p>

<p><img src="/articles/2012/git-merge-rebase/rebase3-merge.png" alt="rebase3-merge" title="" /></p>

<p>다음 그림은 위에서 Rebase 없이 Merge한 결과다. 한번 비교해보자:</p>

<p><img src="/articles/2012/git-merge-rebase/merge3.png" alt="merge3" title="" /></p>

<p>Rebase를 하고 나서 Merge한 것이 훨씬 보기 좋다. 아무리 복잡한 과정을 거쳤어도 한눈에 들어오게 할 수 있다.</p>

<h2>마치며</h2>

<p>Git처럼 히스토리를 다중으로 관리하는 시스템에서 Rebase는 필수다. Mercurial도 Git의 영향을 받아 Rebase를 지원한다. 이글에서는 Rebase가 왜 필요하고 언제 어떻게 해야 하는지 알아봤다.</p>]]>
</content></entry><entry><title><![CDATA[ Meteor: Windows에 설치하기 ]]></title><link href="http://dogfeet.github.com/articles/2012/meteor-for-windows.html" /><updated>2012-08-02T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/meteor-for-windows.html</id><content type="html"><![CDATA[
<p>Rod Johnson에 Meteor에 합류했다기에 자료를 좀 찾아봤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/meteor/meteor.jpg" alt="" title="" /></p>

<h2>Meteor</h2>

<p>Meteor가 무엇인지는 <a href="https://twitter.com/rkjun">@rkjun</a>님의 '<a href="http://rkjun.wordpress.com/2012/06/04/meteor-js-preview-0-3-6-intro/">자바스크립트기반 웹플랫폼 Meteor.js 란 무엇인가</a>'읽어보면 좋다.</p>

<p>현재는 PREVIEW이고 펀딩도 받았으니 곧 좀 더 정리된 버전을 내놓으리라 기대된다.</p>

<p>driver만 구현하면(driver라는 건 mongo API다 mongo API로 질의할 수 있도록 만들어 주면 된다) mongoDB말고 다른 것도 사용할 수 있다고 하고 있고 hanldebar말고 다른 템플릿 엔진도 사용할 수 있다고 하는데 아직 직접 통합해서 써야 한다. 특히 RDB를 사용하려면 기다려야 한다.</p>

<p><a href="https://github.com/bevry/docpad">docpad</a>의 <a href="https://twitter.com/balupton">@balupton</a>은 JavaScript 컬랙션에 대해서 Mongo API처럼 질의하는 <a href="https://github.com/bevry/query-engine">query-engine</a> 만들어서 사용한다. mongo API가 데이터를 질의하는데 꽤 편리한 방법인듯 하다.</p>

<p>node는 CRUD 웹 앱에 취약하다라고 생각했는데, meteor를 보면 CRUD 웹 앱 분야에서도 node가 빛을 발할 수 있다는 것을 보여준다. 현재 구조로도 'Single Page 웹 앱'에 대해서는 어느 플랫폼 보다 나은 생산성을 보여줄 것 같다.</p>

<h2>Windows 용 Meteor</h2>

<p>아직 Meteor가 공식 지원하는 플랫폼은 Linux와 Mac뿐이다. Installer를 열어보면 Linux에서는 해당 패키지로 설치하니 Debian 계열에서만 도드라지는 결벽증에도 안심이다.</p>

<p>다음 글을 보면 아직 완전하진 않은 것 같지만, 비공식적으로 Window 용 Meteor를 배포하고 있다:</p>

<p><a href="https://github.com/meteor/meteor/pull/162">Windows support for Meteor</a></p>

<p><a href="https://dl.dropbox.com/s/8g6o0edqhqmzly1/Meteor.msi?dl=1">meteor.msi</a> 다운 로드해서 설치하고 path만 걸어 주면 된다. node도 들어 있기 때문에 기존에 사용하던 node와 엉키지 않도록 Path를 잘 걸어준다. 'c:\Meteor'에 설치했으면 다음과 같이 설정한다:</p>

<pre><code>set PATH=c:\Meteor;c:\Meteor\bin;%PATH%
</code></pre>

<p><code>c:\Meteor\bin</code>에 node, npm이 들어 있으니 이 디렉토리도 추가한다.</p>

<p>현재 이 패키지에 들어 있는 node 버전은 <code>v0.6.19</code>이고 meteor 버전은 <code>v0.3.7</code>이다. node의 최신 버전은 <code>v0.8.4</code>이고 meteor의 최신 버전은 <code>v0.3.8</code>인 걸 가만할 때 쓸만한 것 같다. meteor에서 직접 신경 쓰는 것 같으니, 앞으로도 너무 버전이 벌어지지 않게끔 해줄 것 같다.</p>

<p>meteor/docs 앱을 실행하면 다음과 같이 실행된다:</p>

<p><img src="/articles/2012/meteor/meteor-run.jpg" alt="" title="" /></p>

<p>출력메시지는 최신 버전이 아니니 update하라는 얘기인데 <code>meteor update</code>할 수 없다. 그 외에는 잘 동작하는 것 같다. 아마 msi 파일을 다시 배포할 것이라고 생각한다. </p>]]>
</content></entry><entry><title><![CDATA[ sbt: Getting Started Guide: .sbt Build Definition ]]></title><link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-basic-def.html" /><updated>2012-07-29T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/sbt-getting-started-basic-def.html</id><content type="html"><![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2><code>.sbt</code> Build Definition</h2>

<p>이 페이지는 sbt 빌드를 정의하는 법을 설명한다. sbt "원리"와 <code>build.sbt</code>의 문법을 설명한다. <a href="/articles/2012/sbt-getting-started-running.html">sbt를 실행하는 방법</a>은 이미 숙지했다고 가정하고 설명한다. 아직 익히지 못했으면 이전 페이지를 읽어라.</p>

<h3><code>.sbt</code> vs. <code>.scala</code> Definition</h3>

<p>sbt 빌드는 base 디렉토리에 <code>.sbt</code> 파일을 만들고 그 파일에 정의한다. <code>.scala</code> 파일은 base 디렉토리 하위에 <code>project</code> 디렉토리에 만들고 거기에 넣는다.</p>

<p>두 파일 중 아무거나 하나만 만들어 사용할 수도 있고 함께 혼용해도 된다. 그래도 <code>.sbt</code> 파일로 할 수 없는 일만 <code>.scala</code> 파일로 구현하고 대부분은 <code>.sbt</code> 파일을 사용하는 것이 바람직하다:</p>

<ul>
<li>sbt 커스트마이즈하기(설정이나 타스크를 추가한다)</li>
<li>네스티드(nested) 서브 프로젝트를 정의한다.</li>
</ul>

<p>이 글은 <code>.sbt</code> 파일만 설명한다. <code>.scala</code> 파일을 사용하는 방법은 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala build definition</a>에서 설명한다.</p>

<h3>What is a build definition?</h3>

<p><em>* 이 부분은 반드시 절대로 꼭 읽어주세요. *</em></p>

<p>sbt는 실제로 빌드하기 전에 프로젝트를 검사하고 빌드 스크립트를 처리한다. 그 전처리를 완료하면 immutable 맵이 하나 생성되는데 그 맵에 빌드 정보가 <code>키/밸류</code> 형태로 들어간다.</p>

<p>예를 들어, 키가 <code>name</code>인 항목의 스트링 밸류는 프로젝트 이름을 의미한다.</p>

<p><em>우리가 만든 빌드 정의가 바로 sbt 맵으로 만들어지는 것이 아니다.</em></p>

<p>우선 모든 빌드 정의를 <code>Setting[T]</code> 타입의 객체를 담는 리스트로 만든다. <code>Setting[T]</code>의 T는 맵의 밸류 타입을 의미한다. Java에서 <code>Setting&lt;T&gt;</code>이라고 하는 것과 같은 표현이다. <code>Setting</code>에는 맵으로 변환하기 위한 정보가 들어간다. 예를 들어, <code>키/밸류</code> 항목을 새로 만들어야 하는지 기존의 항목의 밸류에 추가하면 되는지의 정보가 담긴다. '함수형 프로그래밍' 정신에 따라서 맵으로 변형 시 기존의 맵을 수정해서 리턴하는 것이 아니라 맵을 새로 만들어 리턴한다.  </p>

<p><code>build.sbt</code> 파일에서 다음과 같이 프로젝트 이름을 정의하면 <code>Setting[String]</code> 인스턴스가 만들어진다:</p>

<pre><code class="dfm scala">name := "hello"
</code></pre>

<p>키가 <code>name</code>이고 밸류가 <code>"hello"</code>인 <code>Setting[String]</code> 객체가 생성되고 sbt 맵에 키가 <code>name</code>인 항목이 있으면 그 항목의 밸류만 교체하고 없으면 해당 항목을 새로 만든다. 다시 말하지만, 이때 변형된 맵은 새로 생성된다.</p>

<p>이 맵이 만들어지는 과정을 살펴보자. sbt는 먼저 Setting 리스트을 정렬한다. 키가 같은 항목들은 하나로 합치고 밸류에서 다른 항목을 사용하고 있으면 그 항목부터 처리한다. 설정 간 의존성이 있으면 의존성부터 해결한다. sbt는 정렬된 <code>Setting</code> 리스트를 하나씩 map으로 변환한다.</p>

<p>요약: <em>빌드 정의는 먼저 <code>Setting[T]</code> 리스트로 만들고 다시 <code>Setting[T]</code> 리스트를 sbt 맵으로 변환한다. <code>T</code>는 각 밸류의 타입이다</em>.</p>

<h3>How <code>build.sbt</code> defines settings</h3>

<p><code>build.sbt</code> 파일의 자료구조는 <code>Seq[Setting[_]]</code>이다. 이 파일은 Scala Expression의 리스트인데 한 줄 띄우는 것으로 구분한다. 각 줄은 리스트의 항목 하나이고 순서대로 처리된다. <code>.scala</code> 파일에서 <code>.sbt</code> 파일의 내용을 <code>Seq(</code>와 <code>)</code>로 감싸고 빈 줄 대신에 콤마를 넣으면 <code>.sbt</code> 파일에서 한 것과 동일한 코드가 된다.</p>

<p>다음은 <code>.sbt</code> 파일 예제이다:</p>

<pre><code class="dfm scala">name := "hello"

version := "1.0"

scalaVersion := "2.9.1"
</code></pre>

<p><code>build.sbt</code> 파일은 빈 줄로 구분하는 <code>Setting</code> 객체의 리스트다. 각 <code>Setting</code>은 Scala Expression으로 정의한다. </p>

<p><code>build.sbt</code>에 있는 Expression은 서로서로 독립적이고 문법상으로 Scala Statement가 아니라 Scala Expression이다. 그래서 <code>build.sbt</code> 파일에 Scala Expresion을 정의할 때 그 Expresion 제일 앞에는 <code>val</code>, <code>object</code>, 클래스, 메소드를 정의할 수 없다.</p>

<p>왼쪽에 사용한 <code>name</code>, <code>version</code>, <code>scalaVersion</code>은 <em>키</em>다. 키는 <code>SettingKey[T]</code>, <code>TaskKey[T]</code>, <code>InputKey[T]</code>의 인스턴스이고 <code>T</code>는 밸류의 타입이다. 아래에서 키에 대해서 좀 더 설명한다.</p>

<p>키는 <code>Settings[T]</code>를 리턴하고 이름이 <code>:=</code>인 메소드를 호출한다. 이 메소드는 Java 처럼 호출할 수도 있다:</p>

<pre><code class="dfm scala">name.:=("hello")
</code></pre>

<p>스칼라에서는 <code>name := "hello"</code>라고 사용해도 메소드를 호출할 수 있다. 스칼라 문법에서는 이렇게 메소드를 호출하는 것도 가능하다.</p>

<p><code>name</code> 키에 있는 <code>:=</code> 메소드는 <code>Setting</code> 객체를 반환한다. 정확한 타입은 <code>Setting[String]</code>이다. <code>name</code> 키의 타입은 <code>SettingKey[String]</code>인데 여기서 <code>String</code>은 <code>name</code> 자체의 타입이다. <code>Setting[String]</code> 인스턴스가 반환되면 <code>name</code>을 키로 해서 sbt 맵에 넣는다. 이 <code>Setting[String]</code> 인스턴스의 값은 <code>"hello"</code>다.</p>

<p>타입을 틀리게 넣으면 컴파일 안 된다:</p>

<pre><code class="dfm scala">name := 42  // will not compile
</code></pre>

<h3>Settings are separated by blank lines</h3>

<p>다음과 같이 <code>build.sbt</code> 파일을 작성할 수 없다:</p>

<pre><code class="dfm scala">// will NOT work, no blank lines
name := "hello"
version := "1.0"
scalaVersion := "2.9.1"
</code></pre>

<p>Setting을 구분해 주는 구분자가 필요하다. sbt는 구분자가 있어야 Scala Expression을 구분할 수 있다.</p>

<p><code>.sbt</code> 파일에 구현하는 것은 Scala Expression이지 Scala 프로그램이 아니다. sbt는 각 Scala Expression을 하나씩 잘라서 개별적으로 컴파일한다.</p>

<p>Scala 프로그램을 사용하고 싶으면 <code>.sbt</code> 파일이 아니라 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala 파일</a>로 구현해야 한다. 이때에는 <code>.sbt</code> 파일이 없어도 된다. <code>.scala</code> 파일을 사용하는 방법은 나중에 설명한다. 어떻게 하는지 살짝 들춰보자면 <code>.sbt</code> 파일에서 정의하던 Setting Expression을 <code>.scala</code> 파일에서 <code>Seq[Setting]</code> 자료구조로 정의하면 된다.</p>

<h3>Keys are defined in the Keys object</h3>

<p>빌트인 키는 <a href="http://harrah.github.com/xsbt/latest/sxr/Keys.scala.html">Keys</a> 객체에 정의되 있다. <code>build.sbt</code>에는 <code>import sbt.Keys._</code>가 묵시적으로 선언돼 있어서 <code>sbt.Keys.name</code>라고 안 쓰고 <code>name</code>이라고 바로 써도 되는 것이다.</p>

<p>Key를 새로 정의하려면 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala 파일</a>이나 <a href="/articles/2012/sbt-getting-started-using-plugins.html">plugin</a>으로 정의해야 한다.</p>

<h3>Other ways to transform settings</h3>

<p><code>:=</code>으로 리플레이스 하는 것이 가장 단순한 변형 방법이지만 다른 방법도 있다. 예를 들어 <code>+=</code>으로도 Setting 밸류를 추가할 수 있다.</p>

<p>다른 방법에 대해서 <a href="/articles/2012/sbt-getting-started-scopes.html">scopes</a>과 그 다음으로 이어지는 '<a href="/articles/2012/sbt-getting-started-more-about-settings.html">More About Settings</a>'에서 자세히 설명한다.</p>

<h3>Task Keys</h3>

<p>Key는 세 종류이다:</p>

<ul>
<li><code>SettingKey[T]</code>: 이 키와 밸류는 딱 한 번 해석한다. 프로젝트를 로드할 때 해석하고 다시 해석하지 않는다.</li>
<li><code>TaskKey[T]</code>: 이 키와 밸류는 매번 다시 해석한다. 그래서 문제가 될 수도 있다.</li>
<li><code>InputKey[T]</code>: 이 가이드에서는 <code>InputKey</code>는 설명하지 않는다. 이 가이드를 다 보고 나서 <a href="https://github.com/harrah/xsbt/wiki/Input-Tasks">Input Task</a>를 봐라.</li>
</ul>

<p><em>타스크</em>를 정의한다고 sbt에 말할 때 <code>TaskKey[T]</code>를 사용한다. <code>compile</code>이나 <code>package</code> 같은 것이 타스크이다. 이 타스크는 <code>Unit</code>을 리턴하거나 해당 타스크와 관련된 어떤 밸류를 리턴한다. 스칼라에서는 <code>Unit</code>이 <code>void</code>다. 예를 들어 <code>package</code> 타스크는 타입이 <code>TaskKey[File]</code>이고 생성할 jar 파일을 리턴한다.</p>

<p>타스크를 실행할 때마다 항상 다시 실행한다. <code>compile</code> 타스크를 실행하면 <code>compile</code> 타스크에 필요한 모든 타스크가 한 번씩 다시 실행된다.</p>

<p>sbt 맵에는 프로젝트 정보가 담겨 있다. <code>name</code> 같은 게 이에 해당하고 항상 고정된 밸류를 저장한다. <code>compile</code>같은 타스크는 고정 값이 아니라 실행 코드이다. 이 실행 코드가 스트링을 리턴한다고 해도 스트링을 얻으려면 항상 다시 실행해야 한다.</p>

<p><em>타스크나 설정이나 키를 사용하는 것은 동일하다.</em> 매번 실행하는 것인지 아닌지가 타스크인지 아닌지를 구분하는 요소이며 이것은 밸류가 아니라 키의 프로퍼티에 해당한다.</p>

<p><code>:=</code>을 사용해서 타스크에 코드를 할당할 수 있다. 이 코드는 매번 실행된다:</p>

<pre><code class="dfm scala">hello := { println("Hello!") }
</code></pre>

<p>타스크 키로 <code>Setting</code>을 만들 때와 설정 키로 <code>Setting</code> 을 만들 때는 타입이 다르다. <code>taskKey := 42</code> 가 생성하는 결과의 타입은 <code>Setting[Task[T]]</code>이지만 <code>settingKey := 42</code>가 생성하는 결과의 타입은 <code>Setting[T]</code>이다. 타스크는 타스크를 실행해서 <code>T</code> 타입의 밸류를 생성하는 것뿐이고 그 외에는 차이가 없다.</p>

<p>내부적으로 <code>T</code>와 <code>Task[T]</code> 타입이 다른 점이 더 있다. 설정키는 프로젝트를 로드할 때 한 번만 처리하기 때문에 타스크 키에 의존하지 않는다. 곧 읽게 될 <a href="/articles/2012/sbt-getting-started-more-about-settings.html">More About Settings</a>에서 이 문제를 자세히 다룬다.</p>

<h3>Keys in sbt interactive mode</h3>

<p>대화형 모드에서 타스크 이름을 입력하면 해당 타스크가 실행된다. <code>compile</code>이라는 타스크 키가 있으니까 대화형 모드에서 <code>compile</code>이라고 입력했을 때 compile 타스크가 실행될 수 있다.</p>

<p>타스크 키가 아니라 설정 키를 입력하면 그냥 화면에 그 키의 밸류를 보여준다. <br />타스크 키를 입력하면 타스크가 실행되지만, 그 결과를 보여주진 않는다. 타스크의 결과를 보고 싶으면 <code>show &lt;task name&gt;</code>이라고 입력해야 한다.</p>

<p>키 이름은 Scala 관례에 따라 카멜케이스 방식으로 지어야 하고 sbt 명령어는 <code>하이픈 구분자</code> 방식을 사용한다. <a href="http://harrah.github.com/xsbt/latest/sxr/Keys.scala.html">Keys</a>에 정의된 키를 sbt에서 사용할 때는 하이픈 구분자를 사용해야 한다. <code>Keys.scala</code>에 정의한 것 중 한 예를 보자:</p>

<pre><code class="dfm scala">val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")
</code></pre>

<p>sbt에서 타스크를 입력할 때는 <code>scalacOptions</code>이 아니라 <code>scalac-options</code>라고 입력한다.</p>

<p>sbt 대화형 모드에서 <code>inspect &lt;keyname&gt;</code>을 입력하면 입력한 키에 대한 정보를 자세히 보여준다. <code>inspect</code>는 입력한 키의 밸류와 간략한 설명을 보여준다. 물론 처음 보는 정보들까지도 함께 보여준다.</p>

<h3>Imports in <code>build.sbt</code></h3>

<p><code>build.sbt</code> 파일에 import 구문을 사용할 수 있다. import 구문은 한 줄 띄우기를 할 필요가 없다.</p>

<p>다음을 보면 무슨 소린지 한 번에 알 수 있다:</p>

<pre><code class="dfm scala">import sbt._
import Process._
import Keys._
</code></pre>

<p>(<a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala build definition</a>를 보면 <code>Build</code>나 <code>Plugin</code> 객체도 임포트해서 사용하는 방법을 설명한다. <code>Build</code>나 <code>Plugin</code> 객체를 임포트해야 하면 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala build definition</a>를 보라.)</p>

<h3>Adding library dependencies</h3>

<p>라이브러리 의존성을 추가하는 방법은 두 가지다. 하나는 unmanaged 방식으로 <code>lib/</code> 디렉토리에 jar 파일을 그냥 넣으면 된다. 다른 하나는 managed 방식으로 <code>build.sbt</code> 파일에 다음과 같이 추가한다:</p>

<pre><code class="dfm scala">libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3"
</code></pre>

<p>이 것은 버전이 10.4.1.3인 Apache Derby 라이브러리를 managed 방식으로 추가하는 것을 보여준다. </p>

<p><code>libraryDependencies</code>에서는 <code>+=</code>와 <code>%</code> 메소드를 추가로 알아야 한다: <code>+=</code>는 기존의 밸류를 교체하는 것이 아니라 기존의 밸류에 새 밸류를 추가하는 것이다. 자세한 것은 <a href="/articles/2012/sbt-getting-started-more-about-settings.html">More About Settings</a>에서 설명한다. <code>%</code>는 Ivy 모듈 ID를 조합하는 데 사용하고 자세한 설명은 <a href="/articles/2012/sbt-getting-started-library-dependencies.html">Library Dependencies</a>에 있다.</p>

<p>라이브러리 의존성은 <a href="/articles/2012/sbt-getting-started-library-dependencies.html">Library Dependencies</a>에서 다룰 예정이다. 여기서는 이 정도로 마무리하겠다.</p>]]>
</content></entry><entry><title><![CDATA[ sbt: Getting Started Guide: Running ]]></title><link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-running.html" /><updated>2012-07-24T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/sbt-getting-started-running.html</id><content type="html"><![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h1>Running</h1>

<p>이 페이지는 이미 설정이 끝난 프로젝트에서 <code>sbt</code> 명령을 사용하는 법을 설명한다. <a href="/articles/2012/sbt-getting-started-setup.html">sbt를 설치</a>했고 <a href="/articles/2012/sbt-getting-started-hello.html">Hello, World</a>정도는 만들어 봤다고 간주한다.</p>

<h2>Interactive mode</h2>

<p>프로젝트 디렉토리에서 아무런 아규먼트 없이 sbt를 실행한다:</p>

<pre><code>$ sbt
</code></pre>

<p>아규먼트 없이 sbt를 실행하면 인터랙티브 모드로 실행돼서 커맨드 프롬프트가 나온다. 이 커맨드 프롬프트는 탭 완성과 히스토리까지 지원한다!</p>

<p>예를 들어 sbt 프롬프트에서 <code>compile</code>이라고 실행하고:</p>

<pre><code>&gt; compile
</code></pre>

<p><code>compile</code>을 다시 실행할 때는, 위 방향키를 누르고 엔터를 친다.</p>

<p><code>run</code>을 입력해서 프로그램을 실행한다.</p>

<p>Unix에서는 Ctrl+D 키를, Windows에서는 Ctrl+Z 키를 누르거나 <code>exit</code>라고 입력하면 인터랙티브 모드를 빠져나온다.</p>

<h2>Batch mode</h2>

<p>sbt를 배치 모드로 실행할 수도 있다. 스페이스로 구분해서 목록을 죽 나열하고 sbt 아규먼트로 넘기면 된다. sbt의 아규먼트는 sbt 명령과 그 명령의 아규먼트를 의미한다. sbt 명령어와 해당 명령의 아규먼트는 따옴표(<code>"</code>)로 묶어서 아규먼트 하나로 만든다:</p>

<pre><code>$ sbt clean compile "test-only TestA TestB"
</code></pre>

<p>이 예제에서는 <code>test-only</code> 명령에 <code>TestA와</code>TestB<code>아규먼트를 넘기면 입력한 sbt 명령어 순으로</code>clean<code>,</code>compile<code>,</code>test-only`가 실행된다.</p>

<h2>Continuous build and test</h2>

<p>소스 파일이 수정될 때 자동으로 컴파일하고 테스트를 실행하게 할 수 있으니 수정-컴파일-테스트 과정에 드는 시간을 절약할 수 있다.</p>

<p>명령을 실행할 때 앞에 <code>~</code> 라고 적어주면 소스 파일이 변경될 때마다 명령어가 실행된다. 예를 들어, 인터랙티브 모드에서는 다음과 같이 실행한다:</p>

<pre><code>&gt; ~ compile

Press enter to stop watching for changes.
</code></pre>

<p>인터랙티브 모드 뿐만 아니라 배치 모드에서도 <code>~</code>를 사용할 수 있다.</p>

<p>자세한 내용은 <a href="https://github.com/harrah/xsbt/wiki/Triggered-Execution">Triggered Execution</a>에서 있다.</p>

<h2>Common commands</h2>

<p>다음은 자주 사용하는 sbt 명령어다. 나머지 sbt 명령어는 <a href="https://github.com/harrah/xsbt/wiki/Command-Line-Reference">Command Line Reference</a>에서 설명한다.</p>

<ul>
<li><code>clean</code>
<code>target</code> 디렉토리에 생성한 파일을 모두 삭제한다.</li>
<li><code>compile</code>
<code>src/main/scala</code>와 <code>src/main/java</code> 디렉토리에 있는 소스를 컴파일한다.</li>
<li><code>test</code>
테스트를 전부 컴파일하고 실행한다.</li>
<li><code>console</code>
컴파일한 소스와 모든 의존성을 자동으로 클래스패스에 포함시켜서 Scala 인터프리터를 실행한다. sbt 콘솔에서 <code>:quit</code>를 입력하거나 Ctrl+D(Unix) 키나 Ctrl+Z(Windows)를 누르면 빠져나온다.</li>
<li><code>run &lt;argument&gt;*</code>
<code>sbt</code>가 실행되고 있는 가상 머신에서 해당 프로젝트의 메인 클래스를 실행한다.</li>
<li><code>package</code>
<code>src/main/scala</code>와 <code>src/main/java</code>에 있는 소스 파일을 컴파일한 클래스와 <code>src/main/resources</code>에 있는 파일까지도 전부 포함하는 jar파일을 생성한다. </li>
<li><code>help &lt;command&gt;</code>
해당 명령어의 도움말을 보여준다. <command>를 생략하면 모든 명령어에 대한 요약 도움말을 보여준다.</li>
<li><code>reload</code>
빌드 정의 파일인 <code>build.sbt</code>, <code>project/*.scala</code>, <code>project/*.sbt</code>을 다시 로드한다. 이 파일을 수정했을 때 필요하다.</li>
</ul>

<h2>Tab completion</h2>

<p>인터랙티브 모드에서는 탭 자동완성을 사용할 수 있다. 프롬프트에 입력한 게 없을 때에도 탭 자동완성을 사용할 수 있다. 탭 키를 한번 누르면 가능한 데까지 자동완성을 해주고 거기서 한 번더 누르면 그 다음에 선택할 수 있는 모든 명령어를 보여준다.</p>

<h2>History Commands</h2>

<p>인터랙티브 모드에서는 히스토리가 저장되는데 sbt를 종료하거나 재시작할 때도 저장된다. 방향키로 히스토리를 조회할 수 있다. 다음은 히스토리와 관련된 명령이다:</p>

<ul>
<li><code>!</code>
히스토리 명령어에 대한 도움말을 보여준다.</li>
<li><code>!!</code>
이전 명령어를 실행한다.</li>
<li><code>!:</code>
모든 이전 명령어를 보여준다.</li>
<li><code>!:n</code>
최근에 실행한 n번째 명령어를 보여준다.</li>
<li><code>!n</code>
최근에 실행한 n번째 명령어를 실행한다. <code>!:</code> 명령어는 과거 명령어를 순서에 따라 보여준다.</li>
<li><code>!-n</code>
최근에 실행한 n번째 명령어를 실행한다.</li>
<li><code>!string</code>
<code>string</code>으로 시작하는 가장 최근 명령어를 실행한다.</li>
<li><code>!?string</code>
<code>string</code>이 포함된 가장 최근 명령어를 실행한다.</li>
</ul>]]>
</content></entry><entry><title><![CDATA[ sbt: Getting Started Guide: Directory Layout ]]></title><link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-directory-layout.html" /><updated>2012-07-15T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/sbt-getting-started-directory-layout.html</id><content type="html"><![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h3>Base directory</h3>

<p>sbt에서 "base 디렉토리"는 프로젝트가 들어 있는 디렉토리를 말한다. <a href="/articles/2012/sbt-getting-started-hello.html">Hello, World</a> 에서 만든 <code>hello</code> 프로젝트에는 <code>hello/build.sbt</code>와 <code>hello/hw.scala</code> 파일이 있는데 여기서 <code>hello</code> 디렉토리가 base 디렉토리이다.</p>

<h2>Source code</h2>

<p>소스는 <code>hello/hw.scala</code>처럼 프로젝트 base 디렉토리에 넣으면 된다. 하지만 보통은 그냥 넣으면 너무 지저분하기 때문에 정리해서 넣는 규칙이 있다.</p>

<p>sbt는 기본적으로 <a href="http://maven.apache.org/">Maven</a>과 같은 디렉토리 레이아웃을 사용한다(모든 경로는 base 디렉토리를 기준으로 하는 상대 경로다):</p>

<pre><code>src/
  main/
    resources/
       &lt;files to include in main jar here&gt;
    scala/
       &lt;main Scala sources&gt;
    java/
       &lt;main Java sources&gt;
  test/
    resources
       &lt;files to include in test jar here&gt;
    scala/
       &lt;test Scala sources&gt;
    java/
       &lt;test Java sources&gt;
</code></pre>

<p><code>src/</code> 안에 있는 다른 디렉토리와 숨겨진 디렉토리는 무시된다.</p>

<h2>sbt build definition files</h2>

<p><code>build.sbt</code> 파일은 base 디렉토리에 넣지만 다른 sbt 파일은 <code>project</code> 디렉토리를 만들어 넣는다.</p>

<p><code>project</code> 디렉토리에는 <code>.scala</code> 파일을 넣을 수 있고 이 <code>.scala</code> 파일은 <code>.sbt</code> 파일과 함께 빌드를 정의하는데 쓴다. 자세한건 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala Build Definition</a>를 봐라.</p>

<pre><code>build.sbt
project/
  Build.scala
</code></pre>

<p><code>project/</code> 디렉토리 안쪽에도 <code>.sbt</code> 파일을 넣을 수 있지만 base 디렉토리에 있는 <code>.sbt</code> 파일과 다르다. 이점은 몇 가지 사전지식이 필요하기 때문에 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">나중에</a>에서 설명한다.</p>

<h2>Build products</h2>

<p>기본적으로 <code>target</code> 디렉토리에 파일을(컴파일한 클래스, 패키지한 jar 파일, managed 파일, 캐시, 문서) 생성한다.</p>

<h2>Configuring version control</h2>

<p><code>.gitignore</code> 파일에 <code>target/</code> 디렉토리를 추가한다. 다른 버전관리 시스템도 git처럼 <code>target/</code> 디렉토리를 추가해야 한다:</p>

<pre><code>target/
</code></pre>

<p>이름이 <code>/</code>로 끝났다. <code>/</code> 끝나는 이름은 디렉토리만 매치하겠다는 의미다. 그리고 <code>/</code>로 시작하지 않았기 때문에 base 디렉토리에 있는 <code>target/</code> 뿐만 아니라 <code>project/target</code>처럼 하위 디렉토리 안에 있는 디렉토리도 매치된다.</p>]]>
</content></entry><entry><title><![CDATA[ sbt: Getting Started Guide: Hello, World ]]></title><link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-hello.html" /><updated>2012-07-07T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/sbt-getting-started-hello.html</id><content type="html"><![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2>소스 코드에 프로젝트 디렉토리 만들기</h2>

<p>어떤 디렉토리에 소스 파일이 하나라도 있으면 그 디렉토리는 sbt 프로젝트라고 할 수 있다. <code>hello</code> 디렉토리를 만들고 그 안에 다음과 같은 <code>hw.scala</code> 파일을 만들어 넣는다:</p>

<pre><code>object Hi {
    def main(args: Array[String]) = println("Hi!")
}
</code></pre>

<p><code>hello</code> 디렉토리에서 sbt를 실행하고 sbt 콘솔에서 <code>run</code>을 실행한다. Linux와 OS X에서는 다음과 같이 실행한다:</p>

<pre><code>$ mkdir hello
$ cd hello
$ echo 'object Hi { def main(args: Array[String]) = println("Hi!") }' &gt; hw.scala
$ sbt
...
&gt; run
...
Hi!
</code></pre>

<p>sbt는 관례에 따라 동작하는 것인데 다음과 같은 것을 찾는다.</p>

<ul>
<li>Base 디렉토리에 있는 소스</li>
<li><code>src/main/scala</code> 또는 <code>src/main/java</code>에 있는 소스</li>
<li><code>src/test/scala</code> 또는 <code>src/test/java</code>에 있는 테스트</li>
<li><code>src/main/resources</code> 또는 src/test/resources`에 있는 데이터 파일</li>
<li><code>lib</code>에 있는 jar 파일</li>
</ul>

<p>sbt는 sbt를 실행하는 데 사용한 Scala 버전으로 프로젝트를 빌드한다.</p>

<p><code>sbt run</code>으로 프로젝트를 실행하거나 <code>sbt console</code> 명령으로 <a href="http://www.scala-lang.org/node/2097">Scala REPL</a>을 연다. <code>sbt console</code>은 프로젝트의 클래스패스에서 실행하는 것이라서 프로젝트 소스를 이용한 Scala 코드를 라이브로 실행 수 있다.</p>

<h2>빌드 정의하기</h2>

<p>프로젝트들은 보통 손으로 설정해줘야 한다. 프로젝트 Base 디렉토리에 <code>build.sbt</code> 파일을 만들고 기본 설정을 한다.</p>

<p>예를 들어, 프로젝트 Base 디렉토리가 <code>hello</code>라면 <code>hello/build.sbt</code> 파일에 다음과 같이 만든다:</p>

<pre><code>name := "hello"

version := "1.0"

scalaVersion := "2.9.1"
</code></pre>

<p>각 아이템 사이에 빈 줄이 있는데 그냥 보기 좋으라고 넣은 것이 아니다. 아이템 사이에는 꼭 빈 줄을 넣어줘야 한다. <a href="/articles/2012/sbt-getting-started-sbt-build-definition.html">.sbt build definition</a>에서 <code>build.sbt</code> 파일을 작성하는 방법을 자세히 배운다.</p>

<p>프로젝트를 jar 파일로 패키지할 거라면 <code>build.sbt</code> 파일에 버전과 이름 정도는 설정할 것이다.</p>

<h2>sbt 버전 설정하기</h2>

<p><code>hello/project/build.properteis</code> 파일에 어떤 버전의 sbt를 사용할지 명시할 수 있다. 다음과 같이 만든다:</p>

<pre><code>sbt.version=0.11.3
</code></pre>

<p>0.10 버전부터는 버전이 올라가도 99% 이상 잘 호환된다. 하지만 <code>project/build.properties</code>에 sbt 버전을 명시하면 혹시 모를 문제를 예방할 수 있다.</p>]]>
</content></entry><entry><title><![CDATA[ sbt: Getting Started Guide: Setup ]]></title><link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-setup.html" /><updated>2012-07-02T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/sbt-getting-started-setup.html</id><content type="html"><![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2>Overview</h2>

<p>다음과 같은 과정을 거쳐서 sbt 프로젝트를 만든다:</p>

<ul>
<li>sbt를 설치하고 실행할 스크립트를 만든다.</li>
<li><a href="/articles/2012/sbt-getting-started-hello.html">hello-world</a> 프로젝트를 만든다.
<ul><li>프로젝트 디렉토리를 만들고 소스를 넣는다.</li>
<li>어떻게 빌드할지 정의한다.</li></ul></li>
<li><a href="/articles/2012/sbt-getting-started-running.html">running</a>을 통해 sbt를 실행하는 법을 배운다.</li>
<li><a href="/articles/2012/sbt-getting-started-sbt-build-definition.html">.sbt-build-definition</a>에서 어떻게 빌드할지 정의하는 법을 배운다.</li>
</ul>

<h2>sbt 설치</h2>

<p><code>sbt-launch.jar</code> 파일과 실행할 스크립트만 있으면 된다.</p>

<p><em>Note: 다운로드는 <a href="http://www.scala-sbt.org/download.html">다운로드 페이지</a>에서 할 수 있다.</em></p>

<h3>Yum</h3>

<p><a href="http://rpm.typesafe.com">Typesafe Yum 레파지토리</a>에 yum 패키지가 있다. <a href="http://rpm.typesafe.com/typesafe-repo-2.0.0-1.noarch.rpm">레파지토리 rpm 패키지</a>를 설치하면 typesafe yum 레파지토리가 승인된 소스 목록에 추가된다. 그리고 다음과 같이 실행한다:</p>

<pre><code>yum install sbt
</code></pre>

<p>sbt의 최신 버전이 설치된다.</p>

<p><em>Note: 이슈를 발견하면 <a href="https://github.com/sbt/sbt-launcher-package/issues">여기</a>에 신고할 수 있다.</em></p>

<h2>Apt</h2>

<p><a href="http://apt.typesafe.com">Typesafe Debian 레파지토리</a>에 sbt Debian 패키지가 있다. <a href="http://apt.typesafe.com/repo-deb-build-0002.deb">레파지토리 deb 패키지</a>를 설치하면 typesafe debian 레파지토리가 승인된 소스 목록에 추가된다. 그리고 다음과 같이 실행한다:</p>

<pre><code>apt-get install sbt
</code></pre>

<p>sbt의 최신 버전이 설치된다.</p>

<p>sbt 없으면 레파지토리에서 정보를 업데이트한다:</p>

<pre><code>apt-get update
</code></pre>

<p><em>Note: 이슈를 발견하면 <a href="https://github.com/sbt/sbt-launcher-package/issues">여기</a>에 신고할 수 있다.</em></p>

<h2>Gentoo</h2>

<p>공식 소스 안에는 sbt용 ebuild 스크립트가 없다. 하지만 <a href='https://github.com/whiter4bbit/overlays/tree/master/dev-java/sbt-bin'>https://github.com/whiter4bbit/overlays/tree/master/dev-java/sbt-bin</a> 에 sbt를 머지하는 ebuild 스크립트가 있다. 다음과 같이 ebuild 스크립트로 sbt를 머지한다:</p>

<pre><code>mkdir -p /usr/local/portage &amp;&amp; cd /usr/local/portage
git clone git://github.com/whiter4bbit/overlays.git
echo "PORTDIR_OVERLAY=$PORTDIR_OVERLAY /usr/local/portage/overlay" &gt;&gt; /etc/make.conf
emerge sbt-bin
</code></pre>

<h2>Mac</h2>

<p><a href="http://macports.org/">MacPorts</a>로 설치한다:</p>

<pre><code>$ sudo port install sbt
</code></pre>

<p><a href="http://mxcl.github.com/homebrew/">HomeBrew</a>로 설치할 수 있다:</p>

<pre><code>$ brew install sbt
</code></pre>

<p>sbt-launch.jar를 직접 다운로드할 필요 없다:</p>

<h2>Windows</h2>

<p><a href="http://scalasbt.artifactoryonline.com/scalasbt/sbt-native-packages/org/scala-sbt/sbt-launcher/0.11.3/sbt.msi">msi</a>를 다운로드한다:</p>

<p><em>아니면</em></p>

<p><code>sbt.bat</code> 배치 파일을 만든다:</p>

<pre><code>set SCRIPT_DIR=%~dp0
java -Xmx512M -jar "%SCRIPT_DIR%sbt-launch.jar" %*
</code></pre>

<p>그리고 그 디렉토리에 [sbt-launch.jar][] 파일을 넣는다. 커맨드 라인에서 'sbt'라고 실행하려면 PATH 환경 변수에 <code>sbt.bat</code>를 등록해준다.</p>

<h2>Unix</h2>

<p><a href="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.11.3-2/sbt-launch.jar">sbt-launch.jar</a>를 다운로드해서 <code>~/bin</code> 디렉토리에 넣는다.</p>

<p>이 jar 파일을 실행하는 스크립트를 'sbt'라는 이름으로 만들고 <code>~/bin</code> 디렉토리에 넣는다:</p>

<pre><code>java -Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=384M -jar `dirname $0`/sbt-launch.jar "$@"
</code></pre>

<p>그리고 스크립트를 실행할 수 있게 만든다:</p>

<pre><code>$ chmod u+x ~/bin/sbt
</code></pre>

<h2>팁, 노트</h2>

<p>문제가 생겨서 <code>sbt</code>가 실행이 안되면 <a href="https://github.com/harrah/xsbt/wiki/Setup-Notes">설치 노트</a>를 확인하라. 터미널 엔코딩, HTTP 프록시, JVM 옵션 등에 대해 나와 있다.</p>

<p>꼼꼼하게 만들어진 쉘 스크립트가 있어서 이 스크립트로 sbt를 설치할 수 있다: <a href='https://github.com/paulp/sbt-extras'>https://github.com/paulp/sbt-extras</a> (루트 디렉토리에 있는 sbt 파일). 이 스크립트로 설치하면 패키지로 설치하는 것처럼 원하는 버전의 sbt를 설치할 수 있다. 설치할 sbt의 버전을 선택한다든지 하는 유용한 옵션이 있다.</p>]]>
</content></entry><entry><title><![CDATA[ nodejs에서의 멍키 패칭 ]]></title><link href="http://dogfeet.github.com/articles/2012/nodejs-monkey-patching.html" /><updated>2012-06-23T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/nodejs-monkey-patching.html</id><content type="html"><![CDATA[
<p>JavaScript에서 멍키 패칭이 가능할까? 'require'를 어떻게 좀 바꾸면 될 것 같은데, 그런게 가능하긴 할까해서 찾아봤다. 명색이 프로토타입 언어인데 쓸데가 있을지는 둘 째치고 가능할꺼라는 생각이 들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-monkey-patching/monkey_patch.jpg" alt="monkey-patch" title="" /></p>

<p>(from <a href='http://geargeeksreview.blogspot.kr/2008/09/milspecmonkey-monkey-patch.html'>http://geargeeksreview.blogspot.kr/2008/09/milspecmonkey-monkey-patch.html</a>)</p>

<h2>require</h2>

<p>소스에서 require를 사용할 수 있는 이유는 다음과 같은 코드로 wrapper되기 때문이다. 다음 코드는 node/src/node.js에 있는(node 소스) 코드다:</p>

<pre><code>NativeModule.wrapper = [
    '(function (exports, require, module, __filename, __dirname) { ',
    '\n});'
];
</code></pre>

<p>소스에서 exports, require, module, __filename, __dirname 변수를 사용할 수 있는 이유는 우리가 구현하는 모듈이 이 wrapper의 바디에 해당되기 때문이다.</p>

<p>모든 모듈은 Module 객체이다. <code>require('fs')</code>라고 호출하면 fs.js를 로드해서 Module 객체 인스턴스로 만들어서 반환한다. <code>node/lib/module.js</code> 코드를 보면 모든 모듈은 Module 객체로 만드는 부분이 있다.</p>

<pre><code>var module = new Module(filename, parent);
</code></pre>

<p>require는 module 객체 자체를 반환하는 것이 아니라 <code>module.exports</code>를 반환한다. 그래서 require로 Module 객체에 접근할 수 없다. </p>

<p>module 객체에는 해당 모듈에 필요한 정보를 담고 있으면서 _cached 프로퍼티에 캐시된다. 실제 module.js 소스를 보자:</p>

<pre><code>var cachedModule = Module._cache[filename];
if (cachedModule) {
    return cachedModule.exports;
}
</code></pre>

<p>require가 호출되면 먼저 _cache에 등록는지 확인하고 캐시한 것을 반환한다. 즉, 해당 모듈 객체는 딱 하나만 만든다. 이 것은 API 문서에도 잘 나와 있다.</p>

<h3>Module.prototype.require</h3>

<p>그럼 require는 어딨는 걸까? 뭘 고쳐야 require 호출을 가로챌 수 있을까? 우리가 호출하는 require는 다음과 같은 위치에 있다:</p>

<pre><code>Module.prototype.require = function(path) {
  return Module._load(path, this);
};
</code></pre>

<p>메인 모듈(실행하는 스크립트)뿐만 아니라 모든 모듈 객체의 prototype에 있는 require를 호출한다. 그리고 저걸 바꿔주는 모듈을 만들면 내가 만든 require 함수가 호출되도록 할 수 있다.</p>

<h2>멍키 패칭</h2>

<p>require 함수를 바꾸는 mp.js 모듈을 만든다:</p>

<pre><code>var Module = require('module');

// orig 함수를 두는 위치는 아무 의미없다--;
// 그냥 prototype._require__에 넣은 것이다. 실제로 사용하려면 문제가 될 수 있다.
Module.prototype.__require__ = Module.prototype.require;
Module.prototype.require = function fevent_require(id) {

    //여기에 멍키 패칭 코드를 넣을 수 있다.
    //fs나 net 모듈 같은 걸 수정할 수 있다.
    console.log('called require');

    return this.__require__(id);
}
</code></pre>

<p>mp.js 모듈을 사용해보자:</p>

<pre><code>require('fs');

require('./mp');

require('fs'); //called require
require('net'); //called require
</code></pre>

<p>잘된다.</p>

<p>그런데 여기서 한가지 의문이 든다. Module.prototype.require를 수정했지만 <code>(function (exports, require, module, __filename, __dirname)</code>라는 wrapper를 통해 파라미터로 넘겨진 require의 레퍼런스는 그대로 인데도 잘 수행된다.</p>

<p>이 wrapper를 통해 넘겨진 함수는 다음과 같다:</p>

<pre><code>var self = this;
//....
function require(path) {
    return self.require(path);
}
</code></pre>

<p>그래서 해당 모듈의 require 함수가 호출되는 것이기 때문에 잘된다.</p>

<p>require 함수를 바꿀 수 있으니 이제 원하는 모듈을 멍키 패칭할 수 있다. 이 방법의 안정성은 좀 더 다듬어야 하고--; 멍키 패칭이 필요한 이유도 아직 없지만--;; 가능하긴 하다는 것을 알아 보았다.</p>]]>
</content></entry></feed>