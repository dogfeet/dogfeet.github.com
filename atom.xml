<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-04-15T17:01:59Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <entry>
    <title><![CDATA[ nodejs: Mocha ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-mocha.html" />
    <updated>2012-04-14T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-mocha.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 '<a href="http://dailyjs.com/2011/12/08/mocha/">Testing with Mocha</a>'을 다시 쓴 것이다. <a href="http://alexyoung.org/">Alex Young</a>님이 만든 예제도 내가 쓰기 편하게 좀 고쳤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-mocha/mocha-test.png" alt="mocha-test" title="" /></p>

<p><a href="http://dailyjs.com/2011/12/08/mocha/">Testing with Mocha</a>를 읽고 Mocha 메뉴얼을 읽으니 훨씬 눈에 잘 들어온다.</p>

<h2>Mocha</h2>

<p><a href="http://visionmedia.github.com/mocha/">Mocha</a>는 TJ Holowaychuk이 만든 <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> 프레임워크이다. </p>

<p>이 글에서는 그냥 Mocha로 BDD하는 법에 대해서만 설명한다. 원래 글은 TDD를 하는 법에 대해서 다뤘지만, 다시 정리하면서 BDD로 수정했다. 다른 방법, 다른 프레임워크와의 비교는 @outsider님이 잘 정리해 주었다. @outsider님 <a href="http://blog.outsider.ne.kr/770">블로그 글</a>을 읽어보자. </p>

<h2>package.json</h2>

<p>먼저 package.json 파일을 다음과 같이 만든다.</p>

<pre><code>{
    "name": "async-testing-tutorial"
    , "version": "0.0.1"
    , "description": "A tutorial for Mocha"
    , "keywords": ["test", "tutorial"]
    , "author": "Alex R. Young &lt;<a href='mailto:info@dailyjs.com'>info@dailyjs.com</a>&gt;"
    , "main": "index"
    , "engines": { "node": "&gt;= 0.4.x &lt; 0.7.0" }
    , "scripts": {
        "test": "make test"
    }
    , "devDependencies": {
        "mocha": "1.0.x"
        , "should": "0.6.x"
    }
}
</code></pre>

<p>원래 코드는 assert 모듈과 TDD 스타일로 돼 있었지만, 나는 should와 BDD가 더 직관적이라고 생각하므로 바꿨다.</p>

<p>이를 위해 의존성을 추가한다.: </p>

<pre><code>, "devDependencies": {
    "mocha": "1.0.x"
    , "should": "0.6.x"
}
</code></pre>

<p>이제 <code>npm install</code>하면 해당 모듈이 설치된다.</p>

<h2>Makefile</h2>

<p>다음과 같이 Makefile을 만들고 <code>make test</code>를 실행하면 된다. </p>

<pre><code>test:
    @./node_modules/.bin/mocha --require should

.PHONY: test
</code></pre>

<ul>
<li><code>--require should</code> - 테스트 코드에서 should 모듈을 끼워 넣어 준다. 생략하면 테스트 코드에 <code>require('should')</code>를 직접 넣어 줘야 한다.</li>
<li><code>--reporter dot</code> - 테스트 결과를 어떻게 보여줄지 reporter를 고를 수 있다. 생략 시 기본 값은 <code>dot</code>.</li>
<li><code>--u bdd</code> - 테스트 스타일을 고를 수 있는데. 생략 시 기본 값은 <code>bdd</code>.</li>
</ul>

<p>자세한 옵션은 <a href="http://visionmedia.github.com/mocha/">Mocha</a> 페이지에서 확인한다.</p>

<h2>prime Module</h2>

<p><a href="http://alexyoung.org/">Alex Young</a>님이 작성한 모듈 코드:</p>

<pre><code>function nextPrime(n) {
    var smaller;
    n = Math.floor(n);

    if (n &gt;= 2) {
        smaller = 1;
        while (smaller * smaller &lt;= n) {
            n++;
            smaller = 2;
            while ((n % smaller &gt; 0) &amp;&amp; (smaller * smaller &lt;= n)) {
                smaller++;
            }   
        }   
        return n;
    } else {
        return 2;
    }   
}

function asyncPrime(n, fn) {
    setTimeout(function() {
        fn( nextPrime(n) );
    }, 10);
}

module.exports.nextPrime = nextPrime;
module.exports.asyncPrime = asyncPrime;
</code></pre>

<h2>Test</h2>

<p>BDD 스타일로 작성한 테스트는 다음과 같다.</p>

<pre><code>var nextPrime = require('./../index').nextPrime
var asyncPrime = require('./../index').asyncPrime;

describe('prime', function() {

    describe('nextPrime', function() {

        it('nextPrime should return the next prime number', function() {
            nextPrime(7).should.equal(11);
        }); 

        it('zero and one are not prime numbers', function() {
            nextPrime(0).should.equal(2);
            nextPrime(1).should.equal(2);
        }); 
    }); 

    describe('asyncPrime', function() {

        it('asyncPrime should return the next prime number', function(done) {
            asyncPrime(128, function(n) {
                n.should.equal(131);
                done();
            });
        });
    });
});
</code></pre>

<p>비동기 테스트 예제인 'asyncPrime'은 done()을 호출해서 테스트가 성공했음을 알린다.</p>

<h2>hooks</h2>

<ul>
<li>before() - describe()를 시작하기 전에 한번</li>
<li>after() - describe()를 끝내고 나서 한번</li>
<li>beforeEach() - describe() 안에 있는 it()이 시작할 때마다 한번</li>
<li>afterEach() - describe() 안에 있는 it() 이 끝날 때마다 한번</li>
</ul>

<p>위 테스트코드에 hooks을 추가해보고:</p>

<pre><code>var nextPrime = require('./../index').nextPrime
var asyncPrime = require('./../index').asyncPrime;

describe('prime', function() {

    before(function(){
        console.log('before');
    }); 

    after(function(){
        console.log('after');
    }); 

    beforeEach(function(){
        console.log('beforeEach');
    }); 

    afterEach(function(){
        console.log('afterEach');
    }); 

    describe('nextPrime', function() {
        before(function(){
            console.log('new before');
        }); 

        it('nextPrime should return the next prime number', function() {
            nextPrime(7).should.equal(11);
        }); 

        it('zero and one are not prime numbers', function() {
            nextPrime(0).should.equal(2);
            nextPrime(1).should.equal(2);
        }); 
    }); 

    describe('asyncPrime', function() {
        afterEach(function(){
            console.log('new afterEach');
        });

        it('asyncPrime should return the next prime number', function(done) {
            asyncPrime(128, function(n) {
                n.should.equal(131);
                done();
            });
        });
    });
});
</code></pre>

<p>결과는 다음과 같다:</p>

<pre><code>  before
new before
beforeEach
.afterEach
beforeEach
.afterEach
beforeEach
.new afterEach
afterEach
after


  ✔ 3 tests complete (25ms)
</code></pre>

<p>'new afterEach'나 'new before' 부분에서 스택처럼 동작해서 상위 describe()에 정의한 것은 생략될까 싶었는데, 아니었다. 모두 호출된다.</p>

<p><a href="http://alexyoung.org/">Alex Young</a> 만든 코드는 <a href="https://github.com/alexyoung/async-testing-tutorial">async-testing-tutorial</a>이고 내가 수정한 코드는 <a href="https://github.com/pismute/async-testing-tutorial">async-testing-tutorial-pismute</a>이다.</p>

<p>TDD 스타일로 테스트를 작성하고 assert방식의 expecting을 선호한다면 <a href="http://alexyoung.org/">Alex Young</a>만든 코드를 보는 것이 낫다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ PAC: proxy auto-config ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/proxy-auto-config.html" />
    <updated>2012-04-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/proxy-auto-config.html</id>
    <content type="html">
<![CDATA[
<p>Proxy을 통해 우회하고 싶을 때가 왕왕 있다.</p>

<p>중국이나 한국같은 인터넷 통제국을 여행한다거나. 인터넷 통제하는 회사에서 일을 한다거나. 특정 ip에서만 접근 가능한 사이트에 접근하고 싶을 때도 있고, 논문을 조회해야 하는데 이런건 학교에서만 무료라서 학교를 통해야 한다든지. 어쨌든 이런게 가끔식 필요할 때가 있다.</p>

<p>사실 보통은 PAC까지 필요없다. 매우 특이한 경우, 사무실에서 인터넷을 엉터리로 막아서 일하는데 필요한 자료를 얻을 수 없을 때에나 필요하다. 이럴 때는 디테일하게 우회해야 해야 한다.</p>

<p>이글을 쓰는 시점에서는 OTN(Oracle TechNet)에서 파일을 다운 받으려 하는데, HTTPS를 막아서 인증을 할 수가 없었다. 왜? OTN만 HTTPS가 안되는지 모르겠다. Proxy는 유료 개인 서버니까 Proxy를 통해 인증만 하고 1GB가 넘는 파일은 다이렉트로 다운 받도록 설정했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/proxy-auto-config/pacman.gif" alt="pacman" title="" /></p>

<p>이 설정은 Window에서만 확인했다.</p>

<h2>PAC(Proxy Auto-Config) 파일</h2>

<p>아무튼 규칙이 2~3개만 되도 헷갈리고 관리하기 쉽지 않다. 그냥 프로토콜이 무엇인지, ip가 무엇인지, 도메인이 무엇인지에 따라 규칙을 만들고 활용하면 좋다. PAC 파일을 만들어 사용하면 규칙을 스크립트로 관리할 수 있다.</p>

<p>PAC는 아주 간단한 파일이다:</p>

<pre><code>function FindProxyForURL(url, host) {

    url = url.toLowerCase();
    host = host.toLowerCase();
    hostip=dnsResolve(host);
    isHttp=(url.substring(0,5) == "http:");
    isHttps=(url.substring(0,6) == "https:")

    // 로컬은 항상 DIRECT로 접근한다.
    if(0
        || isPlainHostName(host)
        || isInNet(hostip, "10.0.0.0", "255.0.0.0") 
        || isInNet(hostip, "172.16.0.0", "255.240.0.0") 
        || isInNet(hostip, "192.168.0.0", "255.255.0.0")
        ) { 
        return "DIRECT"; 
    }

    // Https가 필요한데, 접근을 막혔다.
    if(isHttps) {
        //먼저 SOCKS PROXY를 통하고 실패하면 그냥 연결한다.
        return "SOCKS 127.0.0.1:8580; DIRECT";
    }

    // dropbox도 막았다.
    if (shExpMatch(url, "<a href='http://www.dropbox.com*'>http://www.dropbox.com*</a>")) {
        //이건 HTTP PROXY로 연결하고 실패하면 그냥 연결한다.
        return "PROXY 127.0.0.1:8580; DIRECT";
    }

    return "DIRECT"; 
}
</code></pre>

<p>파일 이름은 상관없지만 그래도 PAC파일임을 알 수 있게 my.pac쯤으로 짓는다.</p>

<p>그리고 Explorer에서 "Internet Options/Connections/LAN settings"에서 my.pac파일을 지정해줄 수 있다:</p>

<p><img src="/articles/2012/proxy-auto-config/pac.png" alt="my.pac" title="" /></p>

<h2>Browser</h2>

<p>그러면 이제 저 규칙을 따라 동작한다. 브라우저별로 보면 Explorer/Firefox/Opera는 각각 별도로 설정할 수 있다. 그래서 굳이 PAC를 사용하지 말고 브라우저 별로 다르게 설정해서 필요에 따라 다른 브라우저를 선택해 사용하는 것도 방법이다.</p>

<p>그리고 Chrome은 System 설정을 사용하니까 Explorer와 같은 설정을 사용한다.</p>

<h2>Best Practice</h2>

<p>PAC 설정은 나름 까다롭다. 수정하면 테스트도 해야하고 모든 사이트나 모든 상황에 통용되는 매우 일반적인 규칙을 만드는 것은 정말 까다롭다. 그러니, 적당한 규칙을 만들어 상황에 따라 스위칭하는 것이 유리하다. </p>

<p>Proxy profile을 만들고 필요에 따라 선택해서 사용하면 좋다. Chrome의 <a href="http://switchy.samabox.com/">Switchy</a> Extension은 내가 사용해본 것중 가장 편리하다. Switchy는 Proxy Profile을 만들고 Profile 사이를 쉽게 스위칭할 수 있다. Chrome은 시스템 설정을 사용하므로 Switchy에서 Profile을 변경하면 시스템 설정이 바뀐다.</p>

<p>Switchy + PAC 를 사용하면 다양한 조합이 가능하다.</p>

<h2>기타.</h2>

<ul>
<li>SSH tunnel은 SOCKS 프록시다.</li>
<li>8580은 <a href="http://en.wikipedia.org/wiki/Freegate">freegate</a> 기본 포트다.</li>
<li>freegate는 중국 여행 필수품; 공익재단이(라고 쓰고 '미국이' 라고 읽는다) 만든다. freegate는 무료 Proxy로 인터넷 통제국을(이라고 쓰고 '중국을' 이라고 읽는다) 무력화할 목적으로 개발되고 있다. 인터넷 통제국으로 인정해주지 않은 나라에서는 사용할 수 없다. 그런데, 한국은 인터넷 통제국임에도 불구하고 freegate를 사용할 수 없다. 한국도 인정해달라!</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ J언어를 배워보자 - 제 1장. 기본기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/learning-j-chapter1.html" />
    <updated>2012-04-06T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/learning-j-chapter1.html</id>
    <content type="html">
<![CDATA[
<p>Roger Stokes이 쓴 <a href="http://www.jsoftware.com/docs/help701/learning/contents.htm">Learning J</a>의 chapter 1:Basics를 번역/정리했다.</p>

<p>요즘 J를 배워보려 하는데 관련된 한국어 자료가 거의 없었다. 그래서 공부하는 겸 Learning J를 읽고 간단히 정리했다. 원문을 그대로 옮기진 않았고, 필요하면 표현을 바꿨다.</p>

<p>이 책은 J701을 기준으로 쓰였다. 따라서 <a href="http://www.jsoftware.com">www.jsoftware.com</a> 에서 J701을 다운받아서 설치해 하나하나 실습해보면 좋다. J는 APL, K와 비슷한 언어로 리스트, 행렬등을 연산하기에 좋은 기호 중심의 언어이다. 따라서 수학, 통계, 논리적인 분석등에 쓰기에 좋다. 코드가 일반 알파벳이 아닌 특수문자가 많아 읽기가 난해하고 기존의 제어 흐름과는 다른 프로그래밍 스타일 때문에 배우기 어려워하는 사람이 많다. J에 대한 자세한 소개는 <a href="http://www.jsoftware.com/docs/help701/primer/contents.htm">여기</a> 에서 위의 글 몇 개를 읽으면 된다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/learning-j-chapter1/j-code.png" alt="j-code" title="" /></p>

<h2>1.1 인터렉티브 환경</h2>

<p>J의 개발환경은 사용자가 한 줄 입력하면, 그게 곧바로 해석되어 아랫줄에 출력된다. 사용자의 입력하는 것은 들여쓰기가 된 것으로 보이고, 아래 줄에 출력되는 결과는 들여쓰기가 없다.</p>

<pre><code>   2+2
4
</code></pre>

<p>결과가 출력되고 나면 바로 아랫줄에 다시 커서가 깜빡이고, 다른 표현식을 입력할 수 있다.</p>

<h2>1.2 산수</h2>

<p>곱셈을 위한 심볼은 <code>*</code>(asterisk)이다.</p>

<pre><code>   2*3
6
</code></pre>

<p>물론 아래와 같이 빈칸을 집어넣을 수도 있다.</p>

<pre><code>   2 * 3
6
</code></pre>

<p>결과는 똑같다. 빈칸은 있어도 되고 없어도 된다. 가독성을 위해서 필요하면 넣는다.</p>

<p>나눗셈을 위한 심볼은 <code>%</code>(percent)이다.</p>

<pre><code>   3 % 4
0.75
</code></pre>

<p>뺄셈을 위해서는 <code>-</code>를 쓴다.</p>

<pre><code>   3 - 2
1
</code></pre>

<p>다음 예제는 음수에 대한 것이다. 음수는 숫자 앞에 <code>_</code>부호가 붙는다. 숫자와 <code>_</code>사이에는 빈칸이 있어선 안 된다. <code>_</code>는 산수 할 때 쓰는 연산자가 아니라 숫자의 표현 중 하나이다. 마치 부동소수점을 표현할 때 수 중간에 <code>.</code>을 찍는 것과 같다.</p>

<pre><code>   2 - 3
_1
</code></pre>

<p><code>-</code>또한 음수를 만들어내기는 한다. 하지만 음수를 '만들어낸다'고 한 것에 주의해야 한다. <code>_</code>는 숫자를 표현하는 방식 중 하나이지만 <code>-</code>는 연산자라는 뜻이다.</p>

<pre><code>   - 3
_3
</code></pre>

<p>거듭제곱을 위해서는 <code>^</code>(caret)을 쓴다. 2의 3 제곱을 계산하면 아래와 같다.</p>

<pre><code>   2 ^ 3
8
</code></pre>

<p>그냥 제곱을 위한 연산자는 <code>*:</code>(asterisk colon)이다.</p>

<pre><code>   *: 4
16
</code></pre>

<h2>1.3 몇몇 용어들: 함수, 인자, 적용, 값</h2>

<p><code>2 * 3</code>을 한번 보자. 이건 <strong>두 인자에 곱하기 함수인 <code>*</code>가 적용되었다</strong> 라고 말할 수 있다. 왼쪽 인자는 <code>2</code>이고 오른쪽 인자는 <code>3</code>이다. 그리고 <code>2</code>와 <code>3</code>은 각 인자의 값이다.</p>

<h2>1.4 리스트</h2>

<p>리스트는 <code>1 2 3 4</code>와 같이 쓸 수 있다. 숫자 사이에 빈칸이 들어있음에 주의하자. 리스트에 있는 각 숫자의 제곱을 알고 싶으면 다음과 같이 쓴다.</p>

<pre><code>   *: 1 2 3 4
1 4 9 16
</code></pre>

<p>위 예제에서 "Square" 함수(<code>*:</code>)가 리스트의 각 아이템에 적용되었음을 알 수 있다. 리스트로 이루어진 두 개의 인자와 <code>+</code>같은 함수가 주어지면 그 함수는 두 리스트에서 서로 대응되는 아이템에 적용된다.</p>

<pre><code>   1 2 3 + 10 20 30
11 22 33
</code></pre>

<p>만약 한 인자는 리스트이고 다른 인자는 숫자 하나 라면, 숫자 하나는 리스트의 각 아이템에 대응된다.</p>

<pre><code>   1 + 10 20 30
11 21 31

   1 2 3 + 10
11 12 13
</code></pre>

<p>이런 식의 실험은 새로운 함수가 여러 인자 패턴에 어떻게 동작하는지 알아보는 데에 효과적이다. </p>

<p>예를 들어서 7을 2로 나누면, 몫이 3이고 나머지가 1이다. 나머지를 계산하는 J의 내장 함수는 <code>|</code>(vertical bar)이다. <code>|</code>의 이름은 "Residue"이다. 여러 패턴이 들어왔을 때 아래와 같은 결과가 나온다.</p>

<pre><code>   2 | 0 1 2 3 4 5 6 7
0 1 0 1 0 1 0 1

   3 | 0 1 2 3 4 5 6 7
0 1 2 0 1 2 0 1
</code></pre>

<p>Residue 함수는 "mod"(modulo)함수와 같다. 다만 이건 <code>2|7</code>이라고 쓰고, mod 함수는 7mod2라고 쓰는게 다르다.</p>

<h2>1.5 괄호</h2>

<p>필요하다면 표현식은 괄호를 포함할 수 있다. 괄호 안의 표현식은 따로 계산된다.</p>

<pre><code>   (2+1)*(2+2)
12
</code></pre>

<p>괄호는 항상 필요하지는 않다. <code>3*2+1</code>이라는 표현식을 보자. 이 식이 <code>(3*2)+1</code>로 해석되어 7이 될까, 아니면 <code>3*(2+1)</code>이 되어 9가 될까?</p>

<pre><code>   3 * 2 + 1
9
</code></pre>

<p>학교에서 수학을 배울 때에는 곱셈을 덧셈보다 연산을 먼저 한다고 배웠다. 이런 규칙이 있어서 괄호를 적게 쓸 수 있다.</p>

<p>J에는 그런 규칙이 없다. 먼저 따로 계산해야 할 부분이 필요하다면 괄호를 쓰면 된다. 하지만 괄호가 없다면 뒤부터(오른쪽부터) 계산된다. 다시 말하자면 자연스레 읽었을 때에 연산자의 오른쪽 인자부터 계산된다. 따라서 <code>3*2+1</code>의 경우에는 <code>*</code>의 오른쪽 인자인 <code>2+1</code>부터 계산된다. 다른 예제를 보자.</p>

<pre><code>   1 + 3 % 4 
1.75
</code></pre>

<p>여기서 <code>%</code>가 <code>+</code>보다 먼저 적용되는 것을 볼 수 있다. 즉 "제일 오른쪽 먼저" 연산이 시작되었다.</p>

<p>이 "제일 오른쪽 먼저" 규칙은 일반 수학의 "덧셈보다 곱셈 먼저"규칙하고는 다르다. 이 규칙이 별로 편하지 않다면 그냥 괄호를 쓰면 된다. 하지만 이 규칙을 사용하면 함수나 숫자가 엄청나게 많이 사용된 문장에서도 어디에서부터 계산해나가야 할지 쉽게 알 수 있다.</p>

<p>이 책에서는 "제일 오른쪽 먼저" 규칙을 적용 시킬 필요가 없다면 괄호를 쓸 것이다. 지금 여기서 중요한 건 코드를 잘 읽을 수 있을 정도로 표현식의 구조를 아는 것이다.</p>

<h2>1.6 변수와 할당</h2>

<p>영어 표현으로 'let <code>x</code> be <code>100</code>'라는 문장은 J로</p>

<pre><code>   x =: 100
</code></pre>

<p>로 나타낼 수 있다.</p>

<p>우리가 할당문이라고 불리는 이 표현식은 <code>100</code>이라는 값을 <code>x</code>라는 이름에 할당한다. 이 말은 즉 <code>x</code>라는 이름의 변수가 생성되고 이 변수에 <code>100</code>이라는 값을 넣었다고 할 수 있다. 만약 사용자가 입력한 한 라인에 할당문만 있다면 그 아래 결과가 출력되는 줄에는 아무런 값도 출력되지 않는다.</p>

<pre><code>   x - 1
99
</code></pre>

<p>값이 할당된 변수는 다른 표현식에서 가져다 쓸 수 있다.</p>

<pre><code>   y =: x - 1
</code></pre>

<p>여기서 <code>y</code>는 <code>x-1</code>의 결과 값을 저장하는 데에 쓰였다. 변수에 저장된 값을 살펴보고 싶다면 그냥 변수의 이름을 입력하면 된다. 그것만으로도 다른 표현식처럼 하나의 표현식이 된다. </p>

<pre><code>   y
99
</code></pre>

<p>같은 변수에 반복해서 할당이 가능하다. 마지막에 할당한 것이 변수에 담긴다.</p>

<pre><code>   z =: 6
   z =: 8
   z
8
</code></pre>

<p>변수는 그 변수에 할당된 값을 이용해서 자기 자신에게 새로운 값을 할당할 때에도 사용할 수 있다.</p>

<pre><code>   z =: z + 1
   z
9
</code></pre>

<p>위의 예제는 한 라인이 할당문으로만 이루어졌을 때에 결과 줄에 아무것도 출력되지 않음을 보여준다. 그럼에도 할당문 역시 하나의 표현식이다. 할당문이 어떤 표현식의 부분에 쓰였을 때에는 값으로 사용할 수 있다.</p>

<pre><code>   1 + (u =: 99)
100
   u
99
</code></pre>

<p>아래는 어떤 이름을 변수명으로 사용할 수 있는지에 대한 예제이다.</p>

<pre><code>   x                       =: 0
   X                       =: 1
   K9                      =: 2
   finaltotal              =: 3
   FinalTotal              =: 4
   average_annual_rainfall =: 5
</code></pre>

<p>변수명은 반드시 알파벳으로 시작해야 한다. 그리고 변수명은 알파벳(대문자, 소문자), 숫자(0-9), 밑줄(_)로 이루어진다. 그리고 대소문자를 가린다. 즉, <code>x</code>와 <code>X</code>는 다른 변수이다.</p>

<pre><code>   x
0
   X
1
</code></pre>

<h2>1.7 용어: 모나드와 다이아드(Monads and Dyads)</h2>

<p>오른쪽에 하나의 인자만 받는 함수를 모나딕 함수(monadic function)이라고 부른다. 줄여서 모나드라고 한다. 예를 들자면 "Square"(<code>*:</code>)함수가 있다. 함수의 오른쪽과 왼쪽에 인자를 하나씩 두어 총 두 개의 인자를 받는 함수를 다이아딕(dyadic) 함수라 부른다. 이 역시 줄여서 다이아드라고 한다. 위에서 봤던<code>+</code>가 그 예가 될 수 있겠다.</p>

<p>"Subtraction"(빼기) 함수와 "negation"(부정)함수는 같은 심볼(<code>-</code>)로 두가지 다른 기능을 하는 함수 중 하나이다. 다른 말로, <code>-</code>는 모나딕으로도 다이아딕으로도 사용할 수 있다는 것이다. 사실 J의 거의 모든 내장 함수가 모나딕과 다이아딕으로 사용될 수 있다. 아까 배웠던 나누기 함수, <code>%</code>도 그렇다. <code>%</code>는 다이아딕으로는 나누기이지만 모나딕으로 사용될 때는 역수 함수가 된다.</p>

<pre><code>   % 4
0.25
</code></pre>

<h2>1.8 내장 함수들 더 보기</h2>

<p>이 섹션의 목적은 J의 내장 함수 중 몇 개를 더 소개해서 J로 프로그래밍하는 걸 맛 보는데 있다.</p>

<p>영어로 "add together the numbers  2, 3, and 4, or more"말을 살펴보자. 이건 더 간단하게 다음과 같이 표현할 수 있다.</p>

<pre><code>add together 2 3 4
</code></pre>

<p>이걸 계산하면 9이다. 이걸 J로 표현하면 다음과 같다.</p>

<pre><code>   + / 2 3 4
9
</code></pre>

<p>영어 표현과 J의 표현을 비교해보자. "add"는 <code>+</code>에 대응되고 "together"는 <code>/</code>에 대응된다. 비슷하게 다음 표현을 생각해보자.</p>

<pre><code>multiply together 2 3 4
</code></pre>

<p>이걸 계산하면 24이다. 이건 J로 다음과 같이 표현한다.</p>

<pre><code>   * / 2 3 4
24
</code></pre>

<p><code>+/2 3 4</code>는 <code>2+3+4</code>와 같은 의미이고 <code>*/2 3 4</code>는 <code>2*3*4</code>와 같은 의미임을 알 수 있다. <code>/</code>는 "Insert"라고 한다. 이 녀석은 왼쪽에 있는 함수를 오른쪽의 리스트의 각 아이템 사이에 끼워 넣는 역할을 하기 때문이다. 일반화하여 말하자면, F가 임의의 다이아딕 함수이고, L이 숫자로 이루어진 리스트 a, b, c, .... y, z 라면</p>

<pre><code>F / L    은   a F b F .... F y F z   이다.
</code></pre>

<p>또 다른 함수를 더 알아보자. <br />아래에 세 가지 명제가 있다.</p>

<pre><code>2 는 1보다 크다     (명백히 참이다)
2 는 1과 같다          (거짓)
2 는 1보다 작다        (거짓)
</code></pre>

<p>J에서 "참"은 1로 표현하고, "거짓"은 0으로 표현한다. 그래서 위의 세 명제는 다음과 같이 쓸 수 있다.</p>

<pre><code>   2 &gt; 1
1

   2 = 1
0

   2 &lt; 1
0
</code></pre>

<p>만약 x가 수열이라면,</p>

<pre><code>   x =: 5 4 1 9
</code></pre>

<p>'x의 어떤 수가 2보다 큰가?' 라고 J에게 물어볼 수 있다.</p>

<pre><code>   x &gt; 2
1 1 0 1
</code></pre>

<p>위에서 보면, '어떤 게 2보다 큰가?'라는 물음에 첫 번째, 두 번째, 네 번째가 1로 표현되었다. x에서 2보다 더 큰 숫자가 존재하는지 알려면 이렇게 쓰면 될까?</p>

<pre><code>   * / x &gt; 2
0
</code></pre>

<p>틀렸다. <code>x&gt;2</code> 는 <code>1 1 0 1</code>인데 곱셈에(1<em>1</em>0*1) 0("거짓")이 들어있으면 죽어도 1이 될 수 없다.<br />x에 2보다 큰 수가 얼마나 많은지 알려면 어떻게 해야 할까? <code>x&gt;2</code>의 결과를 전부 더하면 된다!</p>

<pre><code>   + / x &gt; 2
3
</code></pre>

<p>x에 숫자가 몇 개 있는지 알려면? <code>x=x</code>의 결과를 모두 더하면 된다.</p>

<pre><code>   x
5 4 1 9

   x = x
1 1 1 1

   +/ x = x
4
</code></pre>

<p>그런데 이미 리스트의 길이를 반환하는 <code>#</code>이라는 내장 함수가 있다. </p>

<pre><code>   # x
4
</code></pre>

<h2>1.9 옆으로 늘어 놓아 표시하기</h2>

<p>우리가 컴퓨터에 J를 입력할 때, 입력한 문장과 결과 값은 아래로 주욱 내려가면서 붙어 표시된다. 아까 입력했던 몇 줄을 보면 알 수 있다.</p>

<pre><code>   x
5 4 1 9
   x = x
1 1 1 1
   +/ x = x
4
   # x
4
</code></pre>

<p>이제부터는 종종 옆으로 늘어놓아서 표시할 것이다. 밑의 표처럼 말이다.</p>

<table cellpadding="10" style="margin:20px 0px;" border="1">
<tbody><tr valign="TOP">
<td><tt> x </tt></td>
<td><tt>x = x</tt></td>
<td><tt>+/ x = x</tt></td>
<td><tt># x</tt></td>
</tr><tr valign="TOP">
<td><tt>5 4 1 9</tt></td>
<td><tt>1 1 1 1</tt></td>
<td><tt>4</tt></td>
<td><tt>4</tt></td>
</tr></tbody></table>

<p>이 표는 코드가 수행되는 순서에 따라서, <code>x</code>를 입력하면 <code>5 4 1 9</code>가 나오고, <code>x=x</code>를 입력하면 <code>1 1 1 1</code>이 나오고... 그런 의미이다. 이런 표시방식은 J에서 제공하는 것은 아니다. 하지만 여기에선 자주 쓸 거다. 첫째 줄에는 입력들이, 그 아래 줄에는 출력들이 나온다.</p>

<p>할당문(<code>x=:something</code>)을 입력했을 때에는 아무것도 표시되지 않은 것을 봤을 것이다. 그래도 할당문은 표현식이기 때문에 값을 가진다. 할당문의 값을 보거나, 뭔가를 기억하거나 보기에 쉽도록 종종 차례로 문장이 완성되는 것을 보여줄 거다. 예를 들자면 아래와 같다.</p>

<table cellpadding="10" style="margin:20px 0px;" border="1">
<tbody><tr valign="TOP">
<td><tt>x =: 1 + 2 3 4</tt></td>
<td><tt>x = x</tt></td>
<td><tt>+/ x = x</tt></td>
<td><tt># x</tt></td>
</tr><tr valign="TOP">
<td><tt>3 4 5</tt></td>
<td><tt>1 1 1</tt></td>
<td><tt>3</tt></td>
<td><tt>3</tt></td>
</tr></tbody></table>

<p>이제 다시 내장 함수로 돌아가자. 리스트가 하나 있다고 하자. 그럼 우리는 그 리스트를 차례대로 보면서 "통과, 통과, 아니, 통과, 아니" 하면서 특정 아이템들만 고를 수 있다. 리스트를 선택하기 위한 리스트(아까 말했던 "통과, 아니"의 리스트)는 J로는 <code>1 1 0 1 0</code>으로 표현할 수 있다. 이렇게 1과 0으로만 이루어진 리스트를 비트-스트링(bit-string)이라고 부른다. (비트-리스트나 비트-벡터라고 부르기도 한다.) <code>#</code>함수가 다이아딕으로 사용되면 왼쪽 인자로 들어온 비트-스트링을 이용해서 오른쪽 인자의 아이템을 골라서 새로운 리스트를 만든다.</p>

<table style="margin:20px 0px;" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>y =: 6 7 8 9 10</tt></td>
<td><tt>1 1 0 1 0 # y</tt></td>
</tr><tr valign="TOP">
<td><tt>6 7 8 9 10</tt></td>
<td><tt>6 7 9</tt></td>
</tr></tbody></table>

<p>이제 y에서 특정한 조건을 만족하는 아이템만 고를 수도 있다. 예를 들자면 7보다 큰 수들 같은 것.</p>

<table style="margin:20px 0px;" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> y </tt></td>
<td><tt>y &gt; 7</tt></td>
<td><tt>(y &gt; 7) # y</tt></td>
</tr><tr valign="TOP">
<td><tt>6 7 8 9 10</tt></td>
<td><tt>0 0 1 1 1</tt></td>
<td><tt>8 9 10</tt></td>
</tr></tbody></table>

<h2>1.10 주석</h2>

<p>J에서 <code>NB.</code>심볼은 주석을 나타낸다. <code>NB.</code>심볼 부터 그 라인의 끝까지는 평가되지 않는다. 예를 들자면 아래와 같다.</p>

<pre><code>   NB.   여기는 라인 전체가 주석입니다.

   6 + 6   NB. 12가 출력돼야 합니다.
12
</code></pre>

<h2>1.11 내장 함수가 가진 이름의 구조</h2>

<p>J의 각 내장 함수들은 공식적인 이름과 비공식 이름이 있다. 예를 들어 공식적인 이름이 <code>+</code>인 함수는 비공식 이름이 "Plus"이다. 게다가 모나딕과 다이아딕의 경우도 생각해야 한다. 공식 이름이 <code>-</code>인 함수는 비공식 이름이 "Negate"와 "Minus"가 있다.<br />비공식적인 이름은 보통 한 단어 정도로 짧다. 이 이름은 J가 인식하지 못하기때문에 J에서는 반드시 공식적인 이름을 사용해야 한다. 이 책에서는 비공식 이름은 큰따옴표로 감싸서 표현한다. ("Minus"처럼)</p>

<p>거의 모든 내장 함수가 한 글자 내지 두 글자로 이루어진 공식적인 이름을 가지고 있다. (<code>*</code>나 <code>*:</code> 등등...) 두 번째 글자는 항당 <code>:</code>(colon)나 <code>.</code>(dot, full stop, period)이다.</p>

<p>두 글자로 이루어진 이름은 한 글자로 이루어진 함수와 뭔가 관련이 있다. "Square"(<code>*:</code>)는 "Times"(<code>*</code>)와 관련성이 있다. 느껴지는가?</p>

<p>따라서 J의 내장언어는 한 함수에 보통 6개 정도의 관련 함수들이 있다. 기본 함수에 더해서 위에서 말한 <code>:</code>와 <code>.</code>가 붙은 두 가지 변형과 각각에 대한 모나딕, 다이아딕까지 있다. 예제로 <code>&gt;</code>패밀리를 보자.</p>

<p>다이아딕 '<code>&gt;</code>'은 위에서 봤듯이 "Larger Than"이다.</p>

<p>모나딕 '<code>&gt;</code>'은 뒤에 나올 것이다.</p>

<p>모나딕 '<code>&gt;.</code>'은 올림 연산을 한다. 올림은 자기 자신보다 큰 정수 중 가장 가까운 수이다. 이것의 이름은 "Ceiling"이다.</p>

<pre><code>   &gt;. _1.7 1 1.7
_1 1 2
</code></pre>

<p>다이아딕 '<code>&gt;.</code>'은 두 인자 중 큰 녀석을 선택한다. ("Larger Of")</p>

<pre><code>   3 &gt;. 1 3 5 
3 3 5
</code></pre>

<p><code>/</code>를 이용해서 "Larger Of"를 리스트의 아이템 사이에 끼워 넣으면, 리스트에서 가장 큰 수를 뽑아낼 수 있다. 예를 들어서 리스트 <code>1 6 5</code>에서 가장 큰 수를 알아내려면 <code>&gt;. / 1 6 5</code>를 입력하면 된다. 아래 예제를 통해 어떻게 해서 <code>6</code>이 나오는지 확인할 수 있다. 주석은 왜 이전 입력과 같은 결과가 나오는지 이유를 설명한다.</p>

<pre><code>   &gt;. / 1 6 5
6
   1 &gt;. 6 &gt;. 5      NB. /의 의미에 따라서
6
   1 &gt;. (6 &gt;. 5)    NB. 제일 오른쪽 먼저 규칙에 따라서
6
   1 &gt;. (6)         NB. &gt;.의 의미에 따라서
6
   1 &gt;. 6           NB. ()의 의미에 따라서
6
   6                NB. &gt;.의 의미에 따라서
6
</code></pre>

<p>모나딕 '<code>&gt;:</code>'은 비공식적으로 "Increment"라고 부른다. 인자의 값에 1을 더한다.</p>

<pre><code>   &gt;: _2 3 5 6.3
_1 4 6 7.3
</code></pre>

<p>다이아딕 '<code>&gt;:</code>'은 "Larger or Equal"이다.</p>

<pre><code>   3 &gt;: 1 3 5 
1 1 0
</code></pre>

<p>이 책의 1장을 마친다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ SMACSS: Brief Notes - Part 2 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss-part2.html" />
    <updated>2012-03-31T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss-part2.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://smacss.com/">SMACSS</a>('smacks', 아마도 '스맥스'로 읽는다)에는 '<a href="http://snook.ca/">Jonathan Snook</a>'의 오랜 경험과 통찰이 담겨 있다. SMACSS는 프레임워크라기 보다는 스타일 가이드에 가까워서 만드는 사이트에 따라 그때그때 유연하게 사용할 수 있다.</p>

<p><em>Back-End 출신이라 CSS를 사용할 때마다 '이 많은 스타일은 어떻게 관리해야 할까?'라는 궁금증을 늘 가지고 있었다. 이 책은 그 궁금증을 해결해 준다.</em></p>

<p><a href="/articles/2012/smacss.html">Part 1</a>은 CSS Rule에 대하여 다루었고, Part 2는 SMACSS의 나머지 부분을 다룬다. <a href="/articles/2012/smacss.html">Part 1</a>에서 SMACSS는 4가지 중요한 Rule이 있다고 했는데 여기 하나가 더 추가되었다.</p>

<ul>
<li>Base - 기본 스타일</li>
<li>Layout - 엘리먼트를 나열하는 것과 관련된 스타일</li>
<li>Module - 재사용 위해 하나로 묶는 스타일</li>
<li>State - Hidden/Expand나 Active/Inactive 같은 상태를 스타일</li>
<li><strong>Theme - 사이트 전체가 보이는 느낌에 대한 스타일</strong></li>
</ul>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="SMACSS" title="" /></p>

<h2>테마 Rule</h2>

<p>우리가 <a href="/articles/2012/smacss.html">Part 1</a>을 쓸 당시 저자는 사실 이 부분을 SMACSS Rule에 넣기에는 부족하지만 어쨌든 한번은 다루어야 겠다는 생각을 했다고 언급했다. 결국은 SMACSS Rule에 들아갔다.</p>

<p>테마는 웹사이트에 따라 사용할수도 사용하지 않을수도 있다. 테마를 지원하는 사이트를 살펴보면 Google 메일이나 Yahoo 메일 같은 사이트가 있다. 비록 그대가 지금 만들고 있는 웹사이트가 테마를 지원하지 않더라도 알아둘 필요가 있다고 생각한다.</p>

<h3>테마</h3>

<p>딱히 설명이 필요 없지만 굳이 정의하자면 테마라는 것은 색상 및 이미지를 사용하여 사이트의 전체적인 Look and Feel을 결정한다. 테마와 관련된 부분을 따로 하나의 CSS로 분리해두면 나중에 새로운 테마를 만들거나 테마를 서로 바꿀 때 아주 적절하게 사용할 수 있다.</p>

<p>테마는 모든 스타일을 재정의 할 수 있다. 예를 들어 링크의 색상을 바꾼다거나 사이트 전체의 레이아웃을 변경할 수도 있다. 테마와 스타일을 분리하기 위해 클래스 이름을 쓰는 방법도 있지만 대개 테마를 하나의 파일로 분리하여 사용하면 될 것이다.</p>

<h3>타이포그러피</h3>

<p>마지막으로 중요한 것이 타이포그러피(역주: 활자라 부르고 싶다)이다. 종종 사이트의 타이포그러피를 전체적으로 변경해야 할 상황이 있다. 또한 예를 들어 여러 나라의 언어를 지원할 때 만약 한국어나 중국어의 글자는 크기가 작으면 읽기가 매우 힘들다. 이러한 경우에도 전반적인 글자 크기 조정이 필요하다.</p>

<p>타이포그러피는 Base, Module, State Rule에 영향을 미치지만 Layout에는 영향을 주지 않는다. 글자의 크기를 조절할 때 약 3가지 정도의 다른 크기를 정해서 사용하는 것이 좋다. 만약 여러 단계의 글자 크기가 있다면 사용자는 구별하기 힘들어 할 것이다.</p>

<h2>상태 변경</h2>

<p>사이트를 만들 때 어떤 부분은 처음부터 보이는 부분이 있고 어떤 부분은 어떤 상태가 변경이 되어야만 보이는 부분이 있다. 상태라는 것을 무엇으로 나타내고 어떻게 변경할 수 있을까?</p>

<p><strong>클래스 이름</strong></p>

<p>마우스를 움직이거나 키보드를 누르거나하는 이벤트가 발생하면 JavaScript를 사용하여 클래스 이름을 변경할 수 있다. 클래스 이름이 변경되면 스타일이 변경되고 그에 따라 보여지는 모습도 바뀔 것이다.</p>

<p><strong>Pseudo 클래스</strong></p>

<p>Pseudo 클래스를 사용하면 JavaScript를 사용하지 않고도 상태 변경을 보여줄 수 있다. 하자만 보통 인접한 엘리먼트만 변경할 수 있는 제한이 있다.</p>

<p><strong>미디어 쿼리</strong></p>

<p>페이지가 보여지는 화면의 크기에 따라 스타일을 변경할 수 있다.</p>

<h3>상태 변경 해보기</h3>

<p><a href="http://smacss.com/book/state">SMACSS - Changing State</a> 사이트에서 저자는 상태를 변경하는 여러 코드를 직접 보여주고 있다. '클래스 이름으로 상태 변경하기', 'Pseudo 클래스로 상태 변경하기', '미디어 쿼리로 상태 변경하기' 등의 예제를 볼 수 있다.</p>

<h2>SMACSS를 쓰면...</h2>

<p>이어지는 아래의 여러 내용은 SMACSS를 적용했을 때 기대할 수 있는 부분을 설명하고 있다.</p>

<h2>적용도(Depth of Applicability)</h2>

<p>깊이는 쉽게 말해 CSS 셀렉터의 길이를 의미한다. CSS 깊이 문제는 이미 만들어놓은 HTML 구조에 관련있는 것이고 HTML 구조를 그대로 CSS 셀렉터에 표현하면 너무 길어진다. 예를 들어 다음과 같은 CSS Rule이 있으면:</p>

<pre><code>#sidebar div, #footer div {
    border: 1px solid #333;
}

#sidebar div h3, #footer div h3 {
    margin-top: 5px;
}

#sidebar div ul, #footer div ul {
    margin-bottom: 5px;
}
</code></pre>

<p>div 엘레멘트를 기본으로 하여 다음과 같이 바꿀 수 있다.</p>

<pre><code>.pod {
    border: 1px solid #333;
}

.pod &gt; h3 {
    margin-top: 5px;
}

.pod &gt; ul {
    margin-bottom: 5px;
}
</code></pre>

<p>엘리먼트 마다 Class 셀렉터를 만들지 않고 <code>.pod</code> 하나만 만들었다. 깊이도 간단해졌고 문서 구조에 따라 의도하지 않은 CSS 적용도 피할 수 있다. 문서 구조는 변하지 않았지만 대신 적용해야 하는 부분마다 <code>.pod</code> 클래스를 지정해줘야 한다 이런 점이 고민할 부분이다. 한 쪽으로 치우치면 다른 한 쪽이 아쉬워진다.</p>

<p>이렇게 얕은 깊이의 CSS은 템플릿 엔진을 사용할 때 효과적이다. 이 CSS를 따르는 <a href="http://mustache.github.com/">Mushache</a>의 템플릿 코드를 살펴보자:</p>

<pre><code>&lt;div class="pod"&gt;
    &lt;h3&gt;{{heading}}&lt;/h3&gt;
    &lt;ul&gt;
        {{#items}}
        &lt;li&gt;{{item}}&lt;/li&gt;
        {{/items}}
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>중요한 점은 관리성, 성능, 가독성을 잘 조화시켜야 한다. CSS 셀렉터 길이가 너무 길면 HTML 여기저기 클래스 속성이 남발하는 것을 낮출 수 있지만 관리성과 가독성을 포기해야 한다. 반대로 모든 엘리먼트에 Class 셀렉터를 새로 만들어 줄 수도 있다. 이 예제에서 h3, h1에 까지 class 셀렉터를 부여하는 것은 불필요하다.</p>

<p>Container는 보통 Header, Body, Footer 영역으로 나눈다. 이 것은 일종의 디자인 패턴이라고 할 수 있다. 그래서 <code>.pod &gt; ul</code>을 다음과 같은 CSS Rule을 만들고 HTML에 적용시면:</p>

<pre><code>.pod-body {
    margin-bottom: 5px;
}
</code></pre>

<p>Container 안에서 ul, ol, div에서 클래스 지정만으로 같은 효과를 사용할 수 있다.</p>

<p>이렇게 단일 셀렉터를 사용하면 결국 '어떤 CSS 셀렉터를 사용해야 할지?' 더는 고민하지 않아도 된다. 특별한 이유가 없으면 이렇게 단일 셀렉터를 사용하는게 장땡이다.</p>

<h2>셀렉터 성능 고려</h2>

<p>성능을 위해 CSS 셀렉터를 어떻게 적용할 지 몇가지 팁을 제시하고 있다. 성능 측정을 위해 몇 가지 도구를 사용한다고 말하는데 <a href="http://css-tricks.com/efficiently-rendering-css/">Google Page Speed</a>같은 프로그램으로 한번 측정해보는 것이 적당할 것이다.</p>

<p>우선 스타일은 HTML의 엘리먼트가가 생성되는 시점에 적용이 된다. 브라우저는 HTML문서를 일종의 Stream으로 다룬다. 그러니까 먼저 들어온 엘리먼트를 먼저 생성한다. 다음 예제를 보면:</p>

<pre><code>&lt;body&gt;
    &lt;div id="content"&gt;
        &lt;div class="module intro"&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="module"&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
            &lt;p&gt;Lorem Ipsum &lt;span&gt;Test-&lt;/span&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p><code>body, div#content, div.module.intro ...</code> 순으로 엘리먼트를 생성하고 스타일을 evaluate한다는 말이다. 각 엘리먼트를 Evaluate할 때 Font는 뭐고, 컬러는 뭐고, 높이나 넓으는 얼마인지 브라우저는 정리한 스타일대로 적용하고 그린다. 그리고 하위 엘리먼트의 크기가 바뀌면 브라우저는 Body를 다시 그려야(Repaint)한다고 생각한다(저자는 다른 변수가 있는 사례가 있다고 의심하지만 확실한 것은 보통 width와 height값이 바뀌면 다시 그린다는 것이다).</p>

<p>HTML이 실제로 Render되는 영상을 소개하고 있다. <a href='http://youtu.be/ZTnIxIA5KGw'>http://youtu.be/ZTnIxIA5KGw</a> 는 Firefox의 reflow/repaint 영상이다.</p>

<h3>Right to Left</h3>

<p>CSS는 오른쪽 부터 Evaluate한다. <code>#content &gt; div &gt; p</code> 같은 셀렉터가 있다면 <code>p</code> 엘리먼트가 그려질 때 마다 상위 <code>div</code>를 찾고 상위 <code>#content</code>를 찾는다. 스타일이 적용되기 위해 셀렉터가 찾아봐야 하는 엘리먼트의 갯수가 얼마나 될지 생각해봐야 한다.</p>

<h3>그외 다른 규칙은?</h3>

<p>Google Page Speed는 다음 네 가지 셀렉터 Rule은 비효율적이라고 말한다.</p>

<ul>
<li><code>#content h3</code>와 같은 Descendant Selector</li>
<li><code>#content &gt; h3</code>와 같은 Child Selector</li>
<li><code>div#content &gt; h3</code>와 같이 불필요한 엘리먼트까지 정의하는 Selector</li>
<li><code>div#content:hover</code>와 같이 link 엘리먼트가 아닌 엘리먼트에 :hover를 정의하는 Selector</li>
</ul>

<p>자세한 내용은 <a href="http://code.google.com/speed/page-speed/docs/rendering.html">Google Page Speed의 조언</a>을 참고하는 것이 좋다.</p>

<p><a href="http://css-tricks.com/efficiently-rendering-css/">Efficiently Rendering CSS</a> 사이트를 참고해 보는 것도 좋다.</p>

<h2>HTML5와 SMACSS</h2>

<p><a href="http://smacss.com/">SMACSS</a>는 당근 HTML5에 잘 들어맞는다. 사실 HTML4에도 잘 들어맞는다. <a href="http://smacss.com/">SMACSS</a>는 다음 두 가지 목표를 위해 노력하기 때문이다.</p>

<ol>
<li>증가: HTML과 Content에서 Section의 의미</li>
<li>감소: 특정 구조로 HTML을 만들거라는 기대</li>
</ol>

<p>특히 HTML5에서 새로 추가된 의미 태그는 1번 항목을 도와준다. 하지만 HTML5라고 해서 충분히 모든 의미를 포함할수는 없다. 클래스 속성을 통해서 아주 구체적인 의미를 밝힐 수 있다. 아래의 두 <code>&lt;nav&gt;</code> 엘리먼트는 클래스로 그 의미를 밝혀두고 있다. 클래스 속성에 따라 <code>nav-primary</code> 클래스는 가로 메뉴로, <code>nav-secondary</code> 세로메뉴로 만들수도 있다.</p>

<pre><code>&lt;nav class="nav-primary"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;…&lt;/ul&gt;
&lt;/nav&gt;

&lt;nav class="nav-secondary"&gt;
    &lt;h1&gt;External Links&lt;/h1&gt;
    &lt;ul&gt;…&lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h3>2단계 메뉴 목록</h3>

<p>SMACSS의 목표는 최대한 얕은 깊이의 셀렉터를 사용하는 것이다. 만약 아래와 같은 마크업이 있을 때 2단계를 어떻게 다르게 처리할 수 있을까.</p>

<pre><code>&lt;nav class="nav-primary"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;About Us
            &lt;ul&gt;
                &lt;li&gt;Team&lt;/li&gt;
                &lt;li&gt;Location&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<p>CSS 셀렉터를 중첩해서 쓰면 아래와 같다:</p>

<pre><code>nav.nav-primary li { 
    display: inline-block; 
}

nav.nav-secondary li,
nav.nav-primary li li {
    display: block;
}
</code></pre>

<p>자 여기서 엘리먼트를 제한하는 <code>nav</code>를 제거하고 셀렉터의 깊이도 더 얕게 만들어보면:</p>

<pre><code>.l-inline &gt; * { 
    display: inline-block;
}

.l-stacked &gt; * {
    display: block;
}
</code></pre>

<p>요렇게 만들어볼 수 있다. 마크업은 아래와 같이 수정되어야 한다.</p>

<pre><code>&lt;nav class="l-inline"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;About Us
            &lt;ul class="l-stacked"&gt;
                &lt;li&gt;Team&lt;/li&gt;
                &lt;li&gt;Location&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h2>프로토타입</h2>

<p>좋은 프로그래머는 패턴을 좋아해~ 좋은 디자이너도 패턴을 좋아해~</p>

<p>패턴으로서 재사용성을 높일 수 있다. SMACSS는 코드에서도 디자인에서도 패턴을 찾아내려 애쓴다. 프로토타입을 써서 전체적인 혹은 빌딩 블록 각 부분의 코드와 디자인이 제대로 되었는가를 확인할 수 있다. 잘 만든 디자인과 코드는 재사용하기가 매우매우 좋다. <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> 과 <a href="http://960.gs/">960.gs</a>를 보라.</p>

<h3>프로토타입</h3>

<p>프로토타입을 통해 다음 사항을 확인해볼 수 있다.</p>

<p><strong>상태</strong></p>

<p>프로토타입에서는 정의해 둔 모든 상태에 대해서 테스트해 볼 수 있어야 한다. 데이터를 필요로 한다면 JSON이든 실제 서버든 간에 만들어서 테스트해보아야 한다.</p>

<p><strong>지역화</strong></p>

<p>사이트가 여러 언어를 지원하면 프로토타입을 통해 지역화를 지원하는지, 지역화를 통해 레이아웃이 손상되지 않는지 테스트 해볼 수 있다.</p>

<p><strong>의존관계</strong></p>

<p>프로토타입을 통해 각 모듈이 잘 보여지기 위한 최소의 필요조건을 테스트해볼 수 있다. 사이트가 커질수록 불필요한 부분을 줄이는것이 중요하다.</p>

<h3>퍼즐 맞추기</h3>

<p>야후처럼 아주 큰 사이트의 경우 프로토타입을 만들기 위한 시스템을 구축하여 부분적인 또한 전체적인 스타일을 테스트 해볼 수 있다. 운영하는 사이트가 규모가 작다면 이런 시스템은 오히려 배보다 배꼽이 더 클수도 있다. 사이트에 적당한 프로토타입을 정하는것이 중요하다.</p>

<p>좋은 모듈을 만들고 패턴을 재사용하기 좋게 만드는 것이 추구해야할 목적이다. <a href="http://www.flickr.com/photos/aarronwalter/5579386649/">MailChimp의 디자인 패턴 깜지</a>처럼 한눈에 보기쉽게 정리해두면 좋을 것이다.</p>

<p>패턴은 락(樂)이다. 패턴을 코드로 만듦도 락(樂)이다. 패턴을 리뷰하고 테스트 하는 프로세스를 만듦은 극락(極樂)이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ GitHub로 남의 프로젝트에 감놓고 배놓기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/how-to-github.html" />
    <updated>2012-03-31T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/how-to-github.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://github.com/">GitHub</a>를 사용하여 오픈소스 프로젝트에 어떻게 참여할 수 있는 방법을 정리한다. GitHub에 계정이 있어야 하고 <a href="http://git-scm.org/">Git</a>을 어느정도 써 본 사람이어야 한다. </p>

<p><em>원문은 <a href="http://gun.io/">Rich Jones</a>의 <a href="http://gun.io/blog/how-to-github-fork-branch-and-pull-request/">How to GitHub: Fork, Branch, Track, Squash and Pull Request</a> 이다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/how-to-github/banner_ul2.png" alt="gun.io" title="" /></p>

<h2>저자 공지사항</h2>

<p><a href="http://github.com/">GitHub</a>에서 활동하는 개발자 중 저자의 <a href="http://gun.io/contracts/new/">구인구직 사이트</a>에 등록하면 구직하는 사람과 연결해준다고 한다. 관심있는 사람은 둘러보시길!</p>

<h2>자 시작!</h2>

<p><a href="http://github.com/">GitHub</a>에서 저장소를 새로 하나 만들면 아래와 같은 설명을 보여준다.</p>

<p><img src="/articles/2012/how-to-github/LiEI3.png" alt="GitHub" title="" /></p>

<p>GitHub은 새로운 프로젝트와 새로운 저장소를 만들었을 경우에 대한 설명은 친절하게 해주고 있다. 하지만 다른 프로젝트를 개선하고 참여하는 방법에 대해서는 그다지 좋은 설명을 해주고 있지 않다. 이 글은 그러한 점에서 도움이 될 것이다.</p>

<p>우선 시작하기 전에 고쳐보고 싶은 프로젝트를 하나 골라보자. GitHub에서 프로젝트를 찾아서 코드도 둘러보고 익숙한 개발방식을 갖고 있는지 확인도 해보고 커밋 로그도 살펴보고 참여하는 사람이 어떤 사람인지도 살펴들 보자.</p>

<h2>네트워크</h2>

<p><img src="/articles/2012/how-to-github/naZ6I.png" alt="GitHub Network" title="" /></p>

<p>네트워크 그림이다. 'mobile' 이라는 브랜치에서 누군가 열심히 작업을 하고 있기 때문에 'mobile'에 대한 일을 하는 수고는 하지 않는것이 좋을듯 하다.</p>

<p>우선 해야할 일은 프로젝트의 네트워크를 확인해보는 것이다. 네트워크를 확인함으로서 누가 어떤일을 하고 있는지를 살펴볼 수 있다. 네트워크를 한참 들여다보면 고쳐보고자 하던 부분도 이미 다른이가 하고 있는지 알수도 있다. 프로젝트 활동상황도 알 수 있으며 고친 부분이 어떻게 프로젝트에 Merge되는지도 알 수 있다.</p>

<h2>이슈 등록</h2>

<p><img src="/articles/2012/how-to-github/oksQI.png" alt="GitHub Issue" title="" /><br /><em>이슈가 왔어요!</em></p>

<p>프로젝트 화면에서 이슈메뉴로 가 봅시다. 얼마나 많은 이슈가 있는지 그리고 내가 고쳐보고픈 부분이 이미 이슈로 등록이 되어있는지 알 수 있다.</p>

<p>많은 사람들이 잊기 쉬운 이 과정이 왜 중요하냐면 고친점을 보내는 사람들은 보통 프로젝트의 관리자 즉 메인테이너가 같은 문제로 고민중이라는 점을 전혀 고려하지 않기 때문이다.</p>

<p>고쳐볼 부분이 아직 이슈로 등록이 안되어있다면 새로 하나 등록하자. 이슈를 등록할때는 메인테이너에게 공손히 프로젝트에 감사하다는 마음을 갖고 고쳐보고자 하는 버그나 개선사항을 적는거다.</p>

<p>메인테이너가 만들어진 이슈에 대한 댓글로 도움이 될 만한 점을 달아줄지도 모른다.</p>

<h2>Fork로 저장소 분리</h2>

<p><img src="/articles/2012/how-to-github/VWFCB.png" alt="Hardcore Fork" title="" /></p>

<p>'Fork' 버튼을 누르는 희열!! 복제된 저장소가 내 가슴속으로 들어왔다. 나의 복제된 저장소 페이지로 가보라! Clone해서 내려받을 수 있는 주소가 적혀있을 것이다. 바로 그냥 내려받는거다.</p>

<pre><code>git clone **your ssh/git url**
</code></pre>

<h2>Fork로 만든 저장소와 원본 저장소 연결</h2>

<p><img src="/articles/2012/how-to-github/bbNRs.png" alt="Fork" title="" /><br /><em>Fork가 이거냥!</em></p>

<p>이 과정이 꼭 필요한건 아니다. 하지만 단 한번만 이 프로젝트에 참여할 것이 아니라면 이 과정을 해두면 정말 쓸모있다. 아래 명령을 실행하여 원래 프로젝트 저장소를 'upstream'으로 등록해두면 원래 프로젝트의 변경사항을 계속 받아볼 수 있다. 'upstreamname'과 'projectname' 부분을 실제 프로젝트에 맞게 적당히 바꿔서 명령을 실행한다.</p>

<pre><code>git remote add --track master upstream git://github.com/upstreamname/projectname.git
</code></pre>

<p>자 이렇게 하면 <code>upstream</code> 이라는 리모트로 등록이 된다.</p>

<pre><code>git fetch upstream
</code></pre>

<p>이렇게 하면 원래 프로젝트의 최신 내용을 받아오고</p>

<pre><code>git merge upstream/master
</code></pre>

<p>이렇게 하면 최신 내용을 현재 작업하고 있는 브랜치에 Merge하게 된다. 짜잔!</p>

<h2>개발용 브랜치</h2>

<p><img src="/articles/2012/how-to-github/fI9qT.gif" alt="Old Internet" title="" /><br /><em>그 옛날의 인터넷이 생각나지 않나요들?</em></p>

<p>자 이제 고쳐야 할 부분에 집중하기 위해 <code>master</code> 브랜치에서 새로운 브랜치로 <code>checkout</code>할 때가 왔다. Pull Request는 Branch 단위로 하기 때문에 브랜치를 잘 만들어두는게 중요하다. 고쳐야 할 이슈가 여럿이라면 브랜치도 여러개 이어야 겠다. 아래처럼 해서 브랜치를 만들자:</p>

<pre><code>git branch newfeature
</code></pre>

<p>해당 브랜치로 바꾸려면 즉 <code>checkout</code> 하려면:</p>

<pre><code>git checkout newfeature
</code></pre>

<p>새로 만든 브랜치로 변경했다. 현재 위치한 브랜치를 확인하려면 <code>git branch</code>를 실행해보라.</p>

<h2>Hack!</h2>

<p>이제 실제 고치는 작업을 하자. 계획했던 고칠점이 맘에 들 때 까지 될대로 코드를 고쳐보고 테스트해보고 행복의 경지에 이르러보자. 음하하하~</p>

<h2>커밋 하나로 합치기</h2>

<p><img src="/articles/2012/how-to-github/FgOPu.png" alt="Squash" title="" /><br /><em>이게 '스쿼시'냥!</em></p>

<p>여러분도 나처럼 엄청나게 커밋을 해댄다면 커밋 메시지는 안봐도 거지같을게('동작함!', '안돌아감', '열여덟', '후아~', 등등) 뻔하다. 사실 이런 습관은 좋지 않지만 고치고 싶은 생각도 없고 이런 습관을 가진 사람도 많이 봤다.</p>

<p>Pull Request를 보내기 전에 여러 커밋을 하나 혹은 몇 개의 커밋으로 모아서 정리하고 싶을 수도 있다. 하여 <code>git rebase</code> 명령을 써 볼 것이다. 우선 <code>git log</code>로 커밋 메시지를 확인해보고 어떻게 정리할 지 생각해둔다. 마지막 3개의 커밋을 하나로 합치려면 아래와 같은 명령을 실행한다:</p>

<pre><code>git rebase -i HEAD~3
</code></pre>

<p>명령을 실행하면 Git은 기본 편집기를 불러내서 아래같은 내용을 보여준다.</p>

<pre><code>pick df94881 Allow install to SD 
pick a7323e5 README Junkyism 
pick 3ead26f rm classpath from git 
</code></pre>

<p>각 줄이 각 커밋에 해당하는데 하나로 합치려면 아래와 같이 내용을 수정한다.</p>

<pre><code>pick df94881 Allow install to SD 
squash a7323e5 README Junkyism 
squash 3ead26f rm classpath from git 
</code></pre>

<p>내용을 저장하고 편집기를 종료하면, 새로운 내용으로 편집기가 다시 뜰텐데 그때는 새로 하나로 만들어진 커밋 메시지를 입력하는 것이다. 거지같은 커밋이 깔끔하게 정리된 새 커밋으로 재탄생했다. 만쉐이~ 이제 Pull Request를 해도 부끄럽지 않겠다.</p>

<h2>Pull Request 보내기</h2>

<p>단장하고 커밋해놓은 브랜치를 서버 저장소로 아래와 같은 명령으로 보낸다:</p>

<pre><code>git push origin newfeature
</code></pre>

<p>그리고 GitHub 사이트로 가서 새로 만든 브랜치로 이동한다. 보통 기본으로 master 브랜치로 되어있을 것이다.</p>

<p><img src="/articles/2012/how-to-github/aAd2v.png" alt="Pull Request" title="" /><br /><em>Pull Request를 보내자</em></p>

<p>브랜치로 이동한 것을 확인하고 'Pull Request' 버튼을 누르자. 다음과 같은 화면이 나오는데 브랜치에서 변경한 내용에 대한 설명을 적어주고 'Submit Pull Request' 버튼을 눌러준다.</p>

<p><img src="/articles/2012/how-to-github/5Euiy.png" alt="Pull Request" title="" /><br /><em>Pull Request 설명 달기</em></p>

<p>룰루랄라~ 끝났다. 사실 완전히 다 끝난건 아니다. 'Pull Request' 보낸 커밋에 고칠점이 있다면 메인테이너는 'Pull Request'를 바로 받아주지 않고 해당사항을 고쳐달라고 할 것이다. 메인테이너가 'Pull Request'를 닫지(Clone) 않는 한 해당 브랜치로 커밋을 Push하면 다행히도 'Pull Request' 속으로 들어간다.</p>

<h2>Pull Request 받아서 Merge하기</h2>

<p>보너스! Pull Request를 받았을 때에는 어떻게 Merge하면 되는가! 그냥 버튼 하나만 누르면 된다. 쉽네. GitHub이 버튼 한 번만 누르면 모든게 자동으로 되도록 잘 만들어놨다. 간혹, 자동으로 되지 않을때가 있는데 그때는 직접 명령어를 써서 Merge해야 한다.</p>

<pre><code>git checkout master
git remote add contributor git://github.com/contributor/project
git fetch contributor
git merge contributor/newfeature
git push origin master
</code></pre>

<p>이렇게 하면 다른사람이 수정한 내용을 메인 master 브랜치로 merge하게 된다.</p>

<h2>Pull Request를 받아주지 않는 이유</h2>

<p>이 부분은 <a href="http://gun.io/blog/how-to-github-fork-branch-and-pull-request/">원본 페이지</a>를 확인하시라!</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ KTH 발표 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/first-speach.html" />
    <updated>2012-03-29T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/first-speach.html</id>
    <content type="html">
<![CDATA[
<p>지난 3월 15일에 @kth에서 'Git이 왜 좋은가?'라는 주제로 발표했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/first-speach/first-speach.jpg" alt="first-speach" title="" /></p>

<p>Git은 정리하기도 발표하기도 어렵더라.</p>

<h2>발표</h2>

<p>발표를 한 내가 훨씬 더 배운게 많은 시간이였다. 소중한 기회를 준 KTH에 감사드린다.</p>

<p>땀이 비오듯 흘렀다. 열심히 준비했는데도 실제로 준비가 부족했고 여러가지 실수도 많이 저질렀다. 특히, 긴장하면 힘이 빠지는 체질이라 긴장하지 않기 위해 최대한 집중했는 데도 '졸린창우' 문제는 여전했다.</p>

<p>발표 후, @andrwj님이 진솔하게 조언을 해주셨다(정말 감사드립니다, 그러니까 나도 @andrwj님께 혼나본 남자!:).</p>

<p>이제 SVN을 사용하기 시작하는 회사도 봤는데 KTH 같이 규모가 되는 회사에서 Git을 도입하려는 시도는 너무 인상적이다. 질문도 많이 하셨다. KTH는 열심히 노력하는, 좋은 회사의 냄새가 난다. 왕멍의 가르침이 떠오른다.</p>

<pre><code>'입신경지立身境地'는 '변화의 경지'이다. 이것은 한두 권의 책을 읽고 도달할 수 있는 것이 아니다. 한평생 책을 읽어도 입신경지에 도달하기 어렵다. 읽기 위해서 책을 읽는다면 이를 제대로 소화할 수 없다. 이는 입신경지에 도달하는 학습의 과정이며, 실행의 과정이며, 탁마의 과정이며, 터득의 과정이며, 반성의 과정이며, 발전과 성숙의 과정이다. 이는 승화하고 정화하여 넉넉함과 충실함에 도달하는 과정이다. - 왕멍 &lt;나는 학생이다&gt;
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: git-ff ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-ff.html" />
    <updated>2012-03-24T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-ff.html</id>
    <content type="html">
<![CDATA[
<p>리모트 저장소와 내 저장소를 자주 동기화하고 싶은데 좋은 방법이 없을까? 'git pull'은 별로 맘에 들지 않는다. 전 쓴 '<a href="http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking.html">Git: Remote Tracking Branch vs Tracking Branch</a>'에서도 말했지만, Tracking 브랜치는 불편하다.</p>

<p>그래서 'git pull' 대신 사용할 수 있는 '<a href="https://github.com/pismute/git-tles/blob/master/git-ff">git ff</a>'를 만들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/git.png" alt="git-ff-result" title="" /></p>

<h2>git-ff 특징</h2>

<h3>Dirty 체크</h3>

<p>Working Directory의 상태가 Dirty가 아닐 때만 동작한다.</p>

<h3>'git fetch --prune'</h3>

<p>Fetch시 --prune 옵션을 주기 때문에 리모트에서 삭제된 브랜치가 있으면 로컬의 Remote Tracking Branch도 삭제한다.</p>

<h3>이름으로 매칭하기.</h3>

<p>원격 브랜치와 로컬 브랜치를 시스템이 연결해주는 것이 Tracking 브랜치인 건데, 이게 유용한 때도 있겠다. 아직은 모르겠지만….</p>

<p>그냥 이름으로 하는 게 알아보기도 쉽고 기억하기도 쉽다. 그래서 <code>origin/master</code>에 대응되는 로컬 브랜치는 <code>master</code>라고 간주한다.</p>

<h3>Fast-Foward Merge</h3>

<p>리모트 저장소를 Fetch하고 로컬 브랜치가 있는지 확인한 다음에 Fast-Forward Merge가 가능한 브랜치가 있으면 자동으로 Merge한다.</p>

<h3>Rebase</h3>

<p>리모트 브랜치가 수정됐지만, 로컬 브랜치도 수정됐다면 얘기가 달라진다. 그냥 Merge 하면 Merge Commit이 생긴다. 그래서 Rebase하고 나서 Fast-Forward Merge를 해야 한</p>

<p>이 기능도 넣고서 1달 정도 사용해봤는데, 큰 문제는 없었지만 영 찜찜해서 빼버렸다.</p>

<p>이 기능을 넣으려면 마음의 두려움부터 극복해야겠다.</p>

<h2>git-ff 사용법</h2>

<p>'git ff'라고 실행하면 origin에서 Fetch한다:</p>

<pre><code>git ff [remote]
</code></pre>

<p>하지만, origin이 아니라 다른 저장소로도 작업해야 할 때도 왕왕 있다. 특히 origin이 메인 저장소가 아닐 때가 그렇다. 'git ff managers'라고 실행하면 managers 저장소에서 Fetch한다.</p>

<p>실행결과는 다음과 같다:</p>

<p><img src="/articles/2012/git-ff/git-ff-result.png" alt="git-ff-result" title="" /></p>

<p>Fast-Forward Merge도 하지만 해당 저장소랑 Delta가 얼마나 되는지 한눈에 알 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Bash: 자동완성 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/bash-completion.html" />
    <updated>2012-03-17T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/bash-completion.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 'An introduction to bash completion'(<a href="http://www.debian-administration.org/articles/316">part 1</a>, <a href="http://www.debian-administration.org/articles/317">part 2</a>)을 정리한 것이다. DocPad에 Completion이 있으면 좀 편할 것 같아서 시작했다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/bash-completion/tab-key.jpeg" alt="tab-key" title="" /></p>

<p>Bash Completion은 간단한 메커니즘으로 구현하는 것 같은데 막상 원하는 대로 조작하긴 쉽지 않다.</p>

<h2>Part 1</h2>

<p>Completion 덕에 명령어와 인자를 좀 더 쉽게 사용할 수 있다. 자주 사용하는 명령어에 Completion을 구현하려면 이 글을 읽는 것이 좋다.</p>

<p>보통 셸에서 TAB 키를 누르면 파일 이름, 디렉토리 이름, 실행경로($PATH)에 있는 명령어를 자동으로 완성해준다:</p>

<pre><code>ls /bo[TAB]
</code></pre>

<p><code>/bo</code> 다음에 TAB 키를 누르면 <code>/bo</code>가 <code>/boot</code>로 대체된다.</p>

<p><a href="http://packages.debian.org/bash">Debian bash package</a>는 <code>/etc/bash_completion</code>이라는 Completion 파일이 있고 이 파일에는 일반적인 명령어에 대한 Completion이 정의돼 있다. 아직 사용하고 있지 않으면 ". /etc/bash_completion"라고 실행해서 바로 사용하자:</p>

<pre><code>skx@lappy:~$ . /etc/bash_completion
skx@lappy:~$ 
</code></pre>

<p>이걸 한 번만 해주면 다양한 명령어에 Completion을 이용할 수 있다:</p>

<pre><code>skx@lappy:~$ apt-get upd[TAB]
skx@lappy:~$ apt-get upg[TAB]
</code></pre>

<p>그런데, 어떻게 만들지? 직접 만들고 싶은데. Completion 루틴은 'complete' 같은 bash 내부 명령어 몇 개를 조합해서 만든다. 이 루틴을 만들어 .bash_profile에 넣거나 별도의 파일로 만들어 /etc/bash_completion.d/에 넣을 수 있다.</p>

<p>/etc/bash_completion 파일을 로드하면(sourced) /etc/bash_completion.d 디렉토리에 있는 모든 파일이 같이 로드된다. 편리하다.</p>

<p>개중에는 호스트 이름을 완성해주는 것도 있다. 이 게 유용한 명령어도 있고 아닌 명령어도 있지만 하나 살펴보자.</p>

<p>저자인 [Steve][]는 <a href="http://www.debian-administration.org/articles/135">VNC로 관리하는 컴퓨터가 몇 대 있다</a>. 보통 "xvncviewer hostname"이라고 실행한다.</p>

<p>다음과 같이 complete 명령을 실행해 주면 위 명령에서 hostname 부분을 Completion할 수 있다:</p>

<pre><code>skx@lappy:~$ complete -F _known_hosts xvncviewer
</code></pre>

<p>이 complete 명령을 한번 실행하고 [TAB]을 입력하면 다음과 같이 보여 줄 거다:</p>

<pre><code>skx@lappy:~$ xvncviewer s[TAB]
savannah.gnu.org            ssh.tardis.ed.ac.uk
scratchy                    steve.org.uk
security.debian.org         security-master.debian.org
sun
skx@lappy:~$ xvncviewer sc[TAB]
</code></pre>

<p>이 호스트들은 나한테만 이렇게 보인다.</p>

<p>_known_hosts 함수는 /etc/bash_completion에 정의돼 있다. 이런 함수가 있다는 걸 내가 어떻게 알았을까? "complete -p" 명령을 실행하면 현재 사용하고 있는 것을 모두 보여준다:</p>

<pre><code>skx@lappy:~$ complete -p
....
complete -F _known_hosts tracepath
complete -F _known_hosts host
...
</code></pre>

<h2>Part 2</h2>

<p>이제 직접 Completion 함수를 작성해 보자.</p>

<p>'part 1'에서 아무 명령에나 hostname을 완성하는 것을 만들어 봤다:</p>

<pre><code>complete -F _known_hosts xvncviewer
</code></pre>

<p>이 명령은 xvncviewer의 인자를 Completion할 때 _known_hosts 함수를 사용하라고 알리는 것이다.</p>

<p>이제는 이미 만들어진 함수를 사용하는 것이 아니라 직접 만들어 사용하는 것을 알아보자.</p>

<h3>A Basic Example</h3>

<p>먼저 <code>foo</code>라는 명령어의 인자를 Completion하는 예제를 만들어보자. <code>foo</code>는 다음과 같은 인자를 가진 가짜 명령어다:</p>

<ul>
<li>--help
<ul><li>Shows the help options for foo, and exits.</li></ul></li>
<li>--version
<ul><li>Shows the version of the foo command, and exits.</li></ul></li>
<li>--verbose
<ul><li>Runs foo with extra verbosity</li></ul></li>
</ul>

<p>/etc/bash_comletion을 로드할 때 자동으로 로드되도록 /etc/bash_completeion.d/foo 파일을 만든다. </p>

<p>파일에 다음과 같은 내용을 넣고 저장한다:</p>

<pre><code>_foo() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="--help --verbose --version"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}
complete -F _foo foo
</code></pre>

<p>그리고 나서 이 파일만 읽어들여 테스트해본다: </p>

<pre><code>skx@lappy:~$ . /etc/bash_completion.d/foo
skx@lappy:~$ foo --[TAB]
--help     --verbose  --version  
</code></pre>

<p>한번 해보면 인자가 자동으로 완성되는 것을 볼 수 있다. 그리고 예를 들어, "foo --h[TAB]"라고 입력하면 '--help' 옵션을 자동으로 완성해준다</p>

<p>이제 실제로 동작하는 것을 만들어 봤고 어떻게 동작하는 것인지 뜯어보자!</p>

<h3>How Completion Works</h3>

<p>Completion에 사용할 함수를 간단하게 구현해봤다.</p>

<p>이 함수는 cur, prev, opts 옵션을 정의하면서 시작한다. cur는 '현재 입력된 단어(word)'에 사용하고, prev는 '이전에 입력된 단어'에, opts는 Completion할 옵션에 사용한다.</p>

<p>그리고 실제로 옵션을 Completion하는 것은 compgen이라는 명령어를 통해서다:</p>

<pre><code>COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
</code></pre>

<p>compgen 명령의 결과를 $COMPREPLY에 할당한다:</p>

<pre><code>compgen -W "${opts}" -- ${cur}
</code></pre>

<p>여기서 변수 대신 실제 값을 넣어보면 이 명령이 실제로 어떻게 동작하는지 이해하기 쉬울 것이다:</p>

<pre><code>compgen -W "--help --verbose --version" -- "userinput"
</code></pre>

<p>compgen은 "--help --verbose --version" 중에서 "${cur}"와 일치하는 것을 찾아 리턴한다. 잘 이해가 안되면 바로 셸에서 이 명령을 직접 실행해 보면 알 수 있다:</p>

<pre><code>skx@lappy:~$ compgen -W "--help --verbose --version" -- --
--help
--verbose
--version
skx@lappy:~$ compgen -W "--help --verbose --version" -- --h
--help
</code></pre>

<p>"--"라고 입력하면 세 옵션 모두 일치하므로 전부 반환된다. 하지만 "--h"만 입력하면 "--help"만 일치하므로 --help만 반환한다.</p>

<p>그래서 이 결과를 "COMPREPLY" 변수에 할당하면 bash가 입력 중인 부분의 글자를 대체시킨다. bash에서 COMPREPLY는 Completion 루틴에서 결과를 반환하는 방법이라서 특별한 의미가 있는 변수다.</p>

<p><a href="http://www.gnu.org/software/bash/manual/bash.html">the bash reference manual</a>에 있는 COMPREPLY에 대한 설명을 살펴보자:</p>

<h4>COMPREPLY</h4>

<p>Completion 함수가 반환한 결과를 배열 형태로 반환하고 Bash가 이 변수를 읽는다.</p>

<p>그리고 사용자가 입력하는 단어가 무엇인지 COMP_WORDS라는 배열로 알 수 있다. 그리고 현재 단어와 이전 단어가 무엇인지도 알 수 있다.</p>

<h4>COMP_WORDS</h4>

<p>지금 Command line에 있는 각 단어가 담긴 배열이다. 이 변수는 Completion을 만들 때 사용하는 명령어를 통해 호출한 함수에서만 사용할 수 있다.</p>

<h4>COMP_CWORD</h4>

<p>${COMP_WORDS} 배열에서 현 단어를 가리키는 인덱스다. 이것도 Completion 명령어가 호출한 함수에서만 사용할 수 있다.</p>

<h3>A Complex Example</h3>

<p>옵션이 굉장히 복잡한 명령어도 많다. 이런 명령어는 상당히 정교한 작업이 필요하다.</p>

<p>Xen에 있는 xm 명령어의 예를 살펴보자(<a href="http://www.ibm.com/developerworks/kr/library/l-xen/">developerworks의 Xen 소개</a>):</p>

<ul>
<li>xm list
<ul><li>List all running Xen instances</li></ul></li>
<li>xm create ConfigName
<ul><li>Create a new Xen instances using the configuration file in /etc/xen called ConfigName.</li></ul></li>
<li>xm console Name
<ul><li>Connect to the console of the running machine named "Name".</li></ul></li>
</ul>

<p>예를 들어, "xm operation args" 라는 명령어에서 "args"는 앞에 "operation"이 무엇이냐에 따라 다르다.</p>

<p>먼저 "operation"의 Completion을 구현하는 것은 앞에서 설명했던 것과 방법이 같다. "--" 없이 구현하고 사용하면 된다. 하지만, 후속 인자를 Completion하는 것은 특별한 처리가 필요하다.</p>

<p>Completion할 때 이전 토큰을 알아야 해서 명령어마다 다르게 처리한다. 예를 들자면:</p>

<pre><code>_xm() 
{
    local cur prev opts base
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    #
    #  The basic options we'll complete.
    #
    opts="console create list"


    #
    #  Complete the arguments to some of the basic commands.
    #
    case "${prev}" in
        console)
            local running=$(for x in `xm list --long | grep \(name | grep -v Domain-0 | awk '{ print $2 }' | tr -d \)`; do echo ${x} ; done )

            COMPREPLY=( $(compgen -W "${running}" -- ${cur}) )
            return 0
            ;;
        create)
            local names=$(for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//} ; done )

            COMPREPLY=( $(compgen -W "${names}" -- ${cur}) )
            return 0
            ;;
        *)
            ;;
    esac

    COMPREPLY=($(compgen -W "${opts}" -- ${cur}))  
    return 0
}
complete -F _xm xm
</code></pre>

<p>이 코드는 "operation"을 Completion하는 것이고 "create"와 "console"이라는 "operation"에 대해서는 추가적인 코드를 더 했다. <br />사용자가 입력하는 값을 Completion하기 위해 compgen을 사용하는 것까지는 같지만, 상황에 따라 다른 목록을 사용한다.</p>

<p>"console" operation에 사용하는 목록은 다음과 같은 명령으로 만든다:</p>

<pre><code>xm list --long | grep \(name | grep -v Domain-0 | awk '{ print $2 }' | tr -d \)
</code></pre>

<p>이 명령은 지금 도는 Xen 시스템의 목록을 반환한다.</p>

<p>"creation" operation에 사용하는 목록은 다음 명령으로 만든다:</p>

<pre><code>for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//} ; done
</code></pre>

<p>이 명령은 /etc/xen 디렉토리에 있는 '*.cfg' 파일을 모두 반환한다. 예를 들면 다음과 같다:</p>

<pre><code>skx@lappy:~$ for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//}; done
etch.cfg
root.cfg
sarge.cfg
steve.cfg
x.cfg
skx@lappy:~$ 
</code></pre>

<h3>Other Completion</h3>

<p>지금까지 compgen을 사용해서 사용자가 입력한 값과 일치하는 스트링을 찾았다. 찾을 스트링은 하드 코딩한 목록이거나 명령어가 반환하는 결과에서 찾았다. 디렉토리 이름이나 프로세스 이름등 다른 것에서 찾을 수도 있다. 자세한 내용은 "man bash"를 실행해서 살펴볼 수 있다.</p>

<p>다음은 파일과 호스트이름을 Completion하는 방법을 설명하는 예제다:</p>

<pre><code>#
#  Completion for foo:
#
#  foo file [filename]
#  foo hostname [hostname]
#
_foo() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="file hostname"

    case "${prev}" in
        file)
        COMPREPLY=( $(compgen -f ${cur}) )
            return 0
            ;;
        hostname)
        COMPREPLY=( $(compgen -A hostname ${cur}) )
            return 0
            ;;
        *)
        ;;
    esac

    COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
}
complete -F _foo foo
</code></pre>

<p>이 예제를 활용하면 직접 Completion 함수를 만들 수 있다. 사실 Completion 함수를 만드는데 시간이 많이 들고 나머지는 매우 간단하다.</p>

<p>@pismute가 만든 <a href="https://github.com/dogfeet/docpad/blob/dogfeet/contrib/docpad-completion.bash">docpad-completion.bash</a>도 읽어 볼 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ SMACSS:The Icon Module ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss-icon-module.html" />
    <updated>2012-03-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss-icon-module.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="https://smacss.com/book/icon-module">The Icon Module</a>을 정리한 것이다. <a href="https://smacss.com/">SMACSS</a>를 읽고 SMACSS의 철학이 실제로 어떻게 적용되는지 알아보기에 좋다. 이글은 'CSS Sprite' 기법을 사용하는 엉성한 Icon Module을 SMACSS의 방법으로 단단한 Icon Module로 리팩토링하는 것을 보여준다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="smacss" title="" /></p>

<p>이 글은 무료로 공개돼 있지 않다.</p>

<h2>SMACSS</h2>

<p><a href="https://smacss.com/">SMACSS</a>는 좋은 책이다. CSS '관리'에 초점을 맞추고 이렇게 일목요연하게 정리된 자료는 일찍이 보지 못했다. 이 글을 읽고 도움이 됐다면 <a href="https://smacss.com/">SMACSS</a>를 꼭 사길 바란다. $30 짜리 workshop 계정을 사면 저자인 <a href="http://snook.ca/">Jonathan Snook</a>가 지속적으로 업데이트하는 유로 컨텐츠를 계속 이용할 수 있다.</p>

<h2>The Icon Module</h2>

<p>Asset(Image)을 한 파일로 모으면 HTTP 요청 수도 줄고 이미 모든 Asset을 내려받았기 때문에 나중에 필요할 때 바로 사용할 수 있다. 이것을 <code>CSS Sprite</code>라고 부른다.</p>

<p>다음 그림을 보면 이 말이 무슨 뜻인지 알 수 있다:</p>

<p><img src="/articles/2012/smacss/icon-menu.png" alt="icon-menu" title="" /></p>

<p>Menu HTML:</p>

<pre><code>&lt;ul class="menu"&gt;
    &lt;li class="menu-inbox"&gt;Inbox&lt;/li&gt;
    &lt;li class="menu-drafts"&gt;Drafts&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Menu CSS:</p>

<pre><code>.menu li {
    background: url(/img/sprite.png) no-repeat 0 0;
    padding-left: 20px;
}

.menu .menu-inbox {
    background-position: 0 -20px;
}

.menu .menu-drafts {
    background-position: 0 -40px;
}
</code></pre>

<p>모든 Icon은 Sprite 파일 하나에 다 들어 있고 아이템마다 필요한 Icon이 있는 위치를 보여준다.</p>

<p>이걸로도 되긴 되지만 좀 더 작업을 다듬을 수 있다:</p>

<ul>
<li>list 아이템이라는 특정 DOM에만 사용할 수 있다.</li>
<li>모듈마다 Sprite를 항상 다시 만들어야 한다.</li>
<li>위치가 취약하다: 폰트 크기를 늘리면 다른 부분이 살짝 보일 수 있다.</li>
<li>x가 항상 0이기 때문에 수평적으로 처리하기 까다롭다.</li>
</ul>

<p>이 이슈만 해결되면 소위 Icon Module이라 칭할 수 있다.</p>

<p>Icon Module을 사용하도록 HTML을 바꾼다:</p>

<pre><code>&lt;li&gt;&lt;i class="ico ico-16 ico-inbox"&gt;&lt;/i&gt; Inbox&lt;/li&gt;
</code></pre>

<p><code>&lt;i&gt;</code> 태그는 간단하고 시맨틱과는 거리가 먼 태그다. Icon은 다른 텍스트를 부연 설명하는 거니까 시멘틱이 없는 태그라고 볼 수 있다. Icon이 혼자 쓰일 때는 꼭 title 속성을 넣어줘서 Screen Reader나 tooltip에서 읽을 수 있도록 해주는 것이 좋다. <code>&lt;i&gt;</code> 태그가 싫다면 <code>&lt;span&gt;</code> 태그가 적당하다.</p>

<p><code>&lt;i&gt;</code>는 HTML 속 어디에 넣어도 되니까 HTML 구조의 의존성은 사라졌다고 볼 수 있다.</p>

<p>그리고 "ico ico-16 ico-inbox" 클래스는 각각 역할이 다르다. 게다가 <code>&lt;img&gt;</code> 태그와 잘 섞어 사용할 수 있다.</p>

<p>Icon Module CSS:</p>

<pre><code>.ico {
    display: inline-block;
    background: url(/img/sprite.png) no-repeat;
    line-height: 0;
    vertical-align: bottom;
}

.ico-16 {
    height: 16px;
    width: 16px;
}

.ico-inbox {
    background-position: 20px 20px;
}

.ico-drafts {
    background-position: 20px 40px;
}
</code></pre>

<p><code>ico</code> 클래스는 모듈의 기본적인 토대를 다지는 클래스다. <code>&lt;img&gt;</code>처럼 inline-block 엘리멘트로 만들고 <code>vertical-align</code>으로 Icon이 텍스트와 잘 어우러지도록 해준다. IE는 <code>inline-block</code>을 <code>block</code> 엘리먼트로 취급하기 때문에 IE에서는 <code>{ zoom:1; display:inline; }</code>로 해야 한다.</p>

<p><code>ico-16</code>은 크기 정해주기 위함이다. ico 클래스에 같이 넣어줘도 되지만 Icon마다 크기가 다를 수도 있어서 이렇게 하는 거다.</p>

<p><code>icon-inbox</code>는 Sprite 이미지에서의 Inbox용 Icon의 위치를 정의하는 것이다.</p>

<p>촘촘히 우겨넣은 이미지:</p>

<p><img src="/articles/2012/smacss/icon-menu2.png" alt="icon-menu2" title="" /></p>

<p>잘 우겨넣으면 압축 효율이 좋아진다. 그리고 파일 크기도 더 작아지므로 사이트 성능도 향상된다. 아직 <a href="http://www.smushit.com/ysmush.it/">Smush.it</a>이나 <a href="http://imageoptim.pornel.net/">ImageOptim</a>을 사용해보지 않았으면 한번 사용해보는 것이 좋다.</p>]]>
    </content>
  </entry>
</feed>
