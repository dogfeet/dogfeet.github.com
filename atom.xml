<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.io/atom.xml" rel="self" />
  <link href="http://dogfeet.github.io" />
  <updated>2013-09-22T09:10:20.219Z</updated>
  <id>http://dogfeet.github.io</id>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ grunt: 수정된 파일만 Lint하기 ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/grunt-do-only-files-changed.html" />
    <updated>2013-09-21T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/grunt-do-only-files-changed.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 예로 Lint를 사용하지만, Watch 이벤트를 다루는 법은 CoffeeScript 스크립트를 컴파일하는 것 때문에 필요했다. Lint는 번개처럼 빠르지만 CoffeeScript 컴파일은 번개같진 않아서 수정한 파일만 다시 컴파일하는 기능이 간절했다.</p>

<p>grunt의 watch 타스크는 아직 완성되지 않은 것 같다. 조금 모호해서 수정한 파일만 다루는게 처음이라면 실수하기 쉽도록 생겼다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/grunt-do-only-files-changed/gruntjs.png" alt=""/></p>

<h2>Watch 이벤트</h2>

<p>먼저 Watch 이벤트를 핸들링하는 방법을 살펴보자. Watch하고 있다가 파일이 수정되면 해당 파일을 Lint하는 워크플로우를 살펴본다.</p>

<p>아래는 <a href="https://github.com/gruntjs/grunt-init-node">grunt-init-node</a>에서 가져왔고 jshint와 watch를 제외한 다른 부분은 생략한다:</p>
<pre><code><span class="keyword">...</span>
jshint: {
  lib: {
    src: [<span class="string">'lib/**/*.js'</span>]
  }
},
watch: {
  lib: {
    files: <span class="string">'&lt;%= jshint.lib.src %&gt;'</span>,
    tasks: [<span class="string">'jshint:lib'</span>]
  }
}
<span class="keyword">...</span>
</code></pre>
<p>&lsquo;lib/**/*.js'파일이 수정되면 jshint 타스크가 실행된다. 이 때 문제는 수정된 파일만 다시 Lint하는 것이 아니라 모든 파일에 대해 다시 Lint한다.</p>

<p>수정된 파일만 다시 Lint하게 하려면, Watch 이벤트를 직접 핸들링해야 한다. 아래와 같은 코드가 필요하다:</p>
<pre><code><span class="keyword">...</span>
grunt.event.on(<span class="string">'watch'</span>, <span class="keyword">function</span>(action, files, target) {
  grunt.log.writeln(target + <span class="string">": "</span> + files + <span class="string">" has "</span> + action);
  grunt.config([<span class="string">'jshint'</span>, target], {src: files});
});
..
</code></pre>
<p>'lib/**/*.js&rsquo; 파일 중에서 하나라도 수정되면 Watch 이벤트가 발생하고 jshint의 설정을 수정해서 jshint 타스크를 실행시킨다. jshint의 설정을 아예 변경해 버리는 방법으로 원래 jshint의 설정이 사라져 버린다. 여기에서 문제가 생긴다. watch는 jshint를 참조하고 있고 jshint의 설정은 변경됐으므로 마지막에 수정된 파일이 이외의 파일에 대해서는 더 이상 Watch 이벤트가 발생하지 않는다.</p>

<p>파일을 정의해주는 부분을 아래와 같이 변경해줘야 한다:</p>
<pre><code><span class="keyword">...</span>
jshint: {
  lib: {
    src: <span class="string">'&lt;%= watch.lib.files %&gt;'</span>
  }
},
watch: {
  lib: {
    files: [<span class="string">'lib/**/*.js'</span>],
    tasks: [<span class="string">'jshint:lib'</span>]
  }
}
<span class="keyword">...</span>
</code></pre>
<p>이렇게 하면 jshint의 설정이 달라져도 watch 타스크는 영향받지 않는다.</p>

<p>설정을 백업하거나 watch 전용 타겟을 만들어서 해결할 수도 있지만, 코드는 좀더 복잡해질 수 있다. 수정된 파일만 컨트롤하는 방법은 아직 불완전하다.</p>

<p>이 내용을 <a href="https://github.com/gruntjs/grunt-init-node/pull/4">grunt-init-node에 적용해서 PR</a>을 보냈는데 거절됐다. watch는 다른 다스크에 종속적이며 watch 이벤트를 핸들링해서 컴파일을 지원하는 것은 권장하지 않는다고 한다. 다른 방법을 고안중이라고 하니 기다려봐야 겠다.</p>

<p>그리고 <a href="https://github.com/gruntjs/grunt-init-node/issues/3">grunt-init-node의 다른 이슈</a>를 보면 <a href="https://github.com/gruntjs/grunt-init-node">grunt-init-node</a> 프로젝트가 yeoman으로 대체될 것이라고 한다. yeoman과 grunt-init은 기능이 중복되는 감이 있었는데, scaffolding은 전적으로 yeoman이 맡게 될 것으로 보인다.</p>
]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ grunt: 비동기 타스크 ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/grunt-async-task.html" />
    <updated>2013-09-05T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/grunt-async-task.html</id>
    <content type="html">
<![CDATA[
<p>grunt 문서는 비동기 타스크를 자세히 설명하지 않는다. 그래서 처음에 오해하고 삽질을 약간 할 수도 있다(나는 했다&ndash;;).</p>

<p>이 글은 비동기 타스크를 왜 쓰고 언제 어떻게 써야 하는지 설명한다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/grunt-async-task/information-boards.jpg" alt=""/></p>

<h2>비동기 타스크</h2>

<p>우선 setTimeout으로 간단한 비동기 타스크를 하나 만들어 보자.</p>

<p>afterseconds라는 이름의 타스크를 만든다:</p>
<pre><code>module.exports = <span class="keyword">function</span>(grunt) {

  grunt.registerTask(<span class="comment">'afterseconds', 'done after a few seconds', function() {</span>
    var done = this.async();

    console.<span class="built_in">log</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());

    setTimeout(<span class="keyword">function</span>(){
      console.<span class="built_in">log</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());
      done();
    }, <span class="number">2000</span>);
  });

};
</code></pre>
<p>이 타스크는 2초 후에 완료하는 타스크다.</p>

<p>Gruntfile.coffee도 만들자:</p>
<pre><code>module.exports = (grunt)-&gt;
  <span class="keyword">...</span>

  grunt.loadTasks <span class="string">'tasks'</span>

  <span class="comment"># Default task.</span>
  grunt.registerTask <span class="string">'default'</span>, [<span class="string">'afterseconds'</span>, <span class="string">'jshint'</span>]

</code></pre>
<p><code>grunt</code>라고 실행하면 <code>afterseconds</code>, <code>jshint</code>를 차례대로 실행한다:</p>
<pre><code>$ <span class="tag">grunt</span>
<span class="tag">Running</span> "<span class="tag">afterseconds</span>" <span class="tag">task</span>
<span class="tag">Fri</span> <span class="tag">Sep</span> 06 2013 02<span class="pseudo">:24</span><span class="pseudo">:01</span> <span class="tag">GMT</span>+0900 (<span class="tag">KST</span>)
<span class="tag">Fri</span> <span class="tag">Sep</span> 06 2013 02<span class="pseudo">:24</span><span class="pseudo">:03</span> <span class="tag">GMT</span>+0900 (<span class="tag">KST</span>)

<span class="tag">Running</span> "<span class="tag">jshint</span><span class="pseudo">:tasks"</span> (<span class="tag">jshint</span>) <span class="tag">task</span>
&gt;&gt; 0 <span class="tag">files</span> <span class="tag">linted</span>. <span class="tag">Please</span> <span class="tag">check</span> <span class="tag">your</span> <span class="tag">ignored</span> <span class="tag">files</span>.
</code></pre>
<p>이처럼 간단하게 비동기 타스크를 만들 수 있다.</p>

<h2>grunt 비동기 구현</h2>

<p>grunt는 내부에 타스크 큐를 가지고 있다. 우리가 타스크를 실행하면 즉시 실행되는 것이 아니라 일단 큐에 등록되고 다음 틱에 실행된다.</p>

<p>그 큐에 등록된 타스크는 차례대로 수행된다. 앞 타스크가 끝나야 다음 타스크가 실행된다. 위 예제에서는 &lsquo;afterseconds&rsquo;, &lsquo;jshint&rsquo; 타스크가 순서대로 등록됐고 &lsquo;afterseconds'는 2초 후에 끝나므로 2초 후에 'jshint'가 실행된다.</p>

<p><code>var done = this.async();</code>의 async() 함수를 살펴보자:</p>
<pre><code>// When called, sets the async flag <span class="keyword">and</span> returns a <span class="function"><span class="keyword">function</span> <span class="title">that</span> <span class="title">can</span>
// <span class="title">be</span> <span class="title">used</span> <span class="title">to</span> <span class="title">continue</span> <span class="title">processing</span> <span class="title">the</span> <span class="title">queue</span>.
<span class="title">context.async</span> = <span class="title">function</span><span class="params">()</span></span> {
  async = <span class="keyword">true</span>;

  // The returned <span class="function"><span class="keyword">function</span> <span class="title">should</span> <span class="title">execute</span> <span class="title">asynchronously</span> <span class="title">in</span> <span class="title">case</span>
  // <span class="title">someone</span> <span class="title">tries</span> <span class="title">to</span> <span class="title">do</span> <span class="title">this.async</span><span class="params">()</span></span>(); inside a task (WTF).
  <span class="keyword">return</span> function(success) {
    setTimeout(function() { complete(success); }, <span class="number">1</span>);
  };
};
</code></pre>
<p>내부의 async 변수를 true바꾸고 done 함수를 리턴한다.</p>

<p>타스크를 실행시키는 grunt 코드는 아래와 같다:</p>
<pre><code><span class="keyword">try</span> {
  // Get <span class="keyword">the</span> current task <span class="keyword">and</span> <span class="command">run</span> <span class="keyword">it</span>, setting `this` inside <span class="keyword">the</span> task
  // function <span class="keyword">to</span> be something useful.
  var success = fn.call(context);
  // If <span class="keyword">the</span> async flag wasn't <span class="keyword">set</span>, process <span class="keyword">the</span> next task <span class="keyword">in</span> <span class="keyword">the</span> queue.
  <span class="keyword">if</span> (!async) {
    complete(success);
  }
} catch (err) {
  complete(err);
}
</code></pre>
<p><code>fn.call(context)</code>가 타스크를 실행하는 부분이고 async 값을 검사해서 동기일 때는 <code>complete(success)</code>를 바로 실행해서 타스크를 완료시키고 비동기일 때는 <code>done()</code>이 실행될 때까지 연기된다.</p>

<h3>async()는 왜 필요할까?</h3>

<p>간단한 node 프로그램에서는 아래와 같이 코드를 작성해서 실행하면 2초 후에 callback까지 실행되고 나서 프로그램이 종료한다:</p>
<pre><code>console.<span class="built_in">log</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());

setTimeout(<span class="keyword">function</span>(){
  console.<span class="built_in">log</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());
}, <span class="number">2000</span>);
</code></pre>
<p>하지만, grunt에서는 그렇지 않다. 위 예제의 타스크를 동기 타스크로 수정해보자:</p>
<pre><code>module.exports = <span class="keyword">function</span>(grunt) {

  grunt.registerTask(<span class="comment">'afterseconds', 'done after some seconds', function() {</span>
    console.<span class="built_in">log</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());

    setTimeout(<span class="keyword">function</span>(){
      console.<span class="built_in">log</span>(<span class="keyword">new</span> <span class="built_in">Date</span>());
    }, <span class="number">2000</span>);
  });

};
</code></pre>
<p>그리고 <code>grunt</code>를 실행하면 2초 후에 callback이 실행되지 않고 바로 종료한다:</p>
<pre><code>$ <span class="tag">grunt</span>
<span class="tag">Running</span> "<span class="tag">afterseconds</span>" <span class="tag">task</span>
<span class="tag">Fri</span> <span class="tag">Sep</span> 06 2013 03<span class="pseudo">:20</span><span class="pseudo">:08</span> <span class="tag">GMT</span>+0900 (<span class="tag">KST</span>)

<span class="tag">Running</span> "<span class="tag">jshint</span><span class="pseudo">:tasks"</span> (<span class="tag">jshint</span>) <span class="tag">task</span>
&gt;&gt; 0 <span class="tag">files</span> <span class="tag">linted</span>. <span class="tag">Please</span> <span class="tag">check</span> <span class="tag">your</span> <span class="tag">ignored</span> <span class="tag">files</span>.

<span class="tag">Done</span>, <span class="tag">without</span> <span class="tag">errors</span>.
</code></pre>
<p>처음 타스크를 구현할 때는 비동기로 IO를 처리하면 타스크를 병렬로 실행할 수 있어서 자동화 시간이 단축될 거라고 생각했다(메뉴얼에서 그다지 자세히 설명하지 않으므로). 그런데 IO가 끝나지도 않았는데 grunt 프로세스가 종료돼 버렸다. 모든 callback이 실행될 때까지 기다려주는 일반적인 node 프로그램과 동작이 달라서 처음에는 조금 헷갈릴 수 있다.</p>

<p><code>async()</code>라는 이름과 다르게 grunt의 타스크 큐는 차례대로 실행돼야 한다는 점을 명심해야 한다. 'async()'를 사용하는 이유를 간단히 말해보자면 <strong>비동기 코드로 타스크가 차례대로 실행되지 못할 상황에 놓일 때 <code>async()</code> 함수로 타스크가 차례대로 실행되게 만드는 것이다</strong>.</p>

<h3>grunt의 한계</h3>

<p>grunt의 타스크 큐는 차례대로 실행되므로 타스크를 병렬로 실행할 방법은 없다.</p>

<p>플러그인인 <a href="https://github.com/iammerrick/grunt-parallel">grunt-parallel</a> 타스크를 쓰면 타스크를 병렬로 실행할 수 있다. 이 타스크는 grunt 프로세스를 여러 개 띄워서 병렬로 다른 타스크들을 실행시켜 준다.</p>

<p>Async.js처럼 다양하게 flow control를 할 수 있으면 좋지 않을까? 다음이나 다음다음 버전을 기대해본다.</p>
]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ git: msysgit + pageant ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/git-msysgit-pageant.html" />
    <updated>2013-07-26T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/git-msysgit-pageant.html</id>
    <content type="html">
<![CDATA[
<p>윈도우는 늘 불편하니까 <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">putty</a>를 항상 띄워놓고 서버에서 논다. <a href="http://msysgit.github.io/">msysgit</a>을 쓰긴하지만 서버에서 놀기에 로컬에서는 설정 백업할 때나 사용했다. 최근 로컬에서도 git을 사용하는 빈도가 늘면서 매번 인증서 암호를 입력하는게 너무 불편했다. 왠지 <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">pageant</a>와 연동이 잘될 것 같아서 Google님에게 물어보니 바로 나온다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-msysgit-pageant/msysgit-pageant.png" alt="select-plink"/></p>

<h2>pageant</h2>

<p><a href="http://msysgit.github.io/">msysgit</a>을 설치할 때 <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/download.html">plink</a>를 선택하면 바로 동작한다. plink를 사용해서 뭘하려고 한적이 없어서 모르고 있었다:</p>

<p><img src="/articles/2013/git-msysgit-pageant/msysgit-plink.png" alt="select-plink"/></p>

<p>설치할 때 <a href="http://www.openssh.org/">OpenSSH</a>를 사용하도록 설치했더라도 <code>$GIT_SSH</code> 환경 변수에 plink를 지정해주면 된다:</p>
<pre><code><span class="keyword">export</span> GIT_SSH=/my/path/plink<span class="variable">.exe</span>
</code></pre>
<p>그리고 나서 사용하면 바로 pageant를 사용할 수 있는데, <code>git fetch</code> 명령으로 테스트를 해보면 아직 서버랑 인사 안했다고 다음과 같은 에러를 뱉는다:</p>
<pre><code>$ git fetch
The server's host key <span class="keyword">is</span> <span class="keyword">not</span> cached <span class="keyword">in</span> <span class="keyword">the</span> registry. You
have no guarantee <span class="keyword">that</span> <span class="keyword">the</span> server <span class="keyword">is</span> <span class="keyword">the</span> computer you
think <span class="keyword">it</span> <span class="keyword">is</span>.
The server's rsa2 key fingerprint <span class="keyword">is</span>:
ssh-rsa <span class="number">2048</span> <span class="number">97</span>:<span class="number">8</span>c:<span class="number">1</span>b:f2:<span class="number">6</span>f:<span class="number">14</span>:<span class="number">6</span>b:<span class="number">5</span>c:<span class="number">3</span>b:ec:aa:<span class="number">46</span>:<span class="number">46</span>:<span class="number">74</span>:<span class="number">7</span>c:<span class="number">40</span>
Connection abandoned.
fatal: Could <span class="keyword">not</span> <span class="command">read</span> <span class="keyword">from</span> remote repository.
</code></pre>
<p>서버랑 인사를 한번해야 한다:</p>
<pre><code>$ plink git@github.com
The server's host key <span class="keyword">is</span> <span class="keyword">not</span> cached <span class="keyword">in</span> <span class="keyword">the</span> registry. You
have no guarantee <span class="keyword">that</span> <span class="keyword">the</span> server <span class="keyword">is</span> <span class="keyword">the</span> computer you
think <span class="keyword">it</span> <span class="keyword">is</span>.
The server's rsa2 key fingerprint <span class="keyword">is</span>:
ssh-rsa <span class="number">2048</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48</span>
If you trust this host, enter <span class="string">"y"</span> <span class="keyword">to</span> add <span class="keyword">the</span> key <span class="keyword">to</span>
PuTTY's cache <span class="keyword">and</span> carry <span class="function_start"><span class="keyword">on</span> <span class="title">connecting</span></span>.
If you want <span class="keyword">to</span> carry <span class="function_start"><span class="keyword">on</span> <span class="title">connecting</span></span> just once, <span class="keyword">without</span>
adding <span class="keyword">the</span> key <span class="keyword">to</span> <span class="keyword">the</span> cache, enter <span class="string">"n"</span>.
If you do <span class="keyword">not</span> trust this host, press Return <span class="keyword">to</span> abandon <span class="keyword">the</span>
connection.
Store key <span class="keyword">in</span> cache? (y/n) y
Using username <span class="string">"git"</span>.
Server refused <span class="keyword">to</span> allocate pty
Hi pismute! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.
</code></pre>
<p>서버가 &lsquo;Hi pismute!'라고 인사를 한다. 서버의 키는 레지스트리에 저장된다. 이제 실행하면 잘된다.</p>

<p>키를 자동으로 저장하는 방법이 있을 것 같은데 찾지 못했다. <a href="http://rc.quest.com/topics/putty/">Quest의 plink</a>에는 <code>-auto_store_key_in_cache</code> 옵션이 있어서 자동으로 저장해주도록 만들 수 있는데, 이건 왠일인지 msysgit과 연동이 잘 안된다.</p>

<blockquote>
<p>검색하다보니 <a href="https://github.com/cuviper/ssh-pageant">ssh-pageant</a>라는 게 있어서 Cygwin에서는 openSSH 명령어 까지 pageant를 사용하도록 설정할 수 있는 것 같은데 msys 용은 아직 없는 것 같다.</p>
</blockquote>
]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ git: Useful GitHub Patterns ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/git-useful-github-pattern.html" />
    <updated>2013-07-19T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/git-useful-github-pattern.html</id>
    <content type="html">
<![CDATA[
<p>Jake Benilov님이 쓴 <a href="http://blog.quickpeople.co.uk/2013/07/10/useful-github-patterns/">Useful Github Patterns</a>를 번역한 글이다. Jake님은 글이라기보다 요약이나 정리에 가까운 형식으로 썼기 때문에 번역이 어려웠다. 같은 의미로 글을 새로 쓴 게 많아서 오역이 첨가됐을 것 같다.</p>

<p>특히 <code>Pull Request</code>를 글로 정리하는 일은 쉽지 않았는데 Jake님이 잘 설명하신 것 같다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-useful-github-pattern/pattern.jpg" alt="너의 패턴은 파악되었다!"/></p>

<h2>USEFUL GITHUB PATTERNS</h2>

<p>내 <a href="http://blog.quickpeople.co.uk/2013/05/17/the-uk-government-pays-me-to-write-open-source-all-day/">직업</a>이나 <a href="http://benilovj.github.io/dbfit/">오픈소스 활동</a>을 하다 보면 git과 GitHub 컨설팅도 하게 된다. 그러면서 git과 GitHub을 일정한 패턴에 따라 사용하는 나를 발견했다.</p>

<p>(여기부터는, &lsquo;Pull Request'를 PR로 사용한다).</p>

<h3>1. The peel-off PR</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>Feature 브랜치에서 뭔가 하는 도중에</li>
<li>문제를 발견하자마자 바로 수정하고 싶은데, 현재 추가하는 기능과 관련이 없을 때( 작은 버그, 오타, 코딩 규칙 위반을 발견했을 때)</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>하던 일을 저장(Commit하거나 Stash한다)</li>
<li>checkout master</li>
<li>브랜치를 만든다.</li>
<li>문제를 수정하고 PR을 보낸다.</li>
<li>다시 원래의 Feature 브랜치로 돌아와 하던 일을 계속한다.</li>
<li>나중에 그 PR을 보냈던 브랜치가 Merge된 후에 Rebase한다.</li>
</ul>

<p>전혀 다른 문제를 빨리 고치고 싶은 욕망과 Feature 브랜치를 정갈하게 해서 리뷰하기 쉽게 만들고 싶은 욕망을 모두 만족하게 할 수 있다.</p>

<h3>2. The optimistic branch</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>지금은 Merge할 수 없는 브랜치(branch-A)가 있는데(CI 빌드가 깨질 수도 있고, 리뷰어가 바쁠 수도 있다).</li>
<li>내가 당장 구현해야 하는 기능은 branch-A의 코드가 필요하다.</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>branch-A에서 branch-B 브랜치를 만든다.</li>
<li>branch-A가 master에 Merge되면, branch-B를 master에 대해 Rebase하고 충돌 나는 게 있으면 해결한다.</li>
<li>branch-A에 대한 버그픽스 브랜치들은 branch-B에 대해서 Rebase한다.</li>
</ul>

<p>branch-A에서 코드를 많이 수정하면 충돌 날 확률이 높아진다. 하지만, 95% 정도는 잘 된다.</p>

<h3>3. The heads-up PR</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>리뷰가 필요하지 않은 코드를 작성하고 있지만</li>
<li>동료가 알고 있으면 좋을 것 같을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>코드를 작성</li>
<li>PR을 보낸다.</li>
<li>피드백을 기다리지 않고 PR을 직접 Merge한다.</li>
</ul>

<p>GitHub은 PR에 대한 이메일을 동료에게 보낸다. 그래서 맘에 들지 않은 코드를 발견한 동료는 코멘트를 달거나 할 수 있다. 내가 할 일이 별로 없다.</p>

<h3>4. The sneaky commit</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>코드를 리뷰하고 master에 Merge까지 한 다음에</li>
<li>수정할 것이 발견되었는데 너무 사소한 수정(버그픽스나 copy change같은 것)이라서 다른 사람이 알 가치도 없을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>master 브랜치에 바로 커밋한다.</li>
</ul>

<h3>5. The roger roger comment</h3>

<blockquote>
<p>역주: GitHub 이슈 넘버를 넣고 push하면 커밋 넘버에 대한 링크가 해당 이슈 코멘트에 댓글로 달리는 기능에 대해 말하는 것 같다. <a href="https://github.com/blog/957-introducing-issue-mentions">Introducing Issue Mentions</a> 참고.</p>
</blockquote>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>특정 브랜치에 대한 피드백을 받았는데 바로 적용하고 싶을 때</li>
<li>그 피드백에 따라서 고쳤을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>고친 커밋의 Ref가 포함된 PR에 코멘트를 단다.</li>
<li>GitHub은 똑똑해서 Ref를 클릭했을 때 이전 커밋과의 Diff 결과만 보여준다. 그래서 내 동료는:

<ul>
<li>Email로 내가 수정했다는 것을 통보받고</li>
<li>클릭만 하면 간단하게 커밋 Diff를 볼 수 있고</li>
<li>이런 식으로 코드 리뷰를 할 수 있다는 것을 안다.</li>
</ul></li>
</ul>

<blockquote>
<p>역주: PR을 통해서 코드까지 포함된 피드백을 받든지, 단순히 이슈로 피드백을 받든지 간에 이슈와 코드를 함께 묶어서 토론할 수 있는 점을 말하는 것 같다. 이슈와 관련된 사람은 토론 내역을 Email로 통보받고 Push한 커밋에 대한 diff 결과도 웹에서 쉽게 확인할 수 있다.</p>
</blockquote>

<h3>6. The creepin’ commit</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>내가 만든 사소한 포매팅 버그를 발견했을 때(불필요한 공백이나 파일 끝에 한 줄 남기는 것을 빼먹었을 때)나</li>
<li>이전 커밋과 논리적으로 같은 커밋이 돼야 할 때</li>
<li>(실패하는 테스트가 있거나 해서) 아직 커밋할 만한 코드가 아닌 상태에서 하나씩 실험해보고 다시 현재 코드로 되돌리거나 진행하고 싶을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>첫 번째나 두 번째는 그냥 이전 커밋을 수정한다(Amend)</li>
<li>마지막은 일단 (Creeping) 커밋을 하나 만들어 놓고 실험하면서 점진적으로 Amend한다. 실험 결과가 안 좋으면 그냥 버린다. 커밋할만한 단계에 도달할 때까지 계속한다.</li>
</ul>

<h3>7. The forced branch</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>남이 Push한 Feature 브랜치를 Amend해야 할 때. 예를 들어, 커밋 메시지에 이유를 남기고 싶을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>로컬에서 커밋을 Amend한다.</li>
<li>Feature 브랜치를 리모트 저장소에 강제로(-f 옵션을 주고) Push한다.</li>
</ul>

<p>보통 리모트 브랜치에 강제로 Push하는 것은 금단의 영역으로 취급된다. master 브랜치가 아니라면 내 경험상 별로 문제 되지 않았다(역주 - Long-Running 브랜치가 아니면 별로 문제 될 게 없다). GitHub은 PR 브랜치가 강제로 Push돼도 잘 처리한다. 이전 커밋에 있던 코멘트를 잃어버리거나 하지 않는다.</p>

<h3>8. The reformat peel-off</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>코드를 수정하면서 코드 포멧도 수정할 계획이라면</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>포멧을 수정한 커밋은 master 브랜치에 직접 한다.</li>
<li>코드를 수정한 커밋이 들어 있는 브랜치는 master대해 Rebase한다.</li>
</ul>

<p>이럴 때 코드 리뷰하는 사람은 코드를 수정한 브랜치에 Dill 하는 것이 더 좋다. 코드 수정 커밋이 있는 브랜치에는 포멧 수정 커밋이 없어서 Diff 결과가 더 깔끔하다.</p>

<h3>9. The prototype PR</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>본격적으로 구현하기 전에 아이디어에 대해 피드백을 받고 싶을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>브랜치에 뭔가 수정을 한다.</li>
<li>아직 완성된 코드가 아니라고 해도 일단 PR을 하면 토론의 시작점이 된다.</li>
<li>다음 단계로 뭘 할지 합의가 이루어지면 PR을 닫고 브랜치도 삭제한다.</li>
<li>다시 브랜치를 만들고 제대로 구현해서 PR을 한다.</li>
</ul>

<p>나는 PR이 코드를 다 완성하고 나서 하는 것으로 생각했었다. 지금은 &ldquo;Pull Request는 대화의 시작점&quot;이라는 것을 깊이 공감한다. PR과 관련된 GitHub의 기능은(Inline Comment, Reply, Notification, Diff) 매우 훌륭하다. 코드와 설계에 대해 토론을 많이 하게 해서 개발자가 너무 멀리 가거나 벼랑 끝으로 향하는 일을 미리 방지해준다.</p>
]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ git: ckw Solarized!  ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/git-msysgit-ckw-solarized.html" />
    <updated>2013-07-10T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/git-msysgit-ckw-solarized.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://ethanschoonover.com/solarized">Solarized</a>는 적당히 이쁜데다가 다양한 도구에서 사용할 수 있도록 이미 만들어진 테마가 많기 때문에 매우 편리하다. 문득 윈도우에서도 <a href="http://ethanschoonover.com/solarized">Solarized</a>를 사용하고 싶다는 생각이 들었다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-msysgit-ckw-solarized/be-autiful.jpg" alt=""/></p>

<h2>ckw</h2>

<p>cmd 터미널은 너무 구려서 <a href="http://d.hatena.ne.jp/hideden/20071115/1195229532">ckw</a>를 사용하고 있는데 찾아보니 <a href="https://gist.github.com/cd01/4307522">ckw용 Solarized 테마</a>를 만들어 놓은 훌륭한 분이 있었다.</p>

<p>바로 내 설정에 적용했다:</p>

<p><img src="/articles/2013/git-msysgit-ckw-solarized/git-msysgit-ckw-solarized.png" alt="ckw-solarized"/></p>

<p>Putty에도 <a href="http://ethanschoonover.com/solarized">Solarized</a>를 쓰고 있는데 ckw에도 적용했더니 둘이 많이 비슷해졌다.</p>

<p>하지만 미묘하게 이 ckw의 색감이 떨어진다. <a href="https://github.com/brantb/solarized">Solarized 저장소</a>에서 배포하고 있는 것 만큼 색감이 좋지는 않다. 눈에 거슬리는 색은 조금씩 변경해서 쓰는게 좋겠다.</p>

<p>위 설정을 적용한 내 설정은 아래와 같다:</p>
<pre><code>!
! ckw setting
!

Ckw<span class="variable">*title</span>: Powershell
Ckw<span class="variable">*exec</span>:  powershell -ExecutionPolicy RemoteSigned
Ckw<span class="variable">*chdir</span>: C:\Users\pismute\git

Ckw<span class="variable">*scrollHide</span>:  <span class="keyword">no</span>
Ckw<span class="variable">*scrollRight</span>: yes
Ckw<span class="variable">*internalBorder</span>: <span class="number">1</span>
Ckw<span class="variable">*lineSpace</span>: <span class="number">0</span>
Ckw<span class="variable">*topmost</span>: <span class="keyword">no</span>

Ckw<span class="variable">*font</span>: NanumGothicCoding
Ckw<span class="variable">*fontSize</span>: <span class="number">22</span>

Ckw<span class="variable">*geometry</span>:  <span class="number">80</span>x26
Ckw<span class="variable">*saveLines</span>: <span class="number">10000</span>

!! theme
!! Solarized dark
!!

!Ckw<span class="variable">*foreground</span>:     <span class="comment">#657b83</span>
Ckw<span class="variable">*background</span>:     <span class="comment">#073642</span>
!Ckw<span class="variable">*cursorColor</span>:    <span class="comment">#657b83</span>
Ckw<span class="variable">*cursorImeColor</span>: <span class="comment">#dc322f</span>
!Ckw<span class="variable">*backgroundBitmap</span>: background.bmp
!Ckw<span class="variable">*transp</span>:           <span class="number">220</span>
!Ckw<span class="variable">*transpColor</span>:      <span class="comment">#000000</span>

Ckw<span class="variable">*color1</span>:  <span class="comment">#586e75</span>
Ckw<span class="variable">*color2</span>:  <span class="comment">#859900</span>
Ckw<span class="variable">*color3</span>:  <span class="comment">#2aa198</span>
Ckw<span class="variable">*color4</span>:  <span class="comment">#cb4b16</span>
Ckw<span class="variable">*color5</span>:  <span class="comment">#6c71c4</span>
Ckw<span class="variable">*color6</span>:  <span class="comment">#859900</span>

Ckw<span class="variable">*color8</span>:  <span class="comment">#839496</span>
Ckw<span class="variable">*color9</span>:  <span class="comment">#268bd2</span>
Ckw<span class="variable">*color10</span>: <span class="comment">#859900</span>
Ckw<span class="variable">*color11</span>: <span class="comment">#2aa198</span>
Ckw<span class="variable">*color12</span>: <span class="comment">#dc322f</span>
Ckw<span class="variable">*color13</span>: <span class="comment">#d33682</span>
Ckw<span class="variable">*color14</span>: <span class="comment">#b58900</span>
Ckw<span class="variable">*color15</span>: <span class="comment">#fdf6e3</span>
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ 프로 Git 한글책 출간 ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/progit-ko-book-published.html" />
    <updated>2013-05-20T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/progit-ko-book-published.html</id>
    <content type="html">
<![CDATA[
<p>Pro Git 한글 번역이 <a href="http://www.insightbook.co.kr/">인사이트</a>의 도움을 받아 종이책으로 <a href="http://www.insightbook.co.kr/post/5633">프로 Git</a> 으로 출간되었습니다. 학생분들은 도서관에 직장인은 도서구매부에 얼른얼른 구매 신청해주세요! ㅎㅎ</p>

<p><img src="http://dogfeet.github.io/articles/2013/progit-ko-book-published/progit.jpg" alt=""/> <img src="/articles/2013/progit-ko-book-published/devops.png" alt=""/></p>

<h2>프로 Git 출간 이야기</h2>

<p>이미 Pro Git의 한글 번역 전문이 이 블로그 및 github을 통해 오픈소스로 공개되어 있지만, 인사이트 출판사의 도움으로 종이책으로 출간되었습니다. 종이책으로 나올 수 있었던 뒷 이야기는 인사이트 블로그의 <a href="http://www.insightbook.co.kr/post/5633"><프로 Git>, 이미 공개된 내용을 왜 책으로 만들었냐고요?</a> 글을 통해 살펴보실 수 있습니다.</p>

<p>종이책으로 출간된 책의 기본 내용은 동일하지만 몇 번의 교정 과정을 더 거쳤고 이미지도 업데이트 되었으며 부록으로 미처 다루지 못한 몇 가지 내용을 더 담아두었습니다.</p>

<p>주요 오프라인이나 온라인 서점을 통해 구입하실 수 있구요 출간된 것은 4월 중순인데 이렇게 글로 소식을 올리는 것이 늦어졌습니다. <sup>^</sup></p>

<h2>또 다른 번역서, 데브옵스 출간 소식</h2>

<p>또 하나, &lsquo;프로 Git'에 이어 저희 팀원분이 번역한 <a href="http://www.wikibook.co.kr/wiki/Wiki.jsp?page=DevOps">데브옵스</a>도 5월 말에 출간됩니다. 데브옵스에 대한 다양한 문제 상황과 해결법을 다루고 있어 관심있는 분께는 많은 도움이 되리라 생각합니다. 현재 예약판매 중이며 곧 온라인과 오프라인 서점에서 구입하실 수 있습니다.</p>
]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ git: password caching ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/git-password-caching.html" />
    <updated>2013-03-27T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/git-password-caching.html</id>
    <content type="html">
<![CDATA[
<p>요즘은 뭐든 Smart한 시대인지라 http(s) 프로토콜도 Smart하지 않을 수 없다(<a href="http://git-scm.com/2010/03/04/smart-http.html">Smart http</a>). <a href="http://git-scm.com/book/ko">Pro Git</a>에서는 http(s)가 Smart하지 않다고 설명하지만 그건 <a href="http://git-scm.com/book/ko">Pro Git</a>이 출간되고 나서 만들어진 거라 책에는 내용이 빠져 있다. 이제는 ssh를 사용하든 http(s)를 사용하든 효율의 차이는 없다.</p>

<p>ssh는 회사 방화벽에서 막아버릴 수도 있고 익명접근도 허용하지 않지만, http(s)는 그런 게 없다. GitHub도 이제는 ssh가 아닌 http(s)가 기본이다(https 주소를 먼저 보여준다):</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-password-caching/http-ssh.png" alt=""/></p>

<p>그런데 ssh는 인증서를 사용하면 ssh-agent를 사용하면 암호를 한 번만 입력할 수 있는데, http(s)에서는 Basic 인증을 통해서 인증하는지라 다른 메커니즘이 필요하다. 이 글은 GitHub help 페이지에 있는 Password Caching을 요약한 글이다.</p>

<h2>Password Caching.</h2>

<p><em>Git버전이 1.7.10 이상 돼야 한다. 그래야 이 기능을 사용할 수 있다.</em></p>

<p>나는 주로 ssh를 사용하므로 http(s)를 잘 사용하지 않는다. ssh에 익숙해져서 http(s)가 더 어색하다. 하지만, gist에서는 http(s)를 사용하는 것이 편하다. GitHub이 Gist에서는 git 프로토콜 주소를 안내하지 않고 있다:</p>

<p><img src="/articles/2013/git-password-caching/gist-clone.png" alt=""/></p>

<p>화면의 주소는 다음과 같은 형태다:</p>
<pre><code><span class="label">https:</span>//gist<span class="preprocessor">.github</span><span class="preprocessor">.com</span>/xxxxxxxxxxxxxxxxxxxx<span class="preprocessor">.git</span>
</code></pre>
<p>ssh 프로토콜로도 사용할 수 있긴 하다. 단지 복사해서 붙여 넣을 수 없을 뿐이다:</p>
<pre><code>git@gist<span class="variable">.github</span><span class="variable">.com</span>:xxxxxxxxxxxxxxxxxxxx<span class="variable">.git</span>
</code></pre>
<p>gist는 git을 이용하지만 전문 버전관리 도구가 아니라 프로토타이핑 도구라서 http(s) 프로토콜만으로도 충분할 수 있다. 그래도 명령을 실행할 때마다 암호를 입력하는 일은 좀 불편하다. http(s)에도 ssh처럼 사용할 수 있는 매우 편리한 방법이 있다.</p>

<h3>Linux</h3>

<p>다음과 같이 설정하면 한번 입력한 암호가 저장된다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">credential</span>.<span class="comment">helper</span> <span class="comment">cache</span>
</code></pre>
<p>기본적으로 15분 저장해주는데 다음과 같이 기간을 수정할 수 있다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">credential</span>.<span class="comment">helper</span> <span class="comment">'cache</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">timeout=3600'</span>
</code></pre>
<p>&lsquo;ssh-agent'로 하는 것과 거의 비슷하다.</p>

<h3>Mac</h3>

<p>Mac에서는 'osxkeychain credential helper'라는 게 있어서 ssh처럼 keychain을 사용할 수 있다.</p>

<p>먼저 osxkeychain이 잘 동작하는지 확인하고:</p>
<pre><code>% git credential-osxkeychain
Usage: git credential-osxkeychain <span class="tag">&lt;<span class="title">get|store|erase</span>&gt;</span>
</code></pre>
<p>설치돼 있지 않으면 아래와 같이 설치한다:</p>
<pre><code>% git credential-osxkeychain
git: <span class="string">'credential-osxkeychain'</span> <span class="keyword">is</span> <span class="keyword">not</span> a git command. See <span class="string">'git --help'</span>.

% curl -s -O http:<span class="regexp">//gi</span>thub-media-downloads.s3.amazonaws.com<span class="regexp">/osx/gi</span>t-credential-osxkeychain
% chmod u+x git-credential-osxkeychain
% sudo mv git-credential-osxkeychain `<span class="javascript">dirname \</span>`which git\`<span class="javascript"></span>`
</code></pre>
<p>'credential helper'로 osxkeychain을 사용할 것이라고 알린다.:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">credential</span>.<span class="comment">helper</span> <span class="comment">osxkeychain</span>
</code></pre>
<p>이제 ssh를 사용할 때는 ssh 인증서가 사용되고 http(s)를 사용할 때는 'osxkeychain credential helper'가 사용된다.</p>

<p>이렇게 설정하면 CLI뿐만 아니라 <a href="http://www.sourcetreeapp.com/">SourceTree</a>같은 GUI에서도 매번 암호를 입력하지 않을 수 있다.</p>

<h3>Windows</h3>

<p><a href="http://blob.andrewnurse.net/gitcredentialwinstore/git-credential-winstore.exe">git-credential-winstore</a>를 내려받아서 실행경로에 넣고 한번 실행해준다. 그러면 msysgit 에서 잘 사용할 수 있다. 'GitHub for Windows'에는 이미 포함돼 있어서 별도로 설치할 필요가 없다.</p>

<p>Windows XP에서는 SourceTree를 설치할 수 없어서 확인하지 못했다.</p>
]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ mac: java-web-start ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/mac-java-web-start.html" />
    <updated>2013-03-07T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/mac-java-web-start.html</id>
    <content type="html">
<![CDATA[
<p>언제부터 안되더라? 왜 안되더라? 그런건 잘 모르겠고 Mac에서는 Java Web Start가 그냥 실행되지 않는다. Apple이 막은 건데, Oracle이 미운 이유는 뭘까! 아무튼 다시 켜는 방법이 있다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/mac-java-web-start/mung-me.jpg" alt=""/></p>

<h2>Java web start</h2>

<p>윈도에서 처럼 매끄럽게 브라우저 안에서 Java App이 실행되지 않더라도 jnlp 파일을 다운로드 받아서 javaws 명령으로 실행시키면 실행해야 하는데 다음과 같은 에러를 내뱉는다:</p>
<pre><code>% javaws my.jnlp
Java Web Start splash screen process exiting <span class="keyword">...</span>
Can not find message file: No such file or directory
</code></pre>
<p>Google님께 물어보면 Java7을 설치하라는 얘기가 많다. 그래서 설치하고 이것 저것 해봤는데도 됐다가 안됐다가 했다. 자세한 히스토리는 알고 싶지 않았고 그냥 실행만 됐으면 했는데, 그래도 그냥 Java7을 설치했었다. Oracle Java7을 설치하라고 하니 왠지 내 Mac을 욕보이는 것 같았지만 그냥 설치했다.</p>

<p>어짜피 안돼서 Java7을 삭제했는데 Mac이 먹통ㅜㅜ. Mac까지 다시 설치해야 하나 싶었는데 이유는 모르겠지만 복구 됐다(야호!). 욕하고 싶은 상대가 Apple이 아닌 Oracle인건 왜일까!</p>

<p>아래와 같이 파일을 열고:</p>
<pre><code>% sudo vi /System/Library/CoreServices/CoreTypes<span class="variable">.bundle</span>/Contents/Resources/XProtect<span class="variable">.meta</span><span class="variable">.plist</span>
</code></pre>
<p>주석처리를 좀 하고:</p>
<pre><code class="lang-xml"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">plist</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span>
<span class="tag">&lt;<span class="title">dict</span>&gt;</span>
<span class="comment">&lt;!--
  &lt;key&gt;JavaWebComponentVersionMinimum&lt;/key&gt;
  &lt;string&gt;1.6.0_41-b02-446&lt;/string&gt;
--&gt;</span>
  <span class="tag">&lt;<span class="title">key</span>&gt;</span>LastModification<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
  <span class="tag">&lt;<span class="title">string</span>&gt;</span>Mon, 04 Mar 2013 21:47:02 GMT<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
  <span class="tag">&lt;<span class="title">key</span>&gt;</span>PlugInBlacklist<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
  <span class="tag">&lt;<span class="title">dict</span>&gt;</span>
    <span class="tag">&lt;<span class="title">key</span>&gt;</span>10<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dict</span>&gt;</span>
      <span class="tag">&lt;<span class="title">key</span>&gt;</span>com.macromedia.Flash Player.plugin<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
      <span class="tag">&lt;<span class="title">dict</span>&gt;</span>
        <span class="tag">&lt;<span class="title">key</span>&gt;</span>MinimumPlugInBundleVersion<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
        <span class="tag">&lt;<span class="title">string</span>&gt;</span>11.6.602.171<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
<span class="comment">&lt;!--
      &lt;key&gt;com.oracle.java.JavaAppletPlugin&lt;/key&gt;
      &lt;dict&gt;
        &lt;key&gt;MinimumPlugInBundleVersion&lt;/key&gt;
        &lt;string&gt;1.7.15.04&lt;/string&gt;
      &lt;/dict&gt;
--&gt;</span>
    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
  <span class="tag">&lt;<span class="title">key</span>&gt;</span>Version<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
  <span class="tag">&lt;<span class="title">integer</span>&gt;</span>2033<span class="tag">&lt;/<span class="title">integer</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
<span class="tag">&lt;/<span class="title">plist</span>&gt;</span>
</code></pre>
<p>리부팅한다. 그리고 아래와 같이 실행한다:</p>
<pre><code>% javaws <span class="filename">my.jnlp
</code></pre>
<p>Apple이 Flash와 Java Applet을 BlackList로까지 분류하고 있는 줄은 몰랐다.</p>

<p>그리고 Mac update를 하면 다시 Disable된다. Disable되면 jre가 설치돼 있는데도 불구하고 javaws를 실행했을 때 아래와 같은 에러를 뱉는다:</p>
<pre><code>% javaws <span class="keyword">my</span>.jnlp
No Java runtime present, requesting install.
Unable <span class="keyword">to</span> locate a Java Runtime <span class="keyword">to</span> invoke.
</code></pre>
<p>아래와 같이 실행하면 다시 javaws를 사용할 수 있다:</p>
<pre><code>su<span class="operator"><span class="keyword">do</span> ln -sf /System/Library/Frameworks/JavaVM.framework/Commands/javaws /usr/bin/javaws
</code></pre>
<p>수동으로 다시 disable하고 싶으면 아래와 같이 실행한다:</p>
<pre><code>% su<span class="operator"><span class="keyword">do</span> ln -sf /System/Library/Frameworks/JavaVM.framework/Versions/<span class="keyword">Current</span>/Commands/javaws /usr/bin/javaws
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ grunt: node-coffee 템플릿 ]]></title>
    <link href="http://dogfeet.github.io/articles/2013/grunt-init-node-coffee.html" />
    <updated>2013-02-20T15:00:00.000Z</updated>
    <id>http://dogfeet.github.io/articles/2013/grunt-init-node-coffee.html</id>
    <content type="html">
<![CDATA[
<p><a href="https://twitter.com/Outsideris">@Outsideris</a>님의 <a href="http://blog.outsider.ne.kr/892">자바스크립트 빌드 도구 Grunt</a>와 <a href="http://blog.outsider.ne.kr/894">Grunt에 사용자 템플릿 추가하기</a>를 읽고 <a href="https://github.com/pismute/grunt-init-node-coffee">node-coffee</a> 템플릿을 만들었다. <a href="https://twitter.com/docpad">@docpad</a> 덕에 coffeescript에 익숙해졌고 항상 Compile해서 실행하기만 하면 디버그도 할 수 있기 때문에 node를 사용할 때는 coffee를 사용하려고 하는 편이다. 그동안 make를 사용해서 좀 불편했었는데, grunt를 적용하니 정말 편하다. 좀 더 편하려고 Coffeescript에 Mocha를 기본으로 하는 템플릿을 하나 만들었다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/grunt-init-node-coffee/gruntjs.png" alt=""/></p>

<h2>grunt 0.4</h2>

<p>갑자기 0.4 버전이 배포되는 바람에 <a href="https://twitter.com/Outsideris">@Outsideris</a>님의 글이 내용이 틀리게 됐다. 하지만 정리가 잘돼 있어서 grunt를 이해하기에는 여전히 좋은 글이다.</p>

<p><a href="https://twitter.com/Outsideris">@Outsideris</a>님의 글을 읽고 0.3 버전용 <a href="https://github.com/pismute/grunt-init-node-coffee">node-coffee</a>를 만들었다가 나중에 글을 써야지 하고 있었는데, 0.4가 나와 버렸다. <a href="http://gruntjs.com/upgrading-from-0.3-to-0.4">upgrading-from-0.3-to-0.4</a>을 잘 읽고 적용하는 게 좋다. 나는 길어서 대충 읽었다가 삽질을 좀 했다. 다 읽기 귀찮으면 새 템플릿으로 만든 코드를 좀 읽어보고 시작하는 것이 시간을 절약해줄 것 같다.</p>

<h2>node-coffee 템플릿</h2>

<p>이 템플릿은 특징을 요약하면 아래와 같다:</p>

<ul>
<li>Coffeescript

<ul>
<li>Gruntfile.coffee</li>
<li><code>/src/lib/**/*.coffee</code>를 <code>/out/lib/**/*.js</code>로 컴파일</li>
<li><code>/src/test/**/*.coffee</code>를 <code>/out/test/**/*.js</code>로 컴파일</li>
<li>coffeelint</li>
</ul></li>
<li>Javascript

<ul>
<li><code>/src/lib/**/*.js</code>를 <code>/out/lib/**/*.js</code>로 복사</li>
<li><code>/src/test/**/*.js</code>를 <code>/out/test/**/*.js</code>로 복사</li>
<li>jshint 그대로 포함</li>
</ul></li>
<li>Mocha + Should로 변경</li>
</ul>

<p>그 외는 <a href="https://github.com/gruntjs/grunt-init-node">node</a> 템플릿을 수정한 것이기 때문에 node 템플릿과 같다.</p>

<h3>사용법</h3>

<p>다음과 같이 설치한다:</p>
<pre><code>git clone git@github<span class="variable">.com</span>:pismute/grunt-init-node-coffee<span class="variable">.git</span> ~/<span class="variable">.grunt</span>-init/node-coffee
</code></pre>
<p><a href="https://github.com/gruntjs/grunt-init">grunt-init</a>이 설치된 상태에서 다음과 같이 프로젝트를 만든다:</p>
<pre><code><span class="title">mkdir</span> my-project
<span class="title">cd</span> my-project
<span class="title">grunt</span>-init node-coffee
</code></pre>]]>
    </content>
  </entry>
</feed>
