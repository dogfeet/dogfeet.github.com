<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-05-14T20:30:06Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ nodejs: modules ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-modules.html" />
    <updated>2012-05-12T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-modules.html</id>
    <content type="html">
<![CDATA[
<p>읽고, 또 읽고, 또 읽어도 자꾸 까먹는다. 그래서 이번에는 번역을 해보기로 했다. 이 글은 nodejs의 <a href="http://nodejs.org/api/modules.html">modules</a>을 번역한 거다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-modules/hat-girl.jpg" alt="hat-girl" title="" /></p>

<p>('<a href="http://uniquenoun.tumblr.com/post/21839174721">모자라는 아이</a>' - Jiye Park, 2012)</p>

<p>이 글의 원문의 SHA값은 <code>1d5b6f2</code>이다. 나중에 버전이 바뀌었을 때 추적하기 위해 남긴다. 헷갈릴 수도 있으니, 번역하기 시작한 시점의 nodejs 안정 버전은 <code>v0.6.14</code>이다.</p>

<h2>Modules</h2>

<!--
    Stability: 5 - Locked
-->

<!--name=module-->

<p>매우 간단하게 모듈을 로딩할 수 있다. 노드에서는 파일 하나가 모듈 하나다. 예를 들어 <code>foo.js</code> 파일에서 같은 디렉토리에 있는 <code>circle.js</code>를 로드하는 것을 살펴보자.</p>

<p><code>foo.js</code>:</p>

<pre><code>var circle = require('./circle.js');
console.log( 'The area of a circle of radius 4 is '
           + circle.area(4));
</code></pre>

<p><code>circle.js</code>:</p>

<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre>

<p><code>circle.js</code> 모듈은 <code>area()</code>와 <code>circumference()</code>를 Export했다. 뭔가 Export하려면 해당 객체를 <code>exports</code> 객체에 할당한다. <code>exports</code>는 Export하기 위해 사용하는 객체다.</p>

<p>로컬 변수는 모듈 외부에 노출되지 않는다(private). 이 예제에서 <code>PI</code>는 <code>circle.js</code>에서만 사용할 수 있는 private 변수다.</p>

<p>이 모듈 시스템은 <code>module</code>이라는 모듈에 구현했다.</p>

<h3>Cycles</h3>

<!--type=misc-->

<p>두 모듈이 <code>require()</code> 함수로 서로 참조할 때는 한쪽 모듈은 아직 완전히 로딩하지 못한 미완성 모듈을 그냥 반환한다.</p>

<p>이게 무슨 소리냐 하면:</p>

<p><code>a.js</code>:</p>

<pre><code>console.log('a starting');
exports.done = false;
var b = require('./b.js');
console.log('in a, b.done = %j', b.done);
exports.done = true;
console.log('a done');
</code></pre>

<p><code>b.js</code>:</p>

<pre><code>console.log('b starting');
exports.done = false;
var a = require('./a.js');
console.log('in b, a.done = %j', a.done);
exports.done = true;
console.log('b done');
</code></pre>

<p><code>main.js</code>:</p>

<pre><code>console.log('main starting');
var a = require('./a.js');
var b = require('./b.js');
console.log('in main, a.done=%j, b.done=%j', a.done, b.done);
</code></pre>

<p><code>main.js</code>는 <code>a.js</code>를 로드하고, <code>a.js</code>는 <code>b.js</code>를 로드한다. 여기서 <code>b.js</code>는 다시 <code>a.js</code>를 로드하려고 한다. 무한 루프가 생기지 않도록 아직 미완성인 <code>a.js</code>의 exports 객체를 <code>b.js</code>에 반환해 버린다. 그리고 <code>b.js</code>가 완성되면 <code>a.js</code>에 반환된다.</p>

<p><code>main.js</code>이 두 모듈을 로드할 때는 이미 둘 다 완성됐다. 이 프로그램의 실행 결과는 다음과 같다:</p>

<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre>

<p>그러니까 꼭 모듈을 서로 참조하게 하여야 하면 계획을 잘 짜야 한다.</p>

<h3>Core Modules</h3>

<!--type=misc-->

<p>Node 모듈 중에서는 바이너리로 컴파일해야 하는 모듈이 있다. 코어 모듈은 이 문서 곳곳에서 설명한다.</p>

<p>코어 모듈은 Node 소스코드의 <code>lib/</code> 폴더에 들어 있다.</p>

<p>모듈을 require하면 항상 코어 모듈이 먼저 로드된다. 예를 들어, <code>require('http')</code>로 로드될 것 같은 파일이 있어도 Node에 들어 있는 HTTP 모듈이 반환된다.</p>

<h3>File Modules</h3>

<!--type=misc-->

<p>입력한 이름으로 파일을 못 찾으면 Node는 그 이름에 <code>.js</code>, <code>.json</code>, <code>.node</code>를 붙이고 해당 파일이 있는지 찾는다.</p>

<p><code>.js</code> 파일은 JavaScript 텍스트 파일로 Interpret하고 <code>.json</code>은 JSON 텍스트 파일로 Interpret한다. 그리고 <code>.node</code> 파일은 컴파일한 addon 모듈이라서 <code>dlopen</code>으로 로드한다.</p>

<p>모듈을 절대 경로로 찾을 때는 모듈 이름을 <code>'/'</code>로 시작하면 된다. 예를 들어, <code>require('home/marco/foo.js')</code>는 <code>/home/marco/foo.js</code> 파일을 로드한다.</p>

<p>모듈을 상대 경로로 찾으려면 모듈 이름이 <code>'./'</code>로 시작하면 된다. 즉, <code>foo.js</code>라는 파일에서 <code>require('./circle')</code>라고 호출하면 같은 디렉토리에 있는 <code>circle.js</code>를 로드한다.</p>

<p>'/'이나 './'로 시작하지 않으면 그냥 파일이 아니라 코어 모듈이나 <code>node_modules</code> 폴더에 있는 모듈을 찾는다.</p>

<p>모듈을 찾지 못하면 <code>require()</code>는 Error를 던진다. 이 에러의 code 프로퍼티의 값은 <code>'MODULE_NOT_FOUND'</code>이다.<br />(역주 - 어떻게 확인해봐야 할지 모르겠다. 아무튼, <a href="http://git.io/dmzSGw">참고1</a>, <a href="http://git.io/haOtcQ">참고2</a> )</p>

<h3>Loading from <code>node_modules</code> Folders</h3>

<!--type=misc-->

<p><code>require()</code>에 넘어온 모듈 ID가 네이티브 모듈을 가리키는 것도 아니고, 그 모듈 ID가 <code>'/'</code>, <code>'./'</code>, <code>'../'</code>로 시작하지도 않으면 Node는 그 모듈의 상위 디렉토리에서 찾기 시작한다. 상위 디렉토리에 있는 <code>/node_modules</code>에서 해당 모듈을 찾는다.</p>

<p>만약 못 찾으면 상위상위 디렉토리에서 찾고, 그래도 못 찾으면 상위상위상위 디렉토리에서 찾는다. 루트 디렉토리에 다다를 때까지 계속 찾는다.</p>

<p>예를 들어, <code>'home/ry/projects/foo.js'</code>라는 파일에서 <code>requre('bar.js')</code>라고 호출하면 다음과 같은 순서로 모듈을 찾는다:</p>

<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>

<p>그래서 해당 프로그램만의 의존성을 독립적으로 관리할 수 있다. 다른 프로그램에 영향을 끼치지 않는다.</p>

<h3>Folders as Modules</h3>

<!--type=misc-->

<p>모듈을 폴더로 관리하면 프로그램과 라이브러리를 묶음으로 관리할 수 있어 편리하다. 마치 한 파일로 된 모듈처럼 취급한다. 모듈이 폴더일 때 <code>require()</code>는 세 가지 방법으로 모듈을 찾는다.</p>

<p>프로그램 폴더에 <code>package.json</code> 파일을 만들고 main 모듈이 무엇인지 적는다:</p>

<pre><code>{ "name" : "some-library",
  "main" : "./lib/some-library.js" }
</code></pre>

<p>이 파일이 <code>./some-library</code>라는 폴더에 있다고 하고, <code>require('./some-library')</code>를 호출하면 <code>./some-library/lib/some-library.js</code>를 찾아 로드한다.</p>

<p>Node가 package.json을 읽고 사용하기 때문에 이런 게 가능하다.</p>

<p>그 디렉토리에 package.json 파일이 없으면 Node는 <code>index.js</code>나 <code>index.node</code> 파일을 찾는다. package.json 파일이 없으면 <code>require('./some-library')</code>는 다음과 같은 파일을 로드한다:</p>

<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>

<h3>Caching</h3>

<!--type=misc-->

<p>한 번 로드한 모듈은 계속 캐싱한다. 그래서 <code>require('foo')</code>을 여러 번 호출해도 계속 같은 객체를 반환한다. 단, `require('foo')가 계속 같은 파일을 로드할 때만 그렇다.</p>

<p><code>require('foo')</code>를 여러 번 호출해도 해당 모듈 코드는 단 한 번만 호출된다. 그리고 아직 미완성인 객체가 반환될 수 있다는 점까지 더하면 특정 모듈이 서로 의존하고 있어도 성공적으로 로드되는 마법이 이루어진다.</p>

<p>어떤 코드가 꼭 여러 번 호출돼야 하면 함수 자체를 Export하고 그 함수를 여러 번 호출하라.</p>

<h4>Module Caching Caveats</h4>

<!--type=misc-->

<p>모듈은 찾은(resolved) 파일 이름을 키로 캐싱한다. <code>node_modules</code> 폴더에서 로딩하는 것이기 때문에 같은 require 코드라도 호출하는 위치에 따라 찾은 파일이 다를 수 있다. 즉, <code>require('foo')</code>가 다른 파일을 찾아낸다면 다른 객체를 리턴한다.</p>

<h3>The <code>module</code> Object</h3>

<!-- type=var -->

<!-- name=module -->

<ul>
<li>{Object}</li>
</ul>

<p>모듈에서 <code>module</code> 변수는 해당 모듈 객체를 가리킨다. 특히 <code>module.exports</code>는 <code>exports</code>와 같은 객체를 가리킨다. <code>module</code>은 글로벌 변수가 아니라 모듈마다 다른 객체를 가리키는 로컬 변수다.</p>

<h4>module.exports</h4>

<ul>
<li>{Object}</li>
</ul>

<p><code>exports</code> 객체는 Module 시스템이 자동으로 만들어 준다. Export하려는 객체를 <code>module.exports</code>에 할당해서 직접 만든 객체가 반환되게 할 수도 있다. <code>.js</code>라는 모듈을 만들어 보자:</p>

<pre><code>var EventEmitter = require('events').EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the 'ready' event from the module itself.
setTimeout(function() {
  module.exports.emit('ready');
}, 1000);
</code></pre>

<p>이 모듈은 다음과 같이 사용한다:</p>

<pre><code>var a = require('./a');
a.on('ready', function() {
  console.log('module a is ready');
});
</code></pre>

<p><code>module.exports</code>에 할당하는 것은 바로 실행되도록 해야 한다. 콜백으로 할당문이 실행되는 것을 미루면 뜻대로 동작하지 않는다. 다음과 같이 하지 마라:</p>

<p>x.js:</p>

<pre><code>setTimeout(function() {
  module.exports = { a: "hello" };
}, 0);
</code></pre>

<p>y.js:</p>

<pre><code>var x = require('./x');
console.log(x.a);
</code></pre>

<h4>module.require(id)</h4>

<ul>
<li><code>id</code> {String}</li>
<li>Return: {Object} <code>exports</code> from the resolved module</li>
</ul>

<p><code>module.require</code> 메소드로 모듈을 로드하면 해당 모듈에서 require()를 호출하는 것처럼 모듈을 로드한다.</p>

<p>이 메소드를 호출하려면 일단 <code>module</code> 객체의 레퍼런스를 얻어야 한다. <code>module</code> 객체의 레퍼런스는 해당 모듈에서만 접근할 수 있고 <code>require()</code>는 <code>module</code>이 아니라 <code>exports</code>를 리턴하기 때문에 해당 모듈에서 module 객체의 레퍼런스를 직접 리턴해야 한다.</p>

<h4>module.id</h4>

<ul>
<li>{String}</li>
</ul>

<p>모듈 ID인데 보통은 모듈 파일의 전체 경로를 사용한다.</p>

<h4>module.filename</h4>

<ul>
<li>{String}</li>
</ul>

<p>모듈 파일의 전체 경로(fully resolved filename).</p>

<h4>module.loaded</h4>

<ul>
<li>{Boolean}</li>
</ul>

<p>모듈이 로드하고 있는 중인지 다 로드했는지를 나타낸다.</p>

<h4>module.parent</h4>

<ul>
<li>{Module Object}</li>
</ul>

<p>모듈을 require한 모듈을 가리킨다.</p>

<h4>module.children</h4>

<ul>
<li>{Array}</li>
</ul>

<p>모듈이 require한 모듈 객체를 가리킨다.</p>

<h3>All Together...</h3>

<!-- type=misc -->

<p><code>require()</code>로 모듈을 찾을 때 정확한 파일 경로가 궁금하면 <code>require.resolve()</code> 함수로 얻어온다.</p>

<p>require.resolve가 정확히 어떻게 동작하는지 슈도 코드로 살펴보자. 이 슈도 코드는 여태까지 설명한 것을 모두 합쳐 놓은 것이다:</p>

<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with './' or '/' or '../'
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW "not found"

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for "main" field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of "node_modules" in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = "node_modules" CONTINUE
   c. DIR = path join(PARTS[0 .. I] + "node_modules")
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS
</code></pre>

<h3>Loading from the global folders</h3>

<!-- type=misc -->

<p>Node는 모듈을 못 찾으면 환경변수 <code>NODE_PATH</code>에 등록된 경로에서도 찾는다. 절대경로를 <code>NODE_PATH</code>에 할당하면 되는데 콜론(<code>:</code>)으로 구분해서 절대경로를 여러 개 등록할 수 있다(주의: 윈도우는 세미콜론(<code>;</code>)으로 구분한다).</p>

<p>그리고 Node는 다른 디렉토리에서도 찾는다:</p>

<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>

<p><code>$HOME</code>은 사용자의 홈 디렉토리이고 <code>$PREFIX</code>는 노드가 설치된 디렉토리를 말한다.</p>

<p>왜 그런지 말하자면 길다. 무엇보다 <code>node_modules</code> 폴더를 이용해 모듈을 로컬에 설치하는 것이 좋다. 이 방법이 속도도 더 빠르고 더 안전하다.</p>

<h3>Accessing the main module</h3>

<!-- type=misc -->

<p>node로 어떤 파일을 실행하면 <code>require.main</code>은 그 파일의 <code>module</code> 객체를 가리킨다. 그래서 Node로 파일을 직접 실행한 건지 아닌지 알 수 있다:</p>

<pre><code>require.main === module
</code></pre>

<p><code>foo.js</code>라는 파일에 이런 게 들어 있다고 하자. 이 구문의 결과는 <code>node foo.js</code>로 실행하면 <code>true</code>이고 <code>require('./foo')</code>로 실행하면 <code>false</code>가 된다.</p>

<p><code>module</code>에는 <code>filename</code> 프로퍼티가 있어서(<code>__filename</code>과 같은 값이다) <code>require.main.filename</code>의 값을 확인하면 처음 실행한 파일을 무엇인지 알 수 있다.</p>

<h3>Addenda: Package Manager Tips</h3>

<!-- type=misc -->

<p><code>require()</code> 함수는 웬만한 디렉토리면 어디에서나 사용할 수 있다. <code>dpkg</code>, <code>rpm</code> 같은 패키지 매니저처럼 <code>npm</code>도 네이티브 Node 패키지를 아무런 수정 없이 빌드하게 할 수 있다.</p>

<p>모듈은 <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>에 설치하는 것을 권장한다. 어떤 패키지의 어떤 버전이 설치됐는지 한 눈에 알 수 있어 좋다.</p>

<p>패키지는 다른 패키지에 의존할 수도 있다. 예를 들어 <code>foo</code> 패키지를 설치하려면 <code>bar</code> 패키지도 설치해야 한다. 그것도 특정 버전의 <code>bar</code> 패키지가 설치돼야 한다. 그리고 <code>bar</code> 패키지도 다른 패키지에 의존할 수 있는데 충돌이 있거나 서로(cycle) 의존할 수도 있다.</p>

<p>Node는 로드할 모듈을 찾을 때 <code>node_modules</code> 폴더에서 필요한 모듈을 찾는다. 그중에 심볼릭 링크가 있으면 그 링크가 가리키는 모듈도 잘 찾는다. 다음과 같이 모듈을 찾는 매커니즘은 매우 간단하다:</p>

<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - 버전이  1.2.3인 <code>foo</code> 패키지</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - <code>foo</code>가 의존하는 <code>bar</code> 패키지</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - <code>/usr/lib/node/bar/4.3.2/</code>에 대한 심볼릭 링크</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - <code>bar</code>가 의존하는 패키지에 대한 심볼릭 링크</li>
</ul>

<p>그리고 상호 참조나 의존성 충돌이 있어도 모듈을 사용할 수만 있으면 잘 로드한다.</p>

<p><code>foo</code> 패키지에서 <code>require('bar')</code>라고 하면 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>가 가리키는 모듈을 가져온다. 또 그 <code>bar</code> 패키지에서 <code>require('quux')</code>라고 호출하면 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>가 가리키는 모듈을 가져온다.</p>

<p>최적화된 방법으로 모듈을 찾는 방법이 있는데 <code>/usr/lib/node</code> 디렉토리가 아니라 <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>에 모듈을 넣는다. 그러면 Node는 <code>/usr/node_modules</code>이나 <code>/node_modules</code>에서는 모듈을 찾지 않는다.</p>

<p><code>/usr/lib/node_modules</code> 폴더를 환경 변수 <code>$NODE_PATH</code>에 넣으면 Node REPL에서도 모듈을 사용할 수 있다. <code>require()</code>를 호출한 파일이 있는 곳에서부터 상대경로로 <code>node_modules</code> 폴더에 있는 모듈을 찾기 때문에 패키지는 그 <code>node_modules</code> 폴더 중 한 곳에 넣으면 된다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: npm config ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-npm-config.html" />
    <updated>2012-05-04T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-npm-config.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="http://npmjs.org/doc/config.html">npm config</a>를 정리한 글이다. npm이 설정을 관리하는 부분은 꽤 재미있다. npm 설정을 바꿀 일은 아직 없어서 몰랐는데 꽤 꼼꼼하게 설계했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/npm/npm-config.png" alt="npm-config" title="" /></p>

<h2>config</h2>

<p>npm은 설정하는 방법이 여섯 가지나 있고 우선순위는 다음과 같다:</p>

<ul>
<li>Command Line Flags</li>
<li>Environment Variables</li>
<li>Per-user config file</li>
<li>Global config file</li>
<li>Built-in config file</li>
<li>Default Configs</li>
</ul>

<h3>Command Line Flags</h3>

<p>CLI에서 <code>--foo bar</code>라고 사용하면 <code>foo</code>라는 변수에 값이 <code>"bar"</code>라고 설정된다. 그리고 <code>--</code>는 CLI 파서에게 flag 처리는 인제 그만 한다고 말하는 것이다. <code>--flag</code>처럼 단독으로 사용하는 파라미터는 명령어 끝에 사용하고 <code>true</code> 값이 할당된다.</p>

<h3>Environment Variables</h3>

<p><code>npm_config_</code>로 시작하는 환경변수도 npm 설정으로 사용된다. 예를 들어, <code>npm_config_foo=bar</code>라는 환경변수를 정의하면 npm에서 <code>foo</code> 설정의 값을 <code>bar</code>라고 설정하는 것과 같다. 환경변수에 값이 없으면 npm은 해당 설정의 값을 <code>true</code>라고 해석한다. 대소문자를 구분하지 않기 때문에 <code>NPM_CONFIG_FOO=bar</code>와 <code>npm_config_foo=bar</code>는 같다.</p>

<h3>Per-user config file</h3>

<p><code>$HOME/.npmrc</code>(파일의 위치는 <code>userconfig</code> 파라미터로 바꿀 수 있으며 위 방법(CLI 파라미터, 환경변수)으로 설정할 수 있다.)</p>

<p>이 파일은 ini 형식이라서 <code>key = value</code>라고 설정한다.</p>

<h3>Global config file</h3>

<p><code>$PREFIX/etc/npmrc</code>(파일의 위치는 <code>globalconfig</code> 파라미터로 바꿀 수 있고 위 방법(CLI 파라미터, 환경변수, userconfig)으로 설정한다.)</p>

<p>이 파일도 ini 형식이다.</p>

<h3>Built-in config file</h3>

<p><code>path/to/npm/itself/npmrc</code></p>

<p>이 파일은 "빌트인"이라 수정할 수 없다. npm 스크립트에 들어 있는 <code>./configure</code> 스크립트로 값을 설정할 수 있다. 이 파일은 기본 값을 변경해야 하는 배포 관리자를 위한 것이고 표준과 일관성을 지키며 수정해야 한다.</p>

<p>그러니까 회사에서 회사에 맞는 설정(회사의 registry를 기본 registry로 한다든가 하는)을 직원에게 배포할 때 이 설정을 바꾼 npm을 만들어서 배포하면 되겠다.</p>

<h3>Default Configs</h3>

<p>npm 내부에 박혀있는 것으로 파라미터가 어디에도 설정되지 않으면 사용하는 기본값이다. 이것은 그냥 하드코딩된 것으로 생각하면 된다.</p>

<h2>명령어</h2>

<p>config 명령어가 있는데 <code>git config</code>랑 비슷하다.</p>

<h3>set</h3>

<pre><code>npm config set key value
</code></pre>

<p>key, value를 설정한다.</p>

<p>value를 생략하면 "true"로 설정된다.</p>

<h3>get</h3>

<pre><code>npm config get key
</code></pre>

<p>stdout에 설정 값을 보여준다.</p>

<h3>list</h3>

<pre><code>npm config list
</code></pre>

<p>npm 설정 목록을 보여준다.</p>

<h3>delete</h3>

<pre><code>npm config delete key
</code></pre>

<p>모든 설정 파일에서 key를 삭제한다.</p>

<h3>edit</h3>

<pre><code>npm config edit
</code></pre>

<p>설정을 편집기에서 수정하도록 편집기를 열어준다. <code>--global</code> flag를 주면 global 설정 파일이 열린다.</p>

<h2>단축 파라미터</h2>

<p>사용할 수 있는 단축 파라미터들:</p>

<ul>
<li><code>-v</code>: <code>--version</code></li>
<li><code>-h</code>, <code>-?</code>, <code>--help</code>, <code>-H</code>: <code>--usage</code></li>
<li><code>-s</code>, <code>--silent</code>: <code>--loglevel silent</code></li>
<li><code>-q</code>, <code>--quiet</code>: <code>--loglevel warn</code></li>
<li><code>-d</code>: <code>--loglevel info</code></li>
<li><code>-dd</code>, <code>--verbose</code>: <code>--loglevel verbose</code></li>
<li><code>-ddd</code>: <code>--loglevel silly</code></li>
<li><code>-g</code>: <code>--global</code></li>
<li><code>-l</code>: <code>--long</code></li>
<li><code>-m</code>: <code>--message</code></li>
<li><code>-p</code>, <code>--porcelain</code>: <code>--parseable</code></li>
<li><code>-reg</code>: <code>--registry</code></li>
<li><code>-v</code>: <code>--version</code></li>
<li><code>-f</code>: <code>--force</code></li>
<li><code>-l</code>: <code>--long</code></li>
<li><code>-desc</code>: <code>--description</code></li>
<li><code>-S</code>: <code>--save</code></li>
<li><code>-y</code>: <code>--yes</code></li>
<li><code>-n</code>: <code>--yes false</code></li>
<li><code>ll</code> and <code>la</code> commands: <code>ls --long</code></li>
</ul>

<p>파라미터를 입력하다 말아도 특정 파라미터로 판단할 수만 있으면(resolve unambiguously) 해당 파라미터로 사용한다:</p>

<pre><code>npm ls --par
# same as:
npm ls --parseable
</code></pre>

<p>단축 파라미터는 여러 개를 붙여 사용해도 된다. 예를 들어:</p>

<pre><code>npm ls -gpld
# same as:
npm ls --global --parseable --long --loglevel info
</code></pre>

<h2>Per-Package Config Settings</h2>

<p>npm script를 사용할 때만 적용되는 설정도 할 수 있다. package.json의 "config" 설정은 "scripts" 설명을 이용할 때 적용된다. 다음과 같으면:</p>

<pre><code>{ "name" : "foo"
, "config" : { "port" : "8080" }
, "scripts" : { "start" : "node server.js" } }
</code></pre>

<p><code>npm start</code>를 실행시킬 때 config 설정이 적용된다. 하지만, 다른 곳에 설정할 수도 있다. <code>&lt;name&gt;[@&lt;version&gt;]:&lt;key&gt;</code>처럼 정의하면 된다. 이 pacakge.json을 사용하는 server.js가 다음과 같으면:</p>

<pre><code>http.createServer(...).listen(process.env.npm_package_config_port)
</code></pre>

<p>다음과 같이 바꿀 수 있다:</p>

<pre><code>npm config set foo:port 80
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ 프로그래머 관점에서의 바둑 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/the-game-of-go_a-programmers-perspective.html" />
    <updated>2012-05-01T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/the-game-of-go_a-programmers-perspective.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 Louis Chatriot이 자신의 블로그에 쓴 <a href="http://needforair.com/blog/2012/04/18/game-of-go/">The Game of Go: A Programmer's Perspective</a>를 번역한 것이다.</p>

<p>AI 프로그래머가 바라 봤을 때 바둑은 매우 흥미로운 게임이다. 컴퓨터가 실력 좋은 바둑 기사를 이기는게 매우 어렵고, 많은 연구자가 이 문제에 도전하기 때문이다. 모순적이게도 랜덤하게 돌을 놓는 것이 컴퓨터에겐 더 좋은 전략이다.</p>

<p><a href="http://www.flickr.com/photos/obli/322662164/" title="COPA EMBAJADOR DE COREA 2006 by oblivionz, on Flickr"><img src="http://farm1.staticflickr.com/134/322662164_0260e91add.jpg" width="250" height="166" alt="COPA EMBAJADOR DE COREA 2006"></a><br />by <a href="http://www.flickr.com/photos/obli/">oblivionz</a></p>

<h2>바둑: 엄청나게 간단한 개요</h2>

<p>바둑은 아시아에선 대중적인 게임이지만 서양에는 많이 알려지지 않았다. 바둑은 체스와 비슷하게 두 명이서 차례를 바꿔가며 바둑판에 돌을 놓는 전략게임이다. 체스와 바둑이 완전 다른 점은 두 개 정도있다.</p>

<ul>
<li>바둑에선 바둑판이 비어있는 상태로 시작하고 차례를 바꿔가며 돌을 놓는다. 반면 체스는 말을 놓고 시작하며 상대편의 말을 쓰러트려야 하는 게임이다.</li>
<li>게임 <a href="http://senseis.xmp.net/?RulesOfGoIntroductory">규칙</a>은 체스보다 바둑이 더 간단하다. 체스는 6개의 다른 말이 있지만, 바둑은 한 종류의 돌만 놓으면 된다.</li>
</ul>

<p><a href="http://senseis.xmp.net/?RulesOfGoIntroductory">여기</a>에서 배울 수 있고 <a href="http://www.gokgs.com/">여기</a>에서 바둑을 둘 수 있으니 확인해보라고 하고 싶다.</p>

<h2>체스와의 복잡도 비교</h2>

<p>규칙이 단순할지라도 좋은 바둑 프로그램을 만드는것은 매우 어렵다고 증명되어있다. 정말로 가장 뛰어난 체스 프로그램은 가장 뛰어난 체스 플레이어를 이기는게 가능했다. 1997년에 딥 블루가 게리 카스파로프(Gary Kasparov)를 이겼다. 하지만 가장 뛰어난 바둑 프로그램은 그냥 강한 아마추어에게 참패했다. 그리고 강한 아마추어는 프로 기사보다 엄청 약하다. 이런 일이 가능한 것에는 세가지 주된 이유가 있다.</p>

<ul>
<li><strong>게임-트리 복잡도</strong> : 체스에는 <a href="http://en.wikipedia.org/wiki/Shannon_number">10^123개의 게임</a>이 있다. 바둑에 있어서는 <a href="http://en.wikipedia.org/wiki/Go_and_mathematics">여러 추정치</a>가 나올 수 있지만, <a href="http://www.usgo.org/resources/topten.html">미국 바둑 협회 계산으로는 10^700개의 가능한 게임</a>이 있다고 한다. 바둑에는 플레이어에게 주어진 턴이 더 많고(평균적으로 200 대 50) 각각의 턴에서 돌을 놓을 수 있는 경우의 수(350 대 50)가 바둑이 더 많기에 바둑의 게임 수가 더 많다.</li>
<li><strong><a href="http://en.wikipedia.org/wiki/Evaluation_function">훌륭한 휴리스틱의 부족</a></strong> : 체스 프로그램은 어떤 행동이 다른 행동보다 좋은 것인지 꽤나 빠르고 정확하게 판단할 수 있다. 반대로 바둑에 대해선 아직 좋은 휴리스틱이 발견되지 않았다.</li>
<li><strong>패턴 인식</strong> : 뛰어난 바둑 기사라는건 판에 놓여진 돌이 만드는 모양을 인식하는 것에 달려있다. 게임을 하는 도중에 컴퓨터가 그 모양을 인식 하기엔 너무 많은 시간이 든다. <a href="http://curiosity.discovery.com/question/humans-better-than-computers">사람은 컴퓨터보다 훨씬 빠르다.</a></li>
</ul>

<h2>지금까지의 바둑 프로그램을 넘어설 핵심 아이디어</h2>

<p>바둑 알고리즘 연구가 흥미로운 이유가 이런 복잡도가 있기 때문이다. 우리는 몇 년전 스팩타클한 성능 향상을 보인 <a href="http://www.lri.fr/~teytaud/mogo.html">MoGo</a>라는 이름이 프로그램을 보았다. MoGo의 핵심 아이디어는 이렇다.</p>

<ul>
<li><strong>랜덤 게임을 이용한 위치 선정</strong> : 역설적이게도 지금까지 알아낸 돌을 놓을 위치를 알아내는 최고의 방법은 현재 상태에서 시작해 각각의 선수가 바둑판에 랜덤으로 돌을 놓는 수많은 경기를 진행해 보는것 이다. 바둑판 위, 한 위치의 점수는 단순히 랜덤 게임들이 이긴 확률이다.</li>
<li>브랜칭 팩터(각 턴마다 가능한 행동-돌을 놓는 등-의 경우의 수)를 줄이기 위해 <strong>'<a href="http://en.wikipedia.org/wiki/Multi-armed_bandit">multi-armed bandit</a> 알고리즘'를 이용</strong>한다. 목표는 탐색(새로운 행동을 하는 것)과 개척(이미 알고 있는 행동 중에 최적의 하나를 찾아내는 것) 사이에 트레이드 오프를 최적화 하는 것이다. 컴퓨터는 처음에 가능한 모든 행동에 대해 사전 확률 분포를 만든다. 이 분포에 따라 하나를 고르고 그에 상응하는 위치를 기반으로 랜덤 게임을 돌린다. 그리고 결과를 이용해 그 행동에 대한 확률을 업데이트한다. 그리고 업데이트된 분포를 이용해 다음 가능한 수를 선택한다. 그렇게 계속 해나간다.</li>
<li><strong>작은 전문 지식을 이용</strong> : 'multi-armed bandit'에서 쓰이는 사전 분포는 적은 노력으로 멍청한 행동을 피하는 용도로 사용한다. 게임을 시작하면 고전적인 시작 위치를 선호한다. 그리고 랜덤 게임을 하는데 사실 이 랜덤 게임은 완전한 랜덤이 아니다. 간단한 패턴에 따라 특정 행동들은 제거하기 때문이다. 그렇게 몇가지를 제거한다 해도 전문 지식은 탐사 알고리즘 부분의 정말 작은 상처 하나에 불과하다.</li>
<li><strong>병렬화</strong> : MoGo같은 프로그램은 컴퓨터 클러스터에서 더 나은 성능을 보인다. 랜덤 게임 부분이 여러개의 CPU에서 돌 수 있기 때문이다. <a href="http://en.wikipedia.org/wiki/Amdahl's_law">성능 향상</a>은 약 8배 정도이다.</li>
<li><strong>강화된 학습</strong> : MoGo는 게임을 진행하는 동안이나 랜덤 게임을 진행하는 동안 계속 학습한다. 잘못된 결과를 가져오는 행동을 했을때 그 행동에 더 작은 확률을 부여한다.</li>
</ul>

<p><a href="http://www.pleinsud.u-psud.fr/specialR2008/en/12_GOthique.pdf">이 글</a>에 MoGo에 대해 더 많은 자료가 있다.</p>

<h2>현재 컴퓨터의 성능</h2>

<p>오늘날 바둑 프로그램은 조그마한 게임 판에서 프로 바둑 기사를 이기고 잘하는 아마추어 기사를 정식 바둑판에서 이기는 수준이다. 이건 굉장한 성과이지만 정식 바둑판에서 프로 바둑 기사를 상대하기 까지는 너무 먼 여정이 남아있다.</p>

<p><em>난 그리 실력이 좋지 않을지 모르겠지만, 스스로 바둑 플레이어라고 말한다. 2008년에 컴퓨터 공학 연구실에 인턴으로 있을 때, 한 2달 정도 MoGo를 사용했었다.<br />이 글을 검토해준 <a href="http://www.linkedin.com/pub/arpad-rimmel/b/9a7/847">Arpad Rimmel</a>에게 감사의 말을 전한다. 그는 박사과정을 지내는 중 3년 정도 MoGo를 사용했다.</em></p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ J언어 배우기 - 제 3장: 함수 정의하기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/learning-j-chapter3.html" />
    <updated>2012-04-30T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/learning-j-chapter3.html</id>
    <content type="html">
<![CDATA[
<p>Roger Stokes이 쓴 <a href="http://www.jsoftware.com/docs/help701/learning/contents.htm">Learning J</a> 의 chapter 3:Defining Functions를 번역/정리했다. 이전 챕터들은 본 사이트에서 <a href="/site/tagmap.html#j언어">J언어 태그</a>로 검색해 볼 수 있다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/learning_j_chapter3/jcode.png" alt="j code" title="" /></p>

<p>J에는 많은 내장 함수가 있다. 우리는 그 중 몇 가지를 살펴보았다.(<code>*</code>나 <code>+</code>같은 것들) 이번 섹션에서는 이 내장함수를 조합해 원하는 함수를 정의하는 여러 방법을 배운다.</p>

<h2>3.1 이름짓기</h2>

<p>함수를 정의하는 가장 간단한 방법은 그냥 원하는 내장 함수에 이름을 부여하는 것이다. 정의는 할당 함수를 이용해서 한다. 예를 들어서 아래의 <code>square</code>함수는 내장 함수인 <code>*:</code>를 이용하는 것과 똑같다.</p>

<pre><code>   square =: *:

   square 1 2 3 4
1 4 9 16
</code></pre>

<p>우리가 지은 이름이 더 기억하기 쉽거나 해서 그게 좋다면 새로운 이름을 사용한다. 같은 내장 함수에 다른 두 개의 이름을 부여할 수도 있다. 하나는 모나딕용으로, 다른 하나는 다이아딕 용으로.</p>

<pre><code>   Ceiling =: &gt;.
   Max     =: &gt;.
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Ceiling 1.7</tt></td>
<td><tt>3 Max 4</tt></td>
</tr><tr valign="TOP">
<td><tt>2</tt></td>
<td><tt>4</tt></td>
</tr></tbody></table>

<h2>3.2 삽입하기</h2>

<p>표현식 <code>+/ 2 3 4</code>는 의미가 <code>2 + 3 + 4</code>와 같고 비슷하게 <code>*/ 2 3 4</code>는 <code>2 * 3 * 4</code>와 같다. 이제 이 함수에 <code>sum</code>이라는 이름을 붙여보자.</p>

<pre><code>   sum =: + /

   sum 2 3 4
9
</code></pre>

<p><code>sum =: +/</code>라는 코드를 보면 <code>+/</code>가 이 자체로 함수를 표현하는 표현식임을 알 수 있다.<br /><code>+/</code>는 "Insert"(<code>/</code>)가 함수 <code>+</code>에 적용되어 리스트를 합치는 함수가 되었다 라고 말한다.</p>

<p>즉, <code>/</code>은 그 자체로 함수의 한 종류이다. 이 함수는 왼쪽에 인자 하나를 받는다. 그 인자도 함수고 계산 결과도 함수다.</p>

<h2>3.3 용어: 동사, 연산자, 부사</h2>

<p>우리는 두 종류의 함수를 봤다. 첫째로 "일반적인" 함수다. 숫자를 계산해서 숫자를 내뱉는 <code>+</code>나 <code>*</code>같은 함수. J에서는 이런 것들을 "동사"라고 한다. 둘째로 함수를 계산해서 함수를 내뱉는 <code>/</code>같은 함수이다. 이런 종류의 함수를 다른 종류의 함수와는 구별하여 "연산자"라고 한다. </p>

<p>하나의 인자를 받는 연산자는 "부사"라고 한다. 부사는 항상 왼쪽에 하나의 인자를 받는다. 그래서 표현식 <code>+ /</code>에서 부사 <code>/</code>는 동사 <code>+</code>에 적용되어서 리스트를 더하는 동사가 만들어진다.</p>

<p>용어는 영어구문에서 따왔다. 동사는 물건의 행동을 묘사하고 부사는 동사의 의미를 변한다.</p>

<h2>3.4 교환하기(Commuting)</h2>

<p>부사 <code>/</code>말고 다른것도 보자. 부사 <code>~</code>는 왼쪽과 오른쪽의 인자를 서로 바꾸는 기능이 있다.</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>'a' , 'b'</tt></td>
<td><tt>'a' ,~ 'b'</tt></td>
</tr><tr valign="TOP">
<td><tt>ab</tt></td>
<td><tt>ba</tt></td>
</tr></tbody></table>

<p>다이아드 함수 <code>f</code>와 그 인자 <code>x</code>, <code>y</code>에 대해서 <code>~</code>의 구조는 다음과 같다.</p>

<pre><code>         x f~ y      는   y f x   이다
</code></pre>

<p>또 다른 예로 동사 <code>|</code>를 기억하는가? <code>2|7</code>은 "7 mod 2"와 같다. 이제 mod함수를 정의 할 차례이다.</p>

<pre><code>   mod =: | ~
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>7 mod 2</tt></td>
<td><tt>2 | 7</tt></td>
</tr><tr valign="TOP">
<td><tt>1</tt></td>
<td><tt>1</tt></td>
</tr></tbody></table>

<p>그림을 한번 그려보자. 우선 함수 f에 인자 y를 적용해 <code>f y</code>의 결과를 반환하는 다이어그램이 있다. 이 다이어그램에서 함수 f는 사각형으로 그리고 인자가 어떻게 흘러서 결과가 나타나는지 화살표로 나타낸다. 각각의 화살표에는 표현식이 쓰여있다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag01.gif" alt="monadic" title="" /></p>

<p>아래에 다이아딕 함수 f에 인자 x, y를 적용해 <code>x f y</code>가 만들어지는 다이어그램이 있다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag02.gif" alt="dyadic" title="" /></p>

<p>이것이 함수 <code>f~</code>에 대한 다이어그램이다. 상자 안에 함수 f가 있고 인자가 서로 엇갈려서 들어가는 그림으로 나타냈다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag03.gif" alt="~" title="" /></p>

<h2>3.5 묶기(Bonding)</h2>

<p>double이라는 동사를 정의해야한다고 가정해보자. <code>double x</code>는 <code>x * 2</code>를 뜻한다. 즉 double은 "곱하기 2"이다. 아래와 같이 정의할 수 있다.</p>

<pre><code>   double =: * &amp; 2

   double 3
6
</code></pre>

<p>우리는 <code>*</code>를 두 인자중 한 인자를 미리 정해놓고(이 경우엔 2) 그걸 마치 모나드 처럼 써서 <code>*</code>를 다이아드로 사용했다. <code>&amp;</code> 연산자는 함수와 값을 묶어놓는 역할을 한다. f가 다이아딕 함수이고 k가 f의 오른쪽 인자라면 다음과 같은 구조를 가진다.</p>

<pre><code>        (f &amp; k) y    은    y f k   이다.
</code></pre>

<p>오른쪽 인자말고 왼쪽 인자를 고정하고 싶다면 아래와 같이 쓸 수 있다.</p>

<pre><code>        (k &amp; f)  y   은    k f y   이다
</code></pre>

<p>예를 들어서 물건 값의 10% 세금은 계산해야 한다고 하자. 그러면 세액을 계산하는 함수는 다음과 같다.</p>

<pre><code>   tax =: 0.10 &amp; *

   tax 50
5
</code></pre>

<p>아래에 <code>k&amp;f</code>함수의 다이어그램이 있다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag04.gif" alt="bond" title="" /></p>

<h2>3.6 용어: 접속사와 동사</h2>

<p>표현식 <code>*&amp;2</code>는 <code>&amp;</code> 연산자는 두 인자(동사 <code>*</code>와 숫자 2)를 받는 함수이며 그 결과로 "doubling"이라는 동사를 만들어낸다.<br /><code>&amp;</code>와 같은 두 인자를 취하는 "연산자"를 J에서는 "접속사"라고 한다. 이는 두 인자를 묶어주기 때문이다. 반면에 부사는 하나의 인자만을 가지는 연산자이다.</p>

<p>J의 모든 함수는 내장 함수이건 사용자 정의 함수이건 반드시 4종류 중 하나이다. 모나딕 동사, 다이아딕 동사, 부사, 접속사가 그것이다. 같은 심볼이지만 다른 의미를 가지는 동사는 두 개의 다른 동사로 간주한다. 예를 들면 <code>-</code>는 모나딕으로는 "negation"이고 다이아딕으로는 "subtraction"이다.</p>

<p>J의 모든 표현식은 어떤 타입을 가진 값이다. 그리고 함수가 아닌 모든 값은 데이터이다.(정확히는 이전 섹션에서 본 배열이다)</p>

<p>J에서 데이터 값, 즉 배열은 "명사"라고 부른다. 이는 영어의 구문과 비슷하다. 이젠 어떤 것이 동사가 아닌 것을 강조하기 위해서 그것을 명사라 부르고, 어떤 차원을 가지고 있다는걸 강조하기 위해서 그것을 배열이라 부른다.</p>

<h2>3.7 함수의 합성(composition)</h2>

<p>이런 영어 표현을 생각해보자. "the sum of the squares of the numbers 1 2 3" 이건 <code>1+4+9</code> 또는 <code>14</code>이다. 우리가 앞에서 sum과 square동사를 정의 했으니 J로는 다음과 같이 쓸 수 있다.</p>

<pre><code>   sum square 1 2 3
14
</code></pre>

<p>sum과 square를 합성하여 하나의 "sum-of-the-squares"함수를 만들 수도 있다.</p>

<pre><code>   sumsq =: sum @: square

   sumsq 1 2 3
14
</code></pre>

<p>심볼 <code>@:</code>(at colon)은 "composition(합성)" 연산자다. f와 g가 동사이고 y라는 인자가 있을때 이 연산자의 구조는 다음과 같다.</p>

<pre><code>       (f @: g) y    는  f (g y)  이다.
</code></pre>

<p>아래에는 이 구조에 대한 다이어그램이다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag05.gif" alt="composition" title="" /></p>

<p>이 시점에서 독자분들은 동사를 합성할 때 왜 간단하게 <code>f g</code>라고 쓰지 않고 <code>f @: g</code>라고 쓰는지 궁금할 것이다. 간단히 말하자면 <code>f g</code>은 또 다른 의미이다. 이건 곧 나온다.</p>

<p>합성에 대한 다른 예는 화씨를 섭씨로 바꾸는 것이다. 32를 빼는 함수 s와 5%9를 곱하는 함수 m을 합성해보자.</p>

<pre><code>   s       =: - &amp; 32
   m       =: * &amp; (5%9)
   convert =: m @: s
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>s 212</tt></td>
<td><tt>m s 212</tt></td>
<td><tt>convert 212</tt></td>
</tr><tr valign="TOP">
<td><tt>180</tt></td>
<td><tt>100</tt></td>
<td><tt>100</tt></td>
</tr></tbody></table>

<p>이 예제는 이름있는 함수의 합성을 잘 보여준다. 다음과 같이 함수의 표현식 자체를 합성 할 수도 있다.</p>

<pre><code>   conv =: (* &amp; (5%9)) @: (- &amp; 32) 
   conv 212
100
</code></pre>

<p>합성한 함수에 이름을 주지 않고서도 인자를 적용시켜 사용할 수 있다.</p>

<pre><code>   (* &amp; (5%9)) @: (- &amp; 32)  212
100
</code></pre>

<p>위 예제들로 모나드와 모나드를 합성한 것을 보였다. 다음 예제는 다이아드를 합성한 것이다. 일반적인 구조는 다음과 같다.</p>

<pre><code>           x (f @: g) y   은    f (x g y)   이다.
</code></pre>

<p>예를 들어서 아이템 몇 개를 구매한 총 금액은 각 아이템의 가격에 개 수를 곱하고 곱한 값을 더하면 알 수 있다. 아래를 보자.</p>

<pre><code>   P =:  2 3        NB. 가격
   Q =:  1 100      NB. 개 수

   total =: sum @: *
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>P</tt></td>
<td><tt>Q</tt></td>
<td><tt>P*Q</tt></td>
<td><tt>sum P * Q</tt></td>
<td><tt>P total Q</tt></td>
</tr><tr valign="TOP">
<td><tt>2 3</tt></td>
<td><tt>1 100</tt></td>
<td><tt>2 300</tt></td>
<td><tt>302</tt></td>
<td><tt>302</tt></td>
</tr></tbody></table>

<p>합성에 대해서 더 알고 싶으면 8장을 보라.</p>

<h2>3.8 동사의 연결(Trains of Verbs)</h2>

<p>"no pain, no gain"이라는 문구를 아는가. 이것은 압축되고 요약된 관용적 표현이다. 이런 말은 문법적 구조에는 맞지 않지만 제법 알아들을 수 있다. (메인 동사가 없으므로 문장이 아니다) J에는 이와 비슷하게 함수를 몇 개 연결해서 특정한 의미가 되도록 하는 표기법이 있다. 아래에 그 방법이 나온다.</p>

<h3>3.8.1 훅(Hooks)</h3>

<p>위에서 정의했던 세금을 계산하는 동사를 다시 가져오자. 이 동사에서 세율은 10%였다. </p>

<pre><code>   tax =: 0.10 &amp; *
</code></pre>

<p>지불해야 하는 금액은 물건 가격 더하기 세금이다. 지불해야 하는 금액을 계산하는 동사는 다음과 같이 작성 할 수 있다.</p>

<pre><code>   payable =: + tax
</code></pre>

<p>만약 물건 가격이 50달러 라면, 아래와 같이 계산할 수 있다.</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>tax 50</tt></td>
<td><tt>50 + tax 50</tt></td>
<td><tt>payable 50</tt></td>
</tr><tr valign="TOP">
<td><tt>5</tt></td>
<td><tt>55</tt></td>
<td><tt>55</tt></td>
</tr></tbody></table>

<p><code>payable =: + tax</code>라는 정의를 보면 <code>+</code>동사 다음에 곧바로 <code>tax</code>가 온다. 이 시퀀스는 할당 연산자 오른쪽에 위치함으로써 분리되어있다.(isolated) 이렇게 분리된 동사의 시퀀스를 "train"이라고 부르고 동사 2개의 train을 "hook"(훅)이라고 부른다.</p>

<p>두 개의 동사를 괄호 안에 넣어 분리시켜 훅의 형태로 사용할 수 있다.</p>

<pre><code>   (+ tax) 50
55
</code></pre>

<p>f가 다이아드, g가 모나드이고 y라는 어떤 인자가 있을때 훅의 일반적인 구조는 다음과 같다. </p>

<pre><code>        (f g) y       는   y f (g y)   이다.
</code></pre>

<p>이 구조를 다이어그램으로 나타내면 다음과 같다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag06.gif" alt="hook" title="" /></p>

<p>또다른 예로 인자로 들어온 수의 정수 부분을 계산하는 동사인 <code>&lt;.</code>("floor")를 이용해보자. 숫자가 정수인지 아닌지 검사를 하려면 그 숫자가 정수부와 같은지 검사한다. "equal-to-its-floor"라는 의미를 가진 이 동사는 <code>= &lt;.</code>라는 훅으로 정의할 수 있다.</p>

<pre><code>   wholenumber  =:  = &lt;.
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>y =: 3 2.7</tt></td>
<td><tt>&lt;. y</tt></td>
<td><tt>y = &lt;. y</tt></td>
<td><tt>wholenumber y</tt></td>
</tr><tr valign="TOP">
<td><tt>3 2.7</tt></td>
<td><tt>3 2</tt></td>
<td><tt>1 0</tt></td>
<td><tt>1 0</tt></td>
</tr></tbody></table>

<h3>3.8.2 포크(Forks)</h3>

<p>숫자 리스트 L의 산술 평균은 L의 합을 L의 아이템 개 수로 나눈 것이다.(아이템 개 수를 세는 모나딕 동사인 <code>#</code>는 기억하고 있겠지?)</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>L =: 3 5 7 9</tt></td>
<td><tt>sum L</tt></td>
<td><tt># L</tt></td>
<td><tt>(sum L) % (# L)</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5 7 9</tt></td>
<td><tt>24</tt></td>
<td><tt>4</tt></td>
<td><tt>6</tt></td>
</tr></tbody></table>

<p>합을 아이템 개 수로 나누기 계산을 하는 동사는 세가지 동사의 시퀀스로 나타낼 수 있다. <code>sum</code> 다음에 <code>%</code>다음에 <code>#</code>가 오면 된다.</p>

<pre><code>   mean =: sum % #

   mean L
6
</code></pre>

<p>세 동사의 분리된 시퀀스는 "fork(포크)"라고 한다. 임의의 인자 y에 대해서 f가 모나드이고 g가 다이아드이고 h가 모나드일 때 다음과 같은 일반적인 구조를 지닌다.</p>

<pre><code>        (f g h) y     는   (f y) g (h y)   이다.
</code></pre>

<p>이 구조를 다이어그램으로 나타내면 아래와 같다.</p>

<p><img src="/articles/2012/learning_j_chapter3/diag06.gif" alt="hook" title="" /></p>

<p>포크에 대한 다른 예로는 숫자 리스트의 범위를 구하는 것이 있다. 숫자 리스트의 범위는 리스트에서 가장 작은 수와 가장 큰 수를 구하는 것이다. 이는 최소, 최대를 구하는 동사 중간에 콤마 동사를 넣어 포크하면 된다.</p>

<p>리스트에서 가장 큰 수를 구하는 함수 <code>&gt;./</code>와 가장 작은 수를 구하는 함수 <code>&lt;./</code>는 1장에서 배웠다.</p>

<pre><code>   range =: &lt;./  ,  &gt;./
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>L</tt></td>
<td><tt>range L</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5 7 9</tt></td>
<td><tt>3 9</tt></td>
</tr></tbody></table>

<p>훅과 포크는 동사의 시퀀스이다. 이는 동사의 "trains" 라고도 말한다. trains에 대해 더 많은 정보를 알려면 제 9장을 참고하라.</p>

<h2>3.9 다 집어넣고 보자(Putting Things Together)</h2>

<p>이제까지 배운 것들 중 몇가지를 섞어서 좀 더 커다란 예제를 만들어보자<br />어떤걸 만들꺼냐면, 숫자 리스트를 보여주고 각 숫자가 전체에서 몇 퍼센트를 차지하는지 보여주는 간단한 표를 만들 예정이다.</p>

<p>어떤걸 만들어야 하는지 명확히 하기 위해 우선 완성된 예제를 먼저 보자. 아래에 설명 할 것이기 때문에 당장에 이 모든걸 알 필요는 없다. 그냥 아래 6라인의 코드를 보고 어떤 동사가 정의되어 있는지 살펴보자.</p>

<pre><code>   percent  =: (100 &amp; *) @: (% +/)
   round    =: &lt;. @: (+&amp;0.5)
   comp     =: round @: percent
   br       =: ,.  ;  (,. @: comp)
   tr       =: ('Data';'Percentages') &amp; ,
   display  =: (2 2 &amp; $) @: tr @: br
</code></pre>

<p>간단한 데이터로 시작해보자.</p>

<pre><code>   data =: 3 5
</code></pre>

<p>이 데이터를 이용하면 <code>display</code>동사는 각 숫자와 그 숫자의 퍼센트를 표현할 것이다. 아래 표를 보자면, 3은 8에서 38%를 차지한다.</p>

<pre><code>   display data
+----+-----------+
|Data|Percentages|
+----+-----------+
|3   |38         |
|5   |63         |
+----+-----------+
</code></pre>

<p><code>percent</code>동사는 훅 <code>% +/</code>으로 전체 수에서 각각의 수를 나누고 각각에 100을 곱해서 퍼센트를 계산해낸다. 아래에 <code>percent</code>의 정의를 다시 쓸테니 위로 스크롤 하지 않아도 된다.</p>

<pre><code>   percent  =: (100 &amp; *) @: (% +/)
</code></pre>

<p>이를 사용해보자.</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>+/ data</tt></td>
<td><tt>data % +/ data</tt></td>
<td><tt>(% +/) data</tt></td>
<td><tt>percent data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>8</tt></td>
<td><tt>0.375 0.625</tt></td>
<td><tt>0.375 0.625</tt></td>
<td><tt>37.5 62.5</tt></td>
</tr></tbody></table>

<p>퍼센트 값을 반올림하자. 반올림은 각 값에 0.5를 더하고 "floor"(<code>&lt;.</code>)를 이용해 정수 부분만을 취한다. 이런 일을 하는 동사 <code>round</code>는 아래와 같이 정의한다.</p>

<pre><code>   round    =: &lt;. @: (+&amp;0.5)
</code></pre>

<p>그러면 화면에 표시할 값을 계산하는 동사는 다음과 같다.</p>

<pre><code>   comp     =: round @: percent
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>comp data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>38 63</tt></td>
</tr></tbody></table>

<p>이제 테이블에 데이터와 퍼센트로 계산된 값을 표현해야 한다. 리스트를 하나의 열(column)을 만들기 위해선 동사 <code>,.</code>를 사용할 수 있다.("Ravel Items"라고 부른다)</p>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>,. data</tt></td>
<td><tt>,. comp data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>3<br>
5</tt></td>
<td><tt>38<br>
63</tt></td>
</tr></tbody></table>

<p>테이블의 아래쪽 행을 만들기 위해 <code>br</code> 이라는 동사를 정의한다. 이 동사는 데이타와 계산된 값을 열(column)로 링크하는 포크이다.(포크는 위에서 정의했듯이 세 동사의 시퀀스이다.)</p>

<pre><code>   br  =: ,.  ;  (,. @: comp)
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>br data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>+-+--+<br>
|3|38|<br>
|5|63|<br>
+-+--+</tt></td>
</tr></tbody></table>

<p>테이블의 위쪽 행(컬럼 헤딩)은 간단하게 만들 수 있다. 아래쪽 행은 두 박스의 리스트이다. 우리가 그 앞에 두 개의 박스를 더 붙이면 박스가 4개인 리스트가 된다. 동사 <code>tr</code>이 그 작업을 한다.</p>

<pre><code>   tr  =: ('Data';'Percentages') &amp; ,
</code></pre>

<table style="margin:20px 0px" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>data</tt></td>
<td><tt>br data</tt></td>
<td><tt>tr br data</tt></td>
</tr><tr valign="TOP">
<td><tt>3 5</tt></td>
<td><tt>+-+--+<br>
|3|38|<br>
|5|63|<br>
+-+--+</tt></td>
<td><tt>+----+-----------+-+--+<br>
|Data|Percentages|3|38|<br>
|&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|5|63|<br>
+----+-----------+-+--+</tt></td>
</tr></tbody></table>

<p>남은건 박스 4개의 리스트를 2행 2열의 테이블로 만드는 것이다.</p>

<pre><code>   (2 2 &amp; $)  tr br data
+----+-----------+
|Data|Percentages|
+----+-----------+
|3   |38         |
|5   |63         |
+----+-----------+
</code></pre>

<p>이걸 다 합하면,</p>

<pre><code>   display =: (2 2 &amp; $) @: tr @: br

   display data
+----+-----------+
|Data|Percentages|
+----+-----------+
|3   |38         |
|5   |63         |
+----+-----------+
</code></pre>

<p>이렇게 된다.</p>

<p><code>display</code>동사는 두 부분으로 나눈다. 반올림된 퍼센트 값을 계산하는 <code>comp</code>함수와 화면에 결과를 표시하는 나머지 부분이 그것이다. <code>comp</code>함수를 바꾸어 다른 함수를 사용하면 그 함수의 계산 결과를 표 형태로 표시한다. <code>comp</code>를 제곱근을 계산하는 <code>%:</code>함수로 바꿔보자.</p>

<pre><code>   comp =: %:
</code></pre>

<p>동사 <code>tr</code>에 있는 표의 컬럼 헤딩도 알맞게 수정해야한다.</p>

<pre><code>   tr   =: ('Numbers';'Square Roots') &amp; ,

   display 1 4 9 16
+-------+------------+
|Numbers|Square Roots|
+-------+------------+
| 1     |1           |
| 4     |2           |
| 9     |3           |
|16     |4           |
+-------+------------+
</code></pre>

<p>J의 몇몇 특징적인 기능(묶기, 합성, 훅, 포크)을 이용해서 조그마한 J프로그램을 작성해보았다. 모든 J 프로그램과 마찬가지로 이 프로그램은 이걸 작성하는 많은 방법중에 하나일 뿐이다.<br />이 장에서 우리는 함수를 정의하는 방법을 배웠다. 함수는 두 종류가 있다. 동사와 연산자. 지금까지 우리는 동사의 정의하는 것을 보았다. 다음 장에서는 동사를 정의하는 다른 방법을 알아 볼 것이다. 그리고 제 13장에서는 연산자를 정의하는 방법을 배운다.</p>

<p>이렇게 제 3장이 끝났다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: git-svn ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-svn.html" />
    <updated>2012-04-28T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-svn.html</id>
    <content type="html">
<![CDATA[
<p>Progit 8장에 설명된 'git-svn'에서 쓸만한 명령어를 정리했다. svn server + git client 같이 오묘한 조합은 사용하고 싶지 않았는데, 너무 불편해서 못살겠다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-svn/et.jpg" alt="et" title="" /></p>

<p>GitHub는 <a href="http://hg-git.github.com/">git server + hg client</a>, <a href="https://github.com/blog/966-improved-subversion-client-support">git server + svn client</a> 조합도 만들었는데 쓰는 사람이 있을까?</p>

<h2>주요 명령어 정리</h2>

<p>SVN 처럼 로그를 보거나 등등의 기능이 많지만, 어차피 안 쓸 것 같아서 정리하지 않는다. SVN을 Git으로 마이그레이션할 때 필요한 명령어도 정리하지 않았다.</p>

<h3>clone:</h3>

<pre><code>git svn clone url -s
</code></pre>

<p>-s는 표준레이아웃인 <code>trunk, branches, tags</code>를 사용한다는 의미다. 표준레이아웃을 사용하지 않으면 <code>-T trunk -b branches -t tags</code>라고 직접 알려주면 된다.</p>

<p>trunk, branches, tags는 모두 Git 브랜치로 만들어진다. trunk와 branches는 같은 이름으로 만들어지지만, tags는 앞에 <code>tags/</code>라고 붙는다.</p>

<p>progit 책에 나오는 <code><a href='http://progit-example.googlecode.com/svn/'>http://progit-example.googlecode.com/svn/</a></code>을 적용해보면 다음과 같이 만들어진다:</p>

<pre><code>└─▪ git br -av
* master                        5925d95 Support HP C++ on Tru64.
  remotes/my-calc-branch        a52ad75 created a branch
  remotes/tags/2.0.2            fd8e73e Tag release 2.0.2.
  remotes/tags/release-2.0.1    60feb5c Tag the 2.0.1 release.
  remotes/tags/release-2.0.2    85bac46 Set version to 2.0.2 in release branch.
  remotes/tags/release-2.0.2rc1 168051e Update version number in 2.0.2rc1 release branch.
  remotes/trunk                 5925d95 Support HP C++ on Tru64
</code></pre>

<p>SVN 브랜치는 당연히 Git 브랜치로 만들어지지만 SVN의 tag도 Git의 브랜치로 만들어진다.</p>

<h3>fetch:</h3>

<p><code>git fetch</code>에 대응되는 명령어:</p>

<pre><code>git svn fetch
</code></pre>

<p>trunk가 master로 자동으로 Fast-Forward Merge 됐으면 좋겠다. </p>

<p><code>git-svn</code> 프로젝트이면 trunk를 master로 Fast-Forware Merge하도록 <a href="https://github.com/pismute/git-tles">git-ff</a>를 수정했다. 이 브랜치만 Merge한다. svn에서 브랜치를 쓰고 싶지 않다.</p>

<h3>push:</h3>

<p><code>git push</code>에 대응하는 명령어:</p>

<pre><code>git svn dcommit
</code></pre>

<p>svn은 히스토리가 평평하니까 이것만 주의하면 된다.</p>

<h3>annotate:</h3>

<p>어떤 놈이 잘못 고쳤는지 찾아보는 명령어:</p>

<pre><code>git svn blame [FILE] 
</code></pre>

<h3>.gitignore:</h3>

<p><code>.gitignore</code>를 만들어 넣으면 svn 서버에 Push된다. 다른 사람 몰래 혼자 쓰고 싶으면 <code>.git/info/exclude</code>에 만들면된다. <code>.gitignore</code>랑 똑같고 해당 저장소에만 적용되며 Push할 수 없다:</p>

<pre><code>git svn show-ignore &gt; .git/info/exclude
</code></pre>

<h2>Merge</h2>

<p>SVN의 히스토리는 항상 일직선이기 때문에 SVN에 Push할 브랜치는 항상 Fast-Forward로 Merge해야 한다. 그렇지 않으면 알아서 펴주기 때문에 히스토리 모양이 원하는 모양이랑 다를 수 있다.</p>

<h2>브랜치</h2>

<p>SVN의 히스토리는 항상 평평하다. 브랜치 별로 히스토리가 다르게 관리하는 것이 아니라 한 히스토리에서 trunk. branches, tags를 모두 관리한다. 이점을 꼭 기억해야 한다.</p>

<p>SVN 브랜치는 항상 Long-Running 브랜치로 사용한다. Topic 브랜치는 git-svn이 아니라 그냥 git을 사용할 때와 다를 바 없다. 단지 SVN 브랜치를 Tracking하는 Long-Running 브랜치에 Merge할 때 쫙 펴주기만 하면 된다.</p>

<p>문제는 SVN 브랜치를 Git에서 서로 Merge하는 데 있다. 그냥 Fetch해서 평평한 히스토리를 유지하면서 Push하는 것이 아니라 SVN 브랜치를 Git에서 Merge하면 어떨까? 이제 이걸 알아보자.</p>

<h3>일단 SVN 저장소를 하나 준비하고</h3>

<p>일단 SVN 저장소를 하나 준비하고:</p>

<p><img src="/articles/2012/git-svn/svn-repository.png" alt="svn-repository.png" title="" /></p>

<p>Git으로 클론한다. 클론하고 나서 <code>git branch -av</code>를 하면 다음과 같다:</p>

<pre><code>* master             92a713a from trunk
  remotes/dogfeet    e5334ef Add from dogfeet
  remotes/tags/1.0.0 2ec86a0 tag 1.0.0
  remotes/trunk      92a713a from trunk
</code></pre>

<p>master는 remotes/trunk를 트랙킹하고 SVN 브랜치인 'dogfeet'과 SVN 태그인 '1.0.0'이 Git에서는 모두 브랜치로 만들어진다. 그리고 원래 리모트 트래킹 브랜치는 <code>remotes/origin/master</code> 같은 패턴으로 이름 지어지는데 리모트 없이 <code>remotes/trunk</code> 형식으로 이름 지어진다.</p>

<p>SVN 히스토리:</p>

<p><img src="/articles/2012/git-svn/history.png" alt="history.png" title="" /></p>

<p>master 히스토리:</p>

<pre><code>* 92a713a - (HEAD, trunk, master) from trunk (2 hours ago)
* 12bf5f1 - Initial structure. (2 hours ago)
</code></pre>

<p>dogfeet 히스토리:</p>

<pre><code>* e5334ef - (dogfeet) Add from dogfeet (2 hours ago)
* 86cdd49 - branch dogfeet (2 hours ago)
* 92a713a - (HEAD, trunk, master) from trunk (2 hours ago)
* 12bf5f1 - Initial structure. (2 hours ago)
</code></pre>

<h3>이제 Git에서 커밋을 하나씩하고</h3>

<p>master에 커밋을 하나 하고:</p>

<pre><code>* 4c549fb - (master) Add from_git_master (4 minutes ago)
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>dogfeet에도 커밋을 하나 하고:</p>

<pre><code>* 904a4c0 - (HEAD, local_dogfeet) Add from_git_dogfeet (70 seconds ago)
* e5334ef - (dogfeet) Add from dogfeet (23 hours ago)
* 86cdd49 - branch dogfeet (23 hours ago)
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>dogfeet을 master에 Merge한다:</p>

<pre><code>*   8365b59 - (HEAD, master) Merge branch 'local_dogfeet' (2 seconds ago)
|\  
| * 904a4c0 - (local_dogfeet) Add from_git_dogfeet (2 minutes ago)
| * e5334ef - (dogfeet) Add from dogfeet (23 hours ago)
| * 86cdd49 - branch dogfeet (23 hours ago)
* | 4c549fb - Add from_git_master (5 minutes ago)
|/  
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>이걸 SVN에 Push하면 SVN 히스토리는 다음과 같아진다:</p>

<p><img src="/articles/2012/git-svn/history-after-merge.png" alt="history-after-merge.png" title="" /></p>

<p>그러니까 이렇게 Merge 커밋이 있는 히스토리를 SVN에 Push하면 히스토리가 순서가 보장되지 않는다. 히스토리 순서를 보장하려면 Fast-Forward Merge로 펴놓고 Push해야 한다.</p>

<p>그렇다고 Rebase를 해서 Fast-Forward Merge를 하면 같은 커밋이 두 번 들어가게 될 수도 있으니 절대로 SVN에 올라간 커밋은 Rebase하면 안된다. 그러니까 SVN에 Push한 커밋을 Rebase할 바엔 그냥 Merge Commit을 남기는 게 낫다고 볼 수 있다.</p>

<h3>브랜치 결론.</h3>

<p>SVN 세상에서는 히스트리가 항상 평평하고 브랜치도 디렉토리로 관리한다. 그러니까 이점을 명확히 이해하고 있어야 혼란스럽지 않다.</p>

<p>SVN의 브랜치를 Git에서 Merge하는 것은 사실 조금 위험하다. Merge Commit 있는 Git 히스토리를 SVN에 Push하면 커밋 순서는 보장되지 않을 것이고 그렇다고 SVN에 이미 커밋된 것을 Rebase할 수도 없다. 하지만 Topic 브랜치를 만들어 작업하고 히스토리를 평평하게 펴서 SVN에 Push하면 쓸만하다.</p>

<p>그리고 SVN 히스토리가 망가질 수 있다는 단점은 지나친 기우일 수 있다. 오픈 소스 프로젝트라면 히스토리를 더럽히는 것이 당연히 부끄럽겠지만, 원래 커밋 메시지도 없는 히스토리라면 그냥 커밋 몇 개 더 만들어도 괜찮지 않을까? 취미로 하는 프로젝트를 빼고 난 아직 한번도 히스토리에 정성을 쏳는(이라고 쓰고 커밋 메시지를 잘 남기는 이라고 읽는다) 프로젝트를 해보지 못했다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Ubuntu ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/ubuntu-desktop.html" />
    <updated>2012-04-27T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/ubuntu-desktop.html</id>
    <content type="html">
<![CDATA[
<p>Ubuntu 12.04 릴리즈를 기념해서 Ubuntu Desktop 설치 노트를 만들었다. 이번 프로젝트에서는 Linux가 주 플랫폼인데 Linux가 필요해서 Ubuntu Desktop을 설치했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/ubuntu-desktop/ubuntu.png" alt="ubuntu" title="" /></p>

<p>만날 X 없이 Server만 깔아서 쓰다가 Desktop을 설치했는데 너무 편하다. 앞으로는 Ubuntu Desktop을 많이 쓸 것 같다.</p>

<h2>할 일</h2>

<ul>
<li>/tmp를 tmpfs로 만들기</li>
</ul>

<p>noexec로 하면 <code>/tmp</code>에 압축을 풀고 설치하는 인스톨러들이(특히 오라클 제품들...) 실패한다. 보안을 위해 noexec로 설명하는 글들이 많은데, 서버가 아니니 exec로 하도록 하자.</p>

<pre><code>#/etc/fstab
tmpfs            /tmp           tmpfs   defaults,exec,nosuid 0       0
</code></pre>

<ul>
<li>apt source를 ftp.daum.net로 변경. - System Settings/Software Sources</li>
<li>virtual kernel 설치.</li>
<li>dselect 설치 - <code>sudo apt-get install dselect</code></li>
<li>vmware tools 설치 - <code>sudo apt-get install open-vm-dkms</code></li>
<li>나눔폰트 설치 - <code>sudo apt-get install ttf-nanum ttf-nanum-coding ttf-nanum-extra</code></li>
<li>한글설정 - System Settings/Language Support</li>
<li>폰트, 폰트 크기 변경 - <code>sudo apt-get install gnome-tweak-tool</code></li>
<li>git 설치 - git</li>
<li>7zip 설치 - p7zip, p7zip-full</li>
<li>nvm, node를 위해 - curl, libss-dev</li>
<li>vim - default는 vim-tiny</li>
<li>가끔 필요 - jekyll</li>
</ul>

<p>이걸 다 더하면:</p>

<pre><code>sudo apt-get install dselect open-vm-dkms ttf-nanum ttf-nanum-coding ttf-nanum-extra gnome-tweak-tool git p7zip p7zip-full curl libss-dev vim ruby ruby1.9.1 ruby1.9.1-dev

sudo gem install jekyll
</code></pre>

<h3>chrome 설치</h3>

<p>인증서를 등록하고:</p>

<pre><code>wget -q -O - <a href='https://dl-ssl.google.com/linux/linux_signing_key.pub'>https://dl-ssl.google.com/linux/linux_signing_key.pub</a> | sudo apt-key add -
</code></pre>

<p>apt source 등록:</p>

<pre><code>sudo sh -c 'echo "deb <a href='http://dl.google.com/linux/chrome/deb/'>http://dl.google.com/linux/chrome/deb/</a> stable main" &gt;&gt; /etc/apt/sources.list.d/google.list'
</code></pre>

<p>update하고:</p>

<pre><code>sudo apt-get update
</code></pre>

<p>안정 버전을 설치한다:</p>

<pre><code>sudo apt-get install google-chrome-stable
</code></pre>

<p><a href="http://www.howopensource.com/2011/10/install-google-chrome-in-ubuntu-11-10-11-04-10-10-10-04/">원문</a></p>

<h3>sumlime text</h3>

<ul>
<li><a href="http://www.webupd8.org/2011/03/sublime-text-2-ubuntu-ppa.html">sublime text 설치</a></li>
</ul>

<h3>ubuntu one</h3>

<p>모류 5G라, home directory를 백업하기 적당해 보인다.</p>

<p>백업하지 않을 디렉토리:</p>

<pre><code>.nvm
.npm
.jenkins
.m2
.cache #chrome cache
.mozilla/firefox #firefox cache
</code></pre>

<h3>git-svn, svn</h3>

<p>12.04에서만 발생하는 에러일 수도 있지만 당분간 해결되지 않을 것 같은 느낌이다. SVN에서 https인 저장소에 접근하면 다음과 같은 에러가 발생한다.</p>

<pre><code>└─▪ git svn dcommit
Committing to <a href='https://my.svn/trunk'>https://my.svn/trunk</a> ...
RA layer request failed: OPTIONS of '<a href='https://my.svn/trunk'>https://my.svn/trunk</a>': SSL handshake failed: SSL error: Key usage violation in certificate has been detected. (<a href='https://my.svn'>https://my.svn</a>) at /usr/lib/git-core/git-svn line 577
</code></pre>

<p>뭐 이런 에러가 발생하면 다음과 같이 임시로 조치할 수 있다.:</p>

<pre><code>sudo apt-get install libneon27
cd /usr/lib
sudo mv libneon-gnutls.so.27 libneon-gnutls.so.27.old
sudo ln -s libneon.so.27.2.6 libneon-gnutls.so.27
</code></pre>

<p>임시로 이렇게 우회할 수 있지만 Ubunut가 자동으로 복구한다.</p>

<p>그냥 간단하게 스킴을 https가 아니라 http로 해주는 게 더 편하다.</p>

<h3>USB에 있는 Ubuntu를 VM에서 부팅 하고자 할 때</h3>

<p>USB에 우분트를 설치한 게 있는데 그걸 VM에서 부팅하고 싶다면 <a href="http://www.plop.at/en/bootmanager/plpbt.bin.html">Plop Boot Manager</a>로 부팅시킬 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Bash: .profile, .bash_profile, .bashrc ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/bash-profile.html" />
    <updated>2012-04-21T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/bash-profile.html</id>
    <content type="html">
<![CDATA[
<p>필요할 때마다 Google님께 물어보는 것이 '.profile, .bash_profile, .bashrc'의 차이다. 신기하게도 잘 기억나지 않아서 글로 적어본다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/bash-profile/bash-computer.png" alt="bash-computer" title="" /><br />(from <a href="http://www.gamefudge.com/Bash-the-Computer">bash the computer</a>, 이참에 computer를 한번 bash해보자)</p>

<h2>Ubuntu</h2>

<p>최근 업무에 X windows가 필요해서 백 년 만에 ubuntu Desktop을 vmware에 설치했는데, 이거 웬걸 쓸만하다. 적어도 Windows보다 편하다. 회사에서 보안프로그램만 지원해주면 업무용으로 그냥 Ubuntu Desktop를 쓰고 싶다.</p>

<p>이제 돈 받고 팔아도 되겠다. 12.04가 기대된다. 설치도, 내 취향에 맞춘 설정까지 하루밖에 안 걸린다.</p>

<h2>Login Shell vs Non-login Shell</h2>

<p>먼저 'Login Shell'과 'Non-login Shell' 을 구분해야 하는데, 로그인은 계정과 암호를 입력해서 Shell을 실행하는 것이다. ssh로 접속하거나 로컬에서 GUI에서 로그인한다는 의미다.</p>

<p>'.profile', '.bash_profile'이 Login할 때 로드되는(source) 파일이다. '.profile'은 꼭 bash가 아니더라도 로그인하면 로드되고 '.bash_profile'은 꼭 Bash로 Login할 때 로드된다.</p>

<p>그리고 'Non-login Shell'은 로그인 없이 실행하는 Shell을 말한다. ssh로 접속하고 나서 다시 bash를 실행하는 경우나. GUI 세션에서 터미널을 띄우는 것이 이해 해당한다. 'sudo bash'나 'su' 같은 것도 이에 해당한다.</p>

<p>'.bashrc'는 로그인 없이 Bash가 실행될 때 로드된다. 'sudo bash'나 'su'로 root 권한을 얻으려 bash를 실행할 때도 이 파일이 로드된다.</p>

<p>정리:</p>

<ul>
<li>'.profile' - 로그인할 때 로드된다. PATH처럼 로그인할 때 로드해야 하는데 bash와 상관없는 것들을 여기에 넣는다.</li>
<li>'.bash_profile' - 로그인할 때 로드된다. 'bash completion'이나 'nvm'같이 로그인할 때 로드해야 하는데 Bash와 관련된 것이면 여기에 넣는다. </li>
<li>'.bashrc' - 로그인하지 않고 Bash가 실행될 때마다 로드된다.</li>
</ul>

<h2>bash-it</h2>

<p>나는 Bash 프레임워크인 <a href="https://github.com/revans/bash-it">bash-it</a>을 사용하는데, 그냥 터미널에서 ssh로 접속하기만 할 때는 '.bash_profile'에만 넣어주는 걸로 충분했다. 그런데 Desktop으로 쓸려니 로그인 없이 Bash를 실행할 일이 많아서 '.bashrc'에 넣어줘야 했다:</p>

<pre><code>if [ -f "~/.bash_profile" ]; then
    . ~/.bash_profile
fi
</code></pre>

<p>그런데 'sudo bash'를 실행할 때도 bash-it이 로드돼서 root가 아닐 때만 로드되게 했다:</p>

<pre><code>if [ "$USER" != "root" ] &amp;&amp; [ -f "~/.bash_profile" ]; then
    . ~/.bash_profile
fi
</code></pre>

<p>꼭 터미널을 열고 Bash를 띄울 때만 bash-it을 사용하고 싶은데 GUI 세션에 로그인할 때도 실행되는 느낌이다. 이것도 확인해봐야 하는데,</p>

<h2>Mac</h2>

<p>사실 Mac에서 한 번도 'Login Bash'같은 컨셉에 대해 생각해본 적 없다. 그러니까 Bash를 실행할 때 로그인해 본 적 없다. Mac에 ssh로 접속한 적도 없다. 그러니까 Mac에서는 .bash_profile과 .bashrc를 구분해 사용하려고 생각한 적이 없다.</p>

<p>그래서 더 헷갈린다. Mac에서는 터미널을 열어도 '.bash_profile'이 로드된다. 'sudo bash'할 때나 그냥 'bash'를 실행시켰을 때에는 로드하지 않는 것으로 봐서 여태껏 얘기한 것에서 크게 벗어나는 것 같진 않다. 그냥 조금 다르다.</p>

<p>이를테면 '터미널을 연다는 것은 로그인하면서 Bash를 실행시키는 것'이라고 보면 된다. 터미널을 열 때에도 '.bash_profile'이 로드되지만, bash를 그냥 실행시킬 때는 '.bash_profile'은 로드하지 않는다.</p>

<h2>.bash_login, .bash_logout, .bash_complete ...</h2>

<p>그 외 파일이 많은데 별로 중요하지도 않고 필요하다고 생각해본 적 없어서 정리하지 않았다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ J언어 배우기 - 제 2장: 리스트와 테이블 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/learning-j-chapter2.html" />
    <updated>2012-04-17T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/learning-j-chapter2.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://www.jsoftware.com/docs/help701/learning/contents.htm">Learning J</a>의 Chapter2 를 번역했다. 이번엔 리스트와 테이블에 관한 내용이다. 굉장히 기초적이고 중요한 내용이다. 특히 배열의 차원(dimension)에 관한 이야기는 나중에 나올 랭크라는 개념을 이해하기 위한 초석이므로 예제들을 잘 봐야 한다. 눈에 보이는 데이터가 같다고 해서 같은 데이터가 아니라는 것도 중요하다. 지금 말하고 있는 게 무슨 말인지 모르겠다면 이번 챕터를 읽도록 하자.</p>

<p>자 시작하자.</p>

<p><img src="http://dogfeet.github.com/articles/2012/learning-j-chapter2/j-code.png" alt="j-code" title="" /></p>

<p>계산(computation)을 하려면 데이터가 필요하다. 지금까지 단일 숫자와 숫자 리스트로 된 데이터만을 다뤘다. 하지만 테이블 같은, 다른 형태를 가진 데이터도 생각해볼 수 있다. 그런 데이터 즉, 리스트나 테이블들을 "배열"(Array)이라고 한다.</p>

<h2>2.1 테이블</h2>

<p>2행 3열 테이블은 <code>$</code>함수로 만든다.</p>

<pre><code>   table =: 2 3   $   5 6 7  8 9 10
   table
5 6  7
8 9 10
</code></pre>

<p>위 예제는 <code>x $ y</code>라는 표현식으로 테이블을 만드는 것을 보여준다. x는 테이블의 차원(dimensions)을 결정한다. x는 행의 개수 다음에 열의 개수가 오는 리스트의 형태이다. 테이블은 y의 내용으로 채워진다.<br />y의 아이템을 순서대로 가져와서 첫 번째 행을 채우고 다음에는 두 번째 행을 채워나간다. 행이 더 있으면 계속 y의 아이템을 가져와 순서대로 채운다. y는 적어도 하나 이상의 아이템을 가지고 있어야만 한다. 만약 y의 아이템 개수가 테이블을 채우기 부족하다면 y의 처음부터 재사용한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>2 4 $ 5 6 7 8 9</tt></td>
<td><tt>2 2 $ 1</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6 7 8<br>
9 5 6 7</tt></td>
<td><tt>1 1<br>
1 1</tt></td>
</tr></tbody></table>

<p><code>$</code>함수는 한가지 방식으로만 테이블을 만든다. 더 많은 방식을 보고 싶다면 5장을 참고하시라.</p>

<p>우리가 배웠던 함수들은 이전에 리스트 데이터에서도 그랬듯이 테이블 데이터에도 정확하게 똑같이 적용된다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>table  </tt></td>
<td><tt>10 * table</tt></td>
<td><tt>table + table</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6&nbsp;&nbsp;7<br>
8 9 10</tt></td>
<td><tt>50 60&nbsp;&nbsp;70<br>
80 90 100</tt></td>
<td><tt>10 12 14<br>
16 18 20</tt></td>
</tr></tbody></table>

<p>한 인자는 테이블, 또 다른 인자는 리스트인 경우도 가능하다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>table</tt></td>
<td><tt>0 1 * table</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6&nbsp;&nbsp;7<br>
8 9 10</tt></td>
<td><tt>0 0&nbsp;&nbsp;0<br>
8 9 10</tt></td>
</tr></tbody></table>

<p>바로 위 예제에서, 리스트 <code>0 1</code>의 각 아이템은 자동으로 테이블의 행과 매칭되었다. 0은 첫 번째 행과 1은 두 번째 행과 매칭되었다. 다른 패턴들도 이런 식으로 매칭될 수 있다. 더 보려면 7장을 보면 된다.</p>

<h2>2.2 배열</h2>

<p>테이블은 차원이 2이다. (행과 열) 비슷하게, 리스트는 1차원이라고 말할 수 있다.<br />2개 이상의 차원을 가진 테이블 형 데이터 오브젝트도 있다. 그런 의미에서 <code>$</code>함수의 왼쪽 인자는 차원의 개수를 가지는 리스트라고도 말할 수 있다. "배열"이라는 단어는 차원을 가진 데이터 오브젝트를 가리키는 일반적인 말이다. 아래에는 1차원, 2차원, 3차원의 배열에 대한 예제이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>3 $ 1</tt></td>
<td><tt>2 3 $ 5 6 7</tt></td>
<td><tt>2 2 3 $ 5 6 7 8</tt></td>
</tr><tr valign="TOP">
<td><tt>1 1 1</tt></td>
<td><tt>5 6 7<br>
5 6 7</tt></td>
<td><tt>5 6 7<br>
8 5 6<br>
<br>
7 8 5<br>
6 7 8</tt></td>
</tr></tbody></table>

<p>위 예제의 3차원 배열은 2면, 2행, 3열로 이루어져 있다. 두 개의 면은 위아래 차례대로 출력되었다.</p>

<p>모나딕 <code>#</code>함수로 리스트의 길이를 알 수 있는 것을 상기하자.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt># 6 7</tt></td>
<td><tt># 6 7 8</tt></td>
</tr><tr valign="TOP">
<td><tt>2</tt></td>
<td><tt>3</tt></td>
</tr></tbody></table>

<p>모나딕 <code>$</code>함수로는 인자의 차원 리스트를 알 수 있다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>L =: 5 6 7</tt></td>
<td><tt>$ L</tt></td>
<td><tt>T =: 2 3 $ 1</tt></td>
<td><tt>$ T</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6 7</tt></td>
<td><tt>3</tt></td>
<td><tt>1 1 1<br>
1 1 1</tt></td>
<td><tt>2 3</tt></td>
</tr></tbody></table>

<p>그러므로 만약 x가 배열이라면 <code># $ x</code>라는 표현식은 x의 차원 리스트의 길이, 즉 x의 차원 개수를 내뱉는다. 차원의 개수가 1이면 리스트, 2이면 테이블인 식이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> L </tt></td>
<td><tt>$ L </tt></td>
<td><tt> # $ L</tt></td>
<td><tt> T </tt></td>
<td><tt>$T</tt></td>
<td><tt># $ T</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6 7</tt></td>
<td><tt>3</tt></td>
<td><tt>1</tt></td>
<td><tt>1 1 1<br>
1 1 1</tt></td>
<td><tt>2 3</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<p>만약 x가 단일 숫자라면 <code># $ x</code>는 0이다.</p>

<pre><code>   # $ 17
0
</code></pre>

<p>테이블은 2차원이고 리스트가 1차원이므로 단일 수는 차원이 없다라고 말할 수 있다. 단일수의 차원 수는 0이기 때문이다.(위 코드의 결과가 그 근거이다) 차원 수가 0인 데이터 오브젝트는 스칼라(scalar)라고 한다. 위에서 "배열"을 어떤 차원을 가지고 있는 데이터 오브젝트로 정의했었다. 그렇다면 스칼라 또한 배열이다. 다만 차원이 0일 뿐이다.</p>

<p>우리는 위에서 <code># $ 17</code>이 0임을 확인했다. 여기서 이런 결론을 도출할 수 있을 것이다. 스칼라가 차원을 가지고 있지 않기 때문에, (<code>$ 17</code>의 결과물로써의) 차원 리스트는 길이가 0이거나 비어있는 리스트여야만 한다. 이제 2의 길이를 가진 리스트는 <code>2 $ 99</code> 와 같은 코드를 이용해서 만들어 낼 수 있다. 그리고 길이가 0인 빈 리스트는 <code>0 $ 99</code> 같은 코드로 만들어 낼 수 있겠다. (사실 99대신 아무 숫자나 쓰여도 된다.)</p>

<p>빈 리스트의 값은 표시되지 않는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>2 $ 99</tt></td>
<td><tt>0 $ 99</tt></td>
<td><tt> $ 17</tt></td>
</tr><tr valign="TOP">
<td><tt>99 99</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>&nbsp;</tt></td>
</tr></tbody></table>

<p>스칼라(예를 들면 <code>17</code>)는 길이가 1인 리스트(예를 들면 <code>1 $ 17</code>) 와는 다르다. 또 1행 1열짜리인 테이블(예를 들면 <code>1 1 $ 17</code>)과도 다르다. 스칼라는 차원이 없다. 리스트는 차원이 하나, 테이블은 두 개 이다. 하지만 세 개 모두 화면에는 똑같이 보인다.</p>

<pre><code>   S =: 17
   L =: 1 $ 17
   T =: 1 1 $ 17
</code></pre>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> S </tt></td>
<td><tt> L </tt></td>
<td><tt> T </tt></td>
<td><tt># $ S</tt></td>
<td><tt># $ L</tt></td>
<td><tt># $ T</tt></td>
</tr><tr valign="TOP">
<td><tt>17</tt></td>
<td><tt>17</tt></td>
<td><tt>17</tt></td>
<td><tt>0</tt></td>
<td><tt>1</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<p>하나의 열을 가진 테이블도 여전히 2차원 테이블이다. 아래에 3행 1열의 <code>t</code>가 있다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>t =: 3 1 $ 5 6 7</tt></td>
<td><tt>$ t</tt></td>
<td><tt># $ t</tt></td>
</tr><tr valign="TOP">
<td><tt>5<br>
6<br>
7</tt></td>
<td><tt>3 1</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<h2>2.3 용어: 랭크와 모양(Rank and Shape)</h2>

<p>"차원 수"라고 부르는 속성은 J에서는 짧게 줄여 "랭크(Rank)"라고 한다. 그래서 단일 숫자는 랭크-0 배열(rank-0 array)이라고 부르고, 리스트는 랭크-1 배열이라고 한다. 차원 리스트는 "모양(Shape)"이라고 한다.<br />수학 용어에서 "벡터(Vector)"와 "매트릭스(Matrix)"는 위에서 말했던 "리스트"와 "테이블"과 관련이 있다. 3차원 이상의 배열(아, 이제는 랭크 3이상의 배열 이라고 하겠다.)은 "리포트(Report)"라고 한다.</p>

<p>아래 테이블에 배열에 대한 용어와 함수들을 정리해놓았다.</p>

<pre><code>+--------+--------+-----------+------+
|        | Example| Shape     | Rank |
+--------+--------+-----------+------+
|        | x      | $ x       | # $ x|
+--------+--------+-----------+------+
| Scalar | 6      | empty list| 0    |
+--------+--------+-----------+------+
| List   | 4 5 6  | 3         | 1    |
+--------+--------+-----------+------+
| Table  |0 1 2   | 2 3       | 2    |
|        |3 4 5   |           |      |
+--------+--------+-----------+------+
| Report |0  1  2 | 2 2 3     | 3    |
|        |3  4  5 |           |      |
|        |        |           |      |
|        |6  7  8 |           |      |
|        |9 10 11 |           |      |
+--------+--------+-----------+------+
</code></pre>

<p>위 테이블은 사실 J로 짠 프로그램의 출력물이다. 게다가 저건 위에 작은 챕터를 할애해서 말했던 자료구조인 진짜 "테이블"이다. 이 테이블의 모양은 <code>6 4</code>이다. 하지만 이건 숫자로만 이루어진 테이블이 아니라 문자도 있고, 리스트도 담고 있다. 그럼 이제 숫자가 아닌 걸로 이루어진 배열을 살펴보자</p>

<h2>2.4 문자로 이루어진 배열</h2>

<p>문자는 알파벳, 구두점, 숫자 등을 말한다. 숫자로 배열을 만들었듯이 문자로도 배열을 만들 수 있다. 문자의 리스트를 만들려면 작은따옴표 안에 문자들을 넣으면 된다. 하지만 결과 화면에 출력될 때는 작은따옴표는 보이지 않는다. 예를 들자면 아래와 같다.</p>

<pre><code>   title =: 'My Ten Years in a Quandary'
   title
My Ten Years in a Quandary
</code></pre>

<p>문자의 리스트는 문자열(string)이라고 한다. 문자열 안의 작은따옴표를 넣으려면 작은따옴표를 연속 두 번 타이핑 한다.</p>

<pre><code>   'What''s new?'
What's new?
</code></pre>

<p>빈 문자열이나 길이가 0인 문자열을 나타내려면 연속된 두 개의 작은 따옴표를 타이핑한다. 이건 화면에 보이지 않는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> '' </tt></td>
<td><tt># '' </tt></td>
</tr><tr valign="TOP">
<td><tt>&nbsp;</tt></td>
<td><tt>0</tt></td>
</tr></tbody></table>

<h2>2.5 배열에 사용되는 함수</h2>

<p>이 장에서는 배열을 다루는 몇 가지 유용한 함수들을 알아보도록 한다. J는 매우 다양한 함수들을 가진 언어이다. 한번 살펴보자.</p>

<h3>2.5.1 합치기</h3>

<p>내장 함수인 <code>,</code>는 "Append"라고 한다. 이 함수는 여러 개의 요소를 붙여서 리스트를 만든다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>a =: 'rear'</tt></td>
<td><tt>b =: 'ranged'</tt></td>
<td><tt>a,b</tt></td>
</tr><tr valign="TOP">
<td><tt>rear</tt></td>
<td><tt>ranged</tt></td>
<td><tt>rearranged</tt></td>
</tr></tbody></table>

<p>"Append" 함수는 리스트나 아이템 하나를 합친다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>x =: 1 2 3</tt></td>
<td><tt>0 , x </tt></td>
<td><tt>x , 0 </tt></td>
<td><tt>0 , 0</tt></td>
<td><tt>x , x </tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3</tt></td>
<td><tt>0 1 2 3</tt></td>
<td><tt>1 2 3 0</tt></td>
<td><tt>0 0</tt></td>
<td><tt>1 2 3 1 2 3</tt></td>
</tr></tbody></table>

<p>"Append" 함수는 두 개의 테이블의 양 끝을 합쳐서 더 긴 테이블을 만들 수도 있다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T1=: 2 3 $ 'catdog'</tt></td>
<td><tt>T2=: 2 3 $ 'ratpig'</tt></td>
<td><tt>T1,T2</tt></td>
</tr><tr valign="TOP">
<td><tt>cat<br>
dog</tt></td>
<td><tt>rat<br>
pig</tt></td>
<td><tt>cat<br>
dog<br>
rat<br>
pig</tt></td>
</tr></tbody></table>

<p>"Append"에 대한 더 많은 정보를 원하면 5장을 보라.</p>

<h3>2.5.2 아이템</h3>

<p>숫자로 이루어진 리스트의 아이템은 각각이 숫자다. 그리고 테이블의 아이템은 그 테이블의 행이라고 한다. 3차원 배열의 아이템은 그 배열의 평면이다. 일반적으로 말해서 아이템이라 함은 배열의 첫 번째 차원을 따라 늘어서 있는 요소들의 연속이다. 배열은 아이템으로 이루어진 리스트이다.<br /><code>#</code>("Tally")함수가 리스트의 길이를 반환한다고 했었다. 아래를 보자</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>x</tt></td>
<td><tt> # x</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3</tt></td>
<td><tt>3</tt></td>
</tr></tbody></table>

<p>일반적으로 <code>#</code>는 배열의 아이템 개수, 즉 첫 번째 차원의 크기를 잰다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T1</tt></td>
<td><tt>$ T1</tt></td>
<td><tt># T1</tt></td>
</tr><tr valign="TOP">
<td><tt>cat<br>
dog</tt></td>
<td><tt>2 3</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<p>확실히 <code># T1</code>은 차원 리스트인 <code>$ T1</code>의 첫 번째 아이템이다. 차원이 없는 스칼라는 단일 아이템으로 취급한다.</p>

<pre><code>   # 6
1
</code></pre>

<p>밑에 있는 "Append"의 예를 다시 보자.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T1</tt></td>
<td><tt>T2</tt></td>
<td><tt>T1 , T2</tt></td>
</tr><tr valign="TOP">
<td><tt>cat<br>
dog</tt></td>
<td><tt>rat<br>
pig</tt></td>
<td><tt>cat<br>
dog<br>
rat<br>
pig</tt></td>
</tr></tbody></table>

<p>이제 <code>x , y</code>의 의미를 <code>x</code>의 아이템 다음에 <code>y</code>의 아이템이 오는 리스트라고 일반화시켜 말할 수 있겠다.</p>

<p>"아이템"을 잘 이용하기 위한 다른 예제로 <code>+/</code> 함수가 있다. <code>+/</code>는 +를 리스트의 아이템 사이사이에 끼워 넣는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>+/ 1 2 3</tt></td>
<td><tt>1 + 2 + 3</tt></td>
</tr><tr valign="TOP">
<td><tt>6</tt></td>
<td><tt>6</tt></td>
</tr></tbody></table>

<p>일반적으로는 <code>+/</code>는 <code>+</code>를 배열의 아이템 사이에 끼워 넣는다. (리스트의 아이템 사이가 아니다.) 다음 예제는 아이템이 단일 숫자가 아니라 테이블의 행인 경우이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T =: 3 2 $ 1 2 3 4 5 6</tt></td>
<td><tt>+/ T</tt></td>
<td><tt>1 2 + 3 4 + 5 6</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2<br>
3 4<br>
5 6</tt></td>
<td><tt>9 12</tt></td>
<td><tt>9 12</tt></td>
</tr></tbody></table>

<h3>2.5.3 선택하기</h3>

<p>이제 리스트에서 아이템을 선택하는 방법을 알아보자. 리스트에서 아이템의 위치는 0, 1, 2... 로 숫자를 매긴다. 첫 번째 아이템의 위치는 0이다.(10번째 아이템의 위치는 9이다.) 위치 정보를 가지고 아이템을 선택하기 위해서는 <code>{</code>("From") 함수를 사용한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Y =: 'abcd'</tt></td>
<td><tt>0 { Y</tt></td>
<td><tt>1 { Y</tt></td>
<td><tt>3 { Y</tt></td>
</tr><tr valign="TOP">
<td><tt>abcd</tt></td>
<td><tt>a</tt></td>
<td><tt>b</tt></td>
<td><tt>d</tt></td>
</tr></tbody></table>

<p>위치를 나타내는 숫자는 "인덱스"라고 한다. <code>{</code>함수는 왼쪽 인자에 인덱스로써 단일수나 숫자 리스트를 받는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> Y</tt></td>
<td><tt> 0 { Y</tt></td>
<td><tt> 0 1 { Y</tt></td>
<td><tt> 3 0 1 { Y</tt></td>
</tr><tr valign="TOP">
<td><tt>abcd</tt></td>
<td><tt>a</tt></td>
<td><tt>ab</tt></td>
<td><tt>dab</tt></td>
</tr></tbody></table>

<p><code>i.</code> 라는 내장 함수도 있다. 표현식 <code>i. n</code>은 크기가 n인 0부터 순서대로 커지는 양의 정수의 리스트를 생성한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>i. 4</tt></td>
<td><tt>i. 6</tt></td>
<td><tt>1 + i. 3</tt></td>
</tr><tr valign="TOP">
<td><tt>0 1 2 3</tt></td>
<td><tt>0 1 2 3 4 5</tt></td>
<td><tt>1 2 3</tt></td>
</tr></tbody></table>

<p>만약 x가 리스트라면 <code>i. # x</code>라는 표현식은 x에서 사용할 수 있는 모든 인덱스의 리스트를 만들어낸다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>x =: 'park'</tt></td>
<td><tt># x</tt></td>
<td><tt>i. # x</tt></td>
</tr><tr valign="TOP">
<td><tt>park</tt></td>
<td><tt>4</tt></td>
<td><tt>0 1 2 3</tt></td>
</tr></tbody></table>

<p><code>i.</code>의 인자로 리스트가 들어오면 배열이 만들어진다.</p>

<pre><code>   i. 2 3
0 1 2
3 4 5
</code></pre>

<p><code>i.</code>를 다이아딕으로 사용하면 이때는 <code>i.</code>를 "Index Of"라고 한다. <code>x i. y</code>라는 표현식은 x에 있는 y의 위치를 찾아낸다.</p>

<pre><code>   'park' i. 'k'
3
</code></pre>

<p>찾은 인덱스는 x에서 y가 처음으로 발견된 위치이다.</p>

<pre><code>   'parka' i. 'a'
1
</code></pre>

<p>x에 y가 없다면 마지막 위치보다 1 큰 수를 반환한다.</p>

<pre><code>   'park' i. 'j'
4
</code></pre>

<p>인덱싱에 대해 더 많은 것을 알고 싶다면 챕터 6을 보라.</p>

<h3>2.5.4 같음과 매칭(Equality and Matching)</h3>

<p>두 배열이 같은지 알아봐야 하는 상황이라면 내장 함수인 <code>-:</code>("Match")를 사용하면 된다. 이 함수는 두 개의 인자가 같은 모양, 같은 값을 가졌는지 검사한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>X =: 'abc'</tt></td>
<td><tt>X -: X</tt></td>
<td><tt>Y =: 1 2 3 4</tt></td>
<td><tt>X -: Y</tt></td>
</tr><tr valign="TOP">
<td><tt>abc</tt></td>
<td><tt>1</tt></td>
<td><tt>1 2 3 4</tt></td>
<td><tt>0</tt></td>
</tr></tbody></table>

<p>인자가 뭐든 간에 함수의 결과 값은 0 아니면 1이다.</p>

<p>빈 문자 리스트와 빈 숫자 리스트는 같다는 건 알아두어야 한다.</p>

<pre><code>   '' -: 0 $ 0
1
</code></pre>

<p>이 둘의 모양은 같고 모든 매핑되는 요소의 값들이 같기 때문에 위 식은 참이다. (물론 요소가 없긴 하다.)<br /><code>=</code>("Equal")라는 함수도 있다. 이 함수는 주어진 두 인자가 같은지를 확인한다. <code>=</code>는 매핑되는 각 요소의 값이 같은지 확인해서 요소와 같은 모양의 불리언 배열을 반환한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Y</tt></td>
<td><tt>Y = Y</tt></td>
<td><tt>Y = 2</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3 4</tt></td>
<td><tt>1 1 1 1</tt></td>
<td><tt>0 1 0 0</tt></td>
</tr></tbody></table>

<p>결론적으로 <code>=</code>가 가지는 두 인자는 반드시 같은 모양이어야 한다. (아니면 적어도, <code>Y=2</code>의 경우와 같이 호환되는 모양이어야 한다) 그렇지 않으면 에러가 발생한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Y</tt></td>
<td><tt>Y = 1 5 6 4</tt></td>
<td><tt>Y = 1 5 6</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3 4</tt></td>
<td><tt>1 0 0 1</tt></td>
<td><tt>error</tt></td>
</tr></tbody></table>

<h2>2.6 박스의 배열(Arrays of Boxes)</h2>

<h3>2.6.1 연결하기</h3>

<p><code>;</code>("Link")라는 내장 함수가 있다. 이 함수는 두 인자를 리스트의 형태로 연결한다. 두 인자는 다른 것 이어도 된다. 예를 들어 문자열과 숫자를 연결 할수 있다.</p>

<pre><code>   A =: 'The answer is'  ;  42
   A
+-------------+--+
|The answer is|42|
+-------------+--+
</code></pre>

<p>위 에서 A는 길이가 2인 리스트이다. 그리고 이 리스트는 박스의 리스트라고 한다. 첫 번째 박스 안에는 문자열 'The answer is'가 들어있고 두 번째 박스에는 숫자 42가 있다. 박스는 화면에 사각형으로 그려지고 안에 그 박스의 값을 담고 있는 형태로 그려진다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> A </tt></td>
<td><tt> 0 { A</tt></td>
</tr><tr valign="TOP">
<td><tt>+-------------+--+<br>
|The answer is|42|<br>
+-------------+--+</tt></td>
<td><tt>+-------------+<br>
|The answer is|<br>
+-------------+</tt></td>
</tr></tbody></table>

<p>박스 하나는 안에 있는 값이 무엇이든 간에 스칼라로 취급한다. 박스는 그 안에 일반적인 배열(예를 들면 숫자로 이루어진 리스트 같은 거)을 넣을 수 있다. 따라서 A는 스칼라의 리스트이다. (A의 아이템들은 각각이 스칼라는 말이다.)</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> A </tt></td>
<td><tt>$ A</tt></td>
<td><tt>s =: 1 { A</tt></td>
<td><tt> # $ s</tt></td>
</tr><tr valign="TOP">
<td><tt>+-------------+--+<br>
|The answer is|42|<br>
+-------------+--+</tt></td>
<td><tt>2</tt></td>
<td><tt>+--+<br>
|42|<br>
+--+</tt></td>
<td><tt>0</tt></td>
</tr></tbody></table>

<p>박스로 이루어진 배열의 주목적은 다른 종류의 값들을 하나의 변수에 집어넣는 것이다. 예를 들어 구입 한 물건의 자세한 사항들(구매 날짜, 가격, 설명)을 담은 변수는 박스의 리스트로 나타낼 수 있다.</p>

<pre><code>   P =: 18 12 1998  ;  1.99  ;  'baked beans'
   P
+----------+----+-----------+
|18 12 1998|1.99|baked beans|
+----------+----+-----------+
</code></pre>

<p>"Link"와 "Append"의 차이점에 주목해야 한다. "Link"가 다른 종류의 값들을 합치는 반면 "Append"가 합치는 값들은 언제나 같은 종류이다. 즉 "Append" 함수에 주어지는 두 인자는 반드시 둘 다 숫자로 이루어진 배열이거나 둘 다 문자로 이루어진 배열이어야 한다. 아니면 둘 다 박스로 이루어진 배열이어야 한다. 그게 아니면 에러가 난다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>'answer is'; 42</tt></td>
<td><tt>'answer is' , 42</tt></td>
</tr><tr valign="TOP">
<td><tt>+---------+--+<br>
|answer is|42|<br>
+---------+--+</tt></td>
<td><tt>error</tt></td>
</tr></tbody></table>

<p>문자열과 숫자를 연결해야 할 때가 있을 수 있다. 예를 들자면 어떤 결과 값과 그에 대한 설명은 같이 보여줘야 할 때가 있다. 그 때 위에서 봤듯이 문자열과 숫자를 "연결(Link)"할 수 있다. 하지만 더 부드러운 표현은 숫자를 문자열로 바꿔서 두 문자열을 연결하는 방식으로 처리하는 것이다. 그러면 결과물은 박스의 리스트가 아니라 문자열이 된다.</p>

<p>숫자를 문자열로 바꾸는 것은 내장 함수인 <code>":</code>("Format")을 이용한다. 아래 예제에서 n은 단일 숫자이고 s는 n을 포맷해서 만든 문자열이다. s는 길이가 2이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>n =: 42</tt></td>
<td><tt>s =: ": n</tt></td>
<td><tt># s</tt></td>
<td><tt>'answer is ' , s</tt></td>
</tr><tr valign="TOP">
<td><tt>42</tt></td>
<td><tt>42</tt></td>
<td><tt>2</tt></td>
<td><tt>answer is 42</tt></td>
</tr></tbody></table>

<p>"Format"에 대해서 더 알고 싶다면 19장을 보면 된다. 다시 박스로 돌아가도록 하자. 박스는 값이 상자로 둘러싸고 있는 형태이기 때문에, 박스가 화면에 보일 때에는 간단한 표의 형태로 보인다.</p>

<pre><code>   p =: 4 1 $ 1 2 3 4
   q =: 4 1 $ 3 0 1 1

   2 3 $ ' p ' ; ' q ' ; ' p+q ' ;  p ; q ; p+q
+---+---+-----+
| p | q | p+q |
+---+---+-----+
|1  |3  |4    |
|2  |0  |2    |
|3  |1  |4    |
|4  |1  |5    |
+---+---+-----+
</code></pre>

<h3>2.6.2 박싱과 언박싱(Boxing and Unboxing)</h3>

<p><code>&lt;</code>("Box")라는 내장 함수가 있다. 이 함수는 인자로 들어온 값을 감싸 하나의 박스를 만든다.</p>

<pre><code>   &lt; 'baked beans'
+-----------+
|baked beans|
+-----------+
</code></pre>

<p>박스는 숫자를 담을 수 있지만, 그 자체로 숫자는 아니다. 박스 안에 있는 값으로 계산 하려면 박스를 열어서 값을 꺼내야 한다. <code>&gt;</code> 함수가 바로 그런 것이다. 이 함수는 "Open"이라고 한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>b =: &lt; 1 2 3</tt></td>
<td><tt>&gt; b</tt></td>
</tr><tr valign="TOP">
<td><tt>+-----+<br>
|1 2 3|<br>
+-----+</tt></td>
<td><tt>1 2 3</tt></td>
</tr></tbody></table>

<p><code>&lt;</code>를 깔때기 모양의 그림으로 생각하면 이해하기가 쉽다. 데이터가 넓은 쪽으로 흘러들어 가서 좁은 쪽으로 박스에 담겨 나온다. 나온 박스는 스칼라, 즉 차원이 없다. <code>&gt;</code>도 비슷하게 생각하면 된다. 박스가 스칼라이기 때문에 <code>,</code>함수로 각 박스를 리스트로 묶을 수 있다. 하지만 <code>;</code>함수를 쓰는 게 좀 더 편하다. 이 함수는 박스에 담아 연결해주는 작업을 한 번에 해준다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>(&lt; 1 1) , (&lt; 2 2) , (&lt; 3 3)</tt></td>
<td><tt>1 1 ; 2 2 ; 3 3</tt></td>
</tr><tr valign="TOP">
<td><tt>+---+---+---+<br>
|1 1|2 2|3 3|<br>
+---+---+---+</tt></td>
<td><tt>+---+---+---+<br>
|1 1|2 2|3 3|<br>
+---+---+---+</tt></td>
</tr></tbody></table>

<h2>2.7 요약</h2>

<p>결론적으로 J의 모든 데이터 오브젝트는 전부 n 차원 배열(n >= 0)이다. 배열은 숫자로 이루어진 배열일 수도 있고, 문자, 또는 박스로 이루어졌을 수도 있다. (물론 다른 것으로 이루어질 수도 있다.)</p>

<p>2장을 마친다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: Mocha ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-mocha.html" />
    <updated>2012-04-14T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-mocha.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 '<a href="http://dailyjs.com/2011/12/08/mocha/">Testing with Mocha</a>'을 다시 쓴 것이다. <a href="http://alexyoung.org/">Alex Young</a>님이 만든 예제도 내가 쓰기 편하게 좀 고쳤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-mocha/mocha-test.png" alt="mocha-test" title="" /></p>

<p><a href="http://dailyjs.com/2011/12/08/mocha/">Testing with Mocha</a>를 읽고 Mocha 메뉴얼을 읽으니 훨씬 눈에 잘 들어온다.</p>

<h2>Mocha</h2>

<p><a href="http://visionmedia.github.com/mocha/">Mocha</a>는 TJ Holowaychuk이 만든 <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> 프레임워크이다. </p>

<p>이 글에서는 그냥 Mocha로 BDD하는 법에 대해서만 설명한다. 원래 글은 TDD를 하는 법에 대해서 다뤘지만, 다시 정리하면서 BDD로 수정했다. 다른 방법, 다른 프레임워크와의 비교는 @outsider님이 잘 정리해 주었다. @outsider님 <a href="http://blog.outsider.ne.kr/770">블로그 글</a>을 읽어보자. </p>

<h2>package.json</h2>

<p>먼저 package.json 파일을 다음과 같이 만든다.</p>

<pre><code>{
    "name": "async-testing-tutorial"
    , "version": "0.0.1"
    , "description": "A tutorial for Mocha"
    , "keywords": ["test", "tutorial"]
    , "author": "Alex R. Young &lt;<a href='mailto:info@dailyjs.com'>info@dailyjs.com</a>&gt;"
    , "main": "index"
    , "engines": { "node": "&gt;= 0.4.x &lt; 0.7.0" }
    , "scripts": {
        "test": "make test"
    }
    , "devDependencies": {
        "mocha": "1.0.x"
        , "should": "0.6.x"
    }
}
</code></pre>

<p>원래 코드는 assert 모듈과 TDD 스타일로 돼 있었지만, 나는 should와 BDD가 더 직관적이라고 생각하므로 바꿨다.</p>

<p>이를 위해 의존성을 추가한다.: </p>

<pre><code>, "devDependencies": {
    "mocha": "1.0.x"
    , "should": "0.6.x"
}
</code></pre>

<p>이제 <code>npm install</code>하면 해당 모듈이 설치된다.</p>

<h2>Makefile</h2>

<p>다음과 같이 Makefile을 만들고 <code>make test</code>를 실행하면 된다. </p>

<pre><code>test:
    @./node_modules/.bin/mocha --require should

.PHONY: test
</code></pre>

<ul>
<li><code>--require should</code> - 테스트 코드에서 should 모듈을 끼워 넣어 준다. 생략하면 테스트 코드에 <code>require('should')</code>를 직접 넣어 줘야 한다.</li>
<li><code>--reporter dot</code> - 테스트 결과를 어떻게 보여줄지 reporter를 고를 수 있다. 생략 시 기본 값은 <code>dot</code>.</li>
<li><code>--u bdd</code> - 테스트 스타일을 고를 수 있는데. 생략 시 기본 값은 <code>bdd</code>.</li>
</ul>

<p>자세한 옵션은 <a href="http://visionmedia.github.com/mocha/">Mocha</a> 페이지에서 확인한다.</p>

<h2>prime Module</h2>

<p><a href="http://alexyoung.org/">Alex Young</a>님이 작성한 모듈 코드:</p>

<pre><code>function nextPrime(n) {
    var smaller;
    n = Math.floor(n);

    if (n &gt;= 2) {
        smaller = 1;
        while (smaller * smaller &lt;= n) {
            n++;
            smaller = 2;
            while ((n % smaller &gt; 0) &amp;&amp; (smaller * smaller &lt;= n)) {
                smaller++;
            }   
        }   
        return n;
    } else {
        return 2;
    }   
}

function asyncPrime(n, fn) {
    setTimeout(function() {
        fn( nextPrime(n) );
    }, 10);
}

module.exports.nextPrime = nextPrime;
module.exports.asyncPrime = asyncPrime;
</code></pre>

<h2>Test</h2>

<p>BDD 스타일로 작성한 테스트는 다음과 같다.</p>

<pre><code>var nextPrime = require('./../index').nextPrime
var asyncPrime = require('./../index').asyncPrime;

describe('prime', function() {

    describe('nextPrime', function() {

        it('nextPrime should return the next prime number', function() {
            nextPrime(7).should.equal(11);
        }); 

        it('zero and one are not prime numbers', function() {
            nextPrime(0).should.equal(2);
            nextPrime(1).should.equal(2);
        }); 
    }); 

    describe('asyncPrime', function() {

        it('asyncPrime should return the next prime number', function(done) {
            asyncPrime(128, function(n) {
                n.should.equal(131);
                done();
            });
        });
    });
});
</code></pre>

<p>비동기 테스트 예제인 'asyncPrime'은 done()을 호출해서 테스트가 성공했음을 알린다.</p>

<h2>hooks</h2>

<ul>
<li>before() - describe()를 시작하기 전에 한번</li>
<li>after() - describe()를 끝내고 나서 한번</li>
<li>beforeEach() - describe() 안에 있는 it()이 시작할 때마다 한번</li>
<li>afterEach() - describe() 안에 있는 it() 이 끝날 때마다 한번</li>
</ul>

<p>위 테스트코드에 hooks을 추가해보고:</p>

<pre><code>var nextPrime = require('./../index').nextPrime
var asyncPrime = require('./../index').asyncPrime;

describe('prime', function() {

    before(function(){
        console.log('before');
    }); 

    after(function(){
        console.log('after');
    }); 

    beforeEach(function(){
        console.log('beforeEach');
    }); 

    afterEach(function(){
        console.log('afterEach');
    }); 

    describe('nextPrime', function() {
        before(function(){
            console.log('new before');
        }); 

        it('nextPrime should return the next prime number', function() {
            nextPrime(7).should.equal(11);
        }); 

        it('zero and one are not prime numbers', function() {
            nextPrime(0).should.equal(2);
            nextPrime(1).should.equal(2);
        }); 
    }); 

    describe('asyncPrime', function() {
        afterEach(function(){
            console.log('new afterEach');
        });

        it('asyncPrime should return the next prime number', function(done) {
            asyncPrime(128, function(n) {
                n.should.equal(131);
                done();
            });
        });
    });
});
</code></pre>

<p>결과는 다음과 같다:</p>

<pre><code>  before
new before
beforeEach
.afterEach
beforeEach
.afterEach
beforeEach
.new afterEach
afterEach
after


  ✔ 3 tests complete (25ms)
</code></pre>

<p>'new afterEach'나 'new before' 부분에서 스택처럼 동작해서 상위 describe()에 정의한 것은 생략될까 싶었는데, 아니었다. 모두 호출된다.</p>

<p><a href="http://alexyoung.org/">Alex Young</a> 만든 코드는 <a href="https://github.com/alexyoung/async-testing-tutorial">async-testing-tutorial</a>이고 내가 수정한 코드는 <a href="https://github.com/pismute/async-testing-tutorial">async-testing-tutorial-pismute</a>이다.</p>

<p>TDD 스타일로 테스트를 작성하고 assert방식의 expecting을 선호한다면 <a href="http://alexyoung.org/">Alex Young</a>만든 코드를 보는 것이 낫다.</p>]]>
    </content>
  </entry>
</feed>
