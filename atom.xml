<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>개발새발</title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-01-30T14:56:47Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <entry>
    <title>Optimize browser rendering</title>
    <link href="http://dogfeet.github.com/articles/2012/optimize-browser-rendering.html" />
    <updated>2012-01-27T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/optimize-browser-rendering.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>에 있는 <a href="http://code.google.com/speed/page-speed/docs/rendering.html">Optimize browser rendering</a>를 정리한 것이다. 이 글과 이 글에 주렁주렁 달린 글을 모두 독파하면 '한 브라우저 렌더링'한다고 말할 수 있을 것 같다.</p>

<p>브라우저의 특징을 잘 살려서 코딩하면 성능이 빨라진다. 이 글은 다음과 같은 주제에 대해 설명한다:</p>

<ul>
<li>효율적인 CSS 셀렉터</li>
<li>CSS Expression 안 쓰기</li>
<li>CSS는 Document head에 넣기</li>
<li>이미지 크기 명시하기</li>
<li>Charset 명시하기</li>
</ul>

<p><img src="http://dogfeet.github.com/articles/2012/optimize-browser-rendering/google-page-speed.png" alt="google-page-speed" title="" /></p>

<h2>효율적인 CSS 셀렉터</h2>

<p>찾아볼 엘리먼트가 많은 셀렉터만 사용치 않아도 렌더링 성능이 대폭 향상된다.</p>

<p>브라우저는 HTML을 파싱하는 대로 화면에 표시할 엘리먼트를 모두 생성하면서 내부에 도큐먼트 트리를 만든다. 브라우저의 CSS 엔진은 정해진 규칙에 따라 엘리먼트마다 맞는 스타일이 있는지 찾는다. 그 규칙은 표준 CSS cascade, 상속, 정열 규칙에 따른다. "셀렉터"는 어떤 엘리먼트에 스타일을 적용할지를 나타내는 것인데 CSS 엔진은 제일 오른쪽에 있는 셀렉터부터 찾는다. 가장 오른쪽에 있는 셀렉터를 "Key 셀렉터"라고 부르고 필요한 스타일을 찾거나 못 찾을 때까지 계속 Evaluate한다.</p>

<p>이런 시스템이라서 Rule이 적을수록 성능이 좋다. 그러니까 <a href="http://code.google.com/speed/page-speed/docs/payload.html#RemoveUnusedCSS">사용하지 않는 CSS</a>를 삭제하는 것만으로도 성능이 대폭 향상된다. 일단 안 쓰는 CSS를 모두 삭제하고 나서 엘리먼트나 CSS Rule이 많은 페이지를 최적화한다. CSS Rule을 손보는 것만으로도 성능을 향상시킬 수 있다. Rule을 가능한 정확하게 만들고 불필요한 군더더기를 제거하는 게 최적화의 핵심이다. 그래서 스타일 엔진이 사용하지도 않을 Rule까지도 일일이 검사하지 않게끔 해야 한다.</p>

<h4>Descendant 셀렉터</h4>

<pre class="prettyprint"><code>ul li a {...}
</code></pre>

<p>Descendant 셀렉터는 비효율적이다. 브라우저는 Key를 찾고 나서 정확히 일치하는 것을 찾거나 더는 찾을 수 없을 때까지 그 상위 DOM 트리를 전부 뒤진다. Key가 덜 구체적일수록 Evaluate해 봐야 하는 엘리먼트의 수는 많아진다.</p>

<h4>Child 셀렉터</h4>

<pre class="prettyprint"><code>ul &gt; li &gt; a {...}
</code></pre>

<p>Child 셀렉터도 비효율적이다. 브라우저가 엘리먼트를 Evaluate할 때마다 노드를 하나 더 Evaluate해야 한다. 다시 말해서 Child 셀렉터를 사용한 Rule은 비용이 두 배 더 든다. 게다가 Key 셀렉터가 가리키는 엘리먼트가 많을수록 더 많은 엘리먼트를 Evaluate해야 한다. 비효율적이지만 Descendant 셀렉터 보다는 훨씬 빨라서 꽤 사용되는 편이다.</p>

<h4>쓸데없이 셀렉터를 더 사용할 때</h4>

<pre class="prettyprint"><code>ul#top_blue_nav {...}
</code></pre>

<p>정의에 따르면 ID 셀렉터는 중복될 수 없다. 그래서 class나 tag 셀렉터와 함께 사용하면 필요 없는 Evaluate을 추가로 하게 만든다. 노파심을 달래줄 뿐 하지 않아도 될 Evaluate만 더 하는 것이다.</p>

<h4>Pseudo 셀렉터 <code>:hover</code>를 링크가 아닌 엘리먼트에 사용할 때</h4>

<pre class="prettyprint"><code>.foo:hover {...}
</code></pre>

<p><code>:hover</code> 셀렉터를 Non-anchor 엘리먼트에 사용하면 <a href="http://connect.microsoft.com/IE/feedback/ViewFeedback.aspx?FeedbackID=391387">IE7, IE8는 느려질 때가 있다</a>고 알려졌다. Strict Doctype을 사용하지 않을 때 IE7, IE8은 Non-Anchor 엘리먼트에 사용된 <code>:hover</code>를 무시한다. 하지만, Strict Doctype이 사용할 때 Non-Anchor 엘리먼트에 <code>:hover</code>를 사용하면 성능을 저하된다.</p>

<h3>기억할 것.</h3>

<ul>
<li><p>Universal 셀렉터를 Key로 사용하지 말 것.</p>

<ul><li>여러 가지 엘리먼트에 적용해야 할 때는 Class 셀렉터를 사용하자.</li></ul></li>
<li><p>가능한 구체적으로 사용하라.</p>

<ul><li>Tag 셀렉터 보다는 ID나 Class 셀렉터를 사용하라.</li></ul></li>
<li><p>Redundant Qualifier를 제거할 것.</p>

<ul><li>ID 셀렉터와 Tag, Class 셀렉터를 사용하지 말 것.</li>
<li>Class 셀렉터에 추가로 Tag 셀렉터를 사용하지 말 것.</li></ul></li>
<li><p>Descendant 셀렉터를 사용하지 말 것 - 특히 Redundant 때문에 Ancestor를 명시하지 말 것.</p>

<ul><li><code>body ul li a</code> 같은 Rule에서 body는 Redundant 때문에 사용한 것인데 아무 의미 없다.</li></ul></li>
<li><p>Descendant 셀렉터 대신 Class 셀렉터를 사용하라.</p>

<ul><li><code>ul li {color: blue;}</code> 이런 스타일은 <code>.unordered-list-item {color: blue;}</code>으로 바꾼다.</li>
<li><code>ol li {color: red;}</code> 이런 스타일은 <code>.ordered-list-item {color: red;}</code>으로 바꾼다.</li></ul></li>
<li><p>Descendant 셀렉터를 사용할 바에는 Child 셀렉터를 사용해라.</p>

<ul><li>여러 단계를 다 Evaluate하는 것보다 한 단계만 더 Evaluate하는 게 낫다.</li></ul></li>
<li><p>IE를 위해 <code>:hover</code>를 Non-Anchor(non-link) 엘리먼트에 사용하지 말 것.</p>

<ul><li>Non-Anchor 엘리먼트에 <code>:hover</code>를 사용하면 IE7, IE8에서 꼭 해당 페이지를 테스트해야 한다. <code>:hover</code> 때문에 성능에 문제가 생기면 IE에서는 JavaScript의 onmouseover 이벤트 핸들러를 사용하라.</li></ul></li>
</ul>

<h2>CSS expression 안 쓰기.</h2>

<p>CSS expression은 렌더링 성능을 떨어트린다. CSS expression은 IE5, IE6, IE7만 지원하는 것이고 IE 8부터는 deprecated 됐다. 게다가 다른 브라우저는 아예 지원하지 않는다. 정리하지 않음.</p>

<h2>CSS는 document head에 두기</h2>

<p>브라우저는 <code>&lt;link&gt;</code> 엘리먼트의 CSS 파일을 모두 내려받을 때까지 웹 페이지를 렌더링하지 않기 때문에 <code>&lt;link&gt;</code> 엘리먼트를 도큐먼트 헤드에 넣어서 무엇보다 CSS 파일을 먼저 내려받을 수 있도록 해줘야 한다.</p>

<p>브라우저는 도큐먼트를 스트림처럼 다루기 때문에 내려받은 만큼 먼저 렌더링한다. 렌더링하고 나서 스타일이 바뀌면 다시 해야 하기 때문에 인라인 스타일 블럭(<code>&lt;style&gt;</code> 엘리먼트)도 도큐먼트 헤드에 넣어줘야 한다.</p>

<h3>기억할 것</h3>

<ul>
<li><code>&lt;link&gt;</code> 엘리먼트는 항상 <code>&lt;head&gt;</code>에 넣어라.</li>
<li><a href="http://www.clearboth.org/css-link-vs-import/"><code>@import</code>는 사용하지 마라</a></li>
<li><code>&lt;style&gt;</code> 블럭도 <code>&lt;head&gt;</code>에 넣어라.</li>
</ul>

<h2>이미지 크기 명시하기</h2>

<p>이미지 크기를 명시하면 이미지 파일을 다 내려받고 나서 다시 그리지(reflow와 repaint) 않는다. 크기를 명시하지 않았거나 명시한 크기가 실제 이미지 크기와 다르면 브라우저는 내려받고서 다시 그린다.</p>

<h3>기억할 것</h3>

<ul>
<li>실제 이미지 크기로 명시하라.</li>
<li>img 엘리먼트나 그 부모 중에서 block 엘리먼트에 크기를 명시해야 한다. block 엘리먼트가 아니면 명시한 크기 값은 무시된다.</li>
</ul>

<h2>Charset 명시하기</h2>

<p>HTML 문서의 HTTP Response 헤더에 캐릭터 셋을 항상 넣어주면 브라우저는 바로 HTML 파싱하고 스크립트를 실행한다. </p>

<p>Charset을 명시하지 않으면 브라우저는 일정 크기만큼 버퍼링하고 그 버퍼에서 charset 정보를 찾는다. </p>

<p>브라우저마다 버퍼링하는 바이트 수와 Charset을 명시하지 않았을 때 사용하는 기본 Encoding이 다르다. 하지만, 일단 버퍼링하면 바로 렌더링한다. 그리고 만약 기본 Encoding과 버퍼링하고 나서 찾아낸 Charset이 서로 다르면 다시 파싱하고 페이지를 다시 그린다.</p>

<h3>기억할 것</h3>

<ul>
<li>Content Type을 빠트리지 마라. - HTTP 헤더나 HTML meta tag 두 곳에 모두 적어 준다. 브라우저는 Content Type을 "sniff"하는데 알고리즘이 여러 가지 사용된다. 그래서 추가적인 Delay도 생기고 보안에 구멍도 생긴다. 'text/html'이라고 할지라도 반드시 적어준다.</li>
<li>제대로 된 Charset을 명시한다.  - HTTP 헤더와 HTML meta tag 두 곳에 모두 명시한다.</li>
</ul>

<p>HTTP 헤더에 명시하는 예제:</p>

<pre class="prettyprint"><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>HTML meta tag에 명시하는 예제:</p>

<pre class="prettyprint"><code>&lt;meta http-equiv="content-type" content="text/html;charset=UTF-8" /&gt;
</code></pre>

<h2>결론</h2>

<p><a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>를 한번 돌려보자. 굉장히 잘 만들었다. 문제가 무엇인지 알려주고 어떻게 해결해야 하는지도 알려준다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:Todo Plugin</title>
    <link href="http://dogfeet.github.com/articles/2012/git-todo.html" />
    <updated>2012-01-21T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-todo.html</id>
    <content type="html">
<![CDATA[
<p>branch 정보를 요약해주는 Plugin을 만들었다. 각 브랜치에 마지막 커밋 정보(SHA, 메시지, 시각, 커밋터)를 보여주고 그 브랜치가 기준 브랜치에서 얼마나 멀어졌는지 보여준다.</p>

<p><a href="/articles/2012/git-branch-a-v.html"><code>git branch -a -v</code> 명령에 대한 글</a>을 썼었는데 그 글에 설명한 것을 발전시켜 구현했다. <code>git-todo</code> 같이 규모가 작은 프로젝트에서는 별도로 Issue를 관리하고 싶지 않아서 만들었다. </p>

<p>브랜치 이름과 커밋 메시지를 잘 다듬으면 브랜치 정보를 요약해 보는 것만으로도 해야 할 일이 무엇이고 최근 어디까지 진행했는지 알 수 있다.</p>

<p>Pro Git 저장소를 예제로 사용하여 설명한다:</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-todo/git-todo.png" alt="git-todo" title="" /></p>

<h2>Usage</h2>

<ul>
<li><img src="/articles/2012/git-todo/checkouted.png" alt="checkouted" title="" />가 표기된 ko 브랜치가 Checkcout한 브랜치다.</li>
<li><img src="/articles/2012/git-todo/base_branch.png" alt="base_branch" title="" />가 표기된 ko 브랜치가 기준 브랜치다. 이 브랜치를 기준으로 다른 브랜치의 <img src="/articles/2012/git-todo/ahead.png" alt="ahead" title="" />이나 <img src="/articles/2012/git-todo/behind.png" alt="behind" title="" />을 계산한다.</li>
<li><img src="/articles/2012/git-todo/ahead.png" alt="ahead" title="" />가 표기된 private-ko-build-ebook 브랜치는 ko 브랜치에 없는 커밋이 3개 있다는 것을 의미한다.</li>
<li><img src="/articles/2012/git-todo/behind.png" alt="behind" title="" />가 표기된 private-ko-build-ebook 브랜치는 ko 브랜치에 있는 커밋이 23개 없다는 것을 의미한다.</li>
</ul>

<p>기본적으로 로컬 브랜치만 보여준다.</p>

<h3>기준 브랜치</h3>

<p>이 기준 브랜치가 <code>git branch -a -v</code>를 쓰지 않고 Plugin을 만든 진짜 이유다. 원하는 브랜치를 기준으로 두고 토픽 브랜치를 만들어 작업할 수 있다.</p>

<p>설정하지 않으면 master 브랜치가 기준 브랜치다. 이 브랜치를 기준으로 다른 브랜치의 거리를 계산한다. 이 브랜치는 다음과 같이 설정한다:</p>

<pre class="prettyprint"><code>git config todo.base ko
</code></pre>

<p>여기서 보여주는 예제는 Pro Git 저장소를 캡처한 것이기 때문에 기준 브랜치가 ko이다.</p>

<h3>옵션</h3>

<p>기본적으로 로컬 브랜치만 보여주지만, 리모트 브랜치와 tag도 보여준다</p>

<h4>git todo -r</h4>

<p>리모트 브랜치는 노란(똥)색으로 보여준다:</p>

<p><img src="/articles/2012/git-todo/git-todo-r.png" alt="git-todo-r" title="" /></p>

<h4>git todo -t</h4>

<p>Tag는 흰색으로 보여준다:</p>

<p><img src="/articles/2012/git-todo/git-todo-t.png" alt="git-todo-t" title="" /></p>

<h4>git todo -a</h4>

<p>로컬 브랜치, 리모트 브랜치, Tag를 모두 보여준다:</p>

<p><img src="/articles/2012/git-todo/git-todo-a.png" alt="git-todo-a" title="" /></p>

<h2>설치</h2>

<p><a href="https://github.com/pismute/git-tles">git-todo 저장소</a>를 적당한데다 클론하고 git-todo 파일을 실행 경로에 넣는다:</p>

<pre class="prettyprint"><code>cd ~
git clone <a href='https://github.com/pismute/git-tles'>https://github.com/pismute/git-tles</a>
echo "export PATH=~/bin:$PATH" &gt;&gt; ~/.bash_profile
mkdir ~/bin
cd ~/bin
ln -s ~/git-tles/git-todo git-todo
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title>Pro Git 번역 회고</title>
    <link href="http://dogfeet.github.com/articles/2012/progit-retro.html" />
    <updated>2012-01-14T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/progit-retro.html</id>
    <content type="html">
<![CDATA[
<p>허접하게 나마 <a href="http://progit.org">Pro Git</a>을 번역했다. 시간도 부족하고 경험도 부족했다. 부족한 점을 극복하기 위해 번역관련 책도 사서 읽고 새로운 도구와 방법도 찾아서 익혔다. 이 포스트에서는 어떻게 번역을 했는지 그리고 무엇을 배웠는지 얘기하고자 한다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/progit/progit.book-big.jpg" alt="progit" title="" /></p>

<h2>힘들구나 번역. 알면서도 왜 했었나?</h2>

<p><strong>Lee</strong> &raquo; 번역은 그 길이가 짧든 길든 간에 쉽지 않은 작업이다. 짧으면 짧은 대로 길면 긴 대로…. Pro Git 번역 프로젝트는 적지 않은 양이었다. 전에도 함께 했었던 <a href="http://dogfeet.github.com/grails-doc/guide/">Grails User Manual 번역</a>이나, 시작했다가 포기한 과거 번역 작업을 생각해 봤을 때 스스로에 대한 큰 보상 없이 시작하기가 쉽지는 않았다.</p>

<p><strong>Lee</strong> &raquo; Pro Git은 Git에 대한 다른 좋은 Article들도 수없이 많지만, Git을 사용하는 데 있어서 정말 정리가 잘 되어 있는 책이라고 함께 번역을 한 창우형이 매우 칭찬을 했다. 읽어보니 확실히 궁금한 부분, 몰랐던 부분에 대한 빠짐없는 정리가 잘 되어 있다. 게다가 알아야 할 부분에 대한 내용이 깊지만 쉬운 글로 잘 풀어져 있다. 게다가 감사하게도 무료!</p>

<p><strong>Lee</strong> &raquo; 또한 Pro Git의 출력물도 한 번 짚어볼 만하다. 앞서 책을 번역했던 프로젝트에서는 각 프로젝트에 맞게 한 가지 형태 즉 HTML로만 혹은 epub으로만, pdf로만 출력을 뽑아냈었다. Pro Git은 하나의 Source로 한 번에 여러 형태로 출력물을 뽑아내는 재밌는 프로젝트이다. 배워두면 쓸 일 있지 않을까?</p>

<p><strong>Park</strong> &raquo; 2010년에 SVN 쓰면서 브랜치 관리로 골머리를 앓았었다. Spring+Maven으로 나름 갖은 트릭은 다 부렸는데도 잘 안되더라. 사실 그때도 Git이 좋다는 것은 알고 있었다. 그런데 위험요소를 회피하느라 피했지만 후회했다. SVN으로 브랜치 여러 개를 동시에 관리하는 게 더 힘들다.</p>

<p><strong>Park</strong> &raquo; Git은 정말 기능도 많고 설명도 많다. 일단 사다리를 그려줄 자료가 필요했다. 그래서 몇 가지를 검토하고 나서 progit을 읽었다. Chapter 순으로 읽으면 결국 이해되도록 잘 쓴 책이라 꼭 번역해야겠다고 생각했다.</p>

<h2>뭘 가지고 어디에서 작업했나?</h2>

<p><strong>Lee</strong> &raquo; 무엇부터 이야기해야 하나…. 우선 나는 작은 13인치 MBP와 iMac을 주로 사용하였다. 집이나 카페(주로 스타벅스)에서는 MBP를 사용했으며 일터에서는 틈틈이 iMac을 사용하였다. MBP의 사용이 4/5 이상일 것이다. </p>

<p><img alt="MBP" width="500" src="/articles/2012/progit/mbp.jpg" /></p>

<p><strong>Park</strong> &raquo; 나도 주로 집과 카페에서 했다. 특히 죽치고 않고 있기엔 스타벅스가 커피가 싸다. '싱글 벤티 드립'을 시키면 4~5시간은 버틸 수 있다. 다른 카페에서는 양이 적어서 두 잔 마셔야 한다.</p>

<p><strong>Park</strong> &raquo; 2007년형 white MacBook으로 작업했다. Mac을 사용할 수 없을 때도 잦아서 원격으로 접속해서 Ubuntu에서 작업하기도 했다.</p>

<p><img alt="MBP Cafe" height="500" src="/articles/2012/progit/mbp-cafe.jpg" /></p>

<p><strong>Lee</strong> &raquo; epub와 mobi 포맷을 확인하기 위해서 아이폰과 아이패드의 iBooks, Kindle 앱을 사용했다.</p>

<p><img alt="iBooks" height="500" src="/articles/2012/progit/ibooks.jpg" /></p>

<p><strong>Lee</strong> &raquo; 글쓰기를 위해서 <a href="http://www.hogbaysoftware.com/products/writeroom">WriteRoom</a>을 사용하였다. 창우형은 작업 대부분을 터미널에서 vim을 사용했다고 한다. 둘 다 모두 글쓰기에서는 고정 폭 글꼴을 사용하기 위해 <a href="http://dev.naver.com/projects/nanumfont">나눔고딕코딩폰트</a>를 사용했다.</p>

<p><img alt="Writeroom" width="500" src="/articles/2012/progit/writeroom.png" /></p>

<p><strong>Park</strong> &raquo; 터미널에서 vim으로 작업했다. vim은 익숙하기도 했고 언제 어디서는 인터넷만 연결되면 되기 때문에 좋다.</p>

<p><strong>Lee</strong> &raquo; 번역을 도와줄 사전으로는 맥 기본 사전, 아이폰에서 <a href="http://itunes.apple.com/us/app/dictionary-universal/id312088272?mt=8">Dictionary Universal</a>, <a href="http://wiktionary.org">Wiktionary</a>를 이용하였다. 맥이나 아이폰에서는 사용자 사전을 추가할 수 있어서 한영/영한사전 및 시소러스 사전을 유용하게 사용했다. 온라인 한글 맞춤법 검사기와 워드프로세서 한글을 종종 사용하기도 했다.</p>

<p><img alt="Universal Dictionary" height="500" src="/articles/2012/progit/ubdic.jpg" /></p>

<p><strong>Park</strong> &raquo; 나보다 구글 번역기가 나을 때도 많더라.</p>

<p><strong>Park</strong> &raquo; <a href="http://urimal.cs.pusan.ac.kr/urimal_new/">우리말 배움터</a>에 감사드린다. 오래전부터 사용해왔지만, 이번에는 정말 고마웠다.</p>

<p><strong>Lee</strong> &raquo; 번역 소스 관리를 위해서 윈래 Pro Git이 호스팅되고 있는 <a href="http://github.com">GitHub</a>에서 프로젝트를 dogfeet/progit로 Fork하여 작업했다. 개인적으로 iMac과 MBP를 옮겨다닐 때는 BitBucket의 Private 저장소를 사용했다. GitHub가 좋긴 하지만 결재하지 않아서 Private 저장소가 없었다. 소스의 Branch와 Commit을 관리하기 위해 GitX를 사용했다. 번역 소스를 관리하기 위해 전에는 Subversion을 사용했는데 Git은 번역을 위한 프로젝트에서도 정말 괜찮았다! 아니 Git이 유일한 도구처럼 느껴졌다. 번역하면서 사용한 Git-Flow Pattern를 따로 정리할 예정이다.</p>

<p><strong>Park</strong> &raquo; GitHub만 사용했다. BitBucket도 써보고 싶지만, 아직 GitHub도 다 모른다. 나는 Git 때문에 GitHub을 사용하는 것인지 GitHub 때문에 Git을 사용하는 것인지 모를 정도로 GitHub가 맘에 든다.</p>

<p><img src="/articles/2012/progit/gitx-progit.png" alt="GitX" width="500" /></p>

<p><strong>Lee</strong> &raquo; HTML, ePub, Mobi, PDF 출력물을 빌드하기 위해 따로 Ubuntu 서버를 하나 사용했다. x-server를 사용하지 않고 빌드하기 위해 약간의 빌드 스크립트를 수정해서 사용하였으며 주로 pandoc과 xelatex 관련 패키지와 한글 폰트 패키지를 설치하고, <a href="http://jenkins-ci.org">Jenkins</a>(구 Hudson)에 빌드 스크립트를 등록하여 원격으로 빌드하곤 했다.</p>

<p><strong>Park</strong> &raquo; 나는 Mac에서 빌드했다. 처음에는 무척이나 골치 아팠지만 결국 방법을 찾아내고 버그도 수정했다. schacon님이 이 fix도 accept해주었다. GitHub로 번역을 진행하면서 이런 소소한 즐거움도 알게 됐다.</p>

<p><img alt="Jenkins" width="500" src="/articles/2012/progit/jenkins-progit.png" /></p>

<p><strong>Lee</strong> &raquo; 번역을 함께 진행하기 위해서 커뮤니케이션 도구로 <a href="http://yammer.com">Yammer</a>를, 서로 출력물을 항상 최신 것으로 공유하고자 <a href="http://dropbox.com">Dropbox</a>를 사용하였다. 업무용 커뮤니케이션 도구로 메신저도 좋고 메일도 좋지만, Yammer를 강추하는 바이다!</p>

<p><strong>Park</strong> &raquo; yammer는 정말 좋은 도구다. 4년 정도 같이 공부해오면서 2011년과 같이 알찬 해는 없었다. 거기에는 yammer에 힘이 컸다고 생각한다. 위키도 사용해보고 이슈 트레커도 사용해봤지만 모두 실패하고 지금은 그냥 yammer로 토론하고 yammer에 메모한다.</p>

<p><img alt="Yammer" width="500" src="/articles/2012/progit/yammer-progit.png" /></p>

<h2>닥치고 번역에 중요한 거</h2>

<p><strong>Lee</strong> &raquo; 우선 배가 항해를 하는데 좋든 좀 모자라든 선장이나 항해사 없이 제대로 된 길을 가는 것은 불가능하다. 이번 프로젝트는 일꾼 두 명이 땀을 뻘뻘 흘리면서 열심히 노를 젓는 일만 할 줄 알기에 자주 방향을 잃어가며 작업할 수밖에. 틈틈이 Yammer로 대화하며 방향을 잡아갔지만 적당한 경험 있는 편집자가 틀을 잡아줄 수 있었다면 좀 더 좋은 번역을 할 수 있지 않았을까.</p>

<p><strong>Park</strong> &raquo; 특히 중요하게 생각한 점은 최종 결정은 마지막에 수정하는 사람이 결정하기로 했다. 그래서 아쉬운 사람이 한 번 더 검토했다.</p>

<p><strong>Park</strong> &raquo; 번역도 일종의 모험이다. 훌륭한 선장과 항해사를 갖추고 출발했었으면 더 좋았겠지만 그렇지 못했다. 그래서 애초에 목표를 크게 잡지도 않았다. 영어로 읽는 것보다는 쉽게 읽을 수 있게 하자는 것. Git은 내용이 많아서 어차피 영문으로 또 읽어볼 필요도 있으니 처음 사다리를 그릴 때 한글로 좀 더 쉽게 그릴 수 있게 하자는 것 정도였다. 한글판을 읽었으면 영문으로도 한 번 더 읽거나 영문으로 된 다른 자료를 더 읽기를 권한다.</p>

<p><img alt="Translation" width="500" src="/articles/2012/progit/tran.jpg" /></p>

<p style="text-align: center; font-size: 80%">출처: [casaubon](<a href='http://casaubon.tv'>http://casaubon.tv</a>)</p>

<p><strong>Lee</strong> &raquo; 영어의 표현을 틀리지 않게 이해하는 것도 어려웠지만, 한글로 옮겨적는 것이 더 어려웠다. 용어번역표를 제대로 정리하지 못해서 전체적으로 어휘 일관성을 지키지 못한 점도 많이 부끄럽다.</p>

<p><strong>Park</strong> &raquo; 국어 실력이 제일 중요한 것 같다. 자신 있게 문장을 만들어야 한다. 틀릴 때는 그냥 확실히 틀려주는 것이 결국은 더 빠르다. 초반에 이렇게 신경 쓰지 못해서 나중에 다 다시 리뷰해야 했다. 그리고 그 질도 떨어진 것 같다. 시간도 더 들고 질도 떨어진다.</p>

<p><strong>Park</strong> &raquo; 공부가 제일이다. 이렇게 긴 글을 번역할 기회가 적은데 번역에 대한 공부를 더 못한 것이 아쉽다.</p>

<h2>나는 뭘 얻었나</h2>

<p><strong>Lee</strong> &raquo; 물론 제대로 출력된 책은 Amazon에서 돈을 받고 팔기도 하지만 Pro Git 책은 기본적으로 무료다. 저자인 schacon님은 Git 에반젤리스트이기도 하고 GitHub의 CIO이기도 하다. 사람들이 Git을 많이 써서 GitHub를 많이 사용하게 된다면 좋은 일 아닌가 ^^ 하지만 우리 역자들은 ... ^^</p>

<p><strong>Lee</strong> &raquo; 적지않은 노력과 부끄러움을 드러내며 읽고 또 읽는 과정에서 Git에 대해서 그리고 번역에 대해서 경험(이라고 쓰고 삽질)과 노하우를 얻은 것은 나름의 성과라고 할 수 있겠다. 행여나 같은 업종의 동지분들께 아까운 삽질로 시간을 낭비하지 않고 조금이라도 한숨 돌릴 수 있는 여유시간을 만들어 줄 수 있다면 보람 있겠다(윗사람은 Git 같은 거 몰라도 되지 싶다 ^^).</p>

<p><strong>Park</strong> &raquo; 국어, 정말 한글 공부를 열심히 했다.</p>

<p><strong>Park</strong> &raquo; 완주하려면 동료가 꼭 필요하다는 것을 배웠다. 혼자 했으면 분명히 포기했을 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:branch-a-v</title>
    <link href="http://dogfeet.github.com/articles/2012/git-branch-a-v.html" />
    <updated>2012-01-14T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-branch-a-v.html</id>
    <content type="html">
<![CDATA[
<p>Git을 사용하면서 규모가 작은 프로젝트를 많이 만들게 됐다. 예제를 만들거나, 간단한 도구를 만들거나 버전관리가 필요하면 언제든지 Git 저장소를 만들어 사용한다. 몇 일만 잊었다가 다시 돌아오면 어디까지 작업했는지 헷갈린다. 이 때 <code>git branch -a -v</code> 명령은 현 저장소 상태를 알아 보는데 좋다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-todo/todoly.png" alt="todo.ly" title="" /></p>

<p>(todo.ly은 본 글과 아무 상관없다.)</p>

<h2>git branch -a -v</h2>

<p>Git을 사용하면서 가장 많이 사용하는 명령어 중 하나가 <code>git branch -a -v</code>이다. Fetch한 원격 브랜치를 포함해서 모든 브랜치 목록을 볼 수 있을 뿐만 아니라 각 브랜치의 마지막 커밋 정보도 보여준다. 그뿐만 아니라 해당 브랜치가 Remote Tracking 브랜치이면 Tracking 브랜치에서 얼마나 멀어졌는지도 보여준다.</p>

<p>merge를 설명할 때 사용했던 ship 저장소를 다시 살펴보자. 이 저장소를 clone하고 <code>git branch -a -v</code>를 실행한다:</p>

<pre class="prettyprint"><code>$ git branch -a -v
ship                             3f129b5 Fix anchor
remotes/origin/ship              3f129b5 Fix anchor
</code></pre>

<p><code>-a</code>의 는 원격 브랜치를 포함한 모든 브랜치를 보여준다. 그리고 <code>-v</code>는 해당 브랜치의 마지막 커밋을 보여준다.</p>

<p>'origin/ship'을 Tracking하는 'feature/kitchen'라는 브랜치를 만들고 싱크대를 추가한다:</p>

<pre class="prettyprint"><code>$ git co -b feature/kitchen origin/ship
$ touch sink_unit
$ git add sink_unit
$ git commit
[feature/kitchen e054c7e] Add sink unit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 sink_unit
</code></pre>

<p>그리고 누군가 ship 브랜치에 커밋을 추가했다. 그래서 다시 Fetch를 하고 나서 <code>git branch -a -v</code>를 실행한다:</p>

<pre class="prettyprint"><code>feature/kitchen                  e054c7e [ahead 1, behind 1] Add sink unit
ship                             3f129b5 [behind 1] Fix anchor
remotes/origin/ship              3f129b5 Fix anchor
</code></pre>

<p>'feature/kitchen' 의 커밋 메시지에 'ahead 1'를 주목하자. 'ahead 1'은 이 브랜치가 Tracking하는 브랜치에서 커밋 1개만큼 멀어져 있다는 것을 보여준다. 'feature/kitchen'은 <code>git co -b feature/kitchen origin/ship</code> 명령으로 만들었다. 이렇게 만들면 'feature/kitchen'가 'origin/ship'을 Tracking하게 된다.</p>

<p>마찬가지로 'behind 1'은 'origin/sink' 브랜치가 'feature/kitchen' 브랜치보다 커밋을 하나 더 가졌다는 것이다. <code>git log feature/kitchen...origin/ship --left-right</code>을 실행하면 다음과 같다:</p>

<pre class="prettyprint"><code>$ git lg feature/kitchen...origin/ship --left-right
&gt; 2d45d4c - (origin/ship) Add test
&lt; e054c7e - (feature/kitchen) Add sink unit
</code></pre>

<p><code>git branch</code>의 <code>-v</code> 옵션은 리모트 브랜치를 Tracking하는 브랜치의 경우 두 브랜치 사이가 얼마나 멀어졌는지도 함께 보여준다.</p>

<p><strong>UPDATE:</strong> Remote Tracking 브랜치에 대한 내용은 잘못 정리한 것이라서 삭제했다. 나중에 따로 정리하기로 했다.</p>

<h2>todo</h2>

<p>나는 해당 프로젝트의 'todo' 목록을 별도로 관리하지 않고 그냥 토픽 브랜치로 만든다. 그리고 <code>git branch -a -v</code> 명령으로 관리한다. 나는 편의를 위해서 <code>todo</code>라는 alias를 만들어 사용한다:</p>

<pre class="prettyprint"><code>git config --global alias.todo "branch -a -v"
</code></pre>

<h2>결론</h2>

<p><code>git branch -a -v</code> 명령은 하던 일을 뭔지 기억하는데 도움이 된다. 간단하게만 관리할 수 있다면 일을 하는 것과 계획을 관리하는 것을 한 몸으로 할 수 있다.</p>

<p>그리고 커밋 메시지가 정말 중요하다. 시간이 지나서 좀 잊어버리게 된다고 해도 다시 보면 바로 알 수 있어야 한다.</p>

<p>좀 더 개선된 형태가 필요하다. 왜 꼭 Remote 브랜치만 Tracking해야 하는 걸까? 사실 Local 브랜치를 Tracking하게 하고 싶다. 관련 브랜치도 함께 보여줄 수 없을까? 다른 색으로 보여줄 수는 없을까? 좀 더 인식하기 쉬운 형태였으면 좋겠다. 틈틈이 Git 플러그인을 만들자!</p>]]>
    </content>
  </entry>
  <entry>
    <title>progit</title>
    <link href="http://dogfeet.github.com/articles/2012/progit.html" />
    <updated>2012-01-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/progit.html</id>
    <content type="html">
<![CDATA[
<p>GitHub의 CIO인 <a href="http://github.com/schacon">schacon</a>이 쓴 <a href="http://progit.org">progit</a> 번역을 완료했습니다. 부지런히 작업해서 12월 19일에 끝냈으면 가카께 헌정하고 졸라 신났을 텐데 게을러서 늦어졌습니다.--;</p>

<p><img src="http://dogfeet.github.com/articles/2011/progit/progit.book-big.jpg" alt="progit" title="" /></p>

<h2>progit</h2>

<p>다음 Format의 파일로 배포하고 있고 다운 받아서 읽으실 수 있습니다. <code>2012-01-13</code>에 빌드한 파일입니다:</p>

<ul>
<li><a href="http://dogfeet.github.com/progit/progit.ko.epub">progit.ko.epub</a></li>
<li><a href="http://dogfeet.github.com/progit/progit.ko.mobi">progit.ko.mobi</a></li>
<li><a href="http://dogfeet.github.com/progit/progit.ko.pdf">progit.ko.pdf</a></li>
<li><a href="http://dogfeet.github.com/progit/progit.ko.html">progit.ko.html</a></li>
</ul>

<p>mobi 파일은 Android Kindle App에서 띄어쓰기가 안되는 문제가 있습니다. <a href="http://calibre-ebook.com/download">Calibre</a>에서 열어보면 잘 되는데 Kindle App에서는 안되네요.</p>

<p><strong>UPDATE:</strong> Kindle Touch에서는 띄어쓰기가 된다고 합니다(ryan003님 제보).</p>

<p>번역은 <a href="https://github.com/dogfeet/progit">progit 한글 버전 저장소</a>에서 진행하고 있습니다. 오역이나 오탈자는 패치를 보내주시거나 <a href="https://github.com/dogfeet/progit/issues">이슈 트래커</a>에 신고해주세요.</p>

<p>다시 한번 동료의 힘을 몸소 체험한 프로젝트 였습니다. <a href="https://twitter.com/#!/lethee">@lethee</a>와 함께 하지 않고 혼자했다면 결코 완주하지 못했을 겁니다.</p>

<h2>힘내</h2>

<p>구글 번역기는 <code>Git</code>을 <code>힘내</code>라고 번역해 줍니다. 개발자분들 모두 <code>Git</code>으로 힘내시길 바래요.</p>

<p><img src="/articles/2011/progit/git-.png" alt="힘내" title="" /></p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:conflict</title>
    <link href="http://dogfeet.github.com/articles/2012/git-conflict.html" />
    <updated>2012-01-01T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-conflict.html</id>
    <content type="html">
<![CDATA[
<p>충돌을 해결하는 방법은 단순하다. 편집기로 충돌이 일어난 파일을 열어 적절히 편집하고 <code>git add</code> 명령으로 Staging Area에 추가하고 나서 <code>git commit</code>으로 commit하면 끝이다. 하지만, Git으로 좀 더 쉽게 하는 방법을 알아본다.</p>

<p>Git 명령어를 사용하다 보면 'ours', 'theirs'라는 옵션을 자주 보게 된다. 이 옵션은 충돌을 위해 만들어진 옵션이다. 이 글은 이 옵션에 대해 설명한다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-conflict/creation-of-adam.jpg" alt="creation of adam" title="" /></p>

<p>새해 복 많이 받으세요!!</p>

<h2>Config</h2>

<p>기본적으로 <code>git diff</code>와 같은 형식으로 보여주지만 충돌 결과를 보여주는 스타일을 변경할 수 있다:</p>

<pre class="prettyprint"><code>$ git config merge.conflictstyle diff3
</code></pre>

<h2>Checkout</h2>

<p>Checkout 명령에 <code>--ours</code>와 <code>--theirs</code> 옵션이 있다. 이 옵션은 충돌 났을 때 사용한다. <code>ours</code> 브랜치에 conflict 파일은 다음과 같다고 하자:</p>

<pre class="prettyprint"><code>$ cat conflict
ours
</code></pre>

<p><code>theirs</code> 브랜치의 conflict 파일은 다음과 같다:</p>

<pre class="prettyprint"><code>$ cat conflict
theirs
</code></pre>

<p><code>theirs</code> 브랜치를 <code>ours</code> 브랜치에 Merge하면 충돌 난다:</p>

<pre class="prettyprint"><code>$ git merge theirs
Auto-merging conflict
CONFLICT (content): Merge conflict in conflict
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>diff 명령으로 어디서 충돌 났는지 확인한다:</p>

<pre class="prettyprint"><code>$ git diff
diff --cc conflict
index 1b9074b,f853c8d..0000000
--- a/conflict
+++ b/conflict
@@@ -1,1 -1,1 +1,5 @@@
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +ours
++=======
+ theirs
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
</code></pre>

<p>편집기로 conflict 파일을 손으로 수정해도 되지만 그냥 ours에 있는 파일을 사용할 수 있다:</p>

<pre class="prettyprint"><code>$ git checkout --ours -- conflict
</code></pre>

<p>theirs의 파일을 선택할 수도 있다:</p>

<pre class="prettyprint"><code>$ git checkout --theirs -- conflict
</code></pre>

<p>충돌을 해결했으면 <code>git add</code>로 추가하고 커밋한다.</p>

<h2>Diff</h2>

<p><code>git diff</code> 명령에도 <code>--ours</code>, <code>--theirs</code> 옵션이 있다. 이 옵션을 주면 <code>git diff</code> 명령은 다른 색으로 표시해준다. 예를 들어 다음과 같이 실행한다.</p>

<pre class="prettyprint"><code>$ git diff --ours --color=auto
</code></pre>

<p>그러면 ours 브랜치의 내용만 다른 색으로 표시해준다. <code>--theirs</code>도 같은 방법으로 확인할 수 있다.</p>

<p>diff 명령은 <code>--base</code> 옵션이 있어서 이 옵션을 주면 두 브랜치의 base 커밋에 있는 내용도 같이 보여준다:</p>

<pre class="prettyprint"><code># git diff --base
</code></pre>

<h2>Merge</h2>

<p>Merge할 때 아예 어느 것을 선택할지 정해줄 수 있다. ours 브랜치의 것을 선택하는 merge를 해보자.</p>

<pre class="prettyprint"><code>$ git merge -s ours theirs
Merge made by ours.
</code></pre>

<p>그리고 파일 내용을 보면 ours 브랜치의 파일로 Merge 돼 있다.</p>

<pre class="prettyprint"><code>$ cat conflict
ours
</code></pre>

<p>theirs를 선택하면 충돌 내지 않고 theirs 브랜치의 파일로 Merge된다.</p>

<h2>Attribute</h2>

<p>Attribute로 Blob 패턴마다 ours를 사용할지 their를 사용할지 설정할 수 있다.</p>

<p>Git Attribute는 Blob 패턴마다 다른 설정을 하는 것을 말하며 <code>.gitattributes</code> 파일을 만들고 거기에 작성하면 된다. </p>

<p>이 설정은 브랜치의 목적이 환경일 때 유용하다. 예를 들어 prod, test, dev라는 브랜치를 만들어 사용한다고 가정하자. prod는 실제 운영환경을 목적으로 설정돼 있고 test는 CI 등 테스트 자동화를 위해 만들었고, dev는 로컬 개발 환경을 위한 설정을 담고 있다고 하자. 그리고 환경정보는 <code>src/main/resources/env.properties</code>에 기술한다고 가정하자. 실제로 프로젝트를 해본 결과 prod, test, dev 프로파일을 만들고 개발하는 것이 <code>Maven + Spring</code> 환경에서는 꽤 유용했다. 분명히 환경을 위한 브랜치가 필요할 때가 올 것이다. </p>

<p><code>.gitattributes</code> 파일을 프로젝트 루트 디렉토리에 다음과 같이 만들고:</p>

<pre class="prettyprint"><code>src/main/resoruces/env.properties merge=ours
</code></pre>

<p><code>git merge</code> 명령을 실행하면 이 파일은 항상 ours의 파일로 Merge한다. 그래서 환경 설정이 Merge될 걱정 없이 사용할 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:diff</title>
    <link href="http://dogfeet.github.com/articles/2011/git-diff.html" />
    <updated>2011-12-24T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2011/git-diff.html</id>
    <content type="html">
<![CDATA[
<p>Git은 명령어가 엄청나게 많지만, 알면 알수록 일관적인 명령어에 감탄하게 된다.<br />(아무리 그래도 너무 많다.--;)</p>

<p>이 글에서는 <code>git diff</code> 명령어의 사용법을 간단히 정리한다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/git-diff/christmas-in-jelly-village.jpg" alt="heading image" title="" /></p>

<p>산타와 함께 하는 틀린 그림 찾기 "Christmas In Jelly Village". <a href="http://blog.daum.net/_blog/BlogTypeView.do?blogid=0TE6a&amp;articleno=429&amp;categoryId=0&amp;regdt=20100512215001#ajax_history_home">출처</a></p>

<h2>Unified Format</h2>

<p><code>git diff</code>는 결과를 <a href="/articles/2011/1316924580.html">Unified Format</a>으로 보여준다. 이 형식에 익숙하지 않으면 링크를 따라가 읽어보는 것이 도움될 것이다. </p>

<h2>git diff</h2>

<p>diff를 잘 활용하자.</p>

<h3>Modified, Staged, Unmodified 사이 비교</h3>

<p>Modified(Working Directory에 있는)와 Staged(Staging Area에 있는)는 다음과 같이 비교한다:</p>

<pre class="prettyprint"><code>git diff
</code></pre>

<p>특정 파일만 비교할 수도 있다:</p>

<pre class="prettyprint"><code>git diff my-file
</code></pre>

<p>Staged와 Unmodified(HEAD의)는 다음과 같이 비교한다:</p>

<pre class="prettyprint"><code>git diff --staged/--cached
</code></pre>

<p><code>--staged</code>와 <code>--cached</code>는 똑같다. 이것도 특정 파일만 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff --staged my-file
</code></pre>

<h3>Revision 비교</h3>

<p>리비전 두 개를 골라 비교할 수도 있다:</p>

<pre class="prettyprint"><code>git diff bd976f4 59d60f9
</code></pre>

<p>그중 파일 하나만 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff bd976f4 59d60f9 my-file
</code></pre>

<p>다음처럼도 비교할 수도 있다:</p>

<pre class="prettyprint"><code>git diff bd976f4:my-file 59d60f9:my-file
</code></pre>

<h3>Modified, Staged와 Revision 비교</h3>

<p>Working Directory에 있거나 Staging Area에 수정한 파일을 HEAD의 파일이 아니라 이전 커밋하고 비교할 수도 있다. Working Directory를 <code>HEAD~18</code>에 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff HEAD~18
</code></pre>

<p>특정 파일만 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff HEAD~18 my-file
</code></pre>

<p>Staging Area와 <code>HEAD~18</code>과 비교하려면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>git diff --staged HEAD~18
</code></pre>

<p>이때도 특정 파일만 비교하려면 다음과 같다:</p>

<pre class="prettyprint"><code>git diff --staged HEAD~18 my-file
</code></pre>

<h3>파일 이름만 보기</h3>

<p><code>--name-only</code> 옵션을 주면 관련 파일을 볼 수 있다. 다음은 해당 커밋에 수정된 파일 목록을 보여준다:</p>

<pre class="prettyprint"><code>git show --name-only HEAD~4
</code></pre>

<p>다음은 Working Directory와 HEAD~4에서 변경된 파일 이름만 보여준다.</p>

<pre class="prettyprint"><code>git diff --name-only HEAD~4
</code></pre>

<p>이 옵션은 <code>git log</code> 명령에도 사용할 수 있다. 해당 commit에 수정된 파일 이름도 같이 보여준다.</p>

<pre class="prettyprint"><code>git log --name-only
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title>GitHub Flow</title>
    <link href="http://dogfeet.github.com/articles/2011/github-flow.html" />
    <updated>2011-12-22T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2011/github-flow.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 GitHub의 CIO인 <a href="https://github.com/schacon">Scott Chacon</a>님의 <a href="http://scottchacon.com/2011/08/31/github-flow.html">github-flow</a>를 정리한 글입니다. Chacon님은 [git-flow][]가 정리한 것처럼 github를 개발하는 데 사용하는 flow를 정했습니다.</em></p>

<p>Chacon님은 git-flow도 좋지만 Github는 명확히 Release라고 부를 만한 시점이 없어서 git-flow를 사용하지 않는다고 한다. 그 외 세세한 차이점도 거론하긴 했지만 생략한다. Release가 분명하지 않은 경우엔 확실히 git-flow를 적용하기 어렵다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/github-flow/contact-github.png" alt="love github" title="" /></p>

<p>이 글은 그냥 요약한 것이다. 그림이 첨부된 자세한 설명은 <a href="http://scottchacon.com/2011/08/31/github-flow.html">원문</a>를 참고하라.</p>

<h2>GitHub Flow</h2>

<p>이 Flow는 간단하지만, 꽤 큰 규모의 팀(Github 직원이 35명, 그중 15-20 명이 같은 프로젝트를 진행함)에서도 굉장히 좋다.</p>

<h3>master 브랜치에만 정해진 규칙이 있다.</h3>

<p>반드시 규칙을 지켜야 하는 브랜치는 master뿐이다. 다른 브랜치는 임기응변식으로 운영하는 것 같다. </p>

<p>master 브랜치에 Merge하면 이미 deploy했거나 곧 deploy된다는 의미다.</p>

<p>master 브랜치는 안정 버전을 의미하므로 Merge하기 전에 충분히 테스트해야 한다.</p>

<p>테스트는 로컬에서 하는 것이 아니라 브랜치를 Push하고 Jenkins로 테스트한다.</p>

<p>deployed 같은 브랜치를 만들어 deploy한 커밋을 관리할 수도 있지만 GitHub는 해당 SHA 값을 직접 관리하고(webapp이나 curl로) 나중에 비교할 때 사용한다.</p>

<h3>브랜치는 항상 master 브랜치에서 만든다.</h3>

<p><code>git checkout -b mine master</code> 처럼 master 브랜치에서 만든다. </p>

<h3>이름을 잘 짓는다.</h3>

<p>이름은 무슨 브랜치인지 나타나도록 브랜치 이름을 잘 짓는다(예) new-oauth2-scopes, redis2-transition). 그래서 브랜치 목록만 보더라도 곧 어떤 feature가 추가될지 알 수 있다.</p>

<h3>named 브랜치는 자주 Push한다.</h3>

<p>git-flow의 feature 브랜치 쯤 되는 거라고 보면 된다. 위에서 얘기했듯이 브랜치 이름을 잘 짓고 자주 Push한다.</p>

<p>자주 Push해야 하는 이유는 자신이 무엇을 하고 있는지 동료들과 공유하는 것이고 누군가 <code>git fetch</code>를 실행하면 백업도 된다.</p>

<h3>언제든지 Pull Request한다.</h3>

<p>Merge할 때만 하는 것이 아니라 도움이나 피드백이 필요할 때에도 Pull Request를 사용한다. 제목에 '도움이 필요해요', '검토 좀 해주세요.', '머지해도 됩니다'라고 구분한다.</p>

<p><code>@metion</code>으로 쉽게 다른 사람에게 검토를 요청할 수도 있다. 특히 Pull Request는 브랜치를 두고 토론하는 것으로 브랜치 히스토리가 업데이트되면 그 최신정보도 자동으로 포함된다. </p>

<p>나는 이 글을 읽기 전에 Pull Request로 피드백을 요청한다는 것은 상상도 못했다.</p>

<h3>Pull Request로 리뷰한 후에만 Merge한다.</h3>

<p>사람들이 '좋다' 등으로 리뷰해주면 그때 가서 Merge한다. 물론 CI도 통과해야 한다. Push하면 자동으로 Pull Request가 닫힌다.</p>

<h3>일단 <code>master</code>에 Merge하면 바로 deploy한다.</h3>

<p>hubot으로 deploy한다. </p>

<p>GitHub는 최근 Kenkins + Hubot + Github를 묶은 <a href="https://github.com/blog/1013-janky">Janky</a>를 공개했다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>심심한 Kindle Fire</title>
    <link href="http://dogfeet.github.com/articles/2011/kinde-fire.html" />
    <updated>2011-12-18T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2011/kinde-fire.html</id>
    <content type="html">
<![CDATA[
<p>Kindle Fire가 도착했는데 아무것도 할 수 있는 게 없습니다.</p>

<p>Amazon을 전혀 안 쓰는 제가 Kindle Fire를 산 것은 'ebook 읽기 좋은 싼 Tablet이 필요하다.'라는 생각 때문이었습니다. 가카가 내곡동을 사신 것처럼 순수했습니다. 가격이 착했고 ebook 읽기에 나쁘지 않을 것으로 생각했습니다. 그리고 사실 넥서스원에서 사용하는 앱은 쓸 수 있을 거라고 기대했습니다. Amazon이니까요.</p>

<p>인터넷에서 워낙 욕을 많이 먹어서 예상은 하고 있었지만 이렇게나 할 수 있는 게 없을 지는 몰랐습니다. Amazon이 아니면 할 수 있는게 없습니다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/kindle-fire/kindle-fire-price.png" alt="Kindle Fire Price" title="" /></p>

<p>가지고 있던 Ipad2를 팔고 Kindle를 샀습니다. Ipad2로 고작 책밖에 읽지 않더군요. Dropbox도 Daum 클라우드도 잘되고, 영화도 보기 좋고, 음악도 듣기 좋고, 무려 32G나 되는 모델을 샀는데 OS 포함해서 3G도 못 채우고 ebook만 봤습니다….</p>

<h2>Rooting</h2>

<p>Rooting에 관심 없어 보이는 Jeff Bezos의 문구를 보고(어디서 봤는지 다시 찾을 수가 없어요) 지금도 Rooting이 쉽지만, 앞으로도 쉬울 것으로 생각했습니다.</p>

<p>일단 Android Market이 필요하기 때문에 그래서 1. <a href="http://rootkindlefire.com/kindle-fire-root/how-to-root-kindle-fire-for-mac-osx-or-linux/">rootkindlefile.com</a>의 설명대로 루팅을 하고, 2. <a href="http://luckydanny.blogspot.com/2011/12/blog-post.html">Happy Danny</a>님 설명에 따라 market을 설치했습니다. 폰트를 나눔폰트로 바꾸고 그리고 이것저것 설치해보다가 Android가 아니라는 결론을 내렸습니다. 다른 거 하지 말고 그냥 ebook만 읽기로 했습니다. Google 앱도, 한글 IME도 설치하지 않았습니다.</p>

<p>Ipad와 비교해서 ebook을 보는 데는 불편하지 않습니다. 그리고 생각보다 Market에서 설치할 만한 앱이 많지 않습니다. 아마도 앱마다 설치 가능한 기기가 정해져 있는 것 같습니다. 넥서스원에서 사용하던 앱들을 Kindle Fire에서는 쓸 수 없습니다. Kindle Fire문제는 아닙니다만, 가장 아쉬운건 instapaper입니다.</p>

<p>Kindle Fire는 Tablet이 아닌 것 같아요. Rooting하면 Tablet처럼 쓸 수는 있지만, 여전히 Android라고 할 수 없습니다. 그래도 Rooting하면 인터파크 ebook 리더인 biscuit은 설치할 수 있습니다. 다른 Kindle 제품에서는 한글 ebook이 없어서 읽을 수 없지만, Kindle Fire에서는 biscuit으로 읽을 수 있습니다.</p>

<p><a href="http://blog.naver.com/PostView.nhn?blogId=dicagallery&amp;logNo=140143217330&amp;categoryNo=278&amp;viewDate=&amp;currentPage=1&amp;listtype=0">아이뮤즈의 TX72</a>같은 것도 좋아 보입니다만 일단 활자를 읽어야 하니 패널이 좋아야 합니다. TX72은 PMP 시장을 노린 것 같아요. PMP 장비로는 훌륭한 스펙입니다.</p>

<h2>결론</h2>

<p>Kindle Fire의 장점은 가격과 Biscuit이라고 할 수 있겠습니다. 지금 Kindle Fire로 '닥치고 정치'를 읽고 있습니다. 물론 인터파크에서 구입하고 Biscuit로 보고 있습니다. Rooting하는 것이 좀 귀찮지만 Tablet으로 ebook만 보실 분이라면 Kindle Fire도 괜찮은 것 같아요.</p>

<h2>update</h2>

<h3>2012-12-21</h3>

<p>Kindle Fire가 6.2.1로 업데이트 되면서 기존 rooting 방법을 막아 버렸습니다. Kindle Fire는 묻지도 따지지도 않는 잠수함 패치를 하는데, 그럼 그냥 막혀 버려요. 이번에는 아예 기존 rooting 프로그램을 쓸 수 없게 만들었습니다. <a href="http://rootkindlefire.com/kindle-fire-root/how-to-root-kindle-fire-for-mac-osx-or-linux/">rootkindlefile.com</a>에서 해결해 주길 기다리고 있습니다.</p>

<p>앞으로도 rooting이 쉬울거라는 건 취소합니다.</p>

<p>ebook 프로그램으로 yes24 app도 실치할 수 있더군요. 찾아 보면 대개는 가능할 것 같습니다. yes24, aladdin은 5번 다운로드 하는 방식이고 interpark는 동시에 5대만 등록해서 언제든지 다운로드 받는 방식입니다.</p>]]>
    </content>
  </entry>
</feed>
