<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-04-01T23:49:49Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ SMACSS: Brief Notes - Part 2 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss-part2.html" />
    <updated>2012-03-31T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss-part2.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://smacss.com/">SMACSS</a>('smacks', 아마도 '스맥스'로 읽는다)에는 '<a href="http://snook.ca/">Jonathan Snook</a>'의 오랜 경험과 통찰이 담겨 있다. SMACSS는 프레임워크라기 보다는 스타일 가이드에 가까워서 만드는 사이트에 따라 그때그때 유연하게 사용할 수 있다.</p>

<p><em>Back-End 출신이라 CSS를 사용할 때마다 '이 많은 스타일은 어떻게 관리해야 할까?'라는 궁금증을 늘 가지고 있었다. 이 책은 그 궁금증을 해결해 준다.</em></p>

<p><a href="/articles/2012/smacss.html">Part 1</a>은 CSS Rule에 대하여 다루었고, Part 2는 SMACSS의 나머지 부분을 다룬다. <a href="/articles/2012/smacss.html">Part 1</a>에서 SMACSS는 4가지 중요한 Rule이 있다고 했는데 여기 하나가 더 추가되었다.</p>

<ul>
<li>Base - 기본 스타일</li>
<li>Layout - 엘리먼트를 나열하는 것과 관련된 스타일</li>
<li>Module - 재사용 위해 하나로 묶는 스타일</li>
<li>State - Hidden/Expand나 Active/Inactive 같은 상태를 스타일</li>
<li><strong>Theme - 사이트 전체가 보이는 느낌에 대한 스타일</strong></li>
</ul>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="SMACSS" title="" /></p>

<h2>테마 Rule</h2>

<p>우리가 <a href="/articles/2012/smacss.html">Part 1</a>을 쓸 당시 저자는 사실 이 부분을 SMACSS Rule에 넣기에는 부족하지만 어쨌든 한번은 다루어야 겠다는 생각을 했다고 언급했다. 결국은 SMACSS Rule에 들아갔다.</p>

<p>테마는 웹사이트에 따라 사용할수도 사용하지 않을수도 있다. 테마를 지원하는 사이트를 살펴보면 Google 메일이나 Yahoo 메일 같은 사이트가 있다. 비록 그대가 지금 만들고 있는 웹사이트가 테마를 지원하지 않더라도 알아둘 필요가 있다고 생각한다.</p>

<h3>테마</h3>

<p>딱히 설명이 필요 없지만 굳이 정의하자면 테마라는 것은 색상 및 이미지를 사용하여 사이트의 전체적인 Look and Feel을 결정한다. 테마와 관련된 부분을 따로 하나의 CSS로 분리해두면 나중에 새로운 테마를 만들거나 테마를 서로 바꿀 때 아주 적절하게 사용할 수 있다.</p>

<p>테마는 모든 스타일을 재정의 할 수 있다. 예를 들어 링크의 색상을 바꾼다거나 사이트 전체의 레이아웃을 변경할 수도 있다. 테마와 스타일을 분리하기 위해 클래스 이름을 쓰는 방법도 있지만 대개 테마를 하나의 파일로 분리하여 사용하면 될 것이다.</p>

<h3>타이포그러피</h3>

<p>마지막으로 중요한 것이 타이포그러피(역주: 활자라 부르고 싶다)이다. 종종 사이트의 타이포그러피를 전체적으로 변경해야 할 상황이 있다. 또한 예를 들어 여러 나라의 언어를 지원할 때 만약 한국어나 중국어의 글자는 크기가 작으면 읽기가 매우 힘들다. 이러한 경우에도 전반적인 글자 크기 조정이 필요하다.</p>

<p>타이포그러피는 Base, Module, State Rule에 영향을 미치지만 Layout에는 영향을 주지 않는다. 글자의 크기를 조절할 때 약 3가지 정도의 다른 크기를 정해서 사용하는 것이 좋다. 만약 여러 단계의 글자 크기가 있다면 사용자는 구별하기 힘들어 할 것이다.</p>

<h2>상태 변경</h2>

<p>사이트를 만들 때 어떤 부분은 처음부터 보이는 부분이 있고 어떤 부분은 어떤 상태가 변경이 되어야만 보이는 부분이 있다. 상태라는 것을 무엇으로 나타내고 어떻게 변경할 수 있을까?</p>

<p><strong>클래스 이름</strong></p>

<p>마우스를 움직이거나 키보드를 누르거나하는 이벤트가 발생하면 JavaScript를 사용하여 클래스 이름을 변경할 수 있다. 클래스 이름이 변경되면 스타일이 변경되고 그에 따라 보여지는 모습도 바뀔 것이다.</p>

<p><strong>Pseudo 클래스</strong></p>

<p>Pseudo 클래스를 사용하면 JavaScript를 사용하지 않고도 상태 변경을 보여줄 수 있다. 하자만 보통 인접한 엘리먼트만 변경할 수 있는 제한이 있다.</p>

<p><strong>미디어 쿼리</strong></p>

<p>페이지가 보여지는 화면의 크기에 따라 스타일을 변경할 수 있다.</p>

<h3>상태 변경 해보기</h3>

<p><a href="http://smacss.com/book/state">SMACSS - Changing State</a> 사이트에서 저자는 상태를 변경하는 여러 코드를 직접 보여주고 있다. '클래스 이름으로 상태 변경하기', 'Pseudo 클래스로 상태 변경하기', '미디어 쿼리로 상태 변경하기' 등의 예제를 볼 수 있다.</p>

<h2>SMACSS를 쓰면...</h2>

<p>이어지는 아래의 여러 내용은 SMACSS를 적용했을 때 기대할 수 있는 부분을 설명하고 있다.</p>

<h2>적용도(Depth of Applicability)</h2>

<p>깊이는 쉽게 말해 CSS 셀렉터의 길이를 의미한다. CSS 깊이 문제는 이미 만들어놓은 HTML 구조에 관련있는 것이고 HTML 구조를 그대로 CSS 셀렉터에 표현하면 너무 길어진다. 예를 들어 다음과 같은 CSS Rule이 있으면:</p>

<pre class="prettyprint"><code>#sidebar div, #footer div {
    border: 1px solid #333;
}

#sidebar div h3, #footer div h3 {
    margin-top: 5px;
}

#sidebar div ul, #footer div ul {
    margin-bottom: 5px;
}
</code></pre>

<p>div 엘레멘트를 기본으로 하여 다음과 같이 바꿀 수 있다.</p>

<pre class="prettyprint"><code>.pod {
    border: 1px solid #333;
}

.pod &gt; h3 {
    margin-top: 5px;
}

.pod &gt; ul {
    margin-bottom: 5px;
}
</code></pre>

<p>엘리먼트 마다 Class 셀렉터를 만들지 않고 <code>.pod</code> 하나만 만들었다. 깊이도 간단해졌고 문서 구조에 따라 의도하지 않은 CSS 적용도 피할 수 있다. 문서 구조는 변하지 않았지만 대신 적용해야 하는 부분마다 <code>.pod</code> 클래스를 지정해줘야 한다 이런 점이 고민할 부분이다. 한 쪽으로 치우치면 다른 한 쪽이 아쉬워진다.</p>

<p>이렇게 얕은 깊이의 CSS은 템플릿 엔진을 사용할 때 효과적이다. 이 CSS를 따르는 <a href="http://mustache.github.com/">Mushache</a>의 템플릿 코드를 살펴보자:</p>

<pre class="prettyprint"><code>&lt;div class="pod"&gt;
    &lt;h3&gt;{{heading}}&lt;/h3&gt;
    &lt;ul&gt;
        {{#items}}
        &lt;li&gt;{{item}}&lt;/li&gt;
        {{/items}}
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>중요한 점은 관리성, 성능, 가독성을 잘 조화시켜야 한다. CSS 셀렉터 길이가 너무 길면 HTML 여기저기 클래스 속성이 남발하는 것을 낮출 수 있지만 관리성과 가독성을 포기해야 한다. 반대로 모든 엘리먼트에 Class 셀렉터를 새로 만들어 줄 수도 있다. 이 예제에서 h3, h1에 까지 class 셀렉터를 부여하는 것은 불필요하다.</p>

<p>Container는 보통 Header, Body, Footer 영역으로 나눈다. 이 것은 일종의 디자인 패턴이라고 할 수 있다. 그래서 <code>.pod &gt; ul</code>을 다음과 같은 CSS Rule을 만들고 HTML에 적용시면:</p>

<pre class="prettyprint"><code>.pod-body {
    margin-bottom: 5px;
}
</code></pre>

<p>Container 안에서 ul, ol, div에서 클래스 지정만으로 같은 효과를 사용할 수 있다.</p>

<p>이렇게 단일 셀렉터를 사용하면 결국 '어떤 CSS 셀렉터를 사용해야 할지?' 더는 고민하지 않아도 된다. 특별한 이유가 없으면 이렇게 단일 셀렉터를 사용하는게 장땡이다.</p>

<h2>셀렉터 성능 고려</h2>

<p>성능을 위해 CSS 셀렉터를 어떻게 적용할 지 몇가지 팁을 제시하고 있다. 성능 측정을 위해 몇 가지 도구를 사용한다고 말하는데 <a href="http://css-tricks.com/efficiently-rendering-css/">Google Page Speed</a>같은 프로그램으로 한번 측정해보는 것이 적당할 것이다.</p>

<p>우선 스타일은 HTML의 엘리먼트가가 생성되는 시점에 적용이 된다. 브라우저는 HTML문서를 일종의 Stream으로 다룬다. 그러니까 먼저 들어온 엘리먼트를 먼저 생성한다. 다음 예제를 보면:</p>

<pre class="prettyprint"><code>&lt;body&gt;
    &lt;div id="content"&gt;
        &lt;div class="module intro"&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="module"&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
            &lt;p&gt;Lorem Ipsum &lt;span&gt;Test-&lt;/span&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p><code>body, div#content, div.module.intro ...</code> 순으로 엘리먼트를 생성하고 스타일을 evaluate한다는 말이다. 각 엘리먼트를 Evaluate할 때 Font는 뭐고, 컬러는 뭐고, 높이나 넓으는 얼마인지 브라우저는 정리한 스타일대로 적용하고 그린다. 그리고 하위 엘리먼트의 크기가 바뀌면 브라우저는 Body를 다시 그려야(Repaint)한다고 생각한다(저자는 다른 변수가 있는 사례가 있다고 의심하지만 확실한 것은 보통 width와 height값이 바뀌면 다시 그린다는 것이다).</p>

<p>HTML이 실제로 Render되는 영상을 소개하고 있다. <a href='http://youtu.be/ZTnIxIA5KGw'>http://youtu.be/ZTnIxIA5KGw</a> 는 Firefox의 reflow/repaint 영상이다.</p>

<h3>Right to Left</h3>

<p>CSS는 오른쪽 부터 Evaluate한다. <code>#content &gt; div &gt; p</code> 같은 셀렉터가 있다면 <code>p</code> 엘리먼트가 그려질 때 마다 상위 <code>div</code>를 찾고 상위 <code>#content</code>를 찾는다. 스타일이 적용되기 위해 셀렉터가 찾아봐야 하는 엘리먼트의 갯수가 얼마나 될지 생각해봐야 한다.</p>

<h3>그외 다른 규칙은?</h3>

<p>Google Page Speed는 다음 네 가지 셀렉터 Rule은 비효율적이라고 말한다.</p>

<ul>
<li><code>#content h3</code>와 같은 Descendant Selector</li>
<li><code>#content &gt; h3</code>와 같은 Child Selector</li>
<li><code>div#content &gt; h3</code>와 같이 불필요한 엘리먼트까지 정의하는 Selector</li>
<li><code>div#content:hover</code>와 같이 link 엘리먼트가 아닌 엘리먼트에 :hover를 정의하는 Selector</li>
</ul>

<p>자세한 내용은 <a href="http://code.google.com/speed/page-speed/docs/rendering.html">Google Page Speed의 조언</a>을 참고하는 것이 좋다.</p>

<p><a href="http://css-tricks.com/efficiently-rendering-css/">Efficiently Rendering CSS</a> 사이트를 참고해 보는 것도 좋다.</p>

<h2>HTML5와 SMACSS</h2>

<p><a href="http://smacss.com/">SMACSS</a>는 당근 HTML5에 잘 들어맞는다. 사실 HTML4에도 잘 들어맞는다. <a href="http://smacss.com/">SMACSS</a>는 다음 두 가지 목표를 위해 노력하기 때문이다.</p>

<ol>
<li>증가: HTML과 Content에서 Section의 의미</li>
<li>감소: 특정 구조로 HTML을 만들거라는 기대</li>
</ol>

<p>특히 HTML5에서 새로 추가된 의미 태그는 1번 항목을 도와준다. 하지만 HTML5라고 해서 충분히 모든 의미를 포함할수는 없다. 클래스 속성을 통해서 아주 구체적인 의미를 밝힐 수 있다. 아래의 두 <code>&lt;nav&gt;</code> 엘리먼트는 클래스로 그 의미를 밝혀두고 있다. 클래스 속성에 따라 <code>nav-primary</code> 클래스는 가로 메뉴로, <code>nav-secondary</code> 세로메뉴로 만들수도 있다.</p>

<pre class="prettyprint"><code>&lt;nav class="nav-primary"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;…&lt;/ul&gt;
&lt;/nav&gt;

&lt;nav class="nav-secondary"&gt;
    &lt;h1&gt;External Links&lt;/h1&gt;
    &lt;ul&gt;…&lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h3>2단계 메뉴 목록</h3>

<p>SMACSS의 목표는 최대한 얕은 깊이의 셀렉터를 사용하는 것이다. 만약 아래와 같은 마크업이 있을 때 2단계를 어떻게 다르게 처리할 수 있을까.</p>

<pre class="prettyprint"><code>&lt;nav class="nav-primary"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;About Us
            &lt;ul&gt;
                &lt;li&gt;Team&lt;/li&gt;
                &lt;li&gt;Location&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<p>CSS 셀렉터를 중첩해서 쓰면 아래와 같다:</p>

<pre class="prettyprint"><code>nav.nav-primary li { 
    display: inline-block; 
}

nav.nav-secondary li,
nav.nav-primary li li {
    display: block;
}
</code></pre>

<p>자 여기서 엘리먼트를 제한하는 <code>nav</code>를 제거하고 셀렉터의 깊이도 더 얕게 만들어보면:</p>

<pre class="prettyprint"><code>.l-inline &gt; * { 
    display: inline-block;
}

.l-stacked &gt; * {
    display: block;
}
</code></pre>

<p>요렇게 만들어볼 수 있다. 마크업은 아래와 같이 수정되어야 한다.</p>

<pre class="prettyprint"><code>&lt;nav class="l-inline"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;About Us
            &lt;ul class="l-stacked"&gt;
                &lt;li&gt;Team&lt;/li&gt;
                &lt;li&gt;Location&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h2>프로토타입</h2>

<p>좋은 프로그래머는 패턴을 좋아해~ 좋은 디자이너도 패턴을 좋아해~</p>

<p>패턴으로서 재사용성을 높일 수 있다. SMACSS는 코드에서도 디자인에서도 패턴을 찾아내려 애쓴다. 프로토타입을 써서 전체적인 혹은 빌딩 블록 각 부분의 코드와 디자인이 제대로 되었는가를 확인할 수 있다. 잘 만든 디자인과 코드는 재사용하기가 매우매우 좋다. <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> 과 <a href="http://960.gs/">960.gs</a>를 보라.</p>

<h3>프로토타입</h3>

<p>프로토타입을 통해 다음 사항을 확인해볼 수 있다.</p>

<p><strong>상태</strong></p>

<p>프로토타입에서는 정의해 둔 모든 상태에 대해서 테스트해 볼 수 있어야 한다. 데이터를 필요로 한다면 JSON이든 실제 서버든 간에 만들어서 테스트해보아야 한다.</p>

<p><strong>지역화</strong></p>

<p>사이트가 여러 언어를 지원하면 프로토타입을 통해 지역화를 지원하는지, 지역화를 통해 레이아웃이 손상되지 않는지 테스트 해볼 수 있다.</p>

<p><strong>의존관계</strong></p>

<p>프로토타입을 통해 각 모듈이 잘 보여지기 위한 최소의 필요조건을 테스트해볼 수 있다. 사이트가 커질수록 불필요한 부분을 줄이는것이 중요하다.</p>

<h3>퍼즐 맞추기</h3>

<p>야후처럼 아주 큰 사이트의 경우 프로토타입을 만들기 위한 시스템을 구축하여 부분적인 또한 전체적인 스타일을 테스트 해볼 수 있다. 운영하는 사이트가 규모가 작다면 이런 시스템은 오히려 배보다 배꼽이 더 클수도 있다. 사이트에 적당한 프로토타입을 정하는것이 중요하다.</p>

<p>좋은 모듈을 만들고 패턴을 재사용하기 좋게 만드는 것이 추구해야할 목적이다. <a href="http://www.flickr.com/photos/aarronwalter/5579386649/">MailChimp의 디자인 패턴 깜지</a>처럼 한눈에 보기쉽게 정리해두면 좋을 것이다.</p>

<p>패턴은 락(樂)이다. 패턴을 코드로 만듦도 락(樂)이다. 패턴을 리뷰하고 테스트 하는 프로세스를 만듦은 극락(極樂)이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ GitHub로 남의 프로젝트에 감놓고 배놓기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/how-to-github.html" />
    <updated>2012-03-31T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/how-to-github.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://github.com/">GitHub</a>를 사용하여 오픈소스 프로젝트에 어떻게 참여할 수 있는 방법을 정리한다. GitHub에 계정이 있어야 하고 <a href="http://git-scm.org/">Git</a>을 어느정도 써 본 사람이어야 한다. </p>

<p><em>원문은 <a href="http://gun.io/">Rich Jones</a>의 <a href="http://gun.io/blog/how-to-github-fork-branch-and-pull-request/">How to GitHub: Fork, Branch, Track, Squash and Pull Request</a> 이다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/how-to-github/banner_ul2.png" alt="gun.io" title="" /></p>

<h2>저자 공지사항</h2>

<p><a href="http://github.com/">GitHub</a>에서 활동하는 개발자 중 저자의 <a href="http://gun.io/contracts/new/">구인구직 사이트</a>에 등록하면 구직하는 사람과 연결해준다고 한다. 관심있는 사람은 둘러보시길!</p>

<h2>자 시작!</h2>

<p><a href="http://github.com/">GitHub</a>에서 저장소를 새로 하나 만들면 아래와 같은 설명을 보여준다.</p>

<p><img src="/articles/2012/how-to-github/LiEI3.png" alt="GitHub" title="" /></p>

<p>GitHub은 새로운 프로젝트와 새로운 저장소를 만들었을 경우에 대한 설명은 친절하게 해주고 있다. 하지만 다른 프로젝트를 개선하고 참여하는 방법에 대해서는 그다지 좋은 설명을 해주고 있지 않다. 이 글은 그러한 점에서 도움이 될 것이다.</p>

<p>우선 시작하기 전에 고쳐보고 싶은 프로젝트를 하나 골라보자. GitHub에서 프로젝트를 찾아서 코드도 둘러보고 익숙한 개발방식을 갖고 있는지 확인도 해보고 커밋 로그도 살펴보고 참여하는 사람이 어떤 사람인지도 살펴들 보자.</p>

<h2>네트워크</h2>

<p><img src="/articles/2012/how-to-github/naZ6I.png" alt="GitHub Network" title="" /></p>

<p>네트워크 그림이다. 'mobile' 이라는 브랜치에서 누군가 열심히 작업을 하고 있기 때문에 'mobile'에 대한 일을 하는 수고는 하지 않는것이 좋을듯 하다.</p>

<p>우선 해야할 일은 프로젝트의 네트워크를 확인해보는 것이다. 네트워크를 확인함으로서 누가 어떤일을 하고 있는지를 살펴볼 수 있다. 네트워크를 한참 들여다보면 고쳐보고자 하던 부분도 이미 다른이가 하고 있는지 알수도 있다. 프로젝트 활동상황도 알 수 있으며 고친 부분이 어떻게 프로젝트에 Merge되는지도 알 수 있다.</p>

<h2>이슈 등록</h2>

<p><img src="/articles/2012/how-to-github/oksQI.png" alt="GitHub Issue" title="" /><br /><em>이슈가 왔어요!</em></p>

<p>프로젝트 화면에서 이슈메뉴로 가 봅시다. 얼마나 많은 이슈가 있는지 그리고 내가 고쳐보고픈 부분이 이미 이슈로 등록이 되어있는지 알 수 있다.</p>

<p>많은 사람들이 잊기 쉬운 이 과정이 왜 중요하냐면 고친점을 보내는 사람들은 보통 프로젝트의 관리자 즉 메인테이너가 같은 문제로 고민중이라는 점을 전혀 고려하지 않기 때문이다.</p>

<p>고쳐볼 부분이 아직 이슈로 등록이 안되어있다면 새로 하나 등록하자. 이슈를 등록할때는 메인테이너에게 공손히 프로젝트에 감사하다는 마음을 갖고 고쳐보고자 하는 버그나 개선사항을 적는거다.</p>

<p>메인테이너가 만들어진 이슈에 대한 댓글로 도움이 될 만한 점을 달아줄지도 모른다.</p>

<h2>Fork로 저장소 분리</h2>

<p><img src="/articles/2012/how-to-github/VWFCB.png" alt="Hardcore Fork" title="" /></p>

<p>'Fork' 버튼을 누르는 희열!! 복제된 저장소가 내 가슴속으로 들어왔다. 나의 복제된 저장소 페이지로 가보라! Clone해서 내려받을 수 있는 주소가 적혀있을 것이다. 바로 그냥 내려받는거다.</p>

<pre class="prettyprint"><code>git clone **your ssh/git url**
</code></pre>

<h2>Fork로 만든 저장소와 원본 저장소 연결</h2>

<p><img src="/articles/2012/how-to-github/bbNRs.png" alt="Fork" title="" /><br /><em>Fork가 이거냥!</em></p>

<p>이 과정이 꼭 필요한건 아니다. 하지만 단 한번만 이 프로젝트에 참여할 것이 아니라면 이 과정을 해두면 정말 쓸모있다. 아래 명령을 실행하여 원래 프로젝트 저장소를 'upstream'으로 등록해두면 원래 프로젝트의 변경사항을 계속 받아볼 수 있다. 'upstreamname'과 'projectname' 부분을 실제 프로젝트에 맞게 적당히 바꿔서 명령을 실행한다.</p>

<pre class="prettyprint"><code>git remote add --track master upstream git://github.com/upstreamname/projectname.git
</code></pre>

<p>자 이렇게 하면 <code>upstream</code> 이라는 리모트로 등록이 된다.</p>

<pre class="prettyprint"><code>git fetch upstream
</code></pre>

<p>이렇게 하면 원래 프로젝트의 최신 내용을 받아오고</p>

<pre class="prettyprint"><code>git merge upstream/master
</code></pre>

<p>이렇게 하면 최신 내용을 현재 작업하고 있는 브랜치에 Merge하게 된다. 짜잔!</p>

<h2>개발용 브랜치</h2>

<p><img src="/articles/2012/how-to-github/fI9qT.gif" alt="Old Internet" title="" /><br /><em>그 옛날의 인터넷이 생각나지 않나요들?</em></p>

<p>자 이제 고쳐야 할 부분에 집중하기 위해 <code>master</code> 브랜치에서 새로운 브랜치로 <code>checkout</code>할 때가 왔다. Pull Request는 Branch 단위로 하기 때문에 브랜치를 잘 만들어두는게 중요하다. 고쳐야 할 이슈가 여럿이라면 브랜치도 여러개 이어야 겠다. 아래처럼 해서 브랜치를 만들자:</p>

<pre class="prettyprint"><code>git branch newfeature
</code></pre>

<p>해당 브랜치로 바꾸려면 즉 <code>checkout</code> 하려면:</p>

<pre class="prettyprint"><code>git checkout newfeature
</code></pre>

<p>새로 만든 브랜치로 변경했다. 현재 위치한 브랜치를 확인하려면 <code>git branch</code>를 실행해보라.</p>

<h2>Hack!</h2>

<p>이제 실제 고치는 작업을 하자. 계획했던 고칠점이 맘에 들 때 까지 될대로 코드를 고쳐보고 테스트해보고 행복의 경지에 이르러보자. 음하하하~</p>

<h2>커밋 하나로 합치기</h2>

<p><img src="/articles/2012/how-to-github/FgOPu.png" alt="Squash" title="" /><br /><em>이게 '스쿼시'냥!</em></p>

<p>여러분도 나처럼 엄청나게 커밋을 해댄다면 커밋 메시지는 안봐도 거지같을게('동작함!', '안돌아감', '열여덟', '후아~', 등등) 뻔하다. 사실 이런 습관은 좋지 않지만 고치고 싶은 생각도 없고 이런 습관을 가진 사람도 많이 봤다.</p>

<p>Pull Request를 보내기 전에 여러 커밋을 하나 혹은 몇 개의 커밋으로 모아서 정리하고 싶을 수도 있다. 하여 <code>git rebase</code> 명령을 써 볼 것이다. 우선 <code>git log</code>로 커밋 메시지를 확인해보고 어떻게 정리할 지 생각해둔다. 마지막 3개의 커밋을 하나로 합치려면 아래와 같은 명령을 실행한다:</p>

<pre class="prettyprint"><code>git rebase -i HEAD~3
</code></pre>

<p>명령을 실행하면 Git은 기본 편집기를 불러내서 아래같은 내용을 보여준다.</p>

<pre class="prettyprint"><code>pick df94881 Allow install to SD 
pick a7323e5 README Junkyism 
pick 3ead26f rm classpath from git 
</code></pre>

<p>각 줄이 각 커밋에 해당하는데 하나로 합치려면 아래와 같이 내용을 수정한다.</p>

<pre class="prettyprint"><code>pick df94881 Allow install to SD 
squash a7323e5 README Junkyism 
squash 3ead26f rm classpath from git 
</code></pre>

<p>내용을 저장하고 편집기를 종료하면, 새로운 내용으로 편집기가 다시 뜰텐데 그때는 새로 하나로 만들어진 커밋 메시지를 입력하는 것이다. 거지같은 커밋이 깔끔하게 정리된 새 커밋으로 재탄생했다. 만쉐이~ 이제 Pull Request를 해도 부끄럽지 않겠다.</p>

<h2>Pull Request 보내기</h2>

<p>단장하고 커밋해놓은 브랜치를 서버 저장소로 아래와 같은 명령으로 보낸다:</p>

<pre class="prettyprint"><code>git push origin newfeature
</code></pre>

<p>그리고 GitHub 사이트로 가서 새로 만든 브랜치로 이동한다. 보통 기본으로 master 브랜치로 되어있을 것이다.</p>

<p><img src="/articles/2012/how-to-github/aAd2v.png" alt="Pull Request" title="" /><br /><em>Pull Request를 보내자</em></p>

<p>브랜치로 이동한 것을 확인하고 'Pull Request' 버튼을 누르자. 다음과 같은 화면이 나오는데 브랜치에서 변경한 내용에 대한 설명을 적어주고 'Submit Pull Request' 버튼을 눌러준다.</p>

<p><img src="/articles/2012/how-to-github/5Euiy.png" alt="Pull Request" title="" /><br /><em>Pull Request 설명 달기</em></p>

<p>룰루랄라~ 끝났다. 사실 완전히 다 끝난건 아니다. 'Pull Request' 보낸 커밋에 고칠점이 있다면 메인테이너는 'Pull Request'를 바로 받아주지 않고 해당사항을 고쳐달라고 할 것이다. 메인테이너가 'Pull Request'를 닫지(Clone) 않는 한 해당 브랜치로 커밋을 Push하면 다행히도 'Pull Request' 속으로 들어간다.</p>

<h2>Pull Request 받아서 Merge하기</h2>

<p>보너스! Pull Request를 받았을 때에는 어떻게 Merge하면 되는가! 그냥 버튼 하나만 누르면 된다. 쉽네. GitHub이 버튼 한 번만 누르면 모든게 자동으로 되도록 잘 만들어놨다. 간혹, 자동으로 되지 않을때가 있는데 그때는 직접 명령어를 써서 Merge해야 한다.</p>

<pre class="prettyprint"><code>git checkout master
git remote add contributor git://github.com/contributor/project
git fetch contributor
git merge contributor/newfeature
git push origin master
</code></pre>

<p>이렇게 하면 다른사람이 수정한 내용을 메인 master 브랜치로 merge하게 된다.</p>

<h2>Pull Request를 받아주지 않는 이유</h2>

<p>이 부분은 <a href="http://gun.io/blog/how-to-github-fork-branch-and-pull-request/">원본 페이지</a>를 확인하시라!</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ KTH 발표 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/first-speach.html" />
    <updated>2012-03-29T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/first-speach.html</id>
    <content type="html">
<![CDATA[
<p>지난 3월 15일에 @kth에서 'Git이 왜 좋은가?'라는 주제로 발표했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/first-speach/first-speach.jpg" alt="first-speach" title="" /></p>

<p>Git은 정리하기도 발표하기도 어렵더라.</p>

<h2>발표</h2>

<p>발표를 한 내가 훨씬 더 배운게 많은 시간이였다. 소중한 기회를 준 KTH에 감사드린다.</p>

<p>땀이 비오듯 흘렀다. 열심히 준비했는데도 실제로 준비가 부족했고 여러가지 실수도 많이 저질렀다. 특히, 긴장하면 힘이 빠지는 체질이라 긴장하지 않기 위해 최대한 집중했는 데도 '졸린창우' 문제는 여전했다.</p>

<p>발표 후, @andrwj님이 진솔하게 조언을 해주셨다(정말 감사드립니다, 그러니까 나도 @andrwj님께 혼나본 남자!:).</p>

<p>이제 SVN을 사용하기 시작하는 회사도 봤는데 KTH 같이 규모가 되는 회사에서 Git을 도입하려는 시도는 너무 인상적이다. 질문도 많이 하셨다. KTH는 열심히 노력하는, 좋은 회사의 냄새가 난다. 왕멍의 가르침이 떠오른다.</p>

<pre class="prettyprint"><code>'입신경지立身境地'는 '변화의 경지'이다. 이것은 한두 권의 책을 읽고 도달할 수 있는 것이 아니다. 한평생 책을 읽어도 입신경지에 도달하기 어렵다. 읽기 위해서 책을 읽는다면 이를 제대로 소화할 수 없다. 이는 입신경지에 도달하는 학습의 과정이며, 실행의 과정이며, 탁마의 과정이며, 터득의 과정이며, 반성의 과정이며, 발전과 성숙의 과정이다. 이는 승화하고 정화하여 넉넉함과 충실함에 도달하는 과정이다. - 왕멍 &lt;나는 학생이다&gt;
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: git-ff ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-ff.html" />
    <updated>2012-03-24T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-ff.html</id>
    <content type="html">
<![CDATA[
<p>리모트 저장소와 내 저장소를 자주 동기화하고 싶은데 좋은 방법이 없을까? 'git pull'은 별로 맘에 들지 않는다. 전 쓴 '<a href="http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking.html">Git: Remote Tracking Branch vs Tracking Branch</a>'에서도 말했지만, Tracking 브랜치는 불편하다.</p>

<p>그래서 'git pull' 대신 사용할 수 있는 '<a href="https://github.com/pismute/git-tles/blob/master/git-ff">git ff</a>'를 만들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/git.png" alt="git-ff-result" title="" /></p>

<h2>git-ff 특징</h2>

<h3>Dirty 체크</h3>

<p>Working Directory의 상태가 Dirty가 아닐 때만 동작한다.</p>

<h3>'git fetch --prune'</h3>

<p>Fetch시 --prune 옵션을 주기 때문에 리모트에서 삭제된 브랜치가 있으면 로컬의 Remote Tracking Branch도 삭제한다.</p>

<h3>이름으로 매칭하기.</h3>

<p>원격 브랜치와 로컬 브랜치를 시스템이 연결해주는 것이 Tracking 브랜치인 건데, 이게 유용한 때도 있겠다. 아직은 모르겠지만….</p>

<p>그냥 이름으로 하는 게 알아보기도 쉽고 기억하기도 쉽다. 그래서 <code>origin/master</code>에 대응되는 로컬 브랜치는 <code>master</code>라고 간주한다.</p>

<h3>Fast-Foward Merge</h3>

<p>리모트 저장소를 Fetch하고 로컬 브랜치가 있는지 확인한 다음에 Fast-Forward Merge가 가능한 브랜치가 있으면 자동으로 Merge한다.</p>

<h3>Rebase</h3>

<p>리모트 브랜치가 수정됐지만, 로컬 브랜치도 수정됐다면 얘기가 달라진다. 그냥 Merge 하면 Merge Commit이 생긴다. 그래서 Rebase하고 나서 Fast-Forward Merge를 해야 한</p>

<p>이 기능도 넣고서 1달 정도 사용해봤는데, 큰 문제는 없었지만 영 찜찜해서 빼버렸다.</p>

<p>이 기능을 넣으려면 마음의 두려움부터 극복해야겠다.</p>

<h2>git-ff 사용법</h2>

<p>'git ff'라고 실행하면 origin에서 Fetch한다:</p>

<pre class="prettyprint"><code>git ff [remote]
</code></pre>

<p>하지만, origin이 아니라 다른 저장소로도 작업해야 할 때도 왕왕 있다. 특히 origin이 메인 저장소가 아닐 때가 그렇다. 'git ff managers'라고 실행하면 managers 저장소에서 Fetch한다.</p>

<p>실행결과는 다음과 같다:</p>

<p><img src="/articles/2012/git-ff/git-ff-result.png" alt="git-ff-result" title="" /></p>

<p>Fast-Forward Merge도 하지만 해당 저장소랑 Delta가 얼마나 되는지 한눈에 알 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Bash: 자동완성 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/bash-completion.html" />
    <updated>2012-03-17T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/bash-completion.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 'An introduction to bash completion'(<a href="http://www.debian-administration.org/articles/316">part 1</a>, <a href="http://www.debian-administration.org/articles/317">part 2</a>)을 정리한 것이다. DocPad에 Completion이 있으면 좀 편할 것 같아서 시작했다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/bash-completion/tab-key.jpeg" alt="tab-key" title="" /></p>

<p>Bash Completion은 간단한 메커니즘으로 구현하는 것 같은데 막상 원하는 대로 조작하긴 쉽지 않다.</p>

<h2>Part 1</h2>

<p>Completion 덕에 명령어와 인자를 좀 더 쉽게 사용할 수 있다. 자주 사용하는 명령어에 Completion을 구현하려면 이 글을 읽는 것이 좋다.</p>

<p>보통 셸에서 TAB 키를 누르면 파일 이름, 디렉토리 이름, 실행경로($PATH)에 있는 명령어를 자동으로 완성해준다:</p>

<pre class="prettyprint"><code>ls /bo[TAB]
</code></pre>

<p><code>/bo</code> 다음에 TAB 키를 누르면 <code>/bo</code>가 <code>/boot</code>로 대체된다.</p>

<p><a href="http://packages.debian.org/bash">Debian bash package</a>는 <code>/etc/bash_completion</code>이라는 Completion 파일이 있고 이 파일에는 일반적인 명령어에 대한 Completion이 정의돼 있다. 아직 사용하고 있지 않으면 ". /etc/bash_completion"라고 실행해서 바로 사용하자:</p>

<pre class="prettyprint"><code>skx@lappy:~$ . /etc/bash_completion
skx@lappy:~$ 
</code></pre>

<p>이걸 한 번만 해주면 다양한 명령어에 Completion을 이용할 수 있다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ apt-get upd[TAB]
skx@lappy:~$ apt-get upg[TAB]
</code></pre>

<p>그런데, 어떻게 만들지? 직접 만들고 싶은데. Completion 루틴은 'complete' 같은 bash 내부 명령어 몇 개를 조합해서 만든다. 이 루틴을 만들어 .bash_profile에 넣거나 별도의 파일로 만들어 /etc/bash_completion.d/에 넣을 수 있다.</p>

<p>/etc/bash_completion 파일을 로드하면(sourced) /etc/bash_completion.d 디렉토리에 있는 모든 파일이 같이 로드된다. 편리하다.</p>

<p>개중에는 호스트 이름을 완성해주는 것도 있다. 이 게 유용한 명령어도 있고 아닌 명령어도 있지만 하나 살펴보자.</p>

<p>저자인 [Steve][]는 <a href="http://www.debian-administration.org/articles/135">VNC로 관리하는 컴퓨터가 몇 대 있다</a>. 보통 "xvncviewer hostname"이라고 실행한다.</p>

<p>다음과 같이 complete 명령을 실행해 주면 위 명령에서 hostname 부분을 Completion할 수 있다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ complete -F _known_hosts xvncviewer
</code></pre>

<p>이 complete 명령을 한번 실행하고 [TAB]을 입력하면 다음과 같이 보여 줄 거다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ xvncviewer s[TAB]
savannah.gnu.org            ssh.tardis.ed.ac.uk
scratchy                    steve.org.uk
security.debian.org         security-master.debian.org
sun
skx@lappy:~$ xvncviewer sc[TAB]
</code></pre>

<p>이 호스트들은 나한테만 이렇게 보인다.</p>

<p>_known_hosts 함수는 /etc/bash_completion에 정의돼 있다. 이런 함수가 있다는 걸 내가 어떻게 알았을까? "complete -p" 명령을 실행하면 현재 사용하고 있는 것을 모두 보여준다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ complete -p
....
complete -F _known_hosts tracepath
complete -F _known_hosts host
...
</code></pre>

<h2>Part 2</h2>

<p>이제 직접 Completion 함수를 작성해 보자.</p>

<p>'part 1'에서 아무 명령에나 hostname을 완성하는 것을 만들어 봤다:</p>

<pre class="prettyprint"><code>complete -F _known_hosts xvncviewer
</code></pre>

<p>이 명령은 xvncviewer의 인자를 Completion할 때 _known_hosts 함수를 사용하라고 알리는 것이다.</p>

<p>이제는 이미 만들어진 함수를 사용하는 것이 아니라 직접 만들어 사용하는 것을 알아보자.</p>

<h3>A Basic Example</h3>

<p>먼저 <code>foo</code>라는 명령어의 인자를 Completion하는 예제를 만들어보자. <code>foo</code>는 다음과 같은 인자를 가진 가짜 명령어다:</p>

<ul>
<li>--help
<ul><li>Shows the help options for foo, and exits.</li></ul></li>
<li>--version
<ul><li>Shows the version of the foo command, and exits.</li></ul></li>
<li>--verbose
<ul><li>Runs foo with extra verbosity</li></ul></li>
</ul>

<p>/etc/bash_comletion을 로드할 때 자동으로 로드되도록 /etc/bash_completeion.d/foo 파일을 만든다. </p>

<p>파일에 다음과 같은 내용을 넣고 저장한다:</p>

<pre class="prettyprint"><code>_foo() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="--help --verbose --version"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}
complete -F _foo foo
</code></pre>

<p>그리고 나서 이 파일만 읽어들여 테스트해본다: </p>

<pre class="prettyprint"><code>skx@lappy:~$ . /etc/bash_completion.d/foo
skx@lappy:~$ foo --[TAB]
--help     --verbose  --version  
</code></pre>

<p>한번 해보면 인자가 자동으로 완성되는 것을 볼 수 있다. 그리고 예를 들어, "foo --h[TAB]"라고 입력하면 '--help' 옵션을 자동으로 완성해준다</p>

<p>이제 실제로 동작하는 것을 만들어 봤고 어떻게 동작하는 것인지 뜯어보자!</p>

<h3>How Completion Works</h3>

<p>Completion에 사용할 함수를 간단하게 구현해봤다.</p>

<p>이 함수는 cur, prev, opts 옵션을 정의하면서 시작한다. cur는 '현재 입력된 단어(word)'에 사용하고, prev는 '이전에 입력된 단어'에, opts는 Completion할 옵션에 사용한다.</p>

<p>그리고 실제로 옵션을 Completion하는 것은 compgen이라는 명령어를 통해서다:</p>

<pre class="prettyprint"><code>COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
</code></pre>

<p>compgen 명령의 결과를 $COMPREPLY에 할당한다:</p>

<pre class="prettyprint"><code>compgen -W "${opts}" -- ${cur}
</code></pre>

<p>여기서 변수 대신 실제 값을 넣어보면 이 명령이 실제로 어떻게 동작하는지 이해하기 쉬울 것이다:</p>

<pre class="prettyprint"><code>compgen -W "--help --verbose --version" -- "userinput"
</code></pre>

<p>compgen은 "--help --verbose --version" 중에서 "${cur}"와 일치하는 것을 찾아 리턴한다. 잘 이해가 안되면 바로 셸에서 이 명령을 직접 실행해 보면 알 수 있다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ compgen -W "--help --verbose --version" -- --
--help
--verbose
--version
skx@lappy:~$ compgen -W "--help --verbose --version" -- --h
--help
</code></pre>

<p>"--"라고 입력하면 세 옵션 모두 일치하므로 전부 반환된다. 하지만 "--h"만 입력하면 "--help"만 일치하므로 --help만 반환한다.</p>

<p>그래서 이 결과를 "COMPREPLY" 변수에 할당하면 bash가 입력 중인 부분의 글자를 대체시킨다. bash에서 COMPREPLY는 Completion 루틴에서 결과를 반환하는 방법이라서 특별한 의미가 있는 변수다.</p>

<p><a href="http://www.gnu.org/software/bash/manual/bash.html">the bash reference manual</a>에 있는 COMPREPLY에 대한 설명을 살펴보자:</p>

<h4>COMPREPLY</h4>

<p>Completion 함수가 반환한 결과를 배열 형태로 반환하고 Bash가 이 변수를 읽는다.</p>

<p>그리고 사용자가 입력하는 단어가 무엇인지 COMP_WORDS라는 배열로 알 수 있다. 그리고 현재 단어와 이전 단어가 무엇인지도 알 수 있다.</p>

<h4>COMP_WORDS</h4>

<p>지금 Command line에 있는 각 단어가 담긴 배열이다. 이 변수는 Completion을 만들 때 사용하는 명령어를 통해 호출한 함수에서만 사용할 수 있다.</p>

<h4>COMP_CWORD</h4>

<p>${COMP_WORDS} 배열에서 현 단어를 가리키는 인덱스다. 이것도 Completion 명령어가 호출한 함수에서만 사용할 수 있다.</p>

<h3>A Complex Example</h3>

<p>옵션이 굉장히 복잡한 명령어도 많다. 이런 명령어는 상당히 정교한 작업이 필요하다.</p>

<p>Xen에 있는 xm 명령어의 예를 살펴보자(<a href="http://www.ibm.com/developerworks/kr/library/l-xen/">developerworks의 Xen 소개</a>):</p>

<ul>
<li>xm list
<ul><li>List all running Xen instances</li></ul></li>
<li>xm create ConfigName
<ul><li>Create a new Xen instances using the configuration file in /etc/xen called ConfigName.</li></ul></li>
<li>xm console Name
<ul><li>Connect to the console of the running machine named "Name".</li></ul></li>
</ul>

<p>예를 들어, "xm operation args" 라는 명령어에서 "args"는 앞에 "operation"이 무엇이냐에 따라 다르다.</p>

<p>먼저 "operation"의 Completion을 구현하는 것은 앞에서 설명했던 것과 방법이 같다. "--" 없이 구현하고 사용하면 된다. 하지만, 후속 인자를 Completion하는 것은 특별한 처리가 필요하다.</p>

<p>Completion할 때 이전 토큰을 알아야 해서 명령어마다 다르게 처리한다. 예를 들자면:</p>

<pre class="prettyprint"><code>_xm() 
{
    local cur prev opts base
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    #
    #  The basic options we'll complete.
    #
    opts="console create list"


    #
    #  Complete the arguments to some of the basic commands.
    #
    case "${prev}" in
        console)
            local running=$(for x in `xm list --long | grep \(name | grep -v Domain-0 | awk '{ print $2 }' | tr -d \)`; do echo ${x} ; done )

            COMPREPLY=( $(compgen -W "${running}" -- ${cur}) )
            return 0
            ;;
        create)
            local names=$(for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//} ; done )

            COMPREPLY=( $(compgen -W "${names}" -- ${cur}) )
            return 0
            ;;
        *)
            ;;
    esac

    COMPREPLY=($(compgen -W "${opts}" -- ${cur}))  
    return 0
}
complete -F _xm xm
</code></pre>

<p>이 코드는 "operation"을 Completion하는 것이고 "create"와 "console"이라는 "operation"에 대해서는 추가적인 코드를 더 했다. <br />사용자가 입력하는 값을 Completion하기 위해 compgen을 사용하는 것까지는 같지만, 상황에 따라 다른 목록을 사용한다.</p>

<p>"console" operation에 사용하는 목록은 다음과 같은 명령으로 만든다:</p>

<pre class="prettyprint"><code>xm list --long | grep \(name | grep -v Domain-0 | awk '{ print $2 }' | tr -d \)
</code></pre>

<p>이 명령은 지금 도는 Xen 시스템의 목록을 반환한다.</p>

<p>"creation" operation에 사용하는 목록은 다음 명령으로 만든다:</p>

<pre class="prettyprint"><code>for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//} ; done
</code></pre>

<p>이 명령은 /etc/xen 디렉토리에 있는 '*.cfg' 파일을 모두 반환한다. 예를 들면 다음과 같다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//}; done
etch.cfg
root.cfg
sarge.cfg
steve.cfg
x.cfg
skx@lappy:~$ 
</code></pre>

<h3>Other Completion</h3>

<p>지금까지 compgen을 사용해서 사용자가 입력한 값과 일치하는 스트링을 찾았다. 찾을 스트링은 하드 코딩한 목록이거나 명령어가 반환하는 결과에서 찾았다. 디렉토리 이름이나 프로세스 이름등 다른 것에서 찾을 수도 있다. 자세한 내용은 "man bash"를 실행해서 살펴볼 수 있다.</p>

<p>다음은 파일과 호스트이름을 Completion하는 방법을 설명하는 예제다:</p>

<pre class="prettyprint"><code>#
#  Completion for foo:
#
#  foo file [filename]
#  foo hostname [hostname]
#
_foo() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="file hostname"

    case "${prev}" in
        file)
        COMPREPLY=( $(compgen -f ${cur}) )
            return 0
            ;;
        hostname)
        COMPREPLY=( $(compgen -A hostname ${cur}) )
            return 0
            ;;
        *)
        ;;
    esac

    COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
}
complete -F _foo foo
</code></pre>

<p>이 예제를 활용하면 직접 Completion 함수를 만들 수 있다. 사실 Completion 함수를 만드는데 시간이 많이 들고 나머지는 매우 간단하다.</p>

<p>@pismute가 만든 <a href="https://github.com/dogfeet/docpad/blob/dogfeet/contrib/docpad-completion.bash">docpad-completion.bash</a>도 읽어 볼 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ SMACSS:The Icon Module ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss-icon-module.html" />
    <updated>2012-03-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss-icon-module.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="https://smacss.com/book/icon-module">The Icon Module</a>을 정리한 것이다. <a href="https://smacss.com/">SMACSS</a>를 읽고 SMACSS의 철학이 실제로 어떻게 적용되는지 알아보기에 좋다. 이글은 'CSS Sprite' 기법을 사용하는 엉성한 Icon Module을 SMACSS의 방법으로 단단한 Icon Module로 리팩토링하는 것을 보여준다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="smacss" title="" /></p>

<p>이 글은 무료로 공개돼 있지 않다.</p>

<h2>SMACSS</h2>

<p><a href="https://smacss.com/">SMACSS</a>는 좋은 책이다. CSS '관리'에 초점을 맞추고 이렇게 일목요연하게 정리된 자료는 일찍이 보지 못했다. 이 글을 읽고 도움이 됐다면 <a href="https://smacss.com/">SMACSS</a>를 꼭 사길 바란다. $30 짜리 workshop 계정을 사면 저자인 <a href="http://snook.ca/">Jonathan Snook</a>가 지속적으로 업데이트하는 유로 컨텐츠를 계속 이용할 수 있다.</p>

<h2>The Icon Module</h2>

<p>Asset(Image)을 한 파일로 모으면 HTTP 요청 수도 줄고 이미 모든 Asset을 내려받았기 때문에 나중에 필요할 때 바로 사용할 수 있다. 이것을 <code>CSS Sprite</code>라고 부른다.</p>

<p>다음 그림을 보면 이 말이 무슨 뜻인지 알 수 있다:</p>

<p><img src="/articles/2012/smacss/icon-menu.png" alt="icon-menu" title="" /></p>

<p>Menu HTML:</p>

<pre class="prettyprint"><code>&lt;ul class="menu"&gt;
    &lt;li class="menu-inbox"&gt;Inbox&lt;/li&gt;
    &lt;li class="menu-drafts"&gt;Drafts&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Menu CSS:</p>

<pre class="prettyprint"><code>.menu li {
    background: url(/img/sprite.png) no-repeat 0 0;
    padding-left: 20px;
}

.menu .menu-inbox {
    background-position: 0 -20px;
}

.menu .menu-drafts {
    background-position: 0 -40px;
}
</code></pre>

<p>모든 Icon은 Sprite 파일 하나에 다 들어 있고 아이템마다 필요한 Icon이 있는 위치를 보여준다.</p>

<p>이걸로도 되긴 되지만 좀 더 작업을 다듬을 수 있다:</p>

<ul>
<li>list 아이템이라는 특정 DOM에만 사용할 수 있다.</li>
<li>모듈마다 Sprite를 항상 다시 만들어야 한다.</li>
<li>위치가 취약하다: 폰트 크기를 늘리면 다른 부분이 살짝 보일 수 있다.</li>
<li>x가 항상 0이기 때문에 수평적으로 처리하기 까다롭다.</li>
</ul>

<p>이 이슈만 해결되면 소위 Icon Module이라 칭할 수 있다.</p>

<p>Icon Module을 사용하도록 HTML을 바꾼다:</p>

<pre class="prettyprint"><code>&lt;li&gt;&lt;i class="ico ico-16 ico-inbox"&gt;&lt;/i&gt; Inbox&lt;/li&gt;
</code></pre>

<p><code>&lt;i&gt;</code> 태그는 간단하고 시맨틱과는 거리가 먼 태그다. Icon은 다른 텍스트를 부연 설명하는 거니까 시멘틱이 없는 태그라고 볼 수 있다. Icon이 혼자 쓰일 때는 꼭 title 속성을 넣어줘서 Screen Reader나 tooltip에서 읽을 수 있도록 해주는 것이 좋다. <code>&lt;i&gt;</code> 태그가 싫다면 <code>&lt;span&gt;</code> 태그가 적당하다.</p>

<p><code>&lt;i&gt;</code>는 HTML 속 어디에 넣어도 되니까 HTML 구조의 의존성은 사라졌다고 볼 수 있다.</p>

<p>그리고 "ico ico-16 ico-inbox" 클래스는 각각 역할이 다르다. 게다가 <code>&lt;img&gt;</code> 태그와 잘 섞어 사용할 수 있다.</p>

<p>Icon Module CSS:</p>

<pre class="prettyprint"><code>.ico {
    display: inline-block;
    background: url(/img/sprite.png) no-repeat;
    line-height: 0;
    vertical-align: bottom;
}

.ico-16 {
    height: 16px;
    width: 16px;
}

.ico-inbox {
    background-position: 20px 20px;
}

.ico-drafts {
    background-position: 20px 40px;
}
</code></pre>

<p><code>ico</code> 클래스는 모듈의 기본적인 토대를 다지는 클래스다. <code>&lt;img&gt;</code>처럼 inline-block 엘리멘트로 만들고 <code>vertical-align</code>으로 Icon이 텍스트와 잘 어우러지도록 해준다. IE는 <code>inline-block</code>을 <code>block</code> 엘리먼트로 취급하기 때문에 IE에서는 <code>{ zoom:1; display:inline; }</code>로 해야 한다.</p>

<p><code>ico-16</code>은 크기 정해주기 위함이다. ico 클래스에 같이 넣어줘도 되지만 Icon마다 크기가 다를 수도 있어서 이렇게 하는 거다.</p>

<p><code>icon-inbox</code>는 Sprite 이미지에서의 Inbox용 Icon의 위치를 정의하는 것이다.</p>

<p>촘촘히 우겨넣은 이미지:</p>

<p><img src="/articles/2012/smacss/icon-menu2.png" alt="icon-menu2" title="" /></p>

<p>잘 우겨넣으면 압축 효율이 좋아진다. 그리고 파일 크기도 더 작아지므로 사이트 성능도 향상된다. 아직 <a href="http://www.smushit.com/ysmush.it/">Smush.it</a>이나 <a href="http://imageoptim.pornel.net/">ImageOptim</a>을 사용해보지 않았으면 한번 사용해보는 것이 좋다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: Remote Tracking Branch vs Tracking Branch ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking.html" />
    <updated>2012-03-02T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking.html</id>
    <content type="html">
<![CDATA[
<p>Tracking 브랜치와 Remote Tracking 브랜치는 조금 애매하다. <code>Tracking 브랜치</code> 개념은 잘 이용하지 않기 때문에 돌아서면 잊어버린다. 그래서 정리했다. 구분하고 있지 않아도 Git을 사용하는데 불편할 거라고는 생각하지 않지만, 그래도 궁금하다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking/sensei.jpeg" alt="stalker" title="" /></p>

<p>(절망선생)</p>

<h2>Remote Tracking 브랜치</h2>

<p>Remote Tracking 브랜치는 <code>origin/master</code>와 같은 브랜치를 말한다. 이 브랜치는 origin 저장소에 있는 master 브랜치가 가리키는 커밋을 그대로 가리키는 브랜치이다. 리모트 저장소의 브랜치를 Fetch해 오면 이 브랜치가 업데이트된다.</p>

<p>Remote Tracking 브랜치는 다음과 같은 특징이 있다.</p>

<ul>
<li>이 브랜치는 사용자가 임의로 수정할 수 없다.</li>
<li><code>git fetch</code>, <code>git pull</code> 명령으로만 업데이트할 수 있다.</li>
</ul>

<h2>Tracking 브랜치</h2>

<p>Tracking 브랜치는 Remote Tracking 브랜치(이하 리모트 브랜치)보다 복잡하지만 그렇다고 어려운 것도 아니다.</p>

<p>Tracking 브랜치는 로컬 브랜치이다. 로컬 브랜치 중에서 리모트 브랜치를 Tracking하는 브랜치다.</p>

<p>Tracking 특징 다음과 같다:</p>

<ul>
<li>이 브랜치는 사용자가 임의로 수정할 수 있다.</li>
<li><code>git fetch</code>로 정보가 업데이트되지 않는다. <code>git fetch</code>는 단지 리모트 저장소의 브랜치를 Tracking하는 Remote Tracking 브랜치만 만든다.</li>
</ul>

<p>Tracking 브랜치는 도우미 같은 것으로 생각하면 된다. 몰라도 크게 불편하지 않다.</p>

<h3>Tracking 브랜치 확인</h3>

<p><code>git clone</code> 명령은 리모트 저장소를 Fetch하고 나서 master 브랜치를 만들고 Checkout 해준다. 이때 master 브랜치를 origin/master 브랜치를 Tracking하도록 만든다.</p>

<p><code>git clone</code> 명령으로 저장소를 만들고 <code>git config -l</code> 명령을 실행하면 다음과 같은 설정이 들어가 있다:</p>

<pre class="prettyprint"><code>branch.master.remote=origin
branch.master.merge=refs/heads/master
</code></pre>

<h3>Tracking 브랜치 만들기</h3>

<p>Tracking 브랜치는 설정에 이런 정보를 가지고 있다. Tracking 브랜치는 만드는 게 간단하다. 리모트 브랜치에서 브랜치를 만들면 된다.</p>

<pre class="prettyprint"><code>git br tracking origin/master
git co -b tracking origin/master
</code></pre>

<p>하지만, 로컬 브랜치에서 만들면 Tracking 브랜치가 되지 않는다:</p>

<pre class="prettyprint"><code>git br tracking master
git co -b tracking master
</code></pre>

<p>이미 만든 브랜치를 Tracking 브랜치로 만들 수도 있다:</p>

<pre class="prettyprint"><code>git branch --set-upstream master origin/master
</code></pre>

<h3>쓰임새</h3>

<p>Tracking 브랜치 정보는 로컬 브랜치와 리모트 브랜치 사이의 연결 정보이고 설정에 저장된다. Git은 이 정보를 이용해서 몇 가지 정보를 제공한다.</p>

<h4>git branch -v</h4>

<p>Tracking 브랜치의 경우 리모트 브랜치와 거리가 얼마나 되는지(다른 커밋 개수를) 보여준다:</p>

<pre class="prettyprint"><code>$ git branch -v
feature/kitchen e054c7e [ahead 1, behind 1] Add sink unit
* ship            2d45d4c Add test
</code></pre>

<p><code>[ahead 1]</code>은 feature/kitchen은 origin/feature/kitchen에 없는 커밋이 하나 있다는 것이고 [behind 1]은 feature/kitchen은 origin/feature/kitchen에 있는 커밋 하나가 없다는 것이다.</p>

<h4>git checkout</h4>

<p><code>git checkout</code>도 브랜치가 Tracking 브랜치이면 얼마나 다른지 보여준다.</p>

<pre class="prettyprint"><code>$ git checkout feature/kitchen 
Switched to branch 'feature/kitchen'
Your branch and 'origin/ship' have diverged,
and have 1 and 1 different commit(s) each, respectively.
</code></pre>

<h4>git pull</h4>

<p>Tracking 브랜치를 Checkout한 상태에서 <code>git pull</code> 명령을 실행하면 현재 Checkout과 연결된 리모트 저장소와 브랜치를 설정에서 찾아서 Fetch하고 현 브랜치에 Merge한다.</p>

<p>Tracking 브랜치가 아니면 <code>git pull</code>을 할 수 없다. 그러니까 <code>git pull</code>을 하려면 Tracking 브랜치를 Checkout하고 있어야 한다.</p>

<h4>git push</h4>

<p><code>git push</code>라고 실행하면 Checkout한 브랜치와 상관없이 Tracking 브랜치를 모두 Push한다. <code>git push origin master</code>는 Tracking 브랜치와 상관없이 master 브랜치를 origin/master로 Push한다.</p>

<h2>끝으로...</h2>

<p>자동으로 Merge하는 방식은 아름다운 히스토리를 해칠 수 있다. 히스토리는 가능한 평평하게 펴줘야 하고 여러 커밋을 묶어서 관리할 필요가 있을 때만 Merge 커밋을 히스토리에 남기는 것이 좋다.</p>

<p>물론 <code>git pull</code> 명령도 --rebase, --ff, --no-ff, --ff-only와 같은 옵션이 있고 의도대로 Merge하지 못해도 복구할 수 있지만, Fetch하고 확인하고서 Merge하는 것이 아직 마음이 더 편하다.</p>

<p><code>git pull</code> 명령은 어떨 때 유용한 걸까?</p>

<p>저장소와 모든 브랜치를 동기화하는 기능이 필요하긴 하다. 복잡하게 Tracking 브랜치에 따른 것이 아니라 걍 이름으로 했으면 좋겠는데..</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Login Popup & Captive Network ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/login-popup-captive-network.html" />
    <updated>2012-02-26T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/login-popup-captive-network.html</id>
    <content type="html">
<![CDATA[
<p>스마트폰이나 노트북을 항상 들고다니는 사람이 늘어남에 따라 모바일AP(즉, 핫스팟)을 이용하는 사람도 많이 늘어났다. 아직 회원가입이나 인증하지 않은 접속장치가 핫스팟에 접속하고 인터넷을 하면 핫스팟 제공자의 안내페이지나 로그인 페이지가 뜬다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/captive-network/firstwifi.jpg" alt="firstwifi" title="" /></p>

<h2>Captive Network &amp; Problem</h2>

<p>위의 화면은 한국에 가장 많이 사용되는 핫스팟 서비스인 ollehWifi(구, 네스팟)에 접속한 화면이다. 수 많은 호텔이나 큰 규모의 건물 혹은 장소들에서 위와 같은 핫스팟 사용 안내 페이지 혹은 인증 페이지를 볼 수 있다. 이러한 페이지를 Captive Portal이라고 한다.</p>

<p>물론 위에서 ollehWifi 서비스에 가입을 했고 해당 장치가 적절히 인증을 받았다면 위와 같은 화면이 뜨지 않고 바로 원하는 사이트로 이동한다. 인터넷에는 연결했지만, 사용자가 원하는 사이트가 아니라 다른 사이트가 나온다는 점에서 작은 문제가 생긴다.</p>

<p>Wifi를 통해 네트워크에 접속은 되었지만 모바일 어플리케이션이나 웹브라우저가 인터넷에 데이터를 요청하면 실제로 받는 데이터는 원하는 데이터가 아닌 Captive Network의 안내페이지의 데이터를 받아오게 된다. 예를 들어, Captive 네트워크에 스마트폰이 Wifi로 접속해 있다면 http 프로토콜로 JSON 데이터를 요청하는 어플리케이션에서는 html로 된 Captive Portal의 페이지 정보를 받게 될 가능성이 높다. 이러한 데이터 에러를 제대로 처리하지 못하면 어플리케이션에 심각한 문제가 발생할수도 있다.</p>

<h2>Captive Network Detection</h2>

<p>앞서 살펴본 ollehWifi 인증 화면 iOS에 설치된 Captive Network 에 대한 Portal 화면이다. 이 화면은 브라우저를 띄우지 않아도 Captive Network에 접속하게 되면 OS가 자동으로 띄워준다. OS는 이러한 환경을 어떻게 찾아낼 수 있는것일까? </p>

<p><img src="/articles/2012/captive-network/panera-captive.png" alt="panera-captive" title="" /><br /><sup><a href='http://www.docstechnotes.com/2011/07/os-x-lion-learns-wi-fi-login-trick-from.html'>http://www.docstechnotes.com/2011/07/os-x-lion-learns-wi-fi-login-trick-from.html</a></sup></p>

<p>모바일뿐만 아니라 요즘은 데스크톱 OS에서도 적용되어 있다. iOS의 경우 3.0부터, Mac의 경우 Lion부터, Win의 경우 Win7부터 적용된 것 같다. Lion의 경우 브라우저 말고 이런 팝업창에서 입력한 Captive Network에 대한 사용자ID와 패스워드를 OS 차원에서 저장해주기도 한다.</p>

<p><img src="/articles/2012/captive-network/mac-captive.png" alt="mac-captive" title="" /><br /><sup><a href='http://www.apple.com/macosx/whats-new/features.html#networking'>http://www.apple.com/macosx/whats-new/features.html#networking</a></sup></p>

<p>Captive Network인지를 확인하기 위해 Lion의 경우 Captive Service가 항상 동작하고 있으며 수시로 네트워크 상황을 확인한다. Captive Network인지 확인하기 위해서 다음과 같은 URL의 데이터를 불러와본다.</p>

<pre class="prettyprint"><code>$ curl <a href='http://www.apple.com/library/test/success.html'>http://www.apple.com/library/test/success.html</a>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;TITLE&gt;Success&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
Success
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

<p><code><a href='http://www.apple.com/library/test/success.html'>http://www.apple.com/library/test/success.html</a></code>의 데이터를 불러왔을 때 진짜로 원하는 데이터가 들어있는지 확인하는 <a href="http://erratasec.blogspot.com/2010/09/apples-secret-wispr-request.html">방식</a>이다. 간단하다. Windows또한 비슷한 방식을 사용하며 <a href="http://blog.superuser.com/2011/05/16/windows-7-network-awareness/">NCSI:Network Connectivity Status Indicator</a>라고 부른다.</p>

<h2>적용 및 참고</h2>

<p>어플리케이션이 네트워크를 통해 데이터를 불러와서 사용할 때 확인해야할 것으로 다음과 같은 것이 있다.</p>

<ul>
<li>장치가 네트워크를 사용할 수 있는지</li>
<li>네트워크를 통해 데이터를 불러올 수 있는지</li>
<li>불러온 데이터가 원하는 형식인지</li>
</ul>

<p>Captive Network의 경우 위에서 확인할 사항 중 세 번째 사항에 해당할 것이다. Captive Network에 대하여 알아보려면 다음과 같은 사이트를 더 참고해 볼 수 있다.</p>

<ul>
<li><a href="http://erratasec.blogspot.com/2010/09/apples-secret-wispr-request.html">Apple's secret "wispr" request</a></li>
<li><a href="http://www.mactalk.com.au/31/66812-iphone-3-0-wireless-captive-portal-support.html">iOS 3.0에서 Captive Network 찾기</a></li>
<li><a href="http://tools.ietf.org/html/draft-nottingham-http-portal-02">Web-based 인증을 위한 표준 제안</a></li>
<li><a href="http://blog.superuser.com/2011/05/16/windows-7-network-awareness/">Windows 7의 NCSI(Network Connectivity Status Indicator)</a></li>
</ul>

<h2>사족</h2>

<p>Captive Network에서 인증을 하지 않으면 원하는 사이트에 접근할 수 없고 접속할 수 있는 포트 또한 제한된다. 인증을 거쳐야만 제대로 사용할 수 있다. 하지만 보통 인증을 위하여 DNS 프로토콜 53번 포트는 열려있는 경우가 있으므로 이를 잘 활용해(SSH 터널링, Proxy) 볼 수도 있을 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ node: npm-tricks ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/npm-tricks.html" />
    <updated>2012-02-24T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/npm-tricks.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 Guillermo Rauch의 <a href="http://www.devthought.com/2012/02/17/npm-tricks/">NPM tricks</a>을 번역한 것이다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/npm/npm.png" alt="npm" title="" /></p>

<p>나는 매일매일 NPM을 사용한다. 왠지 사람들이 잘 모를 것 같아서 쓸만한 NPM 팁을 정리했다.</p>

<h2>Dev dependencies</h2>

<p>테스트 프레임워크같이 개발할 때만 필요한 '개발용' 모듈은 <code>devDependencies</code>에 넣는다:</p>

<pre class="prettyprint"><code>"devDependencies": {
    "module": "0.1.0"
}
</code></pre>

<h2>Introspecting package.json</h2>

<p>Node 0.6부터는 <code>require()</code>로 JSON 파일을 자동으로 읽어 준다. 그래서 쉽게 모듈의 package.json 파일을 이용할 수 있다:</p>

<pre class="prettyprint"><code>// considering the module lives in lib/module.js:
exports.version = require('../package').version;
</code></pre>

<p>특정 모듈의 package.json을 읽어 오려면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>require('my-module/package').name
</code></pre>

<h2>Linking</h2>

<p>동시에 모듈을 여러 개 개발해야 할 때에는 보통 모듈들이 서로 의존하게 된다. 문제가 없는 모듈만 NPM에 Publish하기 때문에 이 때에는 다른 방법이 필요하다.</p>

<p>이때 <code>npm link</code>로 NPM에 올리지 않고도 의존성을 해결할 수 있다. 의존하는 모듈에서 <code>npm link &lt;package&gt;</code>를 실행하면 <code>global</code>에 있는 모듈을 끌어다 놓는다(link). 예를 들어, <code>moduleB</code>가 아직 개발 중인 <code>moduleA</code>에 의존하는 상황을 살펴보자:</p>

<p>You can leverage <code>npm link</code> to generate a global reference to a module, and then run <code>npm link &lt;package&gt;</code> to install it in other modules. Consider the following example, in which <code>moduleB</code> depends on the version of <code>moduleA</code> you’re currently developing, and <code>moduleB</code> specifies <code>"moduleA"</code> as a dependency in its <code>package.json</code></p>

<pre class="prettyprint"><code>$ cd moduleA/
$ npm link
$ cd ../moduleB

# moduleB의 package.json에는 
# 아직 publish하지 않은 버전의 moduleA가 필요하다고 적혀 있기 때문에
# 'npm install'은 실패한다.
$ npm install

# global에 있는 moduleA를 local에 설치한다.
$ npm link moduleA

# moduleA는 이미 설치했으니까 'npm install'이 무시한다:
$ npm install
</code></pre>

<h2>Production flags</h2>

<p><code>npm install</code>할 때 <code>--production</code> 옵션을 주지 않으면 <code>devDependencies</code>에 있는 모듈을 설치해서 시간을 낭비하게 된다:</p>

<pre class="prettyprint"><code>$ npm install --production
</code></pre>

<p>설치하면서 발생하는 로그도 볼 수 있는데, 필요한 로그를 골라 볼 수 있다:</p>

<pre class="prettyprint"><code>$ npm install --loglevel warn
</code></pre>

<h2>Git dependencies</h2>

<p>NPM에 Publish하는 대신 <code>package.json</code>에 버전 대신 URI를 넣을 수 있다. Private 모듈이든 Public 모듈이든 <code>git://</code>로 시작하는 URI를 명시할 수 있다:</p>

<pre class="prettyprint"><code>"dependencies": {
    "public": "git://github.com/user/repo.git#ref"
    , "private": "git+ssh://<a href='mailto:git@github.com'>git@github.com</a>:user/repo.git#ref"
}
</code></pre>

<p><code>#ref</code>는 생략할 수 있지만 <code>master</code>같은 브랜치, <code>0.0.1</code>같은 태그, SHA 값을(짧은 SHA도 됨) 넣을 수 있다. 태그로 사용하는 것이 좋은데, <code>npm install</code>이 항상 최신 버전을 사용하도록 하는 태그를 사용하는 것이 좋다.</p>

<h2>Local binaries</h2>

<p>가끔은 의존하는 모듈의 <code>bin</code>을 가져다 써야 할 때가 있다. 이것은 테스트를 실행하거나 컴파일을 하려고 <code>Makefile</code> 만드는 것과 비슷하다.</p>

<p>다음과 같이 다른 곳에 설치된 프로그램을 사용하는 것이 아니라:</p>

<pre class="prettyprint"><code>test:
  mocha mytest.js
</code></pre>

<p>숨겨진 <code>node_mdoules/.bin</code> 디렉토리에 있는 local 모듈을 사용한다:</p>

<pre class="prettyprint"><code>test:
  node_modules/.bin/mocha mytest.js
</code></pre>

<p>여기서는 <code>"mocha"</code>를 사용하여 테스트한다. <code>mocha</code>를 <code>package.json</code>의 <code>devDependencies</code>에 넣는다. 그러면 <code>npm install</code>을 실행할 때 모듈이 설치된다.</p>

<p>Makefile을 따로 만들지 않을 거라면 <code>npm run-script</code> 명령어를 사용할 수 있다. <code>package.json</code>의 <code>scripts</code>에 다음과 같이 정의한다:</p>

<pre class="prettyprint"><code>"scripts": {
        "test": "mocha mytest.js"
          , "build": "uglify mycode.js
}
</code></pre>

<p>그러면 다음과 같이 실행할 수 있다:</p>

<pre class="prettyprint"><code>$ npm run-script test
$ npm run-script build
$ npm test # shortcut for `run-script test`
</code></pre>

<p>게다가, 환경변수 <code>$PATH</code>에 <code>./node_modules/.bin/</code>를 추가하면 어디서나 스크립트를 직접 실행할 수 있다!</p>

<h2>Private repositories</h2>

<p>개발 중인 모듈을 Publish하지 않을 때 <code>package.json</code>에 <code>private</code> 설정을 하면 실수로 Publish하는 일을 방지할 수 있다:</p>

<pre class="prettyprint"><code>"private": true
</code></pre>

<p>Private 저장소가 있으면 package.json에 registry로 등록할 수 있다:</p>

<pre class="prettyprint"><code>"publishConfig": { "registry": "<a href='https://yourregistry:1337/'>https://yourregistry:1337/</a>" }
</code></pre>]]>
    </content>
  </entry>
</feed>
