<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title><![CDATA[ 개발새발 ]]></title><link href="http://dogfeet.github.com/atom.xml" rel="self" /><link href="http://dogfeet.github.com" /><updated>2012-12-28T16:40:02.805Z</updated><id>http://dogfeet.github.com</id><author><name>Changwoo Park</name><email>pismute@gmail.com</email></author><author><name>Sean Lee</name><email>sean@weaveus.com</email></author><author><name>Yongjae Choi</name><email>mage@weaveus.com</email></author><entry><title><![CDATA[ Git: GitHub secrets ]]></title><link href="http://dogfeet.github.com/articles/2012/git-github-secrets.html" /><updated>2012-12-29T00:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/git-github-secrets.html</id><content type="html"><![CDATA[
<p>이글은 <a href="https://twitter.com/holman">@holman</a>님이 싱가폴에서 열린 <a href="http://reddotrubyconf.com/">RedDotRubyConf</a>에서 발표한 <a href="http://zachholman.com/talk/git-github-secrets">Git and GitHub Secrets</a>에 설명을 달았다. 내용이 길어서 둘로 나눴는데 이 글은 <code>GitHub Secetets</code> 부분을 정리한 글이다. <a href="/articles/2012/git-secrets.html">Git Secrets</a>은 다른 글에서 정리한다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-github-secrets/holman.png" alt="holman"></p>

<p>이 글을 정리하면서 그림을 많이 삽입하지 않았다. <code>GitHub Secrets</code> 부분은 그림이 너무 많아서 생략했다. 이 글을 읽고서 슬라이드를 한번 보는게 좋을 것 같다.</p>

<h2>숨겨진 기능</h2>

<p>GitHub은 단순함을 추구한다. 그래서 GitHub에는 기능이 많은 데도 불구하고 굳이 화면에 보여주지 않는다.</p>

<h3>.patch, .diff</h3>

<p>커밋 URL 뒤에 .patch나 .diff 붙이면 해당 포멧의 파일이 나온다. 정확하게는 &lsquo;Compare View, Pull Requests, Commit Pages&rsquo; 화면에서 사용할 수 있다.</p>

<ul>
<li><a href="https://github.com/dogfeet/dogit/commit/a1f156b6415439a8a84c3d2fa89ea975fb3a7ac2.diff">.diff 예제</a></li>
<li><a href="https://github.com/dogfeet/dogit/commit/a1f156b6415439a8a84c3d2fa89ea975fb3a7ac2.patch">.patch 예제</a></li>
</ul>

<h2>공백문자는 무시하고 diff를 보여준다.</h2>

<p>diff URL끝에 <code>?w=1</code>를 붙이면 공백문자를 무시한 결과를 보여준다.</p>

<p><img src="/articles/2012/git-github-secrets/ignore-whitespace.png" alt="ignore_whitespace"></p>

<h3>SVN 클라이언트도 지원.</h3>

<p>&lsquo;SVN/Git 서비스 레이어'가 있어서 SVN 요청을 Git 요청으로 변환해준다.</p>

<p>당연히 Git 클라이언트를 사용할 수 있지만:</p>
<pre><code>$ git <span class="keyword">clone</span> https:<span class="comment">//github.com/dogfeet/dogit.git</span>
</code></pre>
<p>SVN 클라이언트도 사용할 수 있다:</p>
<pre><code><span class="char">$ </span>svn checkout <span class="method">https:</span>//github.com/dogfeet/dogit.git
</code></pre>
<h3>SSH & HTTP => HTTP & SSH</h3>

<p>GitHub은 기본 프로토콜을 SSH에서 HTTP로 바꿨다. 원래 HTTP 프로토콜을 사용하는 방식은 성능이 후져서 SSH를 권장했는데 이제 SmartHTTP 덕택에 HTTP도 효율적이다.</p>

<p>원래 SSH를 먼저 보여줬었지만:</p>

<p><img src="/articles/2012/git-github-secrets/ssh-http.png" alt="before"></p>

<p>지금은 HTTP를 먼저 보여준다:</p>

<p><img src="/articles/2012/git-github-secrets/http-ssh.png" alt="after"></p>

<p>이제 HTTP도 효율적이기 때문에 1) 회사 방화벽 뒤에서도 맘껏 GitHub을 즐길 수 있고 2) SSH Key를 사용하기 힘든 Windows 환경에서도 사용하기 쉬워졌다. SSH key없이도 암호를 메모리에 저장해서 사용할 수 있다. 이 방법은 git 1.7.10부터 사용할 수 있고 GitHub의 <a href="https://help.github.com/articles/set-up-git">패스워드 캐싱하는 방법</a>에 잘 설명돼 있다.</p>

<h4>SmartHTTP</h4>

<p>SmartHTTP는 git 1.6.6부터 지원한다. git 1.6.6은 2009년 말에 배포됐다.</p>

<p>Git은 개체를 'Packfile'이라는 덩어리에 묶어서 관리한다. 이전 버전에서는 사용자가 'Packfile'에 들어 있는 개체 한 개가 필요해도 <code>Packfile</code>을 통째로 전송해야 했다. 그래서 HTTP를 더미 프로토콜이라고 불렀다. 이제는 SmartHTTP가 있어서 'Packfile'에서 필요한 개체만 꺼내서 전송할 수 있다.</p>

<p>progit 책을 집필할 때에는 SmartHTTP가 없었기 때문에 이를 설명하지 않았다. SmartHTTP에 대해서 자세히 알아보려면 progit 9장과 <a href="http://git-scm.com/2010/03/04/smart-http.html">Smart HTTP Transport</a>를 읽는게 좋다.</p>

<h3>URL에서 &rsquo;.git'은 생략해도 된다.</h3>
<pre><code>git <span class="keyword">clone</span> https:<span class="comment">//github.com/holman/boom.git</span>
git <span class="keyword">clone</span> https:<span class="comment">//github.com/holman/boom</span>
</code></pre>
<h3>GitHub HD&trade;</h3>

<p>GitHub 페이지의 아이콘이 HD 벡터 아이콘이라서 계속 확대해도 깨지지 않는다.</p>

<h3>Auditing</h3>

<p>우리말로 하자면 &lsquo;감사로그&rsquo; 쯤 되는 건데, GitHub에서 일어난 중요한 액션은 로그가 남는다:</p>

<p><a href="https://github.com/settings/security">https://github.com/settings/security</a></p>

<h3>Octocat</h3>

<p><a href="https://twitter.com/defunkt">@defunkt</a>님이 에러페이지에 사용할 이미지를 찾다가 [Istockphoto]에서 싸게 산 이미지였는데 사람들이 좋아해서 지금은 GitHub의 마스코드가 됐다. 처음에는 아니였지만 지금은 GitHub이 저작권을 가지고 있다.</p>

<p><a href="http://www.quora.com/GitHub/What-is-the-story-behind-GitHub%E2%80%99s-octocat-mascot">Octocat 스토리</a>는 Quora에서 참고.</p>

<p><a href="http://octodex.github.com/">http://octodex.github.com/</a> 에 가면 Octocat 이미지가 많다.</p>

<h3>git.io</h3>

<p>GitHub용 URL Shortner이다. 작은 <a href="git.io/nxVVig">쉘 스크립트</a>로 구현돼 있고 다음과 같이 사용한다.</p>
<pre><code>$ gitio <span class="tag">&lt;<span class="title">url</span>&gt;</span> <span class="tag">&lt;<span class="title">name</span>&gt;</span>
</code></pre>
<p><a href="https://chrome.google.com/webstore/detail/gitio-url-shortener/baceaeopmlhkjbljoiinmbnnmpokgiml">Chrome Extension</a>도 있다.</p>

<h3>Linguist</h3>

<p>저장소에 든 언어가 뭔지 찾아서 직접 그 저장소에서 개발된 파일만 추려서 &lsquo;Syntax Highlighting'도 해준다. GitHub은 이 Linguist를 다음과 같은 걸 만들어 내는데 사용한다:</p>

<p><img src="/articles/2012/git-github-secrets/linguist.png" alt="linguist"></p>

<p>기능:</p>

<ul>
<li>'Language Detection&rsquo; - 어떤 언어가 사용됐는지 찾는다.</li>
<li>&lsquo;Stats&rsquo; - 언어 통계를 알려준다.</li>
<li>&lsquo;Syntax Highlighting&rsquo; - Pygments를 사용한다.</li>
<li>&lsquo;Vendored Files&rsquo; - 저장소에 들어 있는 파일 중 다른 프로젝트에서 가져온 파일. ex) jquery.js</li>
<li>&lsquo;Generated file detection&rsquo; - 생성되는 파일을 알아서 제외한다.</li>
</ul>

<h3>email reply</h3>

<p>이메일로 comments에 답변을 달 수 있다.</p>

<h3>gist</h3>

<p>단순히 코드 snippet을 공유하는 도구가 아니다. 코멘트, 스크린샷, 코드를 공유를 할 수 있기 때문에 프로토타이핑 도구로 사용하기에도 좋다. 개발자와 디자이너 모두에게 유용하다.</p>

<p>gist 자체가 git 저장소이기 때문에 clone할 수도 있다:</p>
<pre><code><span class="title">git</span> clone <span class="url">git://gist.github.com/2720312</span>
</code></pre>
<p>간단하게 만들어서 프로토타이핑을 해보기에 아주 좋다.</p>

<h4>microgems.</h4>

<p>Ruby Gem으로도 사용할 수 있는 것 같다. 나는 Ruby를 몰라서 알 수 없다.</p>

<p><a href="http://jeffkreeftmeijer.com/2011/microgems-five-minute-rubygems/">http://jeffkreeftmeijer.com/2011/microgems-five-minute-rubygems/</a></p>

<h3>Image View Mode</h3>

<p>Gist에 이미지를 올리고 비교하면 비교해보기 좋게 나열해준다. 정말 쩐다. 데모 페이지에 가서 클릭해보자.</p>

<p>이 기능은 <a href="http://www.kaleidoscopeapp.com/">KaleidoScope</a>같은 도구에서 있는 건데 GitHub도 된다. <a href="http://www.sourcetreeapp.com/">SourceTree</a>같은 데서도 가능하면 좋겠다.</p>

<p>GitHub의 <a href="https://github.com/blog/817-behold-image-view-modes">Behold: Image view modes</a>에 잘 소개돼 있다.</p>

<h3>Command Line GitHub - hub</h3>

<p><a href="https://github.com/defunkt/hub">hub</a>라는 프로그램이 있다. Command Line에서 GitHub을 사용할 수 있는 명령이다. git + github 명령이라고 생각하면 된다. GitHub을 사용하면서 자동화한다면 꼭 필요한 툴이라고 생각된다. 나중에 따로 정리해야 겠다.</p>

<h3>Keyboard Shortcuts</h3>

<p>GitHub의 모든 페이지에서 <code>?</code>를 누르면 그 페이지에서 사용할 수 있는 단축키를 보여준다.</p>

<h3>Subscribing People</h3>

<p>GitHub에서 글쓸때 <code>@pismute</code>쓰면 해당 사용자에게 알림이 간다. <code>@org/team</code>라는 팀 표현식도 있어서 팀 전체한테 노티를 줄수도 있다.</p>

<h3>GitHub Flavored Markdown</h3>

<p><a href="http://github.github.com/github-flavored-markdown/">GFM</a>에 대한 설명도 있다.</p>

<h3>Auto-Closing Issues</h3>

<p>커밋메시지에 <code>CLOSES/CLOSED/CLOSE #1</code>나 <code>FIXES/FIXED/FIX #1</code>라고 쓰면 해당 이슈가 자동으로 닫힌다.</p>

<h3>Commit by Author</h3>

<p>GitHub의 커밋 페이지에서 <code>?author=holman</code> 처럼 파라미터를 넘기면 해당 사용자의 커밋만 볼 수 있다:</p>

<ul>
<li><a href="https://github.com/progit/progit/commits/master?author=pismute">https://github.com/progit/progit/commits/master?author=pismute</a></li>
</ul>

<h3>Branch-to-Branch</h3>

<p>Pull Request는 브랜치 단위로 하는 거라는 얘기. 그래서 원 저장소가 아니라 Clone 저장소에도 Pull Request를 보낼 수 있다.</p>

<h3>emoji!</h3>

<p>GitHub에서 emoji 이모티콘을 사용할 수 있다. 사용할 수 있는 이모티콘은 <a href="http://www.emoji-cheat-sheet.com/%EC%97%90%EC%84%9C">http://www.emoji-cheat-sheet.com/에서</a> 참고.</p>

<h3>Link Linking</h3>

<p>GitHub 페이지에서 파일 보기 화면에서 URL 뒤에 <code>#L16</code>을 붙이면 16라인이 노랗게 보인다. <code>#L16-32</code>를 붙이면 16라인부터 32라인까지 노랗게 보인다. 다른 사람과 코드에 대해 수다떨 때 어떤 라인에 대해서 얘기하는 건지 콕 집어 줄 수 있다.</p>

<h3>Advanced Compare View</h3>

<p><code>github.com/user/repo/compare/{range}</code>과 같은 형식의 URL을 사용하면 되고 <code>{range}</code>부분에 다음과 같이 넣을 수 있다:</p>

<ul>
<li><code>master@{1.day.ago}...master</code></li>
<li><code>master@{yesterday}...master</code></li>
<li><code>master@{2012-02-25}...master</code></li>
</ul>

<p>아래와 같이 사용한다:</p>

<p><a href="https://github.com/dogfeet/dogit/compare/master@%7B60.day.ago%7D...master">https://github.com/dogfeet/dogit/compare/master@{60.day.ago}&hellip;master</a></p>
]]>
</content></entry><entry><title><![CDATA[ Git: git secrets ]]></title><link href="http://dogfeet.github.com/articles/2012/git-secrets.html" /><updated>2012-12-19T00:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/git-secrets.html</id><content type="html"><![CDATA[
<p>이글은 <a href="https://twitter.com/holman">@holman</a>님이 싱가폴에서 열린 <a href="http://reddotrubyconf.com/">RedDotRubyConf</a>에서 발표한 <a href="http://zachholman.com/talk/git-github-secrets">Git and GitHub Secrets</a>에 설명을 달았다. 내용이 길어서 둘로 나눴는데 이 글은 <code>Git Secetets</code>부분을 정리한 글이다. <a href="/articles/2012/git-github-secrets.html">GitHub Secrets</a>은 다른 글에 정리한다.</p>

<p>Git은 명령과 옵션이 굉장히 많은데, 그 중에서 <a href="https://twitter.com/holman">@holman</a>님이 추천하는 쓸만한 것이라고 생각하면 되겠다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-secrets/holman.png" alt="holman"></p>

<h2>Git secret</h2>

<h3>&ndash;allow-empty</h3>

<p>파일없이 커밋할 수 있다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">commit</span> <span class="literal">-</span><span class="comment">m</span> <span class="comment">"LOOK</span> <span class="comment">AT</span> <span class="comment">ME</span> <span class="comment">TROLOLOL"</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">allow</span>-<span class="comment">empty</span>
</code></pre>
<p><code>git log</code>를 하면 아무내용없이 그냥 커밋 개체만 달랑 생긴다.</p>
<pre><code>$ git log
<span class="operator"><span class="keyword">commit</span> <span class="number">6</span>eb28f645174fba20d819f40da4ca822c7c67b2a
Author: Changwoo Park &lt;pismute@gmail.com&gt;
<span class="keyword">Date</span>:   Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">25</span> <span class="number">2012</span> +<span class="number">0900</span>

    LOOK <span class="keyword">AT</span> ME TROLOLOL
</code></pre>
<p>히스토리에 뭔가 표식을 남기고 싶을 때 유용하다.</p>

<h3>Staging Hunk</h3>

<p>파일에서 한 부분? 덩어리?를 Hunk라고 부른다. <code>git add -p</code> 명령으로 파일을 통째로 Staging Area에 넣는게 아니라 일정 골라서 부분만(hunk만) 넣는다.</p>

<p>자세한 설명은 <a href="https://twitter.com/semtlnori">@semtlnori</a>님의 <a href="http://npcode.com/blog/archives/449">깔끔하게 커밋하기</a>를 보자.</p>

<h3>git show :/query</h3>

<p>특정 질의가 들어간 커밋 중에서 가장 최근 커밋 하나를 찾아 준다. 로그를 분석할때 매우 유용하다. 커밋 메시지, 파일 이름, 파일 내용에서 찾는다.</p>

<p><code>git log</code> 명령에도 있어서 <code>git log :/query</code>라고 실행해도 된다. <code>:/query</code> 만족하는 커밋을 골라서 보여준다.</p>

<h3>go back</h3>

<p><code>cd -</code>라고 실행하면 이전 디렉토리로 되돌아 간다. <code>cd</code>명령 처럼 <code>git checkout -</code>라고 하면 이전 브랜치를 checkout한다.</p>

<h3>merged branch</h3>

<p>브랜치나 커밋이 다른 브랜치에 Merge됐는지 확인하는 명령들.</p>

<ul>
<li><code>git branch --merged</code> : 이미 다른 브랜치에 머지된 것만 보여준다.</li>
<li><code>git branch --no-merged</code> : 아직 다른 브랜치에 머지되지 않는 것만 보여준다.</li>
<li><code>git branch --contains 838ad46</code> : 특정 커밋이 포함된 브랜치만 보여준다.</li>
</ul>

<h3>Content Copy</h3>

<p>브랜치를 변경하지 않고도 다른 브랜치에 들어 있는 파일을 복사해 올 수 있다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">checkout</span> <span class="comment">BRANCH</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">path/to/file</span>.<span class="comment">rb</span>
</code></pre>
<p><code>path/to/file.rb</code>에 파일이 복사된다.</p>

<p>Reset과 Checkout은 비슷해보여서 구분하기 쉽지 않다. Checkout은 데이터베이스에서 뭔가를 꺼낼때 사용하는 명령이다. 옵션도 스냅샷과 파일이름 등 그와 관련된 옵션으로 구성돼있다. 반대로 Reset은 워킹 디렉토리, Staging Area, 브랜치 등을 스냅샷으로 Reset하는 명령이다.</p>

<p>이렇게 구분하면 쉽다. 데이터베이스에서 뭔가를 꺼낼때는 Checkout을 사용하고 그외는 Reset을 사용한다.</p>

<h3>Reachable Commits</h3>

<p>특정 브랜치에만 있는 커밋이 보고 싶을 때는 다음과 같이 한다:</p>

<p><code>git log branchA ^branchB</code></p>

<p>branchA에는 있고 branchB에는 없는 커밋을 보여준다.</p>

<h3>FINDING LOST COMMITS</h3>

<p>어떤 브랜치에도 들어 있지 않은 커밋을 보여준다. git의 커밋은 개체는 실제로 전부 immutable이라서 커밋을 수정하면 새로운 커밋 개체가 등록된다. 잘 못 수정했으면 아래 명령으로 커밋을 찾아서 복구한다:</p>
<pre><code>$ git fsck <span class="comment">--lost-found</span>
Checking object directories: 100% (256/256), done.
dangling <span class="operator"><span class="keyword">commit</span> <span class="number">4</span>a7f2e89a480d3af0ccfdf71f76f4149f25fb0fb
dangling <span class="keyword">commit</span> d3ad9f17532109d12084646c306e9d7748c2f791
</code></pre>
<p>어떤 브랜치에도 속하지 않은 커밋이 두 개있다.</p>

<h2>DIFFSTATS</h2>

<p>델타(diff)를 다 보여주는 게 기본인데 통계만 볼 수도 있다:</p>

<p><code>git diff HEAD^ --stat</code></p>

<p><img src="/articles/2012/git-secrets/git-diff--stat.png" alt="git-diff--stat"></p>

<h3>BLAME</h3>

<p><code>git blame</code>은 기본적으로 어떤 라인을 누가 고쳤는지 확인하는 명령이다.</p>

<p><strong>blame이니까</strong></p>

<p><code>git blame</code>은 기본적으로 어떤 라인을 <strong>어떤 새끼</strong>가 고쳤는지 확인하는 명령이다.</p>

<h4>git blame -w</h4>

<p>정말 내용을 수정한 <strong>새끼</strong>를 찾는다. 공백만 추가한 경우는 무시한다. <code>git diff HEAD~</code> 명령으로 공백이 어디에 추가됐는지 보자:</p>

<p><img src="/articles/2012/git-secrets/git-blame-w-diff.png" alt="git-blame-w-diff"></p>

<p>히스토리를 보면 마지막에 &ldquo;BBB&quot;가 공백을 추가했다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-w-lg.png" alt="git-blame-w-lg"></p>

<p>다음은 <code>git blame -w</code>의 결과다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-w.png" alt="git-blame-w"></p>

<p>단순히 공백만 추가한 &quot;BBB&quot;는 무시된다. <code>-w</code>을 옵션을 빼고 <code>git blame</code>만 실행하면 공백만 추가한 &quot;BBB&quot;도 나온다.</p>

<p><img src="/articles/2012/git-secrets/git-blame.png" alt="git-blame"></p>

<h4>git blame -M</h4>

<p>해당 라인을 실질적으로 마지막에 수정한 사람을 보여준다. 이 옵션을 주면 같은 파일 내에서 단순히 라인을 옮긴 사람이 아니라 마지막으로 내용을 수정한 사람이 표시된다:</p>

<p>텍스트를 옮긴 후에 <code>git blame</code> 명령을 실행하면 다음과 같이 나온다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-m-before.png" alt="git-blame"></p>

<p><code>-M</code> 옵션을 추가하면 단순히 옮긴 사람이 아니라 원래 그 코드를 추가한 사람을 보여준다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-m.png" alt="git-blame"></p>

<p>원래 의도는 측근 <code>all.md</code> 파일에서 친구 끼리, 가족 끼리 모아서 <code>-M</code> 옵션을 설명할 계획이였다. Git이 정확히 어떤 알고리즘을 사용하는 건지 나중에 살펴봐야 겠다.</p>

<h4>git blame -C</h4>

<p><code>-M</code>와 비슷하게 실제로 마지막에 수정한 사람을 보여준다. 한 파일 내에서의 이동만 감지하는 것이 아니라. 같은 커밋에서의 다른 파일간 이동도 감지한다.</p>

<p><code>all.md</code>라는 파일에서 친구는 <code>friends.md</code>라는 파일로 옮기고 가족은 <code>family.md</code> 파일로 옮겼다. 아래는 <code>git blame -f family.md</code>의 결과다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-c-f.png" alt="git-blame"></p>

<p><code>-f</code>는 원래 파일이름을 보여주는 옵션이다. <code>git blame -fC family.md</code>의 결과는 아래와 같다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-c-cf.png" alt="git-blame"></p>

<h4>git blame -CC</h4>

<p><code>-C</code> 처럼 다른 파일에서 옮긴 것을 감지해주는데 해당 파일을 생성한 커밋내에서도 감지한다.</p>

<h4>git blame -CCC</h4>

<p>다른 파일에서 옮긴 것도 감지하는데 커밋을 가리지 않고 전체에서 찾는다.</p>

<h4>MULTI-REMOTE FETCHES</h4>

<p>원래는 하나씩 fetch해야 하지만 group을 만들어서 한번에 fetch할 수 있다.</p>
<pre><code><span class="variable">$ </span>git config remotes.mygroup <span class="string">'remote1 remote2'</span>
<span class="variable">$ </span>git fetch mygroup
</code></pre>
<h4>A BETTER STATUS</h4>

<p>status의 결과를 더 간략하게 볼 수 있다.</p>

<p><code>git status</code>:</p>

<p><img src="/articles/2012/git-secrets/git-status.png" alt="git-status"></p>

<p><code>git status -sb</code>:</p>

<p><img src="/articles/2012/git-secrets/git-status-sb.png" alt="git-status-sb"></p>

<h4>WORD DIFFING</h4>

<p>라인 단위로 비교하는 것이 아니라 단어 단위로 비교해서 볼 수 있다.</p>

<p><code>git diff HEAD^</code>:</p>

<p><img src="/articles/2012/git-secrets/git-diff-head-1.png" alt="diff-head-1"></p>

<p><code>git diff HEAD^ --word-diff</code>:</p>

<p><img src="/articles/2012/git-secrets/git-diff-head-1--word-diff.png" alt="diff-head-1--word-diff"></p>

<h4>CONFIG: SPELLING</h4>

<p><code>git comit</code>이라고 실행하면 <code>commit</code>이라고 할려고 했냐? 라고 물어봐 주는 게 기본설정이다. 명령을 실행할 때 오타를 내면 자동으로 인식해서 실행하게 할 수 있다. 다음과 같이 설정하면 된다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">help</span>.<span class="comment">autocorrect</span> <span class="comment">1</span>
</code></pre>
<p>이 옵션이 설정되면 <code>git comit</code>이라고 실행하면 그냥 <code>git commit</code>이 실행된다:</p>

<h4>CONFIG: GIT RERERE(REUSE RECORDED RESOLUTION)</h4>

<p><a href="/articles/2012/git-rerere.html">Git: rerere</a>에서 확인한다.</p>

<h4>CONFIG: COLOR!</h4>

<p>다음과 같이 설정하면 결과가 칼라로 나온다.</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">color</span>.<span class="comment">ui</span> <span class="comment">1</span>
</code></pre>
<h4>ALIAS: GIT-AMEND</h4>

<p>아래와 같이 alias를 등록하면 <code>git amend</code>라고 실행해서 HEAD 커밋을 수정할 수 있다. <code>-C</code> 옵션이 있기 때문에 커밋 메시지는 수정하지 않는다. 항상 커밋 메시지를 확인하고 싶으면 <code>-C HEAD</code>를 빼면 된다.</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">alias</span>.<span class="comment">amend</span> <span class="comment">"commit</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">amend</span> <span class="literal">-</span><span class="comment">C</span> <span class="comment">HEAD"</span>
</code></pre>
<h4>ALIAS: GIT-UNDO</h4>

<p>가장 최근 커밋을 되돌린다. <code>--soft</code>이기 때문에 그 커밋의 개체는 Staged 상태로 남는다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">alias</span>.<span class="comment">undo</span> <span class="comment">"reset</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">soft</span> <span class="comment">HEAD^"</span>
</code></pre>
<h4>ALIAS: GIT-COUNT</h4>

<p>누가 얼마나 커밋했는지 보여준다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">alias</span>.<span class="comment">count</span> <span class="comment">"shortlog</span> <span class="literal">-</span><span class="comment">sn"</span>
</code></pre>
<p><img src="/articles/2012/git-secrets/git-shortlog-sn.png" alt="git-shortlog-sn"></p>

<h4>SCRIPT: GIT-CREDIT</h4>

<p>가장 마지막 커밋 author 정보를 바꿀일은 종종 생긴다. 실수일 수도 있고 아닐 수도 있지만 뭐 어찌됐건 최근 커밋의 author를 마음대로 바꾸고 싶을 때가 있다. 다음과 같이 config에 등록한다:</p>
<pre><code><span class="shebang">#!/bin/sh</span>

git commit --amend --author <span class="string">"<span class="variable">$1</span> &lt;<span class="variable">$2</span>&gt;"</span> -C HEAD
</code></pre>
<p><code>git credit &quot;Zach Holman&quot; zach@example.com</code>이라고 실행하면 최근 커밋의 author 정보가 변경된다.</p>

<p><a href="https://twitter.com/holman">@holman</a>님은 <a href="https://twitter.com/holman">@holman</a>님의 <a href="https://github.com/holman/dotfiles/tree/master/bin">dotfile</a> 프로젝트에 가면 <a href="https://twitter.com/holman">@holman</a>님이 사용하는 <code>git-credit</code> 스크립트가 있다.</p>

<h4>Octocat</h4>

<p>이 슬라이드로 옥토캣은 다리가 4개고 꼬리가 1개라는 비밀을 알게 됐다. 맨날 보는 그림이지만 문어니까 그냥 다리가 8개라고 생각했었다.</p>

<p><img src="/articles/2012/git-secrets/pusheencat.png" alt="octocat"></p>
]]>
</content></entry><entry><title><![CDATA[ 잘 빠진 군체 알고리즘 - flock ]]></title><link href="http://dogfeet.github.com/articles/2012/flocking-algorithm.html" /><updated>2012-12-02T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/flocking-algorithm.html</id><content type="html"><![CDATA[
<style>
canvas {display:block;}
.flock {margin-left: 10px;}
</style>

<p><img src="http://dogfeet.github.com/articles/2012/flocking-algorithm/800px-Red-billed_quelea_flocking_at_waterhole.jpg" alt="flock"></p>

<p><a href="http://harry.me/2011/02/17/neat-algorithms---flocking/">harry</a> 님의 사이트에서 보았던 플로킹 알고리즘(flockng algorithm)을 정리했다.(무려 2011년 2월 글이다.) 플로킹 알고리즘은 떼(flock)의 각 개체의 행동 모델이다. 각 개체는 보이드(boid)라고 부르며 이들은 세 가지 규칙을 이용해 움직인다. 이 알고리즘은 1986년에 Craig Reynolds가 낸 논문에서 처음 소개되었다. 원래 알고리즘은 <a href="http://www.red3d.com/cwr/boids/">여기서</a> 볼 수 있다. 그는 이 모델을 이용해 새 떼나 물고기 떼 등을 시뮬레이션했으며 배트맨 리턴즈의 박쥐 떼가 날아다니는 영상, 소셜 네트워크에서 의견의 흐름을 시뮬레이션해서 미래 의견을 예측하거나 분산 시스템에서도 이용되었다고 한다. 어디에서 쓰였는지는 링크를 확인하고 알고리즘이 어떻게 동작하는지 보자.</p>

<h2>예제 먼저</h2>

<div class="flock" id="prettyDemo"></div>

<p>옆의 버튼을 눌러서 한 보이드에 대한 자세한 정보와 그 범례를 볼 수 있다. : <button class="awesome" id="decorateDemo">Undecorate</button></p>

<p>구현은 harry 사이트의 것을 그대로 가져왔다. Coffee Script로 이루어져 있으며 HTML5의 canvas를 이용해서 애니메이션 데모를 보여준다. 따라서 애니메이션 데모를 보고 싶다면 canvas가 지원되는 브라우저로 들어오기를 바란다.  애니메이션은 <a href="http://processingjs.org/">ProcessingJS</a>를 이용해서 이루어진다. (ProcessingJS에 대한 지식은 그리 필요하진 않다.) 이 페이지의 모든 애니메이션 데모는 버튼으로 애니메이션 속도를 조정할 수 있고 애니메이션 화면을 클릭해서 일시 정지시킬 수 있다. 물론 다시 클릭하면 다시 애니메이션이 진행된다. 정지 되었을 때에는 각 보이드에 마우스를 올려서 그 보이드의 정보를 볼 수 있다. 정보를 보는 법은 이 글을 읽으면서 알 수 있으니 성급해하지 말자.</p>

<h2>보이드 - Boid</h2>

<p>보이드는 무리를 이루는 개체 하나하나를 부르는 이름이다. 여기저기에서 에이전트라고 하기도 하고 오브젝트라고도 하지만 원문에 보이드라고 되어있으니 여기서도 보이드라고 부르기로 하자. 보이드는 위치와 속도를 데이터로 가지고 있다. 그리고 위에서 말한 세 가지 행동 규칙을 이용해 가속도를 계산한다. 가속도는 현재 속도에 영향을 미치고 속도에 의해 다음 위치가 결정된다. 이런 일을 하는 메서드가 <code>step</code>이다. 보이드가 너무 빨라지지 않도록 최고 속도를 정해놓고 그보다는 높아지지 않도록 조종하는 것도 중요하다. 다음 코드를 보자. </p>
<pre><code class="lang-coffeescript"><span class="comment"># Ported almost directly from http://processingjs.org/learning/topic/flocking</span>
<span class="comment"># thanks a whole lot to Craig Reynolds and Daniel Shiffman</span>

<span class="class"><span class="keyword">class</span> <span class="title">Boid</span></span>
  location: <span class="literal">false</span>
  velocity: <span class="literal">false</span>

  constructor: (loc, processing) -&amp;gt;
    <span class="property">@velocity</span> = <span class="keyword">new</span> Vector(Math.random()*<span class="number">2</span>-<span class="number">1</span>,Math.random()*<span class="number">2</span>-<span class="number">1</span>)
    <span class="property">@location</span> = loc.copy()
    <span class="property">@p</span> = processing

  <span class="comment"># Called every frame. Calculates the acceleration using the flock method, </span>
  <span class="comment"># and moves the boid based on it.</span>
  step: (neighbours) -&amp;gt;
    acceleration = <span class="keyword">this</span>.flock(neighbours)
    <span class="property">@velocity</span>.add(acceleration).limit(MAX_SPEED) <span class="comment"># Limit the maximum speed at which a boid can go</span>
    <span class="property">@location</span>.add(<span class="property">@velocity</span>)
    <span class="keyword">this</span>._wrapIfNeeded()

  <span class="comment"># Implements the flocking algorthim by collecting the three components </span>
  <span class="comment"># and returning a weighted sum.</span>
  flock: (neighbours) -&amp;gt;
    separation = <span class="keyword">this</span>.separate(neighbours).multiply(SEPARATION_WEIGHT)
    alignment = <span class="keyword">this</span>.align(neighbours).multiply(ALIGNMENT_WEIGHT)
    cohesion = <span class="keyword">this</span>.cohere(neighbours).multiply(COHESION_WEIGHT)
    <span class="keyword">return</span> separation.add(alignment).add(cohesion)
</code></pre>
<p>제일 마지막 메서드인 <code>flock</code>이 앞으로 설명할 세 가지 행동 규칙으로 가속도를 만들어내는 메서드이다. 이에 대한 자세한 이야기는 이 글의 끝에서 하도록 한다.</p>

<h2>응집 - Cohesion</h2>

<div class="flock" id="cohesionDemo" style="float:right;"></div>

<p>보이드는 자기 주변의 보이드의 곁으로 가려는 성질이 있다. 즉 무리지으려는 성질이라고 볼 수 있다. &lsquo;자기 주변의 보이드'는 자신 주변 반경 n 픽셀 안에 있는 보이드로 정의되고 <code>NEIGHBOUR_RADIUS</code>라는 상수가 그 주변을 결정하는 반경 값이다. 하나의 보이드는 주변 보이드들 사이의 무게 중심 쪽으로 방향을 튼다. </p>

<p>옆의 예제를 보면 분홍색 보이드의 Cohesion 정보가 표시되고 있다. 녹색 원이 자신의 주변을 뜻하는 범위이고 그 안에 들어온 보이드들은 녹색으로 표시된다. 그리고 짙은 보라색 화살표가 주변 보이드들의 평균 위치 한 점으로 모인다. 분홍색 보이드는 분홍색 화살표를 이용해 &lsquo;나 그쪽으로 회전 중입니다'라고 알리고 있다.</p>

<div style="clear:right"></div>

<h3>코드</h3>

<p>Cohesion은 <code>NEIGHBOUR_RADIUS</code>안에 있는 모든 보이드의 위치의 평균이다. 코드는 <code>steer_to</code>메서드를 거쳐 리턴한다. <code>stear_to</code>는 현재 위치와 갈 곳을 계산해서 보이드의 방향을 자연스럽게 틀어주는 역할을 한다. 일종의 보정이라고 생각하면 된다.</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">Boid</span></span>

  <span class="comment"># 가속도를 계산할 때 cohesion요소를 계산하기 위해 호출한다.</span>
  cohere: (neighbours) -&amp;gt;
    sum = <span class="keyword">new</span> Vector
    count = <span class="number">0</span>
    <span class="keyword">for</span> boid <span class="keyword">in</span> neighbours
      d = <span class="property">@location</span>.distance(boid.location)
      <span class="keyword">if</span> d &amp;gt; <span class="number">0</span> <span class="keyword">and</span> d &amp;lt; NEIGHBOUR_RADIUS
        sum.add(boid.location)
        count++

    <span class="keyword">if</span> count &amp;gt; <span class="number">0</span>
      <span class="keyword">return</span> <span class="keyword">this</span>.steer_to sum.divide(count)
    <span class="keyword">else</span>
      <span class="keyword">return</span> sum <span class="comment"># 아무런 영향도 주지 않기 위해 빈 벡터를 리턴한다.</span>

  steer_to: (target) -&amp;gt;
    desired = Vector.subtract(target, <span class="property">@location</span>) <span class="comment"># 현재 위치에서 가려 하는 곳을 가리키는 벡터</span>
    d = desired.magnitude()  <span class="comment"># 현재 위치에서 목적지까지의 거리는 벡터의 크기이다.</span>

    <span class="comment"># 만약 거리가 0보다 크면 변경할 방향을 계산한다. (아니면 0을 리턴한다.)</span>
    <span class="keyword">if</span> d &amp;gt; <span class="number">0</span>
      desired.normalize()

      <span class="comment"># 원하는 벡터의 크기를 계산하기 위한 두 옵션(1 -- 거리에 기초하여, 2 -- 최대 스피드)</span>
      <span class="keyword">if</span> d &amp;lt; <span class="number">100.0</span>
        desired.multiply(MAX_SPEED*(d/<span class="number">100.0</span>)) <span class="comment"># 이 제동은 임의적으로 정했다.</span>
      <span class="keyword">else</span>
        desired.multiply(MAX_SPEED)

      <span class="comment"># Steering = Desired minus Velocity</span>
      steer = desired.subtract(<span class="property">@velocity</span>)
      steer.limit(MAX_FORCE)  <span class="comment"># 방향 전환 정도에 제한을 둔다.</span>
    <span class="keyword">else</span>
      steer = <span class="keyword">new</span> Vector(<span class="number">0</span>,<span class="number">0</span>)

    <span class="keyword">return</span> steer
</code></pre>
<h2>정렬 - Alignment</h2>

<div class="flock" id="alignmentDemo" style="float:right;"></div>

<p>각 보이드는 주변의 보이드와 같은 방향을 향하려는 특성도 가지고 있다. 응집도와 비슷하게 <code>NEIGHBOUR_RADIUS</code>의 내에 들어온 주변 보이드들의 속도의 평균을 향한다. 속도는 방향과 크기를 가지고 있으므로 평균을 구하면 방향뿐만이 아니라 크기까지 평균이 된다. 따라서 주변 보이드의 속력이 빠를 수록 정렬되려는 힘도 커진다.</p>

<p>옆의 예제에서 보면 역시 분홍색 보이드의 정보가 보인다. 녹색 원 안에 녹색 보이드가 주변 보이드로 선정된 녀석들이고 주변 보이드의 속도는 녹색 화살표로 표시된다. 이 녹색 화살표의 평균이 분홍색 보이드의 연녹색 화살표이다. 검은색 화살표는 분홍색 보이드의 현재 속도이다. 분홍색 보이드는 다음 프레임에서 자신의 위치와 방향을 결정할 때 연녹색 화살표의 값을 이용한다. </p>

<div style="clear:right"></div>

<h3>코드</h3>

<p>이번 코드는 그리 길지 않다. 로직은 응집도 계산과 똑같다. 다만 위치의 평균이 아니라 속도의 평균인 점이 다르다. 물론 이번에도 최대값이 있어서 너무 커다란 값이 되지 않도록 조정한다.</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">Boid</span></span>

  <span class="comment"># Alignment component for the frame's acceleration</span>
  align: (neighbours) -&amp;gt;
    mean = <span class="keyword">new</span> Vector
    count = <span class="number">0</span>
    <span class="keyword">for</span> boid <span class="keyword">in</span> neighbours
      d = <span class="property">@location</span>.distance(boid.location)
      <span class="keyword">if</span> d &amp;gt; <span class="number">0</span> <span class="keyword">and</span> d &amp;lt; NEIGHBOUR_RADIUS
        mean.add(boid.velocity)
        count++

    mean.divide(count) <span class="keyword">if</span> count &amp;gt; <span class="number">0</span>
    mean.limit(MAX_FORCE)
    <span class="keyword">return</span> mean
</code></pre>
<h2>분리 - Separation</h2>

<div class="flock" id="separationDemo" style="float:right;"></div>

<p>각 보이드들은 너무 가까워지지 않으려는 경향이 있다. 보이드는 일정 공간을 두어 그 안으로 다른 보이드가 들어오면 그 보이드의 반대편으로 힘이 작용하여 멀어진다. 그 개인적인 공간은 <code>DESIRED_SEPARATION</code>이 결정하고 이 값은 <code>NEIGHBOUR_RADIUS</code>보다 작아야 한다. 만약 이 값이 <code>NEIGHBOUR_RADIUS</code>보다 크다면 이웃은 사라지고 모든 보이드를 배척하게 된다.</p>

<p>이번 예제는 빨간 원이 하나 더 생겼다. 이것이 <code>DESIRED_SEPARATION</code>값으로 결정된 생긴 개인 공간이고 이 안에 들어온 보이드는 빨간색으로 표시된다. 그리고 빨간 원 안으로 들어온 보이드에 의해 빨간 화살표로 멀어지려는 힘이 계산된다. 그 방향을 빨간 보이드의 반대 방향이 된다.</p>

<div style="clear:right"></div>

<h3>코드</h3>

<p>코드를 보면 주변 보이드들과의 거리를 검사해서 <code>DESIRED_SEPARATION</code>보다 가까운 보이드와 거리를 정규화해서 평균을 낸다. 그 중간에 정규화된 벡터를 자신과 주변 보이드간의 거리에 반비례하게 크기를 변경한다. 이는 가까이 있을수록 더 빨리 멀어지고 싶어한다는 개념을 넣은 것이다.</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">Boid</span></span>

  <span class="comment"># Separation component for the frame's acceleration</span>
  separate: (neighbours) -&amp;gt;
    mean = <span class="keyword">new</span> Vector
    count = <span class="number">0</span>
    <span class="keyword">for</span> boid <span class="keyword">in</span> neighbours
      d = <span class="property">@location</span>.distance(boid.location)
      <span class="keyword">if</span> d &amp;gt; <span class="number">0</span> <span class="keyword">and</span> d &amp;lt; DESIRED_SEPARATION
        <span class="comment"># Normalized, weighted by distance vector pointing away from the neighbour</span>
        mean.add Vector.subtract(<span class="property">@location</span>,boid.location).normalize().divide(d)
        count++

    mean.divide(count) <span class="keyword">if</span> count &amp;gt; <span class="number">0</span>
    mean
</code></pre>
<h2>죄다 합쳐보자</h2>

<p>위에서 계산했던 세 가지 행동 요소들을 이용해서 무리를 움직이게 하려면 아래와 같이 하면 된다. 보이드 클래스에 자신을 그리는 <code>render</code>메서드를 넣고 이 보이드의 무리를 만들어서 움직일 <code>flock</code>이라는 함수를 만들어 ProcessingJS의 인스턴스에 넘겨준다. <code>flock</code>에서는 보이드를 만들어 각 보이드의 <code>step</code>메서드와 <code>render</code>메서드를 넣어준다.</p>
<pre><code class="lang-coffeescript"><span class="class"><span class="keyword">class</span> <span class="title">Boid</span></span>
  r: <span class="number">2</span> <span class="comment"># "radius" of the triangle</span>
  render: () -&amp;gt;
    <span class="comment"># Draw a triangle rotated in the direction of velocity</span>
    theta = <span class="property">@velocity</span>.heading() + <span class="property">@p</span>.radians(<span class="number">90</span>)
    <span class="property">@p</span>.fill(<span class="number">70</span>)
    <span class="property">@p</span>.stroke(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>)
    <span class="property">@p</span>.pushMatrix()
    <span class="property">@p</span>.translate(<span class="property">@location</span>.x,<span class="property">@location</span>.y)
    <span class="property">@p</span>.rotate(theta)
    <span class="property">@p</span>.beginShape(<span class="property">@p</span>.TRIANGLES)
    <span class="property">@p</span>.vertex(<span class="number">0</span>, -<span class="number">1</span> * <span class="property">@r</span> *<span class="number">2</span>)
    <span class="property">@p</span>.vertex(-<span class="number">1</span> * <span class="property">@r</span>, <span class="property">@r</span> * <span class="number">2</span>)
    <span class="property">@p</span>.vertex(<span class="property">@r</span>, <span class="property">@r</span> * <span class="number">2</span>)
    <span class="property">@p</span>.endShape()
    <span class="property">@p</span>.popMatrix()

<span class="comment"># flock function, passed the Processing instance by Processing itself</span>
flock = (processing) -&amp;gt;
  start = <span class="keyword">new</span> Vector(processing.width<span class="regexp">/2,processing.height/</span><span class="number">2</span>)

  <span class="comment"># Instantiate 100 boids who start in the middle of the map, have a maxmimum </span>
  <span class="comment"># speed of 2, maximum force of 0.05, and give them a reference to the </span>
  <span class="comment"># processing instance so they can render themselves.</span>
  boids = <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0.</span><span class="number">.100</span>]
    <span class="keyword">new</span> Boid(start, <span class="number">2</span>, <span class="number">0.05</span>, processing)

  processing.draw = -&amp;gt;
    processing.background(<span class="number">255</span>)
    <span class="keyword">for</span> boid <span class="keyword">in</span> boids
      boid.step(boids)
      boid.render()
    <span class="literal">true</span>

canvas = $(<span class="string">'&amp;lt;canvas width="550" height="550"&amp;gt;&amp;lt;/canvas&amp;gt;'</span>).appendTo($(<span class="string">'#flockingDemo'</span>))[<span class="number">0</span>]
processingInstance = <span class="keyword">new</span> Processing(canvas, flock)
</code></pre>
<p>여기서 보이는 <code>flock</code>함수는 보이드의 <code>flock</code> 메서드와는 다르다. 위에 코드가 있지만 난 친절하니까 밑에 다시 코드를 적어주겠다.</p>
<pre><code class="lang-coffeescript">flock: (neighbours) -&amp;gt;
  separation = <span class="keyword">this</span>.separate(neighbours).multiply(SEPARATION_WEIGHT)
  alignment = <span class="keyword">this</span>.align(neighbours).multiply(ALIGNMENT_WEIGHT)
  cohesion = <span class="keyword">this</span>.cohere(neighbours).multiply(COHESION_WEIGHT)
  <span class="keyword">return</span> separation.add(alignment).add(cohesion)
</code></pre>
<p>자 이것이 보이드의 <code>flock</code>메서드이다. 보이드의 것은 세 가지 행동 요소(분리, 정렬, 응집)를 이용해 가속도로 사용할 값을 계산하는 것이다. 각 요소 값을 계산하고 그것을 그대로 쓰는 것이 아니라 그 것이 가속도에 끼칠 영향도(weight)를 곱해준다. 그 값은 각각 <code>SEPARATION_WEIGHT</code>, <code>ALIGNMENT_WEIGHT</code>, <code>COHESION_WEIGHT</code>이다. 보이드의 <code>flock</code>메서드는 각 요소에 영향도를 곱해서 전부 더한다. 그게 끝이다.
전체 코드는 <a href="https://github.com/hornairs/blog/tree/master/assets/coffeescripts/flocking">여기</a>에서 구할 수 있다.</p>

<h2>변칙</h2>

<h3>다른 이웃</h3>

<p>여기까지가 기본적인 플로킹 알고리즘이었다. 지금까지는 주변 보이드를 계산할 때 그냥 주변을 360도를 전부 검사했다. 하지만 만약 보이드가 인간이나 동물의 추상체라면 자신의 주변은 관찰 가능한 곳에 있는, 또는 눈에 보이는 보이드로 한정될 것이다. 따라서 주변 보이드를 계산할 때 자신의 뒤쪽은 배제할 수도 있다. 또는 정말 시야에 들어오는 보이드만을 이웃으로 규정할 수도 있다. 이런 이웃을 계산하는 방법에 따라 많은 변칙이 가능해진다.
공간에서 이웃은 위치상의 근접 개체이지만 다른 문제로 환원하면 논리적 근접을 다시 정의해야 한다. 예를 들어 만약 소셜 네트워크라면 이웃은 자신의 친구나 친구가 공유한 다른 친구로 될 것이다. 웹 사이트라면 직접 링크한 문서들을 이웃으로 정할 수도 있겠다.</p>

<h3>영향도 수정</h3>

<p>글에는 세 행동 요소들에 적용되는 영향도 값을 적어놓진 않았지만, 이 영향도 값들을 수정함으로써 보이드들이 다른 행동 양식을 보이도록 할 수도 있다.</p>

<h3>장애물 피하기</h3>

<p>위 데모가 진행되는 동안 마우스를 보이드로 가져다 대면 그들이 마우스 포인터를 휙휙 피하는 모습을 관찰할 수 있다. 아예 갈 수 없는 곳을 피하기도 하는데 이에 대한 설명은 글에서 하지 않았다. 공부를 더 해야 하지만 단순히 추측해보자면 특정 반경 안에 장애물이 감지되거나 장에물과 보이드가 충돌하면 속도를 줄이거나 멈추고 장애물이 없는 방향으로 속도를 올리는 것으로 생각된다. 장애물이 단순 벽일 때, 각이 있는 모서리 일 때, ㄷ자 형태의 벽일 때에 따라 장애물을 피해서 다시 빠져나갈 방법을 잘 설계해야 한다. 잘못하면 아마 벽에 무한으로 부히는 상황이 올지도 모른다.</p>

<h2>마무리</h2>

<p>이 글은 그냥 개인적으로 관심 있던 분야의 글이 뉴스 사이트에 올라왔고 호기심에 읽어본 글이 어쩌다 보니 이해되어 쓴 글이다. 이 모델을 어디에 사용할지는 아직 나도 모르겠지만 군체의 움직임이 예쁘게 모델링 되어있어 소개한다. 사실 예쁘게 모델링 되었다는게 정확한 모델링이라는 것과는 다른 말이지만 더 정교한 알고리즘의 기반 지식이라도 될까 기대해본다.</p>

<script type="text/javascript">
  var Harry = {};
</script>

<script src="/articles/2012/flocking-algorithm/js/processing.js" type="text/javascript"></script>

<script src="/articles/2012/flocking-algorithm/js/vector.js" type="text/javascript"></script>

<script src="/articles/2012/flocking-algorithm/js/boid.js" type="text/javascript"></script>

<script src="/articles/2012/flocking-algorithm/js/flock.js" type="text/javascript"></script>

<script src="/articles/2012/flocking-algorithm/js/flocking.js" type="text/javascript"></script>
]]>
</content></entry><entry><title><![CDATA[ Git: rerere ]]></title><link href="http://dogfeet.github.com/articles/2012/git-rerere.html" /><updated>2012-11-22T00:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/git-rerere.html</id><content type="html"><![CDATA[
<p>왠지 &lsquo;거꾸로 해도 이효리'가 떠오르는 이 이름, 명령어는 외우기는 쉽지만, 용법을 이해하는 데는 공을 좀 들여야 한다.</p>

<p>어떤 Topic 브랜치는 오랫동안 Merge하지 않고 유지하기도 한다. 이런 Topic 브랜치를 Merge하면 Conflict가 날 확률이 높다. Conflict가 예상되는 브랜치를 Merge할 때 <code>git rerere</code> 명령으로 난관을 극복하는 방법을 알아보자.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-rerere/overcome.jpg" alt="overcome"></p>

<p>이 글은 <a href="http://git-scm.com/2010/03/08/rerere.html">Rerere your boat&hellip;</a>을 주로 참고 했다. 내용은 거의 같다.</p>

<h2>rerere(Reuse Recorded Resolution)</h2>

<p><code>rerere</code>는 간단히 말하자면 Conflict를 해결한 Resolution을 저장해두고 같은 Conflict가 나면 저장한 Resolution을 재사용하는 명령이다.</p>

<p>Conflict가 발생하면 우선 conflict를 해결한 다음에, 다시 Merge하기 전으로 돌아와서 다시 Merge하면 저장된 Resolution이 적용돼서 Conflict 없이 자동으로 Merge된다.</p>

<p>어떻게 보면 말장난 같아 보일 수도 있다. Conflict를 Resolve하는 실험을 하고 실험에 성공하면 수동으로 그 실험을 재현해서 적용한다. 실패하면 다시 처음으로 돌아와 다시 시도한다. 그런데 이때 성공한 실험 내용을 기록해 뒀다가 자동으로 다시 적용하면 매우 편리할 것이다. <strong><code>rerere</code> 옵션을 켜면 Conflict를 Resolve하는데 성공하면 그 내용을 자동으로 저장해주고 같은 일을 다시 시도하면 git이 자동으로 재현해준다.</strong></p>

<p>그러면 이 명령어 어떻게 동작하는지 예제와 함께 살펴보자.</p>

<h3>설정</h3>

<p><code>rerere</code> 기능은 설정해야 사용할 수 있다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">rerere</span>.<span class="comment">enabled</span> <span class="comment">1</span>
</code></pre>
<p>각 저장소에 <code>.git/rr-cache</code> 디렉토리를 만들어도 이 기능이 켜지지만, 그냥 <code>--global</code>에 설정하자.</p>

<h3>Hello World</h3>

<p><code>hello.js</code> 프로그램 하나인 프로젝트가 있다. master 브랜치의 <code>hello.js</code> 프로그램은 아래와 같다:</p>
<pre><code class="lang-javascript">#!<span class="regexp">/usr/</span>bin/env node

console.log( <span class="string">'hello world'</span>)
</code></pre>
<p>그리고 아래와 같이 프로젝트를 진행한다. master 브랜치의 메시지를 'hola world'로 변경하고 i18n-world 브랜치의 메시지는 'hello mundo'로 변경한다:</p>

<p><img src="/articles/2012/git-rerere/rerere1.png" alt="rerere1"></p>

<p>이 상태에서 Merge를 하면 Conflict가 난다. 이 예제의 Conflict는 너무 간단해서 Recorded Resolution이 필요하지 않지만 <code>rerere</code>를 설명하기에는 더없이 좋은 예다.</p>

<h3>Recored Resolution 만들기</h3>

<p><a href="https://twitter.com/chacon">@chacon</a>님은 쓴 원래 글에서는 Conflict를 해결하는 브랜치에 바로 Merge하는 방법으로 Resolution을 만들었다. 그리고 Reset한 후에 다시 Merge해서 Resolution을 저장했다. 이 글에서는 detached HEAD를 이용하는 방법을 설명한다. 뭐 결과는 같지만 난 이 방법이 더 좋다.</p>

<p>먼저 detached HEAD 상태로 만든다:</p>
<pre><code>% git checkout HEAD^0
Note: checking out 'HEAD^0'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and <span class="operator"><span class="keyword">commit</span> them, <span class="keyword">and</span> you can discard <span class="keyword">any</span> commits you make <span class="keyword">in</span> this
state without impacting <span class="keyword">any</span> branches <span class="keyword">by</span> performing another checkout.

If you want <span class="keyword">to</span> <span class="keyword">create</span> a new branch <span class="keyword">to</span> retain commits you <span class="keyword">create</span>, you may
<span class="keyword">do</span> so (now <span class="keyword">or</span> later) <span class="keyword">by</span> <span class="keyword">using</span> -b <span class="keyword">with</span> the checkout command again. Example:

  git checkout -b new_branch_name

HEAD <span class="keyword">is</span> now <span class="keyword">at</span> <span class="number">7</span>d71bbe... hola world
</code></pre>
<p>master 브랜치가 가리키는 <code>7d71bbe</code>를 checkout 했기 때문에 워킹 디렉토리 내용은 master 브랜치와 같다. 단지 'detached HEAD&rsquo; 상태인 것만 다르다. 그래서 여기서 커밋을 하면 &lsquo;detached HEAD&rsquo; 상태로 커밋된다. master 브랜치는 움직이지 않는다.</p>

<p>그러면 여기서 Merge한다:</p>
<pre><code>% git merge i18n-world
Auto-merging hello.js
CONFLICT (content): Merge conflict <span class="keyword">in</span> hello.js
Recorded preimage <span class="keyword">for</span> 'hello.js'
Automatic merge failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> commit <span class="keyword">the</span> <span class="constant">result</span>.
</code></pre>
<p>보통 Conflict 날 때의 상황과 다르게 &ldquo;Recorded preimage for &lsquo;hello.js&rsquo;&rdquo; 라는 메시지를 추가로 보여준다. <code>rerere</code>를 켰기 때문에 생겼다.</p>

<p><code>git status</code>는 Conflict가 있다고 아래와 같이 알려준다:</p>
<pre><code>% git status
<span class="preprocessor"># Not currently on any branch.</span>
<span class="preprocessor"># Unmerged paths:</span>
<span class="preprocessor">#   (use "git add/rm &lt;file&gt;..." as appropriate to mark resolution)</span>
<span class="preprocessor">#</span>
<span class="preprocessor">#       both modified:      hello.js</span>
<span class="preprocessor">#</span>
no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)
</code></pre>
<p><code>git diff</code>라고 실행하면 어느 부분에서 Conflict가 난 것인지 보여준다:</p>
<pre><code><span class="comment">diff</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cc</span> <span class="comment">hello</span>.<span class="comment">js</span>
<span class="comment">index</span> <span class="comment">68d2f27</span>,<span class="comment">2c3b5e5</span>.<span class="string">.</span><span class="comment">0000000</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">a/hello</span>.<span class="comment">js</span>
<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">b/hello</span>.<span class="comment">js</span>
<span class="comment">@@@</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">+</span><span class="comment">1</span>,<span class="comment">8</span> <span class="comment">@@@</span>
  <span class="comment">#!/usr/bin/env</span> <span class="comment">node</span>

<span class="literal">+</span><span class="literal">+</span>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="comment">ours</span>
 <span class="literal">+</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">world')</span>
<span class="literal">+</span><span class="literal">+</span><span class="comment">=======</span>
<span class="literal">+</span> <span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hello</span> <span class="comment">mundo')</span>
<span class="literal">+</span><span class="literal">+</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="comment">theirs</span>
</code></pre>
<p>이제 &lsquo;hello.js&rsquo; 파일을 편집해서 &lsquo;hola mundo'로 Conflict를 해결하고 저장한다. 아직 Resolve를 Mark하지 않은 상태에서 <code>git diff</code>를 실행하면 아래와 같이 나온다:</p>
<pre><code><span class="comment">diff</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cc</span> <span class="comment">hello</span>.<span class="comment">js</span>
<span class="comment">index</span> <span class="comment">68d2f27</span>,<span class="comment">2c3b5e5</span>.<span class="string">.</span><span class="comment">0000000</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">a/hello</span>.<span class="comment">js</span>
<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">b/hello</span>.<span class="comment">js</span>
<span class="comment">@@@</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">+</span><span class="comment">1</span>,<span class="comment">4</span> <span class="comment">@@@</span>
  <span class="comment">#!/usr/bin/env</span> <span class="comment">node</span>

<span class="literal">-</span> <span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">world')</span>
 <span class="literal">-</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hello</span> <span class="comment">mundo')</span>
<span class="literal">+</span><span class="literal">+</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">mundo')</span>
</code></pre>
<p>이 명령은 'hola world'가 'hello mundo'와 Merge돼서 'hola mundo'가 되는 거라고 보여준다. 그런데 웬걸 <code>git add</code> 명령으로 Resolution을 Mark하면 <code>git diff</code> 명령은 더는 이런 메시지를 보여주지 않는다. 대신 <code>git rerere diff</code>를 사용해야 한다:</p>
<pre><code><span class="header">--- a/hello.js</span>
<span class="header">+++ b/hello.js</span>
<span class="chunk">@@ -1,8 +1,4 @@</span>
 #!/usr/bin/env node

<span class="deletion">-&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
<span class="deletion">-console.log( 'hello mundo')</span>
<span class="deletion">-=======</span>
<span class="deletion">-console.log( 'hola world')</span>
<span class="deletion">-&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="addition">+console.log( 'hola mundo')</span>
</code></pre>
<p>Resolution은 다 만들었고 이제 커밋한다:</p>
<pre><code>% git commit -m '<span class="keyword">sample</span> resolution'
Recorded resolution <span class="keyword">for</span> 'hello.js'.
[detached HEAD f35bf55] <span class="keyword">sample</span> resolution
</code></pre>
<p>&ldquo;Recorded resolution for 'hello.js&rsquo;&quot;라는 메시지는 Resolution이 저장됐음을 보여주는 것이고 &quot;detached HEAD&quot;는 detached HEAD 상태에서 커밋했기 때문에 보여주는 것이다.</p>

<p>이제 Resolution은 다 만들었다. Conflict를 해결하는 실험을 성공적으로 마친 것이다. 이 실험 결과를 실전에 적용해보자.</p>

<h2>rerere</h2>

<p>i18n-world를 master로 Merge하기 전에 i18n-world를 Rebase한다. 먼저 i18n-world를 Checkout한다:</p>
<pre><code>% git co i18n-world
Warning: you are leaving 1 <span class="operator"><span class="keyword">commit</span> behind, <span class="keyword">not</span> connected <span class="keyword">to</span>
<span class="keyword">any</span> <span class="keyword">of</span> your branches:

  f35bf55 sample resolution

If you want <span class="keyword">to</span> keep them <span class="keyword">by</span> creating a new branch, this may be a good <span class="keyword">time</span>
<span class="keyword">to</span> <span class="keyword">do</span> so <span class="keyword">with</span>:

 git branch new_branch_name f35bf550d886286e5e75569fb9597c664cd7743d

Switched <span class="keyword">to</span> branch <span class="string">'i18n-world'</span>
</code></pre>
<p>detached HEAD에서 벗어난다는 경고 메시지를 보여준다. 그리고 Rebase한다:</p>
<pre><code>% git rebase master
First, rewinding head <span class="keyword">to</span> replay your work <span class="function_start"><span class="keyword">on</span> <span class="title">top</span></span> <span class="keyword">of</span> <span class="keyword">it</span>...
Applying: hello mundo
Using index info <span class="keyword">to</span> reconstruct a base tree...
Falling <span class="keyword">back</span> <span class="keyword">to</span> patching base <span class="keyword">and</span> <span class="number">3</span>-way merge...
Auto-merging hello.js
CONFLICT (content): Merge conflict <span class="keyword">in</span> hello.js
Resolved 'hello.js' using previous resolution.
Failed <span class="keyword">to</span> merge <span class="keyword">in</span> <span class="keyword">the</span> changes.
Patch failed <span class="keyword">at</span> <span class="number">0001</span> hello mundo

When you have resolved this problem <span class="command">run</span> <span class="string">"git rebase --continue"</span>.
If you would prefer <span class="keyword">to</span> skip this patch, instead <span class="command">run</span> <span class="string">"git rebase --skip"</span>.
To check out <span class="keyword">the</span> original branch <span class="keyword">and</span> stop rebasing <span class="command">run</span> <span class="string">"git rebase --abort"</span>.
</code></pre>
<p>&quot;Resolved &lsquo;hello.js&rsquo; using previous resolution&rdquo; 메시지가 추가돼 있다. 편집기로 hello.js를 열어보면 좀 전에 만들었던 Resolution대로 파일이 Resolve됐음을 알 수 있다. <code>git diff</code> 명령으로 차이를 확인할 수 있다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">diff</span>
<span class="comment">diff</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cc</span> <span class="comment">hello</span>.<span class="comment">js</span>
<span class="comment">index</span> <span class="comment">68d2f27</span>,<span class="comment">2c3b5e5</span>.<span class="string">.</span><span class="comment">0000000</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">a/hello</span>.<span class="comment">js</span>
<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">b/hello</span>.<span class="comment">js</span>
<span class="comment">@@@</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">+</span><span class="comment">1</span>,<span class="comment">4</span> <span class="comment">@@@</span>
  <span class="comment">#!/usr/bin/env</span> <span class="comment">node</span>

<span class="literal">-</span> <span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">world')</span>
 <span class="literal">-</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hello</span> <span class="comment">mundo')</span>
<span class="literal">+</span><span class="literal">+</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">mundo')</span>
</code></pre>
<p><img src="/articles/2012/git-rerere/rerere3.png" alt="rerere1"></p>

<p>그러면 이 상태에서 Resolution을 Mark하고 <code>git rebase --continue</code>를 실행하면 Rebase가 완료된다. 아래와 같이 실행한다:</p>
<pre><code><span class="preprocessor"># git add .</span>
<span class="preprocessor"># git rebase --continue</span>
Applying: hello mundo
</code></pre>
<p><code>rerere</code>를 이용한 Merge를 마쳤다. &lsquo;detached HEAD&rsquo; 상태를 만들어서 Conflict를 해결하는 실험을 하고 Resolution을 만들어 놓는다. 그다음에 다시 Merge를 하면 만들어 놓은 Resolution이 재사용된다. 그래서 명령어 이름이 &lsquo;rerere(REuse REcorded REsolution)'이다.</p>

<h3>Resolution을 재사용하지 않기</h3>

<p>Resolution을 Mark하기 전으로 돌아가 보자. <code>git rebase master</code>를 실행하면 자동으로 저장된 Resolution이 적용된다. 그 상태로 돌아가서 <code>git diff</code>를 실행하면 결과는 아래와 같다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">diff</span>
<span class="comment">diff</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">cc</span> <span class="comment">hello</span>.<span class="comment">js</span>
<span class="comment">index</span> <span class="comment">68d2f27</span>,<span class="comment">2c3b5e5</span>.<span class="string">.</span><span class="comment">0000000</span>
<span class="literal">-</span><span class="literal">-</span><span class="literal">-</span> <span class="comment">a/hello</span>.<span class="comment">js</span>
<span class="literal">+</span><span class="literal">+</span><span class="literal">+</span> <span class="comment">b/hello</span>.<span class="comment">js</span>
<span class="comment">@@@</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">-</span><span class="comment">1</span>,<span class="comment">4</span> <span class="literal">+</span><span class="comment">1</span>,<span class="comment">4</span> <span class="comment">@@@</span>
  <span class="comment">#!/usr/bin/env</span> <span class="comment">node</span>

<span class="literal">-</span> <span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">world')</span>
 <span class="literal">-</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hello</span> <span class="comment">mundo')</span>
<span class="literal">+</span><span class="literal">+</span><span class="comment">console</span>.<span class="comment">log(</span> <span class="comment">'hola</span> <span class="comment">mundo')</span>
</code></pre>
<p>여기서 git이 자동으로 적용해준 Resolution이 마음에 들지 않으면 다시 Conflict 파일을 생성할 수 있다:</p>
<pre><code>% git checkout --conflict=merge hello.j
% cat hello.js
#!<span class="regexp">/usr/</span>bin/env node

&lt;<span class="xml"><span class="tag">&lt;<span class="title">&lt;&lt;&lt;&lt;&lt;</span> <span class="attribute">ours</span>
<span class="attribute">console.log</span>( '<span class="attribute">hola</span> <span class="attribute">world</span>')
=<span class="value">======</span>
<span class="attribute">console.log</span>( '<span class="attribute">hello</span> <span class="attribute">mundo</span>')
&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt; theirs
</span></code></pre>
<p><code>--conflict</code> 옵션은 Conflict를 해결할 때 사용하면 유용하다. <code>merge</code> 대신 <code>diff3</code>를 사용하면 base Commit의 것도 알 수 있다. Checkout명령은 <code>.git</code> 데이터베이스에 들어 있는 내용을 워킹 디렉토리로 복사하는 명령이다. 이 명령을 실행하면 충돌이 표시된 hello.js파일이 워킹 디렉토리에 생성된다:</p>
<pre><code>% git checkout --conflict=diff3 hello.js
% cat hello.js
#!<span class="regexp">/usr/</span>bin/env node

&lt;<span class="xml"><span class="tag">&lt;<span class="title">&lt;&lt;&lt;&lt;&lt;</span> <span class="attribute">ours</span>
<span class="attribute">console.log</span>( '<span class="attribute">hola</span> <span class="attribute">world</span>')
||||||| <span class="attribute">base</span>
<span class="attribute">console.log</span>( '<span class="attribute">hello</span> <span class="attribute">world</span>')
=<span class="value">======</span>
<span class="attribute">console.log</span>( '<span class="attribute">hello</span> <span class="attribute">mundo</span>')
&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt; theirs
</span></code></pre>
<p>이제 원하는 데로 편집하고 <code>git add .;git rebase --continue</code> 명령을 실행하면 Rebase는 완료된다. 하지만, 저장해둔 Resolution을 다시 적용하고 싶어지면 아래와 같이 복원한다:</p>
<pre><code>% git rerere
Resolved <span class="string">'hello.js'</span> <span class="keyword">using</span> previous resolution.
% cat hello.js
<span class="preprocessor">#!/usr/bin/env node</span>

console.log( <span class="string">'hola mundo'</span>)
</code></pre>
<p>Conflict를 다시 해결했으니 계속 진행해서 Rebate를 완료한다:</p>
<pre><code><span class="preprocessor"># git add .</span>
<span class="preprocessor"># git rebase --continue</span>
Applying: hello mundo
</code></pre>
<p>이상으로 <code>rerere</code> 명령에 대해 알아보았다.</p>

<h2>참고</h2>

<ul>
<li><a href="http://www.kernel.org/pub/software/scm/git/docs/git-rerere.html">git-rerere</a></li>
<li><a href="http://git-scm.com/2010/03/08/rerere.html">Rerere your boat&hellip;</a></li>
<li><a href="http://gitster.livejournal.com/41795.html">Fun with rerere</a></li>
</ul>
]]>
</content></entry><entry><title><![CDATA[ GitHub의 페이지 기능 이용하기 ]]></title><link href="http://dogfeet.github.com/articles/2012/github-pages.html" /><updated>2012-10-10T00:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/github-pages.html</id><content type="html"><![CDATA[
<p>GitHub의 Pages 기능을 이용하는 방법에 대해 정리해보고자 한다. <a href="https://twitter.com/pismute">@pismute</a>님의 &lsquo;한 때 버전 컨트롤, 위키, 블로그를 다 따로 사용했었는데, GitHub를 알고 나서 Git, GitHub으로만 사용하고 있다'는 말을 듣고 블로깅을 GitHub로 해보면 어떨까 하는 생각이 들었다. GitHub의 Page 기능을 이용하면 이 블로그처럼 글을 써서 남길 수 있다.
GitHub의 <a href="https://help.github.com/categories/20/articles">help 페이지에 있는 Pages의 글</a> 들중 몇 가지만 빼고 한국어로 옮겨봤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/github-pages/github-help.jpg" alt="help"></p>

<h2>1. GitHub의 Pages란?</h2>

<p>GitHub의 Pages란(이하 페이지) GitHub에서 무료로 호스팅하는 공개 웹페이지이다. GitHub에서 제공하는 페이지 제작 도구로 쉽게 페이지를 만들어 공개할 수도 있고, 로컬에서 git을 이용해 수동으로 만들 수도 있다.</p>

<h2>2. 사용자와 프로젝트를 위한 페이지</h2>

<p>우리는 두 가지 타입의 페이지를 만들 수 있다. 사용자 페이지와 프로젝트 페이지가 그것이다. 이 둘은 몇 가지 사항을 빼고는 거의 똑같다. (역자주 : 원문에는 User, Organization and Project Page라고 나와있다. 하지만 User와 Organization을 나누는 것은 계정을 혼자 사용하느냐 여럿이서 사용하느냐에 따른 차이일 뿐이다. 사용 방법에는 아무런 차이가 없으므로 이 글에서는 뭉쳐서 사용자라고만 표기한다.)</p>

<h3>사용자 페이지</h3>

<p>사용자 페이지는 페이지만을 위한 특별한 저장소에 저장한다. 이 저장소의 이름은 계정 이름을 사용한다. 만약 계정이 dogfeet라면 이 조직을 위한 저장소의 이름은 <a href="https://github.com/dogfeet/dogfeet.github.com">dogfeet/dogfeet.github.com</a> 이 된다.</p>

<ul>
<li>저장소의 이름은 반드시 <code>username/username.github.com</code>의 구조를 가진다.</li>
<li><strong>master</strong> 브랜치의 내용이 곧 페이지에서 보이는 내용이다.</li>
</ul>

<blockquote>
<p><strong>알아둘 것</strong>: 사용자 페이지의 저장소는 반드시 그 자신의 계정 이름밖에 사용하지 못한다. 다시 말해서 <code>joe/bob.github.com</code>식의 저장소는 페이지로 작동하지 않는다.</p>
</blockquote>

<h3>프로젝트 페이지</h3>

<p>사용자 페이지와는 다르게 <strong>프로젝트 페이지</strong>는 그 프로젝트의 저장소를 그대로 사용한다. (새로 저장소를 만들 필요 없다.) 그렇게 만들어진 페이지는 몇 가지를 제외하고 사용자 페이지와 완전히 똑같다.</p>

<ul>
<li>페이지를 만들거나 퍼블리싱 할 때에 <strong>gh-pages</strong> 브랜치를 사용한다.</li>
<li>커스텀 도메인을 사용하지 않으면 프로젝트 페이지는 사용자 페이지의 서브 경로로 제공된다. 주소는 <code>username.github.com/projectname</code>의 형태를 띈다.</li>
<li>커스텀 404 에러 페이지를 사용하려면 커스텀 도메인을 사용해야 한다. 커스텀 도메인을 사용하지 않으면 사용자 페이지의 404 에러 페이지를 사용하게 된다.</li>
</ul>

<h2>3. 자동으로 페이지 만들기</h2>

<p>프로젝트나 사용자의 페이지를 빠르게 만들려면 GitHub에서 제공하는 페이지 제작 도구를 이용한다.</p>

<h3>사용자 페이지</h3>

<p>사용자 페이지를 만들려면 우선 <code>username.github.com</code>이나 <code>orgname.github.com</code>이란 이름의 저장소를 만들어야 한다. 물론 여기서 username이나 orgname은 자기 자신의 github계정 이름이어야 한다. 그렇지 않으면 페이지는 만들어지지 않는다. 저장소의 admin 페이지에 가면 제작 도구를 사용할 수 있다.</p>

<h3>프로젝트 페이지</h3>

<p>모든 프로젝트 저장소에서 페이지를 만들고 퍼블리싱 할 수 있다. 하지만 주의할 것은 비공개 저장소에서 만든 페이지는 공개 페이지가 된다. (비공개 페이지를 만들 수 없다.)</p>

<h3>자동 페이지 제작 도구</h3>

<ol>
<li><p>저장소의 admin 페이지로 간다.</p>

<p><img src="/articles/2012/github-pages/repo-actions-admin.png" alt="repo-actions-admin"></p></li>
<li><p>&ldquo;Automatic Page Generator&rdquo; 버튼을 클릭한다.</p>

<p><img src="/articles/2012/github-pages/pages-automatic-page-generator.png" alt="pages-automatic-page-generator"></p></li>
<li><p>마크다운 에디터로 내용을 작성한다.</p></li>
<li><p>&ldquo;Continue To Layouts&rdquo; 버튼을 누른다.</p></li>
<li><p>제공되는 테마들을 적용해서 미리보기로 확인한다.</p>

<p><img src="/articles/2012/github-pages/page-generator-picker.png" alt="page-generator-picker"></p></li>
<li><p>좋아하는 테마를 발견했으면 &ldquo;Publish&quot;를 클릭한다.</p>

<p><img src="/articles/2012/github-pages/page-generator-publish.png" alt="page-generator-publish"></p></li>
</ol>

<p>페이지가 만들어진 후에 로컬에 복사본을 얻을 수 있다. 프로젝트 페이지를 만들었다면 새로운 브랜치를 fetch 후 checkout 한다.</p>
<pre><code><span class="char">$ </span>cd repo
<span class="char">$ </span>git fetch origin
<span class="method">remote:</span> <span class="class">Counting</span> <span class="method">objects:</span> <span class="number">92</span>, done.
<span class="method">remote:</span> <span class="class">Compressing</span> <span class="method">objects:</span> <span class="number">100</span>% (<span class="number">63</span>/<span class="number">63</span>), done.
<span class="method">remote:</span> <span class="class">Total</span> <span class="number">68</span> (delta <span class="number">41</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)
<span class="class">Unpacking</span> <span class="method">objects:</span> <span class="number">100</span>% (<span class="number">68</span>/<span class="number">68</span>), done.
<span class="class">From</span> <span class="method">https:</span>//github.com/user/repo.git
 * [new branch]      gh-pages     -&gt; origin/gh-pages

<span class="char">$ </span>git checkout gh-pages
<span class="class">Branch</span> gh-pages set up to track remote branch gh-pages from origin.
<span class="class">Switched</span> to a new branch <span class="string">'gh-pages'</span>
</code></pre>
<p>사용자 페이지를 만들었다면 페이지 코드는 gh-pages 브랜치가 아니라 master 브랜치에 페이지의 코드가 들어있다. 따라서 그냥 master 브랜치를 check out 한 뒤 pull 명령을 내리면 된다.</p>
<pre><code>$ cd repo
$ git checkout master
Switched to branch <span class="string">'master'</span>
$ git pull origin master
remote: Counting objects: <span class="number">92</span>, done.
remote: Compressing objects: <span class="number">100</span>% (<span class="number">63</span>/<span class="number">63</span>), done.
remote: Total <span class="number">68</span> (delta <span class="number">41</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)
Receiving objects: <span class="number">100</span>% (<span class="number">424</span>/<span class="number">424</span>), <span class="number">329.32</span> KiB | <span class="number">178</span> KiB/s, done.
Resolving deltas: <span class="number">100</span>% (<span class="number">68</span>/<span class="number">68</span>), done.
From https://github.com/user/repo.git
 * branch      master     -&gt; FETCH_HEAD
Updating abc1234..def5678
Fast-forward
index.html                                     |  <span class="number">265</span> ++++
<span class="keyword">...</span>
<span class="number">98</span> files changed, <span class="number">18123</span> insertions(+), <span class="number">1</span> deletion(-)
create mode <span class="number">100644</span> index.html
<span class="keyword">...</span>
</code></pre>
<h2>4. 수동으로 페이지 만들기</h2>

<p>git을 command-line으로 사용해왔다면 수동으로 새로운 페이지를 만드는 건 어렵지 않다.</p>

<h3>안전하게 가자</h3>

<p>프로젝트에 페이지를 만들어 넣으려면 저장소에 &quot;부모가 없는(orphan)&rdquo; 브랜치를 만들어야 한다. 이걸 하는 가장 안전한 방법은 우선 새로 저장소를 클론하는 것이다.</p>
<pre><code>git clone https://github.com/user/repo.git
Clone our repo

Cloning into <span class="string">'repo'</span><span class="keyword">...</span>
remote: Counting objects: <span class="number">2791</span>, done.
remote: Compressing objects: <span class="number">100</span>% (<span class="number">1225</span>/<span class="number">1225</span>), done.
remote: Total <span class="number">2791</span> (delta <span class="number">1722</span>), reused <span class="number">2513</span> (delta <span class="number">1493</span>)
Receiving objects: <span class="number">100</span>% (<span class="number">2791</span>/<span class="number">2791</span>), <span class="number">3.77</span> MiB | <span class="number">969</span> KiB/s, done.
Resolving deltas: <span class="number">100</span>% (<span class="number">1722</span>/<span class="number">1722</span>), done.
</code></pre>
<h3>이제 놀자!</h3>

<p>깨끗한 저장소를 손에 넣었다. 이제 새로운 브랜치를 만들고 작업 디렉토리와 인덱스의 모든 내용을 지워야 한다.</p>
<pre><code>$ cd repo

$ git checkout <span class="comment">--orphan gh-pages</span>
Creates our branch, without any parents (it<span class="attribute">'s</span> an orphan!)

Switched <span class="keyword">to</span> a <span class="keyword">new</span> branch <span class="attribute">'gh</span>-pages'

git rm -rf .
Remove <span class="keyword">all</span> files from the old working tree

rm '.gitignore'
</code></pre>
<blockquote>
<p><strong>알아둘 것</strong>: <code>gh-pages</code> 브랜치는 처음 커밋이 되기 전까지는 <code>git branch</code>의 브랜치 목록에 나타나지 않는다.</p>
</blockquote>

<p>비어있는 작업 디렉토리를 얻었다. 이 안에 내용을 채워넣고 GitHub로 푸시하면 된다. 예를 들자면 다음과 같다.</p>
<pre><code><span class="variable">$ </span>echo <span class="string">"My GitHub Page"</span> &gt; index.html
<span class="variable">$ </span>git add .
<span class="variable">$ </span>git commit -a -m <span class="string">"First pages commit"</span>
<span class="variable">$ </span>git push origin gh-pages
</code></pre>
<blockquote>
<p><strong>알아둘 것</strong>: 최초의 푸시를 한 뒤에 페이지가 보이기까지는 몇 분 정도 기다려야 한다.</p>
</blockquote>

<h2>5. Jekyll과 페이지</h2>

<p>일반적인 HTML 컨텐츠를 지원하는 차원에서 GitHub의 페이지는 <a href="https://github.com/mojombo/jekyll">Jekyll</a>을 지원한다. (역자주: '지킬 박사와 하이드'의 지킬이다.) Jekyll은 'Tom Preston-Werner'이 제작한 간단한 스태틱 사이트 제네레이터이다. Jekyll을 이용하면 웹사이트 전체에 적용되는 헤더, 푸터를 파일을 여러 번 복제하지 않고도 만들 수 있다. 블로그 기능이나 멋진 템플릿 기능들도 지원한다.</p>

<h3>Jekyll 사용하기</h3>

<p>GitHub의 모든 페이지는 Jekyll로 돌아간다. 일반 HTML 파일 또한 유효한 Jekyll 사이트이기 때문에 이미 가지고 있던 HTML 파일들을 수정하지 않아도 된다. 그냥 전부 HTML 파일이면 괜찮다. <a href="https://github.com/mojombo/jekyll/blob/master/README.textile">README</a>에 Jekyll의 기능들과 그 사용법이 적혀있다.</p>

<h3>Jekyll 설정하기</h3>

<p><code>_config.yml</code> 파일에 Jekyll의 대부분의 설정이 다 들어있다. 퍼머 링크의 스타일이나 마크다운 렌더러를 Maruku에서 RDiscount로 바꿀 수도 있다. 아래와 같은 옵션만 바꾸면 된다.</p>
<pre><code><span class="attribute">safe</span>: <span class="string">true</span>
<span class="attribute">source</span>: <span class="string">&lt;your pages repo&gt;</span>
<span class="attribute">destination</span>: <span class="string">&lt;the build dir&gt;</span>
<span class="attribute">lsi</span>: <span class="string">false</span>
<span class="attribute">pygments</span>: <span class="string">true</span>
</code></pre>
<h3>Troubleshooting</h3>

<p>사이트를 GitHub에 푸시 후에도 Jekyll 사이트가 보이지 않는다면 Jekyll을 로컬에서 돌려보면 여러 오류를 잡을 수 있다. 이 기능을 위해 GitHub에서 사용하는 것과 같은 버전의 Jekyll을 사용하길 바란다.</p>

<p>GitHub의 페이지 서버는 Jekyll 버전 0.11.0, Liquid 버전 2.2.2를 사용하고 다음 명령어로 실행을 시킨다.</p>
<pre><code><span class="comment">$</span> <span class="comment">jekyll</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">pygments</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">no</span>-<span class="comment">lsi</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">safe</span>
</code></pre>
<p>만약 GitHub에 푸시하고도 페이지가 만들어지지 않으면 '페이지가 안 보여요'가이드를 보라.</p>

<h4>Jekyll 끄기</h4>

<p>Jekyll을 그만 사용하려면 저장소의 루트에 <code>.nojekyll</code>이란 이름의 파일을 만들고 푸시하기만 하면 된다. </p>

<h3>기여하기</h3>

<p>Jekyll에 필요한 기능이 있으면 주저하지 말고 <a href="https://github.com/mojombo/jekyll">fork</a> 한 뒤에 풀 리퀘스트를 보내면 된다. 이런 건 언제든지 환영한다</p>

<h2>6. 페이지에 커스텀 도메인 설정하기</h2>

<p>GitHub의 페이지에 사용자가 지정하는 도메인 이름을 설정해줄 수 있다.</p>

<h3>저장소에 도메인 설정하기.</h3>

<p>우리가 가지고 있는 도메인이 <code>example.com</code>라 치고 이걸 우리 페이지에 연결해보자. GitHub에게 이 도메인으로 서비스해주세요~ 라고 말하는 건 쉽다. 페이지의 루트에 CNAME 이라는 파일을 하나 만들고 도메인 이름을 적어넣으면 된다.</p>
<pre><code><span class="filename">example.com
</code></pre>
<blockquote>
<p><strong>알아둘 것</strong>: 이 파일을 만들고 GitHub에서 페이지를 성공적으로 만들었다는 알림을 확인한 후에 다음 단계인 'DNS 세팅하기'를 시작해야 한다.</p>
</blockquote>

<p>만약 <strong>사용자 페이지</strong> 저장소에서 작업하고 있다면 이 일은 <strong>master</strong>브랜치에서 해야 하고 <strong>프로젝트 페이지</strong> 저장소라면 <strong>gh-pages</strong>브랜치에서 작업을 해야 한다.</p>

<blockquote>
<p><strong>알아둘 것</strong>: 하나의 페이지에는 하나의 커스텀 도메인만 할당할 수 있다. 만약 같은 페이지에 여러 도메인을 할당하고 싶다면 다른 도메인에서 당신의 페이지로 리다이렉트 해주는 서비스 등을 이용해야 할 것이다.</p>
</blockquote>

<h3>DNS 세팅하기</h3>

<p>다음은 DNS를 세팅할 차례이다. 세팅은 사용하는 도메인의 종류에 따라서 두 가지 방법으로 나눌 수 있다.</p>

<p>아, DNS 변경이 전 세계로 퍼지기까지는 약 하루가 걸린다. 인내를 가지고 기다려야 한다.</p>

<h4>Top-level 도메인 (TLD)</h4>

<p><code>example.com</code>과 같은 TLD은 <strong>A 레코드</strong>가 204.232.175.78를 가리키도록 해야 한다.</p>
<pre><code>$ dig example<span class="preprocessor">.com</span> +nostats +nocomments +nocmd
<span class="preprocessor"># Look up DNS record for example.com</span>
<span class="comment">;example.com.                    IN      A</span>
example<span class="preprocessor">.com</span>.             <span class="number">3259</span>    <span class="keyword">IN</span>      A       <span class="number">204.232</span><span class="number">.175</span><span class="number">.78</span>
</code></pre>
<blockquote>
<p><strong>경고</strong>: TLD에는 CNAME 레코드를 사용하면 안 된다. CNAME 레코드를 쓰면 해당 도메인의 다른 서비스들(예를 들면 이메일 같은)에 문제가 생길 수 있다.</p>
</blockquote>

<h4>서브 도메인</h4>

<p>서브 도메인을 할당하려면 <strong>CNAME 레코드</strong>로 사용자 페이지 서브 도메인을 가리키는게 최고다. 이 방법을 이용하면 GitHub 서버의 IP가 바뀌어도 자동으로 조정해준다. CNAME 레코드는 A 레코드 위에 쓸 수도 있다. 하지만 이 정보는 자동으로 업데이트 되지 않는다.</p>
<pre><code>$ dig <span class="transposed_variable">www.</span><span class="transposed_variable">example.</span>com +nostats +nocomments +nocmd
;<span class="transposed_variable">www.</span><span class="transposed_variable">example.</span><span class="transposed_variable">com.</span>                 IN      A
<span class="transposed_variable">www.</span><span class="transposed_variable">example.</span><span class="transposed_variable">com.</span>          <span class="number">3592</span>    IN      CNAME   <span class="transposed_variable">username.</span><span class="transposed_variable">github.</span><span class="transposed_variable">com.</span>
<span class="transposed_variable">username.</span><span class="transposed_variable">github.</span><span class="transposed_variable">com.</span>      <span class="number">43192</span>   IN      A       <span class="number">204.232</span><span class="number">.175</span><span class="number">.78</span>
</code></pre>
<h3>자동 리다이렉트</h3>

<p>커스텀 도메인을 세팅하면 서버는 자동으로 몇 가지 리다이렉트 기능을 제공한다.</p>

<ul>
<li>사용자 페이지에서는 <code>username.github.com</code> ⇒ <code>example.com</code></li>
<li>TDL에서는 <code>www.example.com</code> ⇒ <code>example.com</code></li>
<li>www 서브 도메인을 사용 중이라면 <code>example.com</code> ⇒ <code>www.example.com</code></li>
</ul>

<p><code>www</code> ⇔ TLD 리다이렉트가 동작하려면 TLD와 <code>www</code> 서브 도메인 DNS의 레코드가 페이지의 서버를 가리키고 있어야 한다.</p>

<blockquote>
<p><strong>알아둘 것</strong>: 사용자 페이지의 커스텀 도메인은 자체의 커스텀 도메인을 가진 프로젝트 페이지는 제외하고 그 계정 아래에 있는 모든 프로젝트 페이지를 같은 도메인으로 리다이렉트한다.</p>

<p><strong>경고</strong>: <code>http://username.github.com/projectname</code>과 같은 프로젝트 페이지의 서브 경로는 프로젝트의 커스텀 도메인으로 리다이렉트 되지 않는다.</p>
</blockquote>

<h3>실제 예제</h3>

<p><a href="http://github.com/mojombo/mojombo.github.com/">mojombo.github.com</a> 은 <a href="http://tom.preston-werner.com/">tom.preston-werner.com</a> 로 리다이렉트 된다. 커스텀 도메인은 <a href="https://github.com/mojombo/mojombo.github.com/blob/master/CNAME">이 파일</a>에 정의되어 있다.</p>

<h3>Troubleshooting</h3>

<p>커스텀 도메인 설정에 문제가 생기면 <a href="https://help.github.com/articles/my-custom-domain-isn-t-working">이 가이드</a>를 보면 된다.</p>

<h2>7. 커스텀 404 페이지</h2>

<p>404.html 파일을 저장소의 루트에 넣어두면 기존 404페이지 대신 저장소의 404.html 페이지를 보여준다. 404 페이지는 반드시 html 파일이어야 한다.</p>

<blockquote>
<p><strong>알아둘 것</strong>: 커스텀 404 페이지는 페이지 도메인의 루트에 존재해야만 작동한다. 커스텀 도메인을 사용하지 않는 프로젝트 페이지의 커스텀 404 페이지는 동작하지 않는다. (프로젝트 페이지는 루트도메인 외에 프로젝트 이름이 경로에 추가되므로)</p>
</blockquote>

<h3>실제 예제</h3>

<p><a href="http://github.com/tekkub/tekkub.github.com/blob/master/404.html">Tekkub의 404</a> 페이지는 <a href="http://tekkub.net/404.html">tekkub.net/404.html</a> 에서 볼 수 있다.</p>

<h2>8. 페이지가 안 보여요. &ldquo;unable to run Jekyll!&rdquo;</h2>

<p>가끔 페이지는 푸시 후에 빌드에 실패해서 &ldquo;unable to run jekyll&quot;이라는 에러를 내뱉을 때가 있다. 이 에러가 나올 수 있는 몇몇 원인을 알아보자.</p>

<h3>저수준 태그 에러</h3>

<p>Jekyll은 현재 저수준의 Liquid 태그에 대한 <a href="https://github.com/mojombo/jekyll/issues/425">이슈사항</a>이 있다. 만약 이 기능을 사용한다면 템플릿에 중괄호 등을 이스케이프 시킬 때는 HTML 이스케이프 시퀀스 같은 방법을 사용하는 등의 우회로를 찾아야 한다.</p>

<h3>안전하지 않은 플러그인</h3>

<p>페이지의 서버는 안전하다고 확인되지 않은 플러그인은 빌드하지 않는다. <code>_plugins</code>폴더에 있는 모든 플러그인 또한 이 규칙에 적용받는다.
이 문제는 두 가지 해결책이 존재한다.</p>

<ul>
<li>안전하지 않은 플러그인을 지운다. 또는</li>
<li>소스 파일 대신에 페이지를 로컬에서 빌드하고 그 결과 파일을 푸시한다.</li>
</ul>

<p>두 번째 해결책이 <a href="http://octopress.org/">Octopress</a>가 취하고 있는 전략이다.</p>

<h3>문법 에러</h3>

<p>때로 타이핑을 잘못 했다던가 하는 이유로 빌드가 실패하는 때도 있다. 이는 <a href="http://jekyllrb.com/">jekyll</a>을 로컬에서 <code>jekyll --safe</code>를 이용해 확실히 잡아야 한다. GitHub에서 사용하는 서버에서 사용하는 jekyll의 버전은 Jekyll과 페이지 섹션에서 알 수 있다.</p>

<h3>소스 세팅</h3>

<p>GitHub의 빌드 서버는 당신의 페이지를 빌드할 때 <code>source</code> 세팅을 덮어쓴다. 만약 당신이 이 세팅을 바꾼다면 페이지가 빌드되지 않을 수도 있다.</p>

<h2>9. 프로젝트 페이지 지우기</h2>

<p>프로젝트 페이지를 없애려면 <code>gh-pages</code> 브랜치를 지우면 된다.</p>
<pre><code>$ git push origin <span class="comment">--delete gh-pages</span>
<span class="operator"><span class="keyword">Delete</span> the gh-pages branch <span class="keyword">from</span> origin

<span class="keyword">To</span> https://github.com/username/repo.git
- [deleted]         gh-pages
</code></pre>
<h2>10. 브랜치 모델</h2>

<p>섹션 9 까지는 번역이었고, 10 부터는 dogfeet 블로그에서 사용하는 브랜치 모델에 대해서 설명하려 한다. 어렵지 않으나 중요하므로 얼른 하고 마치자.</p>

<h3>draft/* 브랜치</h3>

<p>모든 글은 각자 하나의 브랜치를 가진다. 이 글은 <code>draft/github-pages</code>라는 브랜치 위에서 작성 중이다. 이 블로그의 모든 글이 <code>draft/</code>라는 접미사를 가진 브랜치를 가지고 있었다. 각 글들은 자신의 브랜치 위에서 작성되고 다른 사람들과 공유하여 리뷰를 받는다. 추가돼야 할 내용이나 오타, 비문 등을 지적받고 다시 고친 뒤에 커밋 한다. 
글이 완성되면 저장용, 공유용 커밋들을 rebase를 이용해 합쳐서 1~2개의 커밋으로 정리한다. 이는 중앙 저장소의 히스토리를 예쁘게 유지하기 위함이다. 히스토리가 복잡해지면 같이 공유하는 사람에 대한 예의에 어긋난다. (&hellip;) 사람마다 다르겠지만 내 경우에 완전한 창작 글은 하나의 커밋으로 합치고 번역 글은 markdown으로 포메팅된 원문이 보존된 커밋 하나와 완성된 번역문 두 개로 정리한다.
정리가 다 되면 ready 브랜치로 합친다.</p>

<h3>ready 브랜치</h3>

<p>정리된 draft 브랜치는 ready 브랜치로 합친다. dogfeet은 완성된 글을 곧바로 퍼블리싱하지 않고 ready 브랜치에 먼저 저장한다. 그리고는 매 주마다 master 브랜치를 ready 브랜치로 fast-forwording하여 실제 웹페이지로 보이도록 발행한다. 저장은 merge나 rebase를 하는데 둘 중에 어떤 것을 할지는 <a href="/articles/2012/git-merge-rebase.html">이 글</a>을 참고 하길 바란다.</p>

<p>master 브랜치는 항상 fast-forwording만 한다.</p>

<h3>정리</h3>

<p>하나의 글을 퍼블리싱 하는 프로세스는 다음과 같다.</p>

<ol>
<li>master 브랜치에서 draft/<어쩌구 저쩌구> 라는 이름으로 새로운 브랜치를 딴다.</li>
<li>글을 쓰고 커밋을 정리한다. 필요에 따라 서로 리뷰를 부탁하기도 한다.</li>
<li>ready로 merge 하거나 rebase 시킨다.</li>
<li>ready 브랜치를 master 브랜치로 fast-forword 한다.</li>
</ol>
]]>
</content></entry><entry><title><![CDATA[ Git 인덱스 페이지 프로젝트 dogit ]]></title><link href="http://dogfeet.github.com/articles/2012/dogit.html" /><updated>2012-09-27T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/dogit.html</id><content type="html"><![CDATA[
<p>프로젝트 <a href="http://dogfeet.github.com/dogit">dogit</a>(<code>두깃</code>으로 읽는다). Git과 관련된 자료를 일목요연하게 볼 수 있도록 Git 인덱스 페이지를 만들었다. 여기저기 흩어져 있는 자료를 후진 기억력에 의존해 찾으려니 매우 오래걸리고 귀찮았다. 한 번에 전부 설명할 수는 없지만, 한 페이지에서 키워드와 해당 자료의 링크를 넣어 두면 검색해서 찾아 보기 쉬울 것 같았다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/dogit/index-html.png" alt="brownee"></p>

<p>좋은 자료가 있으면 알려주세요. 쉽게 검색할 수 있도록 간략한 소개나 키워드가 같이 있으면 좋습니다. 이 글의 댓글로 남겨주시거나 Pull Request를 보내 주시면 감사하겠습니다.</p>

<p>풍성하고 즐거운 추석 보내세요.</p>
]]>
</content></entry><entry><title><![CDATA[ Meteor: 스마트 패키지 매니저 "Meteorite" ]]></title><link href="http://dogfeet.github.com/articles/2012/meteor-meteorite.html" /><updated>2012-09-20T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/meteor-meteorite.html</id><content type="html"><![CDATA[
<p><a href="https://github.com/oortcloud/meteorite">Meteorite</a>로 할 수 있는 일은 두 가지이다. 하나는 스마트 패키지를 관리하는 일이고 하나는 Meteor 앱을 관리하는 일이다. 이 글은 Meteor 앱을 관리하는 방법을 설명한다. 스마트 패키지를 관리하는 일은 다음에 정리하겠다.</p>

<p><a href="https://github.com/oortcloud/meteorite">Meteorite</a>는 <a href="http://meteor.com/">Meteor</a> 매니저이자 스마트 패키지 매니저다. meteor 명령을 감싸는 형태로 구현했기 때문에 <a href="https://github.com/oortcloud/meteorite">Meteorite</a>로도 Meteor 앱을 관리할 수 있다. 그리고 meteor 명령은 지원하지 않는 스마트 패키지를 설치/관리할 수도 있다. 게다가 스마트 패키지를 만들고 관리할 수도 있다. <a href="http://rubygems.org/">gem</a>, <a href="http://gembundler.com/">bundler</a>, <a href="https://rvm.io/">rvm</a>을 보고 만들었다고 한다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/meteor/meteorite.png" alt="meteorite"></p>

<p><a href="https://github.com/oortcloud/meteorite">Meteorite</a>를 사용하면 사용할 meteor 버전을 명시할 수도 있고 스마트 패키지 의존성을 관리할 수 있다.</p>

<h2>설치하기</h2>
<pre><code class="lang-bash">npm install -g meteorite
</code></pre>
<h2>mrt 명령어</h2>

<p><a href="https://github.com/oortcloud/meteorite">Meteorite</a>의 명령어는 <code>mrt</code>이다. &lsquo;meteor create myapp'으로도 스케폴드 앱을 만들 수 있지만 <code>mrt</code> 명령으로도 앱을 만들 수 있다:</p>
<pre><code class="lang-bash">mrt create myapp
</code></pre>
<p><code>meteor</code> 명령으로 생성한 것과 거의 같지만 <code>mrt</code> 명령은 meteor 저장소의 master 브랜치를 기준으로 myapp으로 생성한다. 그리고 스마트 패키지 정보파일인 smart.json 파일에 그 정보를 기록한다:</p>
<pre><code class="lang-javascript">{
  <span class="string">"meteor"</span>: {
    <span class="string">"git"</span>: <span class="string">"https://github.com/meteor/meteor.git"</span>,
    <span class="string">"branch"</span>: <span class="string">"master"</span>
  },
  <span class="string">"packages"</span>: {}
}
</code></pre>
<p><code>mrt create</code> 명령에는 <code>--branch</code>, <code>--tag</code>, <code>--ref</code> 옵션이 있어서 원하는 meteor 버전을 명시할 수 있다. </p>

<p>그리고 다음과 같이 실행한다. 아무 옵션없이 <code>mrt</code>를 실행하면 <code>mrt run</code>를 실행한 것과 같고 기본포트는 <code>meteor</code> 명령처럼 3000이다:</p>
<pre><code class="lang-bash">mrt run --port 2222
</code></pre>
<h2>smart.json</h2>

<p><code>smart.json</code>은 npm의 <code>package.json</code> 처럼 스마트 패키지 정보를 기술하는 파일이다. </p>
<pre><code class="lang-javascript">{
  <span class="comment">//meteor는 생략할 수 있다.</span>
  <span class="comment">//생략할 경우 Meteor의 공식 저장소와 master 브랜치가 사용된다.</span>
  <span class="comment">//meteor.branch와 meteor.git 설정은 다른 브랜치를 사용할 때 쓴다.</span>
  <span class="string">"meteor"</span>: { 
    <span class="string">"branch"</span>: <span class="string">"devel"</span>
  },
  <span class="comment">//packages에 명시한 패키지는 기본적으로 중앙저장소(atmosphere)에서</span>
  <span class="comment">//다운로드한다. 여기서는 moment와 fork-me를 다운로드한다.</span>
  <span class="string">"packages"</span>: {
    <span class="string">"moment"</span>: <span class="string">"1.7.0"</span>,
    <span class="string">"fork-me"</span>: {
      <span class="string">"version"</span>: <span class="string">"0.0.1"</span>
    },
    <span class="string">"cool-tool"</span>: {
      <span class="comment">//atmosphere가 아니라 git 저장소에서 패키지를 가져온다.</span>
      <span class="string">"git"</span>: <span class="string">"https://github.com/possibilities/cool-tool.git"</span>,
      <span class="comment">//해당 태그의 버전을 가져온다.</span>
      <span class="string">"tag"</span>: <span class="string">"v0.0.2"</span>
      <span class="comment">//branch도 된다.</span>
      <span class="string">"branch"</span>: <span class="string">"master"</span>
      <span class="comment">//ref도 된다.</span>
      <span class="string">"ref"</span>: <span class="string">"a137a5eee5"</span>
    },
    <span class="string">"another-tool"</span>: {
      <span class="comment">//atmosphere가 아니라 git 저장소에서 패키지를 가져온다.</span>
      <span class="string">"git"</span>: <span class="string">"https://github.com/possibilities/another-tool.git"</span>
    },
    <span class="string">"test-package"</span>: {
      <span class="comment">//로컬 디스크에 있는 패키지를 가져온다.</span>
      <span class="string">"path"</span>: <span class="string">"/path/to/local/package"</span>
    }
  }
}
</code></pre>
<ul>
<li><p>smart.json 파일에는 저장소 이외에 다른 정보는 기입하지 않아도 된다. mrt는 저장소에 있는 package.js 파일을 찾고 해당 Meteor 버전에 맞는 패키지를 다운로드해서 설치한다.</p></li>
<li><p>명시한 스마트 패키지들에 서로 의존관계가 있으면 <code>mrt</code>가 적당히 정렬해서 설치한다. 상호 의존성이 있어도 잘 설치한다.</p></li>
<li><p><code>mrt</code>가 처음 실행되면 smart.lock 파일이 생성된다. 이 파일에는 사용하는 패키지 버전이 들어간다. 다음에 실행할 때 참고하기 때문에 매우 유용하다. smart.lock 파일을 저장소에 커밋해 두면 그 저장소를 클론한 다른 개발자도 원 개발자가 사용하는 버전이 무었인지 알 수 있다. 그리고 smart.json 파일이 수정되면 자동으로 새 버전으로 업데이트 한다. 다음은 smart.lock 샘플이다:</p></li>
</ul>
<pre><code class="lang-javascript">{
  <span class="string">"meteor"</span>: {
    <span class="string">"git"</span>: <span class="string">"https://github.com/meteor/meteor.git"</span>,
    <span class="string">"branch"</span>: <span class="string">"devel"</span>,
    <span class="string">"commit"</span>: <span class="string">"de413efe500174999211eff318ad65eb34794d74"</span>
  },
  <span class="string">"dependencies"</span>: {
    <span class="string">"basePackages"</span>: {
      <span class="string">"moment"</span>: {},
      <span class="string">"groups"</span>: {}
    },
    <span class="string">"packages"</span>: {
      <span class="string">"moment"</span>: {
        <span class="string">"git"</span>: <span class="string">"https://github.com/possibilities/meteor-moment.git"</span>,
        <span class="string">"tag"</span>: <span class="string">"v1.7.0"</span>,
        <span class="string">"commit"</span>: <span class="string">"c64b6ec0e714b9556f4b6643d430b868ba69d3d7"</span>
      },
      <span class="string">"groups"</span>: {
        <span class="string">"git"</span>: <span class="string">"https://github.com/possibilities/meteor-groups.git"</span>,
        <span class="string">"tag"</span>: <span class="string">"v0.0.6"</span>,
        <span class="string">"commit"</span>: <span class="string">"ee45c3fbdb84313f6f0124ed30e02e101d3829cb"</span>
      }
    }
  }
}
</code></pre>
<p><code>mrt install</code>이라고 실행하면 Meteor는 실행하지 않고 패키지만 설치한다.</p>

<p><code>smart.lock</code> 파일을 날려버리고서 <code>mrt update</code> 명령을 실행하면 패키지를 전부 업데이트할 수 있다. <code>mrt update PACKAGE_NAME</code> 처럼 패키지 이름을 입력하면 그 패키지만 업데이트된다.</p>

<h2>Atmosphere</h2>

<p><a href="https://github.com/oortcloud/meteorite">Meteorite</a>는 스마트 패키지용 중앙 저장소를 사용하는데 이 저장소가 <a href="https://atmosphere.meteor.com/wtf/package">Atmosphere</a>이다. </p>

<p>다음과 같이 <a href="https://atmosphere.meteor.com/wtf/package">Atmosphere</a>에 있는 패키지는 설치한다:</p>
<pre><code><span class="comment">mrt</span> <span class="comment">add</span> <span class="comment">moment</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">version</span> <span class="comment">1</span>.<span class="comment">6</span>.<span class="comment">2</span>
</code></pre>
<p>'버전은 생략할 수 있다.'라고 메뉴얼에서 설명하는데 저 옵션은 제대로 동작하는 것인지 모르겠다. 생략도 가능하다. <code>mrt help add</code> 명령을 실행했을 때 나오는 설명도 없고 아직 먼가 부실하다.</p>

<p><code>mrt list</code> 명령을 실행하면 현재 사용할 수 있는 패키지를 보여준다. <code>meteor list</code>과 기본적으로 같지만 mrt 명령으로 설치한 스마트 패키지도 보여진다. 아직 설치하지 않은 <a href="https://atmosphere.meteor.com/wtf/package">Atmosphere</a>에 있는 패키지도 조회할 수 있으면 좋을 것 같은데 아직 그런 명령어는 없다. 현재 사용하고 있는 패키지는 smart.json을 봐야한다. <code>mrt list</code> 명령의 결과는 다음과 같다:</p>
<pre><code>absolute-url      DEPRECATED: Generate absolute URLs pointing <span class="keyword">to</span> the application
amplify           Cross browser API <span class="keyword">for</span> Persistant Storage, PubSub <span class="keyword">and</span> Request.
autopublish       Automatically publish all data <span class="keyword">in</span> the database <span class="keyword">to</span> every client
backbone          A minimalist client-side MVC framework
bootstrap         UX/UI framework from Twitter
code-prettify     Syntax highlighting <span class="keyword">of</span> code, from Google
coffeescript      Javascript dialect <span class="keyword">with</span> fewer braces <span class="keyword">and</span> semicolons
email             Send email messages
force-ssl         Require this application always use transport layer encryption
groups            Simple system <span class="keyword">for</span> groups
handlebars        Simple semantic templating language
htmljs            Easy macros <span class="keyword">for</span> generating DOM elements <span class="keyword">in</span> Javascript
http              Make HTTP calls <span class="keyword">to</span> remote servers
jquery            Manipulate the DOM using CSS selectors
jquery-history    pushState module from the jQuery project
jquery-layout     Easily create arbitrary multicolumn layouts
jquery-waypoints  Execute a <span class="function"><span class="keyword">function</span> <span class="title">when</span> <span class="title">the</span> <span class="title">user</span> <span class="title">scrolls</span> <span class="title">past</span> <span class="title">an</span> <span class="title">element</span>
<span class="title">less</span>              <span class="title">The</span> <span class="title">dynamic</span> <span class="title">stylesheet</span> <span class="title">language</span>.
<span class="title">madewith</span>          <span class="title">Made</span> <span class="title">With</span> <span class="title">Meteor</span> <span class="title">badge</span>
<span class="title">moment</span>            <span class="title">Moment</span>.<span class="title">js</span> <span class="title">packaged</span> <span class="title">for</span> <span class="title">Meteor</span>
<span class="title">sass</span>              <span class="title">Sassy</span> <span class="title">CSS</span> <span class="title">pre</span>-<span class="title">processor</span>.
<span class="title">showdown</span>          <span class="title">Markdown</span>-<span class="title">to</span>-<span class="title">HTML</span> <span class="title">processor</span>
<span class="title">spiderable</span>        <span class="title">Makes</span> <span class="title">the</span> <span class="title">application</span> <span class="title">crawlable</span> <span class="title">to</span> <span class="title">web</span> <span class="title">spiders</span>.
<span class="title">stylus</span>            <span class="title">Expressive</span>, <span class="title">dynamic</span>, <span class="title">robust</span> <span class="title">CSS</span>.
<span class="title">underscore</span>        <span class="title">Collection</span> <span class="title">of</span> <span class="title">small</span> <span class="title">helper</span> <span class="title">functions</span> <span class="params">(map, each, bind, ...)</span>
</code></pre>
<p><code>mrt remote moment</code>라고 실행하면 moment 패키지가 삭제된다. mrt 명령 사용방법은 <code>mrt help</code>를 실행하면 볼 수 있다. 세부 명령어 사용법은 <code>mrt help [command]</code>라고 실행하면 볼 수 있다.</p>

<p>지금까지 mrt 명령으로 앱을 관리하는 방법을 살펴보았다. 다음에는 스마트 패키지를 만드는 법을 살펴보겠다. 기대하시라.</p>
]]>
</content></entry><entry><title><![CDATA[ Meteor 한글 문서 ]]></title><link href="http://dogfeet.github.com/articles/2012/meteor-docs-ko.html" /><updated>2012-09-15T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/meteor-docs-ko.html</id><content type="html"><![CDATA[
<p><a href="https://twitter.com/lethee">@lethee</a>, <a href="https://twitter.com/lnyarl">@lnyarl</a>와 함께 Meteor 문서를 번역했습니다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/meteor/nodejs-framework-comparison.png" alt=""></p>

<h2>Meteor</h2>

<p>이번 프로젝트에는 <a href="https://twitter.com/pismute">@pismute</a>, <a href="https://twitter.com/lethee">@lethee</a>, <a href="https://twitter.com/lnyarl">@lnyarl</a> 셋이서 작업했습니다. Meteor 문서는 Meteor 앱으로 구현돼 있습니다. Meteor Template을 이용해서 문서를 만들었습니다. 번역하는 중간에 버전이 계속 올라가서 공개가 늦어졌습니다만, 어쨌든 벌려 놓으니 끝나는군요:)</p>

<p>Meteor 한글 문서는 <a href="http://docs-ko.meteor.com">http://docs-ko.meteor.com</a> 에 있습니다. 문서는 길지 않아서 금방 읽을 수 있지만, 구조가 독특하기에 익숙해지는 데 생각보다 시간이 들어요.</p>

<p><a href="http://ocdevel.com/blog/nodejs-frameworks-comparison">Top Node.js Frameworks 2012</a>을 읽어보면 언제 Meteor를 선택하는 것이 좋은지 알 수 있습니다.</p>

<p>node의 장점은 IO와 JavaScript라고 생각해서 CRUD 앱을 만드는 것은 적절치 않다고 생각해 왔습니다. JavaScript는 코드가 길어지면 정말 잘 짜야 하는 단점이 있는 것 같습니다. 배움이 부족해서겠지만, 쉽게 복잡해집니다.</p>

<p>그래서 CRUD에는 Rails나 Django 같은 프레임워크가 더 낫다고 생각해왔습니다. 그 험난한 Java + Spring보다도 어렵다고 생각해 왔습니다. 그런데 Meteor는 제한적으로나마 가능성을 보여줍니다. 앞으로도 기대됩니다.</p>

<p>Meteor 한글 문서 저장소는 <a href="https://github.com/dogfeet/meteor">https://github.com/dogfeet/meteor</a> 입니다. 오역이나 오탈자를 발견하면 신고해주세요.</p>
]]>
</content></entry><entry><title><![CDATA[ Understanding CSS3 2D Transforms ]]></title><link href="http://dogfeet.github.com/articles/2012/understanding-css3-2d-transforms.html" /><updated>2012-09-09T15:00:00.000Z</updated><id>http://dogfeet.github.com/articles/2012/understanding-css3-2d-transforms.html</id><content type="html"><![CDATA[
<p>이 글은 Klemen Slavič의 <a href="http://msdn.microsoft.com/en-us/magazine/gg709742.aspx">Understanding CSS3 2D Transforms</a>를 번역한 글이다. 최근 CSS의 transform으로 DOM 객체를 이동시키는데 좌표이동이 헷갈려 정리하고 지나가려 한다. 2011년 3월의 글이라 현재는 다 구현되었는데 글에서는 구현 중으로 표현할 수도 있으니 혼란스러워하지 말길 바란다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/css-transform/optimus-prime.jpeg" alt="optimus-prime"></p>

<h2>변환(Transformation)이 뭐냐?</h2>

<p>수학적으로 엄격하고 광의로의 변환은 한 집합의 요소 X를 다른 집합의 Y로 대응시키는 연산이다. 기하학에서는 한 공간상의 객체들을 다른 기하 공간상에 1:1로 옮기는 수학적 방법이라고 한다.</p>

<p>더 쉽게 말하자면, 우리가 물건을 하나 집어서 이리저리 변형을 시킬 수 있다는 뜻이다. &lsquo;이리저리 변형'이라는 것은 순서가 있는 변환 연산 리스트이다. 변환 연산의 종류는 이동, 확대, 반사, 회전, 기울임이 있다. 이 정도면 쉽게 설명했다. 오케이?</p>

<p>객체를 다루는 영역으로 들어가기 전에 우린 이런 변환들이 정확히 어떻게 동작하는지 알아야 한다. 말했듯이 변환 그룹은 순서 있는 변환 연산의 집합이다. 따라서 변환 연산의 순서에 따라 결과가 달라진다. 변환은 객체의 현재 위치 등 온갖 기하학적 요소를 고려해서 적용되기 때문이다.</p>

<h3>변환의 원점(Origin) 이해하기</h3>

<p>아래의 간단한 예제를 보자. 2x2 크기의 사각형의 중심이 원점(0, 0)에 있다.</p>

<p><img src="/articles/2012/css-transform/gg709742.01-origin(en-us,MSDN.10).png" alt="origin"></p>

<p>이 객체를 2 만큼 확대한 후 1 만큼 오른쪽으로 이동하고 나서 0.5만큼 위로 이동시키면 아래와 같은 결과가 나타난다.</p>

<p><img src="/articles/2012/css-transform/gg709742.02-scale-then-move(en-us,MSDN.10).png" alt="scale-then-move"></p>

<p>정확히 원하던 결과가 나왔다. 사각형은 이제 4x4 크기의 중심이 (1, 0.5)로 옮겨졌다. 하지만 만약 우리가 이 순서를 반대로 적용했다면? 아래에 그 결과가 있다.</p>

<p><img src="/articles/2012/css-transform/gg709742.03-move-then-scale(en-us,MSDN.10).png" alt="move-then-scale"></p>

<p>결과는 올바르다. 하지만 딱 보기에 좀 이상하게 보인다. 사각형의 중심이 이전 예제와는 다르게 (1, 0.5)가 아니라 (2, 1)이다. 변환 결과의 위치가 바뀐 이유는 변환이 변환 원점에 의존적이고 변환 원점이 위치를 포함한 객체의 모든 특성에 적용되기 때문이다. 만약 객체에 변환 원점과 관련이 있는 오프셋이 있다면 이 위치는 다른 특성들을 따라 같이 변환된다. 이 경우에는 객체의 x, y가 2만큼 늘어났다. (즉, 늘어난 뒤 이동한 게 아니라 이동 뒤에 늘어났기 때문이다.)</p>

<p>이게 어려워도 혼란스러워 하지 마라. 변환 원점의 기본값이 (0, 0)이긴 하지만 명시적으로 이 원점을 바꿀 수 있다. 다음 예제는 사각형을 (2, 2)를 기준으로 시계방향 30도 회전한 것이다.</p>

<p><img src="/articles/2012/css-transform/gg709742.04-rotate-without-origin(en-us,MSDN.10).png" alt="rotate-without-origin"></p>

<p>객체가 원점에서부터 떨어져 있기 때문에 사각형 전체가 원점을 중심으로 회전했다. 만약 객체가 왼쪽 위를 중심으로 돌아가게 하고 싶다면 변환 원점을 객체의 왼쪽 위로 옮긴 다음에 회전해야 한다.</p>

<p>여기서 짚고 넘어가야 할 기술적 이슈가 있다. 단일 변환 그룹은 단일 변환 원점에만 적용할 수 있다. 이것은 또 다른 원점을 지정하더라도 다른 개별 변환이 진행되는 동안에는 원점이 변하지 않는다는 의미다. 이를 우회하는 방법은 객체를 원점 주위에 위치시키고 변환을 적용한 후에 객체를 제자리에 옮기면 된다.</p>

<h3>화면 공간 vs 유클리드 공간</h3>

<p>모니터 화면을 고전적인 유클리드 공간이라 생각하면 변환에 대해 더 정확히 이해할 수 있다. 실제 컴퓨터 그래픽(웹페이지도 포함해서)에서는 좌표시스템을 변경해서 사용한다.</p>

<p>편의상 모든 윈도우에서 원점은 왼쪽 위에 있고 y축이 아래쪽이다. 그래서 화면의 모든 픽셀은 양의 정수로 표현할 수 있다.</p>

<h2>TILT!</h2>

<p>변환의 수학적인 개념을 숙지한 채로 이것들을 CSS로 어떻게 구현하는지 알아보자.</p>

<p>시작하기 전에 주의할 것이 있다. 여기서 사용할 CSS의 기능들이 모든 브라우저에서 구현이 안 되어있다. 따라서 표준 CSS 프로퍼티 앞에 벤더에 종속적인 접두어를 표기 할 것이다. '흥미로운 것들&rsquo; 섹션을 보면 크로스-브라우저 CSS 변환을 위한 중복 표기를 우회하는 방법을 설명해놨다.</p>

<h3>변환 원점(Transformation origin)</h3>

<p>변환 원점을 지정하는 건 trasform-origin이라는 CSS 프로퍼티를 이용한다.</p>

<ol>
<li>-moz-transform-origin: 50% 50%;</li>
<li>-webkit-transform-origin: 50% 50%;</li>
<li>-ms-transform-origin: 50% 50%;</li>
<li>-o-transform-origin: 50% 50%;</li>
<li>transform-origin: 50% 50%;</li>
</ol>

<p>변환 원점의 기본값은 바운딩 박스(bounding box)의 가운데이고 바운딩 박스의 왼쪽 위 모서리 좌표가 (0,0)이다.</p>

<h3>변환 그룹(Transformation groups)</h3>

<p>CSS의 transform 프로퍼티에 적용할 변환 연산의 리스트를 순서대로 적어주는 것만으로 변환 그룹을 만들 수 있다.</p>

<ol>
<li>-moz-transform: &lt;trans1&gt; &lt;trans2&gt; &hellip;;</li>
<li>-webkit-transform: &lt;trans1&gt; &lt;trans2&gt; &hellip;;</li>
<li>-ms-transform: &lt;trans1&gt; &lt;trans2&gt; &hellip;;</li>
<li>-o-transform: &lt;trans1&gt; &lt;trans2&gt; &hellip;;</li>
<li>transform: &lt;trans1&gt; &lt;trans2&gt; &hellip;;</li>
</ol>

<p>여기서 &lt;trans1&gt;, &lt;trans2&gt;등은 서로 다른 변환 연산들이다. 각 연산은 공백문자로 구분한다.</p>

<h3>평행이동(Translation)</h3>

<p>객체를 평행이동시키려면 translate, translateX, translateY라는 키워드를 사용한다.</p>

<ol>
<li>-moz-transform: translate(tx[, ty]) | translateX(tx) | translateY(ty);</li>
<li>-webkit-transform: translate(tx[, ty]) | translateX(tx) | translateY(ty);</li>
<li>-ms-transform: translate(tx[, ty]) | translateX(tx) | translateY(ty);</li>
<li>-o-transform: translate(tx[, ty]) | translateX(tx) | translateY(ty);</li>
<li>transform: translate(tx[, ty]) | translateX(tx) | translateY(ty);</li>
</ol>

<p>tx는 가로 방향 오프셋이고 ty는 세로 방향 오프셋이다. 아래는 이미지를 60픽셀 오른쪽, 20픽셀 아래쪽으로 움직이는 예제이다.</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl04_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/01.html" height="220" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>-moz-transform: translate(60px, 20px);</li>
<li>-webkit-transform: translate(60px, 20px);</li>
<li>-ms-transform: translate(60px, 20px);</li>
<li>-o-transform: translate(60px, 20px);</li>
<li>transform: translate(60px, 20px);</li>
</ol>

<h3>스케일링(Scaling)</h3>

<p>객체를 확대하거나 축소하려면 scale이나 scaleX, scaleY를 이용한다.</p>

<ol>
<li>-moz-transform: scale(sx[, sy]) | scaleX(sx) | scaleY(sy);</li>
<li>-webkit-transform: scale(sx[, sy]) | scaleX(sx) | scaleY(sy);</li>
<li>-ms-transform: scale(sx[, sy]) | scaleX(sx) | scaleY(sy);</li>
<li>-o-transform: scale(sx[, sy]) | scaleX(sx) | scaleY(sy);</li>
<li>transform: scale(sx[, sy]) | scaleX(sx) | scaleY(sy);</li>
</ol>

<p>스케일링은 인자로 들어온 크기만큼 객체를 확대/축소 시킨다. 각 인자는 단위가 없는 숫자이다. 만약 scale 키워드에 인자 하나만 넘긴다면, 유니폼 스케일로 작동한다. (가로 세로의 비율을 유지하면서 스케일링 된다.) 음수가 인자로 들어오면 각 축에 대칭적으로 스케일링 된다.</p>

<p>아래에 객체를 오른쪽 위를 기준으로 80% 축소하는 예제를 보자.</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl07_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/02.html" height="220" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>/* 원점을 오른쪽 위로 지정한다. */</li>
<li>-moz-transform-origin: 100% 0;</li>
<li>-webkit-transform-origin: 100% 0;</li>
<li>-ms-transform-origin: 100% 0;</li>
<li>-o-transform-origin: 100% 0;</li>
<li>transform-origin: 100% 0;</li>
<li>&nbsp;</li>
<li>/* 80% 축소 */</li>
<li>-moz-transform: scale(0.8);</li>
<li>-webkit-transform: scale(0.8);</li>
<li>-ms-transform: scale(0.8);</li>
<li>-o-transform: scale(0.8);</li>
<li>transform: scale(0.8);</li>
</ol>

<p>x축을 기준으로 이미지를 반전시키려면 scaleY에 음수를 넘긴다. </p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl09_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/03.html" height="220" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>/* 요소의 중간을 원점으로 잡기(기본값) */</li>
<li>-moz-transform-origin: 50% 50%;</li>
<li>-webkit-transform-origin: 50% 50%;</li>
<li>-ms-transform-origin: 50% 50%;</li>
<li>-o-transform-origin: 50% 50%;</li>
<li>transform-origin: 50% 50%;</li>
<li>&nbsp;</li>
<li>/* 이미지의 가운데를 중심으로 가로로 뒤집기 */</li>
<li>-moz-transform: scaleY(-1);</li>
<li>-webkit-transform: scaleY(-1);</li>
<li>-ms-transform: scaleY(-1);</li>
<li>-o-transform: scaleY(-1);</li>
<li>transform: scaleY(-1);</li>
</ol>

<h3>회전(Rotation)</h3>

<p>객체를 회전시킬 때에는 rotate를 사용한다.</p>

<ol>
<li>-moz-transform: rotate(&lt;angle&gt;);</li>
<li>-webkit-transform: rotate(&lt;angle&gt;);</li>
<li>-ms-transform: rotate(&lt;angle&gt;);</li>
<li>-o-transform: rotate(&lt;angle&gt;);</li>
<li>transform: rotate(&lt;angle&gt;);</li>
</ol>

<p>&lt;angle&gt;은 객체를 변환 원점을 기준으로 얼마나 회전시킬지를 결정한다. 단위를 적어줘야 한다(deg, rad, grad 중에 하나) 양수는 시계방향 회전을 의미한다. 아래 예제는 객체를 오른쪽 아래 모서리를 기준으로 회전시키는 것이다.</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl12_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/04.html" height="220" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>/* 오른쪽 아래를 원점으로 잡기 */</li>
<li>-moz-transform-origin: 100% 100%;</li>
<li>-webkit-transform-origin: 100% 100%;</li>
<li>-ms-transform-origin: 100% 100%;</li>
<li>-o-transform-origin: 100% 100%;</li>
<li>transform-origin: 100% 100%;</li>
<li>&nbsp;</li>
<li>/* 시계방향으로 30도 회전 */</li>
<li>-moz-transform: rotate(30deg);</li>
<li>-webkit-transform: rotate(30deg);</li>
<li>-ms-transform: rotate(30deg);</li>
<li>-o-transform: rotate(30deg);</li>
<li>transform: rotate(30deg);</li>
</ol>

<h3>기울이기(Skewing)</h3>

<p>객체를 기울이려면 skew나 skewX, skewY를 사용한다.</p>

<ol>
<li>-moz-transform: skew(&lt;angleX&gt;[, &lt;angleY&gt;]) | skewX(&lt;angleX&gt;) | skewY(&lt;angleY&gt;);</li>
<li>-webkit-transform: skew(&lt;angleX&gt;[, &lt;angleY&gt;]) | skewX(&lt;angleX&gt;) | skewY(&lt;angleY&gt;);</li>
<li>-ms-transform: skew(&lt;angleX&gt;[, &lt;angleY&gt;]) | skewX(&lt;angleX&gt;) | skewY(&lt;angleY&gt;);</li>
<li>-o-transform: skew(&lt;angleX&gt;[, &lt;angleY&gt;]) | skewX(&lt;angleX&gt;) | skewY(&lt;angleY&gt;);</li>
<li>transform: skew(&lt;angleX&gt;[, &lt;angleY&gt;]) | skewX(&lt;angleX&gt;) | skewY(&lt;angleY&gt;);</li>
</ol>

<p>기울이기는 축의 방향만 바꾸는 거라서 변환 원점과는 관계가 없다. 각도의 단위는 deg, rad, grad 중에 하나를 사용한다. 회전 연산에서 각도가 양수이면 시계 방향으로 회전하지만 여기서는 반대로 동작한다. 그리고 논리적으로 추측해 봤을 때 skewX와 skewY는 각각 x와 y축 자체에 영향을 줄 것으로 생각할 수 있지만 사실 그건 객체가 기울어질 방향을 의미한다.</p>

<p>예제를 보자</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl15_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/05.html" height="220" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>/* 원점을 왼쪽 위 모서리로 옮김 */</li>
<li>-moz-transform-origin: 0 0;</li>
<li>-webkit-transform-origin: 0 0;</li>
<li>-ms-transform-origin: 0 0;</li>
<li>-o-transform-origin: 0 0;</li>
<li> transform-origin: 0 0;</li>
<li>&nbsp;</li>
<li>/* 객체를 가로축을 기준 시계방향으로 20도 기울임 */</li>
<li>-moz-transform: skewX(-20deg);</li>
<li>-webkit-transform: skewX(-20deg);</li>
<li>-ms-transform: skewX(-20deg);</li>
<li>-o-transform: skewX(-20deg);</li>
<li>transform: skewX(-20deg);</li>
</ol>

<p>변환이 어떻게 일어나는지 이 예제로 확실히 알 수 있다. 만약 skewX에 음수의 인자를 넘긴다면 객체는 오른쪽으로 기울진다. 수평 방향 기울이기도 똑같다. 하지만 여기선 양수가 시계방향을 의미한다.</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl17_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/06.html" height="220" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>/* 원점을 왼쪽 위 모서리로 옮김 */</li>
<li>-moz-transform-origin: 0 0;</li>
<li>-webkit-transform-origin: 0 0;</li>
<li>-ms-transform-origin: 0 0;</li>
<li>-o-transform-origin: 0 0;</li>
<li>transform-origin: 0 0;</li>
<li>&nbsp;</li>
<li>/* 객체를 세로축 기준, 반시계방향으로 20도 기울임 */</li>
<li>-moz-transform: skewY(-20deg);</li>
<li>-webkit-transform: skewY(-20deg);</li>
<li>-ms-transform: skewY(-20deg);</li>
<li>-o-transform: skewY(-20deg);</li>
<li>transform: skewY(-20deg);</li>
</ol>

<p>아직도 어떤 방향이 어떤 것인지 모르겠다면 우선 해보는 게 더 나을 것이다.</p>

<h2>바이바이 수평, 우린 널 기억할 거야.</h2>

<p>우리는 각 변환을 마스터했다. 이제는 원하는 효과를 내기 위해서 변환 그룹을 배워보자.</p>

<p>일반적으로 CSS 변환은 버튼에 마우스를 올리면 비틀고, 확대해서 사용자가 그들을 클릭하도록 하는 데에 사용된다. 이 효과는 회전과 스케일링을 이용하면 간단히 구현할 수 있다. 한번 만들어보자.</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl19_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/07.html" onload="setFrameHeight(this);" height="100%" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>button {</li>
<li>  padding: 1em 2em;</li>
<li>}</li>
<li>&nbsp;</li>
<li>button:hover {</li>
<li>-moz-transform: rotate(3deg) scale(1.05);</li>
<li>-webkit-transform: rotate(3deg) scale(1.05);</li>
<li>-ms-transform: rotate(3deg) scale(1.05);</li>
<li>-o-transform: rotate(3deg) scale(1.05);</li>
<li>transform: rotate(3deg) scale(1.05);</li>
<li>}</li>
</ol>

<p>묘하게 회전하면서 확대되는 효과를 만들어서 버튼이 사용자에게 튀어 오르는 효과를 만들어 클릭을 유도했다.</p>

<p>안에 있는 요소의 변환 그룹과 함께 변환할 수도 있다. 아래는 버튼을 다른 요소로 감싸서 버튼과 버튼을 감싼 요소를 서로 다른 방향으로 회전시킨 예제이다.</p>

<iframe id="ctl00_MTContentSelector1_mainContentContainer_ctl21_iframeinclude" src="http://www.microsoft.com/feeds/ScriptJunkie/articlesamples/gg709742/08.html" onload="setFrameHeight(this);" height="100%" width="550" frameborder="0" scrolling="no" marginwidth="0" marginheight="0"></iframe>

<ol>
<li>.wrapper {</li>
<li>  margin: 5px;</li>
<li>  padding: 5px;</li>
<li>  background: red;</li>
<li>}</li>
<li>&nbsp;</li>
<li>.wrapper:hover {</li>
<li>-moz-transform: rotate(-3deg) scale(1.05);</li>
<li>-webkit-transform: rotate(-3deg) scale(1.05);</li>
<li>-ms-transform: rotate(-3deg) scale(1.05);</li>
<li>-o-transform: rotate(-3deg) scale(1.05);</li>
<li>transform: rotate(-3deg) scale(1.05);</li>
<li>}</li>
<li>&nbsp;</li>
<li>.wrapper button {</li>
<li>  padding: 5px 10px;</li>
<li>}</li>
<li>&nbsp;</li>
<li>.wrapper button:hover {</li>
<li>-moz-transform: rotate(6deg) scale(1.05);</li>
<li>-webkit-transform: rotate(6deg) scale(1.05);</li>
<li>-ms-transform: rotate(6deg) scale(1.05);</li>
<li>-o-transform: rotate(6deg) scale(1.05);</li>
<li>transform: rotate(6deg) scale(1.05);</li>
<li>}</li>
</ol>

<p>이런 경우엔 마우스가 버튼을 감싼 요소에 올라갔을 때 감싼 요소가 가진 모든 요소가 변환된다. 그 뒤에 마우스가 버튼 위에 올라갔을 땐 버튼에 적용된 변환 그룹에 따라 변환된다. 이 둘은 독립적이지만 계층적으로 적용된다. 즉 부모 요소의 변환은 모든 자식 요소에 적용된다.</p>

<h3>2D 변환 vs 3D 변환</h3>

<p>여기서 지금까지 배운 것으로 3D변환을 하려면 어떻게 해야 할까. 흠, 만약 단순한 정사영만 필요하다면 객체를 기울이고 이동시키는 변환만으로 가능하다. 하지만 진짜 원근법(아니면 비선형 투영)이 필요하다면 불쌍하다고 해야겠다.</p>

<p>위에서 봤듯이 기울이기는 두 축의 각도를 바꾸기만 하는데 세 번째 축이 생기면 원근법이 적용되어 공간상의 점이 한쪽 평면에 투영되었을 때, 위치가 변한다. 다시 말해, 객체가 더 멀어질수록 더 작게 보인다는 것이다. 이건 2D 변환을 이용해서는 정확하게 구현할 수 없다.</p>

<p>만약 3D 변환이 필요하다면 2가지 선택지가 있다. CSS 2D 변환과 비슷한 문법을 가진 실제 CSS 3D 변환을 하거나 WebGL을 이용하는 것이다. 그런데 두 가지 전부 제대로 지원하는 브라우저가 없고 가장 최신의 몇몇 브라우저만이 지원한다. 게다가 이건 이 글에서 다루지 않기로 했었다.</p>

<p>만약 초심자용 글을 원한다면 <a href="http://www.ticketmonster.co.kr/deal/5807965/">웹킷 블로그</a>를 보면 된다. 여기에 3D 변환의 기초 구현 예제들이 있다.</p>

<h2>그래서 이게 어디서 돌아가는데?</h2>

<p>옛날에 IE6에서 자기들만의 CSS의 필터를 처리하기 위해 DXtransform을 지원하기는 했지만, 그 당시에는 비슷한 기능이라도 구현한 브라우저는 없었기에 2D 변환은 지금 브라우저에서는 참신한 것이다. 그래도 최근에 브라우저 개발 경쟁에 불이 붙어 모든 주요 브라우저 벤더들이 자사 브라우저들의 최신 릴리즈에 2D 변환기능을 넣어가고 있고 하드웨어 가속을 이용하는 브라우저도 있다.  (역자 주: 2011년 3월 글이다.)</p>

<p>현재 다음의 브라우저들이 변환을 지원하고 있다.</p>

<style>
  .grid td {
    padding: 5px;
    border: solid #333 1px;
  }
</style>

<table class="grid">
  <thead>
    <tr style="background-color:black;color:white;">
      <th id="th204812500000">Browser</th>
      <th id="th204812500001">Since</th>
      <th id="th204812500002">Implementing</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th style="padding: 5px; border: solid #333 1px;" id="th204812500100" rowspan="2">Internet Explorer</th>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001 th204812500100">5.5</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500002 th204812500100"><ul><li>Via proprietary CSS DirectX filter:&nbsp;<a id="ctl00_MTContentSelector1_mainContentContainer_ctl24" href="http://msdn.microsoft.com/en-us/library/ms533014(VS.85,loband).aspx" onclick="javascript:Track('ctl00_MTContentSelector1_mainContentContainer_ctl00|ctl00_MTContentSelector1_mainContentContainer_ctl24',this);">Matrix Filter</a></li></ul></td>
    </tr>
    <tr>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500000 th204812500100 th204812500300 th204812500400 th204812500500 th204812500600 th204812500700">9.0</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001"><ul><li>-ms-transform</li></ul></td>
    </tr>
    <tr>
      <th style="padding: 5px; border: solid #333 1px;" id="th204812500300">Firefox (Gecko)</th>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001 th204812500300">3.5 (1.9.1)</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500002 th204812500300"><ul><li>-moz-transform</li><li>transform (<em>newer versions</em>)</li></ul></td>
    </tr>
    <tr>
      <th style="padding: 5px; border: solid #333 1px;" id="th204812500400">Opera</th>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001 th204812500400">10.5</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500002 th204812500400"><ul><li>-o-transform</li><li>transform (<em>newer versions</em>)</li></ul></td>
    </tr>
    <tr>
      <th style="padding: 5px; border: solid #333 1px;" id="th204812500500">Safari (WebKit)</th>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001 th204812500500">3.1 (525)</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500002 th204812500500"><ul><li>-webkit-transform</li><li>transform (<em>newer versions</em>)</li></ul></td>
    </tr>
    <tr>
      <th style="padding: 5px; border: solid #333 1px;" id="th204812500600">Chrome</th>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001 th204812500600">1.0</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500002 th204812500600"><ul><li>-webkit-transform (using WebKit engine)</li><li>transform (<em>newer versions</em>)</li></ul></td>
    </tr>
    <tr>
      <th style="padding: 5px; border: solid #333 1px;" id="th204812500700">iOS</th>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500001 th204812500700">all versions</td>
      <td style="padding: 5px; border: solid #333 1px;" headers="th204812500002 th204812500700">-webkit-transform (using WebKit engine)</td>
    </tr>
  </tbody>
</table>

<h2>흥미로운 것들</h2>

<h3>성능</h3>

<p>위의 브라우저 지원 목록을 보고 곧바로 자리에 앉아 막 객체들을 변환해서 홈페이지를 이리저리 돌아다니도록 할 수도 있다. 기술적으로 분명 가능하다. 하지만 CSS 변환을 이용한 크로스-브라우저 지원은 비용이 많이 들어가고 성능상의 문제도 있다.</p>

<p>2D 하드웨어 가속을 지원하지 않는 브라우저는 모든 변환을 CPU로 해결한다. 구린 렌더링 엔진을 가진 브라우저의 예로 Firefox pre-4.0이나 Internet Explorer pre-9 정도가 있다. 가속하든 안 하든 올바르게 변환되지만, IE 같은 경우는 성능이 구리다. 많은 변환 연산을 하는 웹페이지는 성능저하를 일으킬 것이다. IE는 z-index 문제도 일어날 수 있다.  </p>

<h3>렌더링</h3>

<p>여러 플랫폼에서 돌아가는 크롬에 관해 주의해야 할 또 다른 점은 회전/기울어진 이미지(다른 DOM 요소는 해당하지 않는다.)의 가장자리가 윈도우즈에서는 안티엘리어싱이 적용되지 않고 톱니 모양으로 자글자글한다는 것이다. 이 문제는 리눅스에서도 보인다. 리눅스에서 모든 회전된 문자열은 안티엘리어싱이 적용되지 않고, 글자들 일부분은 끊어져 깨져 보이는 데다가 대부분의 작은 글자는 변환 연산을 거치면 읽을 수도 없다.</p>

<h3>애들&hellip;아니 유저를 생각해!</h3>

<p>아직도 CSS 변환을 만지작 거리고 있다면(그리고 그래야만 한다면!) 2D CSS 변환을 지원하지 않는 브라우저를 이용하고 있는 사용자들을 위해 <a href="http://modernizr.com/">Modernizr</a>를 이용하면 그런 변환을 대체할 수 있는 표현이나 우아하게 다운그레이드된 화면을 보여줄 수 있다. 만약 그게 필요하다면 브라우저의 지원 여부를 알아내서 순수 CSS로 대체 화면을 만들어내거나 요소를 숨기거나 할 수 있다. 예제로 이 글에 있는 iframe은 대체 할 화면을 보여줄 수 있으며 사용자에게 CSS 변환을 지원하지 않는 버전을 사용하고 있다고 알려준다.</p>

<p>또, 만약 여러 버전의 CSS 어트리뷰트를 작성하기가 싫다면 <a href="http://www.useragentman.com/blog/2010/03/09/cross-browser-css-transforms-even-in-ie/">cssSandpaper</a>를 사용해보는 것도 좋다. cssSandpaper는 표준 문법으로 모든 벤더들에서 작동하는 CSS 어트리뷰트를 만들어준다. 그리고 W3C 문법을 DirectX필터로 바꿔서 Explorer5.5에서도 돌아갈 수 있도록 만들어준다.</p>

<h2>가랏!</h2>

<p>그게 2D CSS 변환의 요지이다. 우리는 텍스트, 이미지에 무려 비디오까지 기울이고 자르고 늘이고 줄일 수 있다. 우리는 우리가 과거에 비트맵에서 했던 모든 것들을 여기서 할 수 있다.
이제 가서 슬슬 일해!</p>
]]>
</content></entry></feed>