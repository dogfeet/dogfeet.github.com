<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-04-30T05:54:15Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ Git: git-svn ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-svn.html" />
    <updated>2012-04-28T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-svn.html</id>
    <content type="html">
<![CDATA[
<p>Progit 8장에 설명된 'git-svn'에서 쓸만한 명령어를 정리했다. svn server + git client 같이 오묘한 조합은 사용하고 싶지 않았는데, 너무 불편해서 못살겠다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-svn/et.jpg" alt="et" title="" /></p>

<p>GitHub는 <a href="http://hg-git.github.com/">git server + hg client</a>, <a href="https://github.com/blog/966-improved-subversion-client-support">git server + svn client</a> 조합도 만들었는데 쓰는 사람이 있을까?</p>

<h2>주요 명령어 정리</h2>

<p>SVN 처럼 로그를 보거나 등등의 기능이 많지만, 어차피 안 쓸 것 같아서 정리하지 않는다. SVN을 Git으로 마이그레이션할 때 필요한 명령어도 정리하지 않았다.</p>

<h3>clone:</h3>

<pre><code>git svn clone url -s
</code></pre>

<p>-s는 표준레이아웃인 <code>trunk, branches, tags</code>를 사용한다는 의미다. 표준레이아웃을 사용하지 않으면 <code>-T trunk -b branches -t tags</code>라고 직접 알려주면 된다.</p>

<p>trunk, branches, tags는 모두 Git 브랜치로 만들어진다. trunk와 branches는 같은 이름으로 만들어지지만, tags는 앞에 <code>tags/</code>라고 붙는다.</p>

<p>progit 책에 나오는 <code><a href='http://progit-example.googlecode.com/svn/'>http://progit-example.googlecode.com/svn/</a></code>을 적용해보면 다음과 같이 만들어진다:</p>

<pre><code>└─▪ git br -av
* master                        5925d95 Support HP C++ on Tru64.
  remotes/my-calc-branch        a52ad75 created a branch
  remotes/tags/2.0.2            fd8e73e Tag release 2.0.2.
  remotes/tags/release-2.0.1    60feb5c Tag the 2.0.1 release.
  remotes/tags/release-2.0.2    85bac46 Set version to 2.0.2 in release branch.
  remotes/tags/release-2.0.2rc1 168051e Update version number in 2.0.2rc1 release branch.
  remotes/trunk                 5925d95 Support HP C++ on Tru64
</code></pre>

<p>SVN 브랜치는 당연히 Git 브랜치로 만들어지지만 SVN의 tag도 Git의 브랜치로 만들어진다.</p>

<h3>fetch:</h3>

<p><code>git fetch</code>에 대응되는 명령어:</p>

<pre><code>git svn fetch
</code></pre>

<p>trunk가 master로 자동으로 Fast-Forward Merge 됐으면 좋겠다. </p>

<p><code>git-svn</code> 프로젝트이면 trunk를 master로 Fast-Forware Merge하도록 <a href="https://github.com/pismute/git-tles">git-ff</a>를 수정했다. 이 브랜치만 Merge한다. svn에서 브랜치를 쓰고 싶지 않다.</p>

<h3>push:</h3>

<p><code>git push</code>에 대응하는 명령어:</p>

<pre><code>git svn dcommit
</code></pre>

<p>svn은 히스토리가 평평하니까 이것만 주의하면 된다.</p>

<h3>annotate:</h3>

<p>어떤 놈이 잘못 고쳤는지 찾아보는 명령어:</p>

<pre><code>git svn blame [FILE] 
</code></pre>

<h3>.gitignore:</h3>

<p><code>.gitignore</code>를 만들어 넣으면 svn 서버에 Push된다. 다른 사람 몰래 혼자 쓰고 싶으면 <code>.git/info/exclude</code>에 만들면된다. <code>.gitignore</code>랑 똑같고 해당 저장소에만 적용되며 Push할 수 없다:</p>

<pre><code>git svn show-ignore &gt; .git/info/exclude
</code></pre>

<h2>Merge</h2>

<p>SVN의 히스토리는 항상 일직선이기 때문에 SVN에 Push할 브랜치는 항상 Fast-Forward로 Merge해야 한다. 그렇지 않으면 알아서 펴주기 때문에 히스토리 모양이 원하는 모양이랑 다를 수 있다.</p>

<h2>브랜치</h2>

<p>SVN의 히스토리는 항상 평평하다. 브랜치 별로 히스토리가 다르게 관리하는 것이 아니라 한 히스토리에서 trunk. branches, tags를 모두 관리한다. 이점을 꼭 기억해야 한다.</p>

<p>SVN 브랜치는 항상 Long-Running 브랜치로 사용한다. Topic 브랜치는 git-svn이 아니라 그냥 git을 사용할 때와 다를 바 없다. 단지 SVN 브랜치를 Tracking하는 Long-Running 브랜치에 Merge할 때 쫙 펴주기만 하면 된다.</p>

<p>문제는 SVN 브랜치를 Git에서 서로 Merge하는 데 있다. 그냥 Fetch해서 평평한 히스토리를 유지하면서 Push하는 것이 아니라 SVN 브랜치를 Git에서 Merge하면 어떨까? 이제 이걸 알아보자.</p>

<h3>일단 SVN 저장소를 하나 준비하고</h3>

<p>일단 SVN 저장소를 하나 준비하고:</p>

<p><img src="/articles/2012/git-svn/svn-repository.png" alt="svn-repository.png" title="" /></p>

<p>Git으로 클론한다. 클론하고 나서 <code>git branch -av</code>를 하면 다음과 같다:</p>

<pre><code>* master             92a713a from trunk
  remotes/dogfeet    e5334ef Add from dogfeet
  remotes/tags/1.0.0 2ec86a0 tag 1.0.0
  remotes/trunk      92a713a from trunk
</code></pre>

<p>master는 remotes/trunk를 트랙킹하고 SVN 브랜치인 'dogfeet'과 SVN 태그인 '1.0.0'이 Git에서는 모두 브랜치로 만들어진다. 그리고 원래 리모트 트래킹 브랜치는 <code>remotes/origin/master</code> 같은 패턴으로 이름 지어지는데 리모트 없이 <code>remotes/trunk</code> 형식으로 이름 지어진다.</p>

<p>SVN 히스토리:</p>

<p><img src="/articles/2012/git-svn/history.png" alt="history.png" title="" /></p>

<p>master 히스토리:</p>

<pre><code>* 92a713a - (HEAD, trunk, master) from trunk (2 hours ago)
* 12bf5f1 - Initial structure. (2 hours ago)
</code></pre>

<p>dogfeet 히스토리:</p>

<pre><code>* e5334ef - (dogfeet) Add from dogfeet (2 hours ago)
* 86cdd49 - branch dogfeet (2 hours ago)
* 92a713a - (HEAD, trunk, master) from trunk (2 hours ago)
* 12bf5f1 - Initial structure. (2 hours ago)
</code></pre>

<h3>이제 Git에서 커밋을 하나씩하고</h3>

<p>master에 커밋을 하나 하고:</p>

<pre><code>* 4c549fb - (master) Add from_git_master (4 minutes ago)
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>dogfeet에도 커밋을 하나 하고:</p>

<pre><code>* 904a4c0 - (HEAD, local_dogfeet) Add from_git_dogfeet (70 seconds ago)
* e5334ef - (dogfeet) Add from dogfeet (23 hours ago)
* 86cdd49 - branch dogfeet (23 hours ago)
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>dogfeet을 master에 Merge한다:</p>

<pre><code>*   8365b59 - (HEAD, master) Merge branch 'local_dogfeet' (2 seconds ago)
|\  
| * 904a4c0 - (local_dogfeet) Add from_git_dogfeet (2 minutes ago)
| * e5334ef - (dogfeet) Add from dogfeet (23 hours ago)
| * 86cdd49 - branch dogfeet (23 hours ago)
* | 4c549fb - Add from_git_master (5 minutes ago)
|/  
* 92a713a - (trunk) from trunk (23 hours ago)
* 12bf5f1 - Initial structure. (23 hours ago)
</code></pre>

<p>이걸 SVN에 Push하면 SVN 히스토리는 다음과 같아진다:</p>

<p><img src="/articles/2012/git-svn/history-after-merge.png" alt="history-after-merge.png" title="" /></p>

<p>그러니까 이렇게 Merge 커밋이 있는 히스토리를 SVN에 Push하면 히스토리가 순서가 보장되지 않는다. 히스토리 순서를 보장하려면 Fast-Forward Merge로 펴놓고 Push해야 한다.</p>

<p>그렇다고 Rebase를 해서 Fast-Forward Merge를 하면 같은 커밋이 두 번 들어가게 될 수도 있으니 절대로 SVN에 올라간 커밋은 Rebase하면 안된다. 그러니까 SVN에 Push한 커밋을 Rebase할 바엔 그냥 Merge Commit을 남기는 게 낫다고 볼 수 있다.</p>

<h3>브랜치 결론.</h3>

<p>SVN 세상에서는 히스트리가 항상 평평하고 브랜치도 디렉토리로 관리한다. 그러니까 이점을 명확히 이해하고 있어야 혼란스럽지 않다.</p>

<p>SVN의 브랜치를 Git에서 Merge하는 것은 사실 조금 위험하다. Merge Commit 있는 Git 히스토리를 SVN에 Push하면 커밋 순서는 보장되지 않을 것이고 그렇다고 SVN에 이미 커밋된 것을 Rebase할 수도 없다. 하지만 Topic 브랜치를 만들어 작업하고 히스토리를 평평하게 펴서 SVN에 Push하면 쓸만하다.</p>

<p>그리고 SVN 히스토리가 망가질 수 있다는 단점은 지나친 기우일 수 있다. 오픈 소스 프로젝트라면 히스토리를 더럽히는 것이 당연히 부끄럽겠지만, 원래 커밋 메시지도 없는 히스토리라면 그냥 커밋 몇 개 더 만들어도 괜찮지 않을까? 취미로 하는 프로젝트를 빼고 난 아직 한번도 히스토리에 정성을 쏳는(이라고 쓰고 커밋 메시지를 잘 남기는 이라고 읽는다) 프로젝트를 해보지 못했다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Ubuntu ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/ubuntu-desktop.html" />
    <updated>2012-04-27T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/ubuntu-desktop.html</id>
    <content type="html">
<![CDATA[
<p>Ubuntu 12.04 릴리즈를 기념해서 Ubuntu Desktop 설치 노트를 만들었다. 이번 프로젝트에서는 Linux가 주 플랫폼인데 Linux가 필요해서 Ubuntu Desktop을 설치했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/ubuntu-desktop/ubuntu.png" alt="ubuntu" title="" /></p>

<p>만날 X 없이 Server만 깔아서 쓰다가 Desktop을 설치했는데 너무 편하다. 앞으로는 Ubuntu Desktop을 많이 쓸 것 같다.</p>

<h2>할 일</h2>

<ul>
<li>/tmp를 tmpfs로 만들기</li>
</ul>

<p>noexec로 하면 <code>/tmp</code>에 압축을 풀고 설치하는 인스톨러들이(특히 오라클 제품들...) 실패한다. 보안을 위해 noexec로 설명하는 글들이 많은데, 서버가 아니니 exec로 하도록 하자.</p>

<pre><code>#/etc/fstab
tmpfs            /tmp           tmpfs   defaults,exec,nosuid 0       0
</code></pre>

<ul>
<li>apt source를 ftp.daum.net로 변경. - System Settings/Software Sources</li>
<li>virtual kernel 설치.</li>
<li>dselect 설치 - <code>sudo apt-get install dselect</code></li>
<li>vmware tools 설치 - <code>sudo apt-get install open-vm-dkms</code></li>
<li>나눔폰트 설치 - <code>sudo apt-get install ttf-nanum ttf-nanum-coding ttf-nanum-extra</code></li>
<li>한글설정 - System Settings/Language Support</li>
<li>폰트, 폰트 크기 변경 - <code>sudo apt-get install gnome-tweak-tool</code></li>
<li>git 설치 - git</li>
<li>7zip 설치 - p7zip, p7zip-full</li>
<li>nvm, node를 위해 - curl, libss-dev</li>
<li>vim - default는 vim-tiny</li>
<li>가끔 필요 - jekyll</li>
</ul>

<p>이걸 다 더하면:</p>

<pre><code>sudo apt-get install dselect open-vm-dkms ttf-nanum ttf-nanum-coding ttf-nanum-extra gnome-tweak-tool git p7zip p7zip-full curl libss-dev vim ruby ruby1.9.1 ruby1.9.1-dev

sudo gem install jekyll
</code></pre>

<h3>chrome 설치</h3>

<p>인증서를 등록하고:</p>

<pre><code>wget -q -O - <a href='https://dl-ssl.google.com/linux/linux_signing_key.pub'>https://dl-ssl.google.com/linux/linux_signing_key.pub</a> | sudo apt-key add -
</code></pre>

<p>apt source 등록:</p>

<pre><code>sudo sh -c 'echo "deb <a href='http://dl.google.com/linux/chrome/deb/'>http://dl.google.com/linux/chrome/deb/</a> stable main" &gt;&gt; /etc/apt/sources.list.d/google.list'
</code></pre>

<p>update하고:</p>

<pre><code>sudo apt-get update
</code></pre>

<p>안정 버전을 설치한다:</p>

<pre><code>sudo apt-get install google-chrome-stable
</code></pre>

<p><a href="http://www.howopensource.com/2011/10/install-google-chrome-in-ubuntu-11-10-11-04-10-10-10-04/">원문</a></p>

<h3>sumlime text</h3>

<ul>
<li><a href="http://www.webupd8.org/2011/03/sublime-text-2-ubuntu-ppa.html">sublime text 설치</a></li>
</ul>

<h3>ubuntu one</h3>

<p>모류 5G라, home directory를 백업하기 적당해 보인다.</p>

<p>백업하지 않을 디렉토리:</p>

<pre><code>.nvm
.npm
.jenkins
.m2
.cache #chrome cache
.mozilla/firefox #firefox cache
</code></pre>

<h3>git-svn, svn</h3>

<p>12.04에서만 발생하는 에러일 수도 있지만 당분간 해결되지 않을 것 같은 느낌이다. SVN에서 https인 저장소에 접근하면 다음과 같은 에러가 발생한다.</p>

<pre><code>└─▪ git svn dcommit
Committing to <a href='https://my.svn/trunk'>https://my.svn/trunk</a> ...
RA layer request failed: OPTIONS of '<a href='https://my.svn/trunk'>https://my.svn/trunk</a>': SSL handshake failed: SSL error: Key usage violation in certificate has been detected. (<a href='https://my.svn'>https://my.svn</a>) at /usr/lib/git-core/git-svn line 577
</code></pre>

<p>뭐 이런 에러가 발생하면 다음과 같이 임시로 조치할 수 있다.:</p>

<pre><code>sudo apt-get install libneon27
cd /usr/lib
sudo mv libneon-gnutls.so.27 libneon-gnutls.so.27.old
sudo ln -s libneon.so.27.2.6 libneon-gnutls.so.27
</code></pre>

<p>임시로 이렇게 우회할 수 있지만 Ubunut가 자동으로 복구한다.</p>

<p>그냥 간단하게 스킴을 https가 아니라 http로 해주는 게 더 편하다.</p>

<h3>USB에 있는 Ubuntu를 VM에서 부팅 하고자 할 때</h3>

<p>USB에 우분트를 설치한 게 있는데 그걸 VM에서 부팅하고 싶다면 <a href="http://www.plop.at/en/bootmanager/plpbt.bin.html">Plop Boot Manager</a>로 부팅시킬 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Bash: .profile, .bash_profile, .bashrc ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/bash-profile.html" />
    <updated>2012-04-21T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/bash-profile.html</id>
    <content type="html">
<![CDATA[
<p>필요할 때마다 Google님께 물어보는 것이 '.profile, .bash_profile, .bashrc'의 차이다. 신기하게도 잘 기억나지 않아서 글로 적어본다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/bash-profile/bash-computer.png" alt="bash-computer" title="" /><br />(from <a href="http://www.gamefudge.com/Bash-the-Computer">bash the computer</a>, 이참에 computer를 한번 bash해보자)</p>

<h2>Ubuntu</h2>

<p>최근 업무에 X windows가 필요해서 백 년 만에 ubuntu Desktop을 vmware에 설치했는데, 이거 웬걸 쓸만하다. 적어도 Windows보다 편하다. 회사에서 보안프로그램만 지원해주면 업무용으로 그냥 Ubuntu Desktop를 쓰고 싶다.</p>

<p>이제 돈 받고 팔아도 되겠다. 12.04가 기대된다. 설치도, 내 취향에 맞춘 설정까지 하루밖에 안 걸린다.</p>

<h2>Login Shell vs Non-login Shell</h2>

<p>먼저 'Login Shell'과 'Non-login Shell' 을 구분해야 하는데, 로그인은 계정과 암호를 입력해서 Shell을 실행하는 것이다. ssh로 접속하거나 로컬에서 GUI에서 로그인한다는 의미다.</p>

<p>'.profile', '.bash_profile'이 Login할 때 로드되는(source) 파일이다. '.profile'은 꼭 bash가 아니더라도 로그인하면 로드되고 '.bash_profile'은 꼭 Bash로 Login할 때 로드된다.</p>

<p>그리고 'Non-login Shell'은 로그인 없이 실행하는 Shell을 말한다. ssh로 접속하고 나서 다시 bash를 실행하는 경우나. GUI 세션에서 터미널을 띄우는 것이 이해 해당한다. 'sudo bash'나 'su' 같은 것도 이에 해당한다.</p>

<p>'.bashrc'는 로그인 없이 Bash가 실행될 때 로드된다. 'sudo bash'나 'su'로 root 권한을 얻으려 bash를 실행할 때도 이 파일이 로드된다.</p>

<p>정리:</p>

<ul>
<li>'.profile' - 로그인할 때 로드된다. PATH처럼 로그인할 때 로드해야 하는데 bash와 상관없는 것들을 여기에 넣는다.</li>
<li>'.bash_profile' - 로그인할 때 로드된다. 'bash completion'이나 'nvm'같이 로그인할 때 로드해야 하는데 Bash와 관련된 것이면 여기에 넣는다. </li>
<li>'.bashrc' - 로그인하지 않고 Bash가 실행될 때마다 로드된다.</li>
</ul>

<h2>bash-it</h2>

<p>나는 Bash 프레임워크인 <a href="https://github.com/revans/bash-it">bash-it</a>을 사용하는데, 그냥 터미널에서 ssh로 접속하기만 할 때는 '.bash_profile'에만 넣어주는 걸로 충분했다. 그런데 Desktop으로 쓸려니 로그인 없이 Bash를 실행할 일이 많아서 '.bashrc'에 넣어줘야 했다:</p>

<pre><code>if [ -f "~/.bash_profile" ]; then
    . ~/.bash_profile
fi
</code></pre>

<p>그런데 'sudo bash'를 실행할 때도 bash-it이 로드돼서 root가 아닐 때만 로드되게 했다:</p>

<pre><code>if [ "$USER" != "root" ] &amp;&amp; [ -f "~/.bash_profile" ]; then
    . ~/.bash_profile
fi
</code></pre>

<p>꼭 터미널을 열고 Bash를 띄울 때만 bash-it을 사용하고 싶은데 GUI 세션에 로그인할 때도 실행되는 느낌이다. 이것도 확인해봐야 하는데,</p>

<h2>Mac</h2>

<p>사실 Mac에서 한 번도 'Login Bash'같은 컨셉에 대해 생각해본 적 없다. 그러니까 Bash를 실행할 때 로그인해 본 적 없다. Mac에 ssh로 접속한 적도 없다. 그러니까 Mac에서는 .bash_profile과 .bashrc를 구분해 사용하려고 생각한 적이 없다.</p>

<p>그래서 더 헷갈린다. Mac에서는 터미널을 열어도 '.bash_profile'이 로드된다. 'sudo bash'할 때나 그냥 'bash'를 실행시켰을 때에는 로드하지 않는 것으로 봐서 여태껏 얘기한 것에서 크게 벗어나는 것 같진 않다. 그냥 조금 다르다.</p>

<p>이를테면 '터미널을 연다는 것은 로그인하면서 Bash를 실행시키는 것'이라고 보면 된다. 터미널을 열 때에도 '.bash_profile'이 로드되지만, bash를 그냥 실행시킬 때는 '.bash_profile'은 로드하지 않는다.</p>

<h2>.bash_login, .bash_logout, .bash_complete ...</h2>

<p>그 외 파일이 많은데 별로 중요하지도 않고 필요하다고 생각해본 적 없어서 정리하지 않았다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ J언어 배우기 - 제 2장: 리스트와 테이블 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/learning-j-chapter2.html" />
    <updated>2012-04-17T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/learning-j-chapter2.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://www.jsoftware.com/docs/help701/learning/contents.htm">Learning J</a>의 Chapter2 를 번역했다. 이번엔 리스트와 테이블에 관한 내용이다. 굉장히 기초적이고 중요한 내용이다. 특히 배열의 차원(dimension)에 관한 이야기는 나중에 나올 랭크라는 개념을 이해하기 위한 초석이므로 예제들을 잘 봐야 한다. 눈에 보이는 데이터가 같다고 해서 같은 데이터가 아니라는 것도 중요하다. 지금 말하고 있는 게 무슨 말인지 모르겠다면 이번 챕터를 읽도록 하자.</p>

<p>자 시작하자.</p>

<p><img src="http://dogfeet.github.com/articles/2012/learning-j-chapter2/j-code.png" alt="j-code" title="" /></p>

<p>계산(computation)을 하려면 데이터가 필요하다. 지금까지 단일 숫자와 숫자 리스트로 된 데이터만을 다뤘다. 하지만 테이블 같은, 다른 형태를 가진 데이터도 생각해볼 수 있다. 그런 데이터 즉, 리스트나 테이블들을 "배열"(Array)이라고 한다.</p>

<h2>2.1 테이블</h2>

<p>2행 3열 테이블은 <code>$</code>함수로 만든다.</p>

<pre><code>   table =: 2 3   $   5 6 7  8 9 10
   table
5 6  7
8 9 10
</code></pre>

<p>위 예제는 <code>x $ y</code>라는 표현식으로 테이블을 만드는 것을 보여준다. x는 테이블의 차원(dimensions)을 결정한다. x는 행의 개수 다음에 열의 개수가 오는 리스트의 형태이다. 테이블은 y의 내용으로 채워진다.<br />y의 아이템을 순서대로 가져와서 첫 번째 행을 채우고 다음에는 두 번째 행을 채워나간다. 행이 더 있으면 계속 y의 아이템을 가져와 순서대로 채운다. y는 적어도 하나 이상의 아이템을 가지고 있어야만 한다. 만약 y의 아이템 개수가 테이블을 채우기 부족하다면 y의 처음부터 재사용한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>2 4 $ 5 6 7 8 9</tt></td>
<td><tt>2 2 $ 1</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6 7 8<br>
9 5 6 7</tt></td>
<td><tt>1 1<br>
1 1</tt></td>
</tr></tbody></table>

<p><code>$</code>함수는 한가지 방식으로만 테이블을 만든다. 더 많은 방식을 보고 싶다면 5장을 참고하시라.</p>

<p>우리가 배웠던 함수들은 이전에 리스트 데이터에서도 그랬듯이 테이블 데이터에도 정확하게 똑같이 적용된다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>table  </tt></td>
<td><tt>10 * table</tt></td>
<td><tt>table + table</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6&nbsp;&nbsp;7<br>
8 9 10</tt></td>
<td><tt>50 60&nbsp;&nbsp;70<br>
80 90 100</tt></td>
<td><tt>10 12 14<br>
16 18 20</tt></td>
</tr></tbody></table>

<p>한 인자는 테이블, 또 다른 인자는 리스트인 경우도 가능하다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>table</tt></td>
<td><tt>0 1 * table</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6&nbsp;&nbsp;7<br>
8 9 10</tt></td>
<td><tt>0 0&nbsp;&nbsp;0<br>
8 9 10</tt></td>
</tr></tbody></table>

<p>바로 위 예제에서, 리스트 <code>0 1</code>의 각 아이템은 자동으로 테이블의 행과 매칭되었다. 0은 첫 번째 행과 1은 두 번째 행과 매칭되었다. 다른 패턴들도 이런 식으로 매칭될 수 있다. 더 보려면 7장을 보면 된다.</p>

<h2>2.2 배열</h2>

<p>테이블은 차원이 2이다. (행과 열) 비슷하게, 리스트는 1차원이라고 말할 수 있다.<br />2개 이상의 차원을 가진 테이블 형 데이터 오브젝트도 있다. 그런 의미에서 <code>$</code>함수의 왼쪽 인자는 차원의 개수를 가지는 리스트라고도 말할 수 있다. "배열"이라는 단어는 차원을 가진 데이터 오브젝트를 가리키는 일반적인 말이다. 아래에는 1차원, 2차원, 3차원의 배열에 대한 예제이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>3 $ 1</tt></td>
<td><tt>2 3 $ 5 6 7</tt></td>
<td><tt>2 2 3 $ 5 6 7 8</tt></td>
</tr><tr valign="TOP">
<td><tt>1 1 1</tt></td>
<td><tt>5 6 7<br>
5 6 7</tt></td>
<td><tt>5 6 7<br>
8 5 6<br>
<br>
7 8 5<br>
6 7 8</tt></td>
</tr></tbody></table>

<p>위 예제의 3차원 배열은 2면, 2행, 3열로 이루어져 있다. 두 개의 면은 위아래 차례대로 출력되었다.</p>

<p>모나딕 <code>#</code>함수로 리스트의 길이를 알 수 있는 것을 상기하자.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt># 6 7</tt></td>
<td><tt># 6 7 8</tt></td>
</tr><tr valign="TOP">
<td><tt>2</tt></td>
<td><tt>3</tt></td>
</tr></tbody></table>

<p>모나딕 <code>$</code>함수로는 인자의 차원 리스트를 알 수 있다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>L =: 5 6 7</tt></td>
<td><tt>$ L</tt></td>
<td><tt>T =: 2 3 $ 1</tt></td>
<td><tt>$ T</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6 7</tt></td>
<td><tt>3</tt></td>
<td><tt>1 1 1<br>
1 1 1</tt></td>
<td><tt>2 3</tt></td>
</tr></tbody></table>

<p>그러므로 만약 x가 배열이라면 <code># $ x</code>라는 표현식은 x의 차원 리스트의 길이, 즉 x의 차원 개수를 내뱉는다. 차원의 개수가 1이면 리스트, 2이면 테이블인 식이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> L </tt></td>
<td><tt>$ L </tt></td>
<td><tt> # $ L</tt></td>
<td><tt> T </tt></td>
<td><tt>$T</tt></td>
<td><tt># $ T</tt></td>
</tr><tr valign="TOP">
<td><tt>5 6 7</tt></td>
<td><tt>3</tt></td>
<td><tt>1</tt></td>
<td><tt>1 1 1<br>
1 1 1</tt></td>
<td><tt>2 3</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<p>만약 x가 단일 숫자라면 <code># $ x</code>는 0이다.</p>

<pre><code>   # $ 17
0
</code></pre>

<p>테이블은 2차원이고 리스트가 1차원이므로 단일 수는 차원이 없다라고 말할 수 있다. 단일수의 차원 수는 0이기 때문이다.(위 코드의 결과가 그 근거이다) 차원 수가 0인 데이터 오브젝트는 스칼라(scalar)라고 한다. 위에서 "배열"을 어떤 차원을 가지고 있는 데이터 오브젝트로 정의했었다. 그렇다면 스칼라 또한 배열이다. 다만 차원이 0일 뿐이다.</p>

<p>우리는 위에서 <code># $ 17</code>이 0임을 확인했다. 여기서 이런 결론을 도출할 수 있을 것이다. 스칼라가 차원을 가지고 있지 않기 때문에, (<code>$ 17</code>의 결과물로써의) 차원 리스트는 길이가 0이거나 비어있는 리스트여야만 한다. 이제 2의 길이를 가진 리스트는 <code>2 $ 99</code> 와 같은 코드를 이용해서 만들어 낼 수 있다. 그리고 길이가 0인 빈 리스트는 <code>0 $ 99</code> 같은 코드로 만들어 낼 수 있겠다. (사실 99대신 아무 숫자나 쓰여도 된다.)</p>

<p>빈 리스트의 값은 표시되지 않는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>2 $ 99</tt></td>
<td><tt>0 $ 99</tt></td>
<td><tt> $ 17</tt></td>
</tr><tr valign="TOP">
<td><tt>99 99</tt></td>
<td><tt>&nbsp;</tt></td>
<td><tt>&nbsp;</tt></td>
</tr></tbody></table>

<p>스칼라(예를 들면 <code>17</code>)는 길이가 1인 리스트(예를 들면 <code>1 $ 17</code>) 와는 다르다. 또 1행 1열짜리인 테이블(예를 들면 <code>1 1 $ 17</code>)과도 다르다. 스칼라는 차원이 없다. 리스트는 차원이 하나, 테이블은 두 개 이다. 하지만 세 개 모두 화면에는 똑같이 보인다.</p>

<pre><code>   S =: 17
   L =: 1 $ 17
   T =: 1 1 $ 17
</code></pre>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> S </tt></td>
<td><tt> L </tt></td>
<td><tt> T </tt></td>
<td><tt># $ S</tt></td>
<td><tt># $ L</tt></td>
<td><tt># $ T</tt></td>
</tr><tr valign="TOP">
<td><tt>17</tt></td>
<td><tt>17</tt></td>
<td><tt>17</tt></td>
<td><tt>0</tt></td>
<td><tt>1</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<p>하나의 열을 가진 테이블도 여전히 2차원 테이블이다. 아래에 3행 1열의 <code>t</code>가 있다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>t =: 3 1 $ 5 6 7</tt></td>
<td><tt>$ t</tt></td>
<td><tt># $ t</tt></td>
</tr><tr valign="TOP">
<td><tt>5<br>
6<br>
7</tt></td>
<td><tt>3 1</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<h2>2.3 용어: 랭크와 모양(Rank and Shape)</h2>

<p>"차원 수"라고 부르는 속성은 J에서는 짧게 줄여 "랭크(Rank)"라고 한다. 그래서 단일 숫자는 랭크-0 배열(rank-0 array)이라고 부르고, 리스트는 랭크-1 배열이라고 한다. 차원 리스트는 "모양(Shape)"이라고 한다.<br />수학 용어에서 "벡터(Vector)"와 "매트릭스(Matrix)"는 위에서 말했던 "리스트"와 "테이블"과 관련이 있다. 3차원 이상의 배열(아, 이제는 랭크 3이상의 배열 이라고 하겠다.)은 "리포트(Report)"라고 한다.</p>

<p>아래 테이블에 배열에 대한 용어와 함수들을 정리해놓았다.</p>

<pre><code>+--------+--------+-----------+------+
|        | Example| Shape     | Rank |
+--------+--------+-----------+------+
|        | x      | $ x       | # $ x|
+--------+--------+-----------+------+
| Scalar | 6      | empty list| 0    |
+--------+--------+-----------+------+
| List   | 4 5 6  | 3         | 1    |
+--------+--------+-----------+------+
| Table  |0 1 2   | 2 3       | 2    |
|        |3 4 5   |           |      |
+--------+--------+-----------+------+
| Report |0  1  2 | 2 2 3     | 3    |
|        |3  4  5 |           |      |
|        |        |           |      |
|        |6  7  8 |           |      |
|        |9 10 11 |           |      |
+--------+--------+-----------+------+
</code></pre>

<p>위 테이블은 사실 J로 짠 프로그램의 출력물이다. 게다가 저건 위에 작은 챕터를 할애해서 말했던 자료구조인 진짜 "테이블"이다. 이 테이블의 모양은 <code>6 4</code>이다. 하지만 이건 숫자로만 이루어진 테이블이 아니라 문자도 있고, 리스트도 담고 있다. 그럼 이제 숫자가 아닌 걸로 이루어진 배열을 살펴보자</p>

<h2>2.4 문자로 이루어진 배열</h2>

<p>문자는 알파벳, 구두점, 숫자 등을 말한다. 숫자로 배열을 만들었듯이 문자로도 배열을 만들 수 있다. 문자의 리스트를 만들려면 작은따옴표 안에 문자들을 넣으면 된다. 하지만 결과 화면에 출력될 때는 작은따옴표는 보이지 않는다. 예를 들자면 아래와 같다.</p>

<pre><code>   title =: 'My Ten Years in a Quandary'
   title
My Ten Years in a Quandary
</code></pre>

<p>문자의 리스트는 문자열(string)이라고 한다. 문자열 안의 작은따옴표를 넣으려면 작은따옴표를 연속 두 번 타이핑 한다.</p>

<pre><code>   'What''s new?'
What's new?
</code></pre>

<p>빈 문자열이나 길이가 0인 문자열을 나타내려면 연속된 두 개의 작은 따옴표를 타이핑한다. 이건 화면에 보이지 않는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> '' </tt></td>
<td><tt># '' </tt></td>
</tr><tr valign="TOP">
<td><tt>&nbsp;</tt></td>
<td><tt>0</tt></td>
</tr></tbody></table>

<h2>2.5 배열에 사용되는 함수</h2>

<p>이 장에서는 배열을 다루는 몇 가지 유용한 함수들을 알아보도록 한다. J는 매우 다양한 함수들을 가진 언어이다. 한번 살펴보자.</p>

<h3>2.5.1 합치기</h3>

<p>내장 함수인 <code>,</code>는 "Append"라고 한다. 이 함수는 여러 개의 요소를 붙여서 리스트를 만든다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>a =: 'rear'</tt></td>
<td><tt>b =: 'ranged'</tt></td>
<td><tt>a,b</tt></td>
</tr><tr valign="TOP">
<td><tt>rear</tt></td>
<td><tt>ranged</tt></td>
<td><tt>rearranged</tt></td>
</tr></tbody></table>

<p>"Append" 함수는 리스트나 아이템 하나를 합친다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>x =: 1 2 3</tt></td>
<td><tt>0 , x </tt></td>
<td><tt>x , 0 </tt></td>
<td><tt>0 , 0</tt></td>
<td><tt>x , x </tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3</tt></td>
<td><tt>0 1 2 3</tt></td>
<td><tt>1 2 3 0</tt></td>
<td><tt>0 0</tt></td>
<td><tt>1 2 3 1 2 3</tt></td>
</tr></tbody></table>

<p>"Append" 함수는 두 개의 테이블의 양 끝을 합쳐서 더 긴 테이블을 만들 수도 있다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T1=: 2 3 $ 'catdog'</tt></td>
<td><tt>T2=: 2 3 $ 'ratpig'</tt></td>
<td><tt>T1,T2</tt></td>
</tr><tr valign="TOP">
<td><tt>cat<br>
dog</tt></td>
<td><tt>rat<br>
pig</tt></td>
<td><tt>cat<br>
dog<br>
rat<br>
pig</tt></td>
</tr></tbody></table>

<p>"Append"에 대한 더 많은 정보를 원하면 5장을 보라.</p>

<h3>2.5.2 아이템</h3>

<p>숫자로 이루어진 리스트의 아이템은 각각이 숫자다. 그리고 테이블의 아이템은 그 테이블의 행이라고 한다. 3차원 배열의 아이템은 그 배열의 평면이다. 일반적으로 말해서 아이템이라 함은 배열의 첫 번째 차원을 따라 늘어서 있는 요소들의 연속이다. 배열은 아이템으로 이루어진 리스트이다.<br /><code>#</code>("Tally")함수가 리스트의 길이를 반환한다고 했었다. 아래를 보자</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>x</tt></td>
<td><tt> # x</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3</tt></td>
<td><tt>3</tt></td>
</tr></tbody></table>

<p>일반적으로 <code>#</code>는 배열의 아이템 개수, 즉 첫 번째 차원의 크기를 잰다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T1</tt></td>
<td><tt>$ T1</tt></td>
<td><tt># T1</tt></td>
</tr><tr valign="TOP">
<td><tt>cat<br>
dog</tt></td>
<td><tt>2 3</tt></td>
<td><tt>2</tt></td>
</tr></tbody></table>

<p>확실히 <code># T1</code>은 차원 리스트인 <code>$ T1</code>의 첫 번째 아이템이다. 차원이 없는 스칼라는 단일 아이템으로 취급한다.</p>

<pre><code>   # 6
1
</code></pre>

<p>밑에 있는 "Append"의 예를 다시 보자.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T1</tt></td>
<td><tt>T2</tt></td>
<td><tt>T1 , T2</tt></td>
</tr><tr valign="TOP">
<td><tt>cat<br>
dog</tt></td>
<td><tt>rat<br>
pig</tt></td>
<td><tt>cat<br>
dog<br>
rat<br>
pig</tt></td>
</tr></tbody></table>

<p>이제 <code>x , y</code>의 의미를 <code>x</code>의 아이템 다음에 <code>y</code>의 아이템이 오는 리스트라고 일반화시켜 말할 수 있겠다.</p>

<p>"아이템"을 잘 이용하기 위한 다른 예제로 <code>+/</code> 함수가 있다. <code>+/</code>는 +를 리스트의 아이템 사이사이에 끼워 넣는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>+/ 1 2 3</tt></td>
<td><tt>1 + 2 + 3</tt></td>
</tr><tr valign="TOP">
<td><tt>6</tt></td>
<td><tt>6</tt></td>
</tr></tbody></table>

<p>일반적으로는 <code>+/</code>는 <code>+</code>를 배열의 아이템 사이에 끼워 넣는다. (리스트의 아이템 사이가 아니다.) 다음 예제는 아이템이 단일 숫자가 아니라 테이블의 행인 경우이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>T =: 3 2 $ 1 2 3 4 5 6</tt></td>
<td><tt>+/ T</tt></td>
<td><tt>1 2 + 3 4 + 5 6</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2<br>
3 4<br>
5 6</tt></td>
<td><tt>9 12</tt></td>
<td><tt>9 12</tt></td>
</tr></tbody></table>

<h3>2.5.3 선택하기</h3>

<p>이제 리스트에서 아이템을 선택하는 방법을 알아보자. 리스트에서 아이템의 위치는 0, 1, 2... 로 숫자를 매긴다. 첫 번째 아이템의 위치는 0이다.(10번째 아이템의 위치는 9이다.) 위치 정보를 가지고 아이템을 선택하기 위해서는 <code>{</code>("From") 함수를 사용한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Y =: 'abcd'</tt></td>
<td><tt>0 { Y</tt></td>
<td><tt>1 { Y</tt></td>
<td><tt>3 { Y</tt></td>
</tr><tr valign="TOP">
<td><tt>abcd</tt></td>
<td><tt>a</tt></td>
<td><tt>b</tt></td>
<td><tt>d</tt></td>
</tr></tbody></table>

<p>위치를 나타내는 숫자는 "인덱스"라고 한다. <code>{</code>함수는 왼쪽 인자에 인덱스로써 단일수나 숫자 리스트를 받는다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> Y</tt></td>
<td><tt> 0 { Y</tt></td>
<td><tt> 0 1 { Y</tt></td>
<td><tt> 3 0 1 { Y</tt></td>
</tr><tr valign="TOP">
<td><tt>abcd</tt></td>
<td><tt>a</tt></td>
<td><tt>ab</tt></td>
<td><tt>dab</tt></td>
</tr></tbody></table>

<p><code>i.</code> 라는 내장 함수도 있다. 표현식 <code>i. n</code>은 크기가 n인 0부터 순서대로 커지는 양의 정수의 리스트를 생성한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>i. 4</tt></td>
<td><tt>i. 6</tt></td>
<td><tt>1 + i. 3</tt></td>
</tr><tr valign="TOP">
<td><tt>0 1 2 3</tt></td>
<td><tt>0 1 2 3 4 5</tt></td>
<td><tt>1 2 3</tt></td>
</tr></tbody></table>

<p>만약 x가 리스트라면 <code>i. # x</code>라는 표현식은 x에서 사용할 수 있는 모든 인덱스의 리스트를 만들어낸다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>x =: 'park'</tt></td>
<td><tt># x</tt></td>
<td><tt>i. # x</tt></td>
</tr><tr valign="TOP">
<td><tt>park</tt></td>
<td><tt>4</tt></td>
<td><tt>0 1 2 3</tt></td>
</tr></tbody></table>

<p><code>i.</code>의 인자로 리스트가 들어오면 배열이 만들어진다.</p>

<pre><code>   i. 2 3
0 1 2
3 4 5
</code></pre>

<p><code>i.</code>를 다이아딕으로 사용하면 이때는 <code>i.</code>를 "Index Of"라고 한다. <code>x i. y</code>라는 표현식은 x에 있는 y의 위치를 찾아낸다.</p>

<pre><code>   'park' i. 'k'
3
</code></pre>

<p>찾은 인덱스는 x에서 y가 처음으로 발견된 위치이다.</p>

<pre><code>   'parka' i. 'a'
1
</code></pre>

<p>x에 y가 없다면 마지막 위치보다 1 큰 수를 반환한다.</p>

<pre><code>   'park' i. 'j'
4
</code></pre>

<p>인덱싱에 대해 더 많은 것을 알고 싶다면 챕터 6을 보라.</p>

<h3>2.5.4 같음과 매칭(Equality and Matching)</h3>

<p>두 배열이 같은지 알아봐야 하는 상황이라면 내장 함수인 <code>-:</code>("Match")를 사용하면 된다. 이 함수는 두 개의 인자가 같은 모양, 같은 값을 가졌는지 검사한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>X =: 'abc'</tt></td>
<td><tt>X -: X</tt></td>
<td><tt>Y =: 1 2 3 4</tt></td>
<td><tt>X -: Y</tt></td>
</tr><tr valign="TOP">
<td><tt>abc</tt></td>
<td><tt>1</tt></td>
<td><tt>1 2 3 4</tt></td>
<td><tt>0</tt></td>
</tr></tbody></table>

<p>인자가 뭐든 간에 함수의 결과 값은 0 아니면 1이다.</p>

<p>빈 문자 리스트와 빈 숫자 리스트는 같다는 건 알아두어야 한다.</p>

<pre><code>   '' -: 0 $ 0
1
</code></pre>

<p>이 둘의 모양은 같고 모든 매핑되는 요소의 값들이 같기 때문에 위 식은 참이다. (물론 요소가 없긴 하다.)<br /><code>=</code>("Equal")라는 함수도 있다. 이 함수는 주어진 두 인자가 같은지를 확인한다. <code>=</code>는 매핑되는 각 요소의 값이 같은지 확인해서 요소와 같은 모양의 불리언 배열을 반환한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Y</tt></td>
<td><tt>Y = Y</tt></td>
<td><tt>Y = 2</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3 4</tt></td>
<td><tt>1 1 1 1</tt></td>
<td><tt>0 1 0 0</tt></td>
</tr></tbody></table>

<p>결론적으로 <code>=</code>가 가지는 두 인자는 반드시 같은 모양이어야 한다. (아니면 적어도, <code>Y=2</code>의 경우와 같이 호환되는 모양이어야 한다) 그렇지 않으면 에러가 발생한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>Y</tt></td>
<td><tt>Y = 1 5 6 4</tt></td>
<td><tt>Y = 1 5 6</tt></td>
</tr><tr valign="TOP">
<td><tt>1 2 3 4</tt></td>
<td><tt>1 0 0 1</tt></td>
<td><tt>error</tt></td>
</tr></tbody></table>

<h2>2.6 박스의 배열(Arrays of Boxes)</h2>

<h3>2.6.1 연결하기</h3>

<p><code>;</code>("Link")라는 내장 함수가 있다. 이 함수는 두 인자를 리스트의 형태로 연결한다. 두 인자는 다른 것 이어도 된다. 예를 들어 문자열과 숫자를 연결 할수 있다.</p>

<pre><code>   A =: 'The answer is'  ;  42
   A
+-------------+--+
|The answer is|42|
+-------------+--+
</code></pre>

<p>위 에서 A는 길이가 2인 리스트이다. 그리고 이 리스트는 박스의 리스트라고 한다. 첫 번째 박스 안에는 문자열 'The answer is'가 들어있고 두 번째 박스에는 숫자 42가 있다. 박스는 화면에 사각형으로 그려지고 안에 그 박스의 값을 담고 있는 형태로 그려진다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> A </tt></td>
<td><tt> 0 { A</tt></td>
</tr><tr valign="TOP">
<td><tt>+-------------+--+<br>
|The answer is|42|<br>
+-------------+--+</tt></td>
<td><tt>+-------------+<br>
|The answer is|<br>
+-------------+</tt></td>
</tr></tbody></table>

<p>박스 하나는 안에 있는 값이 무엇이든 간에 스칼라로 취급한다. 박스는 그 안에 일반적인 배열(예를 들면 숫자로 이루어진 리스트 같은 거)을 넣을 수 있다. 따라서 A는 스칼라의 리스트이다. (A의 아이템들은 각각이 스칼라는 말이다.)</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> A </tt></td>
<td><tt>$ A</tt></td>
<td><tt>s =: 1 { A</tt></td>
<td><tt> # $ s</tt></td>
</tr><tr valign="TOP">
<td><tt>+-------------+--+<br>
|The answer is|42|<br>
+-------------+--+</tt></td>
<td><tt>2</tt></td>
<td><tt>+--+<br>
|42|<br>
+--+</tt></td>
<td><tt>0</tt></td>
</tr></tbody></table>

<p>박스로 이루어진 배열의 주목적은 다른 종류의 값들을 하나의 변수에 집어넣는 것이다. 예를 들어 구입 한 물건의 자세한 사항들(구매 날짜, 가격, 설명)을 담은 변수는 박스의 리스트로 나타낼 수 있다.</p>

<pre><code>   P =: 18 12 1998  ;  1.99  ;  'baked beans'
   P
+----------+----+-----------+
|18 12 1998|1.99|baked beans|
+----------+----+-----------+
</code></pre>

<p>"Link"와 "Append"의 차이점에 주목해야 한다. "Link"가 다른 종류의 값들을 합치는 반면 "Append"가 합치는 값들은 언제나 같은 종류이다. 즉 "Append" 함수에 주어지는 두 인자는 반드시 둘 다 숫자로 이루어진 배열이거나 둘 다 문자로 이루어진 배열이어야 한다. 아니면 둘 다 박스로 이루어진 배열이어야 한다. 그게 아니면 에러가 난다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>'answer is'; 42</tt></td>
<td><tt>'answer is' , 42</tt></td>
</tr><tr valign="TOP">
<td><tt>+---------+--+<br>
|answer is|42|<br>
+---------+--+</tt></td>
<td><tt>error</tt></td>
</tr></tbody></table>

<p>문자열과 숫자를 연결해야 할 때가 있을 수 있다. 예를 들자면 어떤 결과 값과 그에 대한 설명은 같이 보여줘야 할 때가 있다. 그 때 위에서 봤듯이 문자열과 숫자를 "연결(Link)"할 수 있다. 하지만 더 부드러운 표현은 숫자를 문자열로 바꿔서 두 문자열을 연결하는 방식으로 처리하는 것이다. 그러면 결과물은 박스의 리스트가 아니라 문자열이 된다.</p>

<p>숫자를 문자열로 바꾸는 것은 내장 함수인 <code>":</code>("Format")을 이용한다. 아래 예제에서 n은 단일 숫자이고 s는 n을 포맷해서 만든 문자열이다. s는 길이가 2이다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>n =: 42</tt></td>
<td><tt>s =: ": n</tt></td>
<td><tt># s</tt></td>
<td><tt>'answer is ' , s</tt></td>
</tr><tr valign="TOP">
<td><tt>42</tt></td>
<td><tt>42</tt></td>
<td><tt>2</tt></td>
<td><tt>answer is 42</tt></td>
</tr></tbody></table>

<p>"Format"에 대해서 더 알고 싶다면 19장을 보면 된다. 다시 박스로 돌아가도록 하자. 박스는 값이 상자로 둘러싸고 있는 형태이기 때문에, 박스가 화면에 보일 때에는 간단한 표의 형태로 보인다.</p>

<pre><code>   p =: 4 1 $ 1 2 3 4
   q =: 4 1 $ 3 0 1 1

   2 3 $ ' p ' ; ' q ' ; ' p+q ' ;  p ; q ; p+q
+---+---+-----+
| p | q | p+q |
+---+---+-----+
|1  |3  |4    |
|2  |0  |2    |
|3  |1  |4    |
|4  |1  |5    |
+---+---+-----+
</code></pre>

<h3>2.6.2 박싱과 언박싱(Boxing and Unboxing)</h3>

<p><code>&lt;</code>("Box")라는 내장 함수가 있다. 이 함수는 인자로 들어온 값을 감싸 하나의 박스를 만든다.</p>

<pre><code>   &lt; 'baked beans'
+-----------+
|baked beans|
+-----------+
</code></pre>

<p>박스는 숫자를 담을 수 있지만, 그 자체로 숫자는 아니다. 박스 안에 있는 값으로 계산 하려면 박스를 열어서 값을 꺼내야 한다. <code>&gt;</code> 함수가 바로 그런 것이다. 이 함수는 "Open"이라고 한다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>b =: &lt; 1 2 3</tt></td>
<td><tt>&gt; b</tt></td>
</tr><tr valign="TOP">
<td><tt>+-----+<br>
|1 2 3|<br>
+-----+</tt></td>
<td><tt>1 2 3</tt></td>
</tr></tbody></table>

<p><code>&lt;</code>를 깔때기 모양의 그림으로 생각하면 이해하기가 쉽다. 데이터가 넓은 쪽으로 흘러들어 가서 좁은 쪽으로 박스에 담겨 나온다. 나온 박스는 스칼라, 즉 차원이 없다. <code>&gt;</code>도 비슷하게 생각하면 된다. 박스가 스칼라이기 때문에 <code>,</code>함수로 각 박스를 리스트로 묶을 수 있다. 하지만 <code>;</code>함수를 쓰는 게 좀 더 편하다. 이 함수는 박스에 담아 연결해주는 작업을 한 번에 해준다.</p>

<table cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>(&lt; 1 1) , (&lt; 2 2) , (&lt; 3 3)</tt></td>
<td><tt>1 1 ; 2 2 ; 3 3</tt></td>
</tr><tr valign="TOP">
<td><tt>+---+---+---+<br>
|1 1|2 2|3 3|<br>
+---+---+---+</tt></td>
<td><tt>+---+---+---+<br>
|1 1|2 2|3 3|<br>
+---+---+---+</tt></td>
</tr></tbody></table>

<h2>2.7 요약</h2>

<p>결론적으로 J의 모든 데이터 오브젝트는 전부 n 차원 배열(n >= 0)이다. 배열은 숫자로 이루어진 배열일 수도 있고, 문자, 또는 박스로 이루어졌을 수도 있다. (물론 다른 것으로 이루어질 수도 있다.)</p>

<p>2장을 마친다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: Mocha ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-mocha.html" />
    <updated>2012-04-14T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-mocha.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 '<a href="http://dailyjs.com/2011/12/08/mocha/">Testing with Mocha</a>'을 다시 쓴 것이다. <a href="http://alexyoung.org/">Alex Young</a>님이 만든 예제도 내가 쓰기 편하게 좀 고쳤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-mocha/mocha-test.png" alt="mocha-test" title="" /></p>

<p><a href="http://dailyjs.com/2011/12/08/mocha/">Testing with Mocha</a>를 읽고 Mocha 메뉴얼을 읽으니 훨씬 눈에 잘 들어온다.</p>

<h2>Mocha</h2>

<p><a href="http://visionmedia.github.com/mocha/">Mocha</a>는 TJ Holowaychuk이 만든 <a href="http://en.wikipedia.org/wiki/Behavior_Driven_Development">BDD</a> 프레임워크이다. </p>

<p>이 글에서는 그냥 Mocha로 BDD하는 법에 대해서만 설명한다. 원래 글은 TDD를 하는 법에 대해서 다뤘지만, 다시 정리하면서 BDD로 수정했다. 다른 방법, 다른 프레임워크와의 비교는 @outsider님이 잘 정리해 주었다. @outsider님 <a href="http://blog.outsider.ne.kr/770">블로그 글</a>을 읽어보자. </p>

<h2>package.json</h2>

<p>먼저 package.json 파일을 다음과 같이 만든다.</p>

<pre><code>{
    "name": "async-testing-tutorial"
    , "version": "0.0.1"
    , "description": "A tutorial for Mocha"
    , "keywords": ["test", "tutorial"]
    , "author": "Alex R. Young &lt;<a href='mailto:info@dailyjs.com'>info@dailyjs.com</a>&gt;"
    , "main": "index"
    , "engines": { "node": "&gt;= 0.4.x &lt; 0.7.0" }
    , "scripts": {
        "test": "make test"
    }
    , "devDependencies": {
        "mocha": "1.0.x"
        , "should": "0.6.x"
    }
}
</code></pre>

<p>원래 코드는 assert 모듈과 TDD 스타일로 돼 있었지만, 나는 should와 BDD가 더 직관적이라고 생각하므로 바꿨다.</p>

<p>이를 위해 의존성을 추가한다.: </p>

<pre><code>, "devDependencies": {
    "mocha": "1.0.x"
    , "should": "0.6.x"
}
</code></pre>

<p>이제 <code>npm install</code>하면 해당 모듈이 설치된다.</p>

<h2>Makefile</h2>

<p>다음과 같이 Makefile을 만들고 <code>make test</code>를 실행하면 된다. </p>

<pre><code>test:
    @./node_modules/.bin/mocha --require should

.PHONY: test
</code></pre>

<ul>
<li><code>--require should</code> - 테스트 코드에서 should 모듈을 끼워 넣어 준다. 생략하면 테스트 코드에 <code>require('should')</code>를 직접 넣어 줘야 한다.</li>
<li><code>--reporter dot</code> - 테스트 결과를 어떻게 보여줄지 reporter를 고를 수 있다. 생략 시 기본 값은 <code>dot</code>.</li>
<li><code>--u bdd</code> - 테스트 스타일을 고를 수 있는데. 생략 시 기본 값은 <code>bdd</code>.</li>
</ul>

<p>자세한 옵션은 <a href="http://visionmedia.github.com/mocha/">Mocha</a> 페이지에서 확인한다.</p>

<h2>prime Module</h2>

<p><a href="http://alexyoung.org/">Alex Young</a>님이 작성한 모듈 코드:</p>

<pre><code>function nextPrime(n) {
    var smaller;
    n = Math.floor(n);

    if (n &gt;= 2) {
        smaller = 1;
        while (smaller * smaller &lt;= n) {
            n++;
            smaller = 2;
            while ((n % smaller &gt; 0) &amp;&amp; (smaller * smaller &lt;= n)) {
                smaller++;
            }   
        }   
        return n;
    } else {
        return 2;
    }   
}

function asyncPrime(n, fn) {
    setTimeout(function() {
        fn( nextPrime(n) );
    }, 10);
}

module.exports.nextPrime = nextPrime;
module.exports.asyncPrime = asyncPrime;
</code></pre>

<h2>Test</h2>

<p>BDD 스타일로 작성한 테스트는 다음과 같다.</p>

<pre><code>var nextPrime = require('./../index').nextPrime
var asyncPrime = require('./../index').asyncPrime;

describe('prime', function() {

    describe('nextPrime', function() {

        it('nextPrime should return the next prime number', function() {
            nextPrime(7).should.equal(11);
        }); 

        it('zero and one are not prime numbers', function() {
            nextPrime(0).should.equal(2);
            nextPrime(1).should.equal(2);
        }); 
    }); 

    describe('asyncPrime', function() {

        it('asyncPrime should return the next prime number', function(done) {
            asyncPrime(128, function(n) {
                n.should.equal(131);
                done();
            });
        });
    });
});
</code></pre>

<p>비동기 테스트 예제인 'asyncPrime'은 done()을 호출해서 테스트가 성공했음을 알린다.</p>

<h2>hooks</h2>

<ul>
<li>before() - describe()를 시작하기 전에 한번</li>
<li>after() - describe()를 끝내고 나서 한번</li>
<li>beforeEach() - describe() 안에 있는 it()이 시작할 때마다 한번</li>
<li>afterEach() - describe() 안에 있는 it() 이 끝날 때마다 한번</li>
</ul>

<p>위 테스트코드에 hooks을 추가해보고:</p>

<pre><code>var nextPrime = require('./../index').nextPrime
var asyncPrime = require('./../index').asyncPrime;

describe('prime', function() {

    before(function(){
        console.log('before');
    }); 

    after(function(){
        console.log('after');
    }); 

    beforeEach(function(){
        console.log('beforeEach');
    }); 

    afterEach(function(){
        console.log('afterEach');
    }); 

    describe('nextPrime', function() {
        before(function(){
            console.log('new before');
        }); 

        it('nextPrime should return the next prime number', function() {
            nextPrime(7).should.equal(11);
        }); 

        it('zero and one are not prime numbers', function() {
            nextPrime(0).should.equal(2);
            nextPrime(1).should.equal(2);
        }); 
    }); 

    describe('asyncPrime', function() {
        afterEach(function(){
            console.log('new afterEach');
        });

        it('asyncPrime should return the next prime number', function(done) {
            asyncPrime(128, function(n) {
                n.should.equal(131);
                done();
            });
        });
    });
});
</code></pre>

<p>결과는 다음과 같다:</p>

<pre><code>  before
new before
beforeEach
.afterEach
beforeEach
.afterEach
beforeEach
.new afterEach
afterEach
after


  ✔ 3 tests complete (25ms)
</code></pre>

<p>'new afterEach'나 'new before' 부분에서 스택처럼 동작해서 상위 describe()에 정의한 것은 생략될까 싶었는데, 아니었다. 모두 호출된다.</p>

<p><a href="http://alexyoung.org/">Alex Young</a> 만든 코드는 <a href="https://github.com/alexyoung/async-testing-tutorial">async-testing-tutorial</a>이고 내가 수정한 코드는 <a href="https://github.com/pismute/async-testing-tutorial">async-testing-tutorial-pismute</a>이다.</p>

<p>TDD 스타일로 테스트를 작성하고 assert방식의 expecting을 선호한다면 <a href="http://alexyoung.org/">Alex Young</a>만든 코드를 보는 것이 낫다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ PAC: proxy auto-config ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/proxy-auto-config.html" />
    <updated>2012-04-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/proxy-auto-config.html</id>
    <content type="html">
<![CDATA[
<p>Proxy을 통해 우회하고 싶을 때가 왕왕 있다.</p>

<p>중국이나 한국같은 인터넷 통제국을 여행한다거나. 인터넷 통제하는 회사에서 일을 한다거나. 특정 ip에서만 접근 가능한 사이트에 접근하고 싶을 때도 있고, 논문을 조회해야 하는데 이런건 학교에서만 무료라서 학교를 통해야 한다든지. 어쨌든 이런게 가끔식 필요할 때가 있다.</p>

<p>사실 보통은 PAC까지 필요없다. 매우 특이한 경우, 사무실에서 인터넷을 엉터리로 막아서 일하는데 필요한 자료를 얻을 수 없을 때에나 필요하다. 이럴 때는 디테일하게 우회해야 해야 한다.</p>

<p>이글을 쓰는 시점에서는 OTN(Oracle TechNet)에서 파일을 다운 받으려 하는데, HTTPS를 막아서 인증을 할 수가 없었다. 왜? OTN만 HTTPS가 안되는지 모르겠다. Proxy는 유료 개인 서버니까 Proxy를 통해 인증만 하고 1GB가 넘는 파일은 다이렉트로 다운 받도록 설정했다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/proxy-auto-config/pacman.gif" alt="pacman" title="" /></p>

<p>이 설정은 Window에서만 확인했다.</p>

<h2>PAC(Proxy Auto-Config) 파일</h2>

<p>아무튼 규칙이 2~3개만 되도 헷갈리고 관리하기 쉽지 않다. 그냥 프로토콜이 무엇인지, ip가 무엇인지, 도메인이 무엇인지에 따라 규칙을 만들고 활용하면 좋다. PAC 파일을 만들어 사용하면 규칙을 스크립트로 관리할 수 있다.</p>

<p>PAC는 아주 간단한 파일이다:</p>

<pre><code>function FindProxyForURL(url, host) {

    url = url.toLowerCase();
    host = host.toLowerCase();
    hostip=dnsResolve(host);
    isHttp=(url.substring(0,5) == "http:");
    isHttps=(url.substring(0,6) == "https:")

    // 로컬은 항상 DIRECT로 접근한다.
    if(0
        || isPlainHostName(host)
        || isInNet(hostip, "10.0.0.0", "255.0.0.0") 
        || isInNet(hostip, "172.16.0.0", "255.240.0.0") 
        || isInNet(hostip, "192.168.0.0", "255.255.0.0")
        ) { 
        return "DIRECT"; 
    }

    // Https가 필요한데, 접근을 막혔다.
    if(isHttps) {
        //먼저 SOCKS PROXY를 통하고 실패하면 그냥 연결한다.
        return "SOCKS 127.0.0.1:8580; DIRECT";
    }

    // dropbox도 막았다.
    if (shExpMatch(url, "<a href='http://www.dropbox.com*'>http://www.dropbox.com*</a>")) {
        //이건 HTTP PROXY로 연결하고 실패하면 그냥 연결한다.
        return "PROXY 127.0.0.1:8580; DIRECT";
    }

    return "DIRECT"; 
}
</code></pre>

<p>파일 이름은 상관없지만 그래도 PAC파일임을 알 수 있게 my.pac쯤으로 짓는다.</p>

<p>그리고 Explorer에서 "Internet Options/Connections/LAN settings"에서 my.pac파일을 지정해줄 수 있다:</p>

<p><img src="/articles/2012/proxy-auto-config/pac.png" alt="my.pac" title="" /></p>

<h2>Browser</h2>

<p>그러면 이제 저 규칙을 따라 동작한다. 브라우저별로 보면 Explorer/Firefox/Opera는 각각 별도로 설정할 수 있다. 그래서 굳이 PAC를 사용하지 말고 브라우저 별로 다르게 설정해서 필요에 따라 다른 브라우저를 선택해 사용하는 것도 방법이다.</p>

<p>그리고 Chrome은 System 설정을 사용하니까 Explorer와 같은 설정을 사용한다.</p>

<h2>Best Practice</h2>

<p>PAC 설정은 나름 까다롭다. 수정하면 테스트도 해야하고 모든 사이트나 모든 상황에 통용되는 매우 일반적인 규칙을 만드는 것은 정말 까다롭다. 그러니, 적당한 규칙을 만들어 상황에 따라 스위칭하는 것이 유리하다. </p>

<p>Proxy profile을 만들고 필요에 따라 선택해서 사용하면 좋다. Chrome의 <a href="http://switchy.samabox.com/">Switchy</a> Extension은 내가 사용해본 것중 가장 편리하다. Switchy는 Proxy Profile을 만들고 Profile 사이를 쉽게 스위칭할 수 있다. Chrome은 시스템 설정을 사용하므로 Switchy에서 Profile을 변경하면 시스템 설정이 바뀐다.</p>

<p>Switchy + PAC 를 사용하면 다양한 조합이 가능하다.</p>

<h2>기타.</h2>

<ul>
<li>SSH tunnel은 SOCKS 프록시다.</li>
<li>8580은 <a href="http://en.wikipedia.org/wiki/Freegate">freegate</a> 기본 포트다.</li>
<li>freegate는 중국 여행 필수품; 공익재단이(라고 쓰고 '미국이' 라고 읽는다) 만든다. freegate는 무료 Proxy로 인터넷 통제국을(이라고 쓰고 '중국을' 이라고 읽는다) 무력화할 목적으로 개발되고 있다. 인터넷 통제국으로 인정해주지 않은 나라에서는 사용할 수 없다. 그런데, 한국은 인터넷 통제국임에도 불구하고 freegate를 사용할 수 없다. 한국도 인정해달라!</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ J언어를 배워보자 - 제 1장. 기본기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/learning-j-chapter1.html" />
    <updated>2012-04-06T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/learning-j-chapter1.html</id>
    <content type="html">
<![CDATA[
<p>Roger Stokes이 쓴 <a href="http://www.jsoftware.com/docs/help701/learning/contents.htm">Learning J</a>의 chapter 1:Basics를 번역/정리했다.</p>

<p>요즘 J를 배워보려 하는데 관련된 한국어 자료가 거의 없었다. 그래서 공부하는 겸 Learning J를 읽고 간단히 정리했다. 원문을 그대로 옮기진 않았고, 필요하면 표현을 바꿨다.</p>

<p>이 책은 J701을 기준으로 쓰였다. 따라서 <a href="http://www.jsoftware.com">www.jsoftware.com</a> 에서 J701을 다운받아서 설치해 하나하나 실습해보면 좋다. J는 APL, K와 비슷한 언어로 리스트, 행렬등을 연산하기에 좋은 기호 중심의 언어이다. 따라서 수학, 통계, 논리적인 분석등에 쓰기에 좋다. 코드가 일반 알파벳이 아닌 특수문자가 많아 읽기가 난해하고 기존의 제어 흐름과는 다른 프로그래밍 스타일 때문에 배우기 어려워하는 사람이 많다. J에 대한 자세한 소개는 <a href="http://www.jsoftware.com/docs/help701/primer/contents.htm">여기</a> 에서 위의 글 몇 개를 읽으면 된다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/learning-j-chapter1/j-code.png" alt="j-code" title="" /></p>

<h2>1.1 인터렉티브 환경</h2>

<p>J의 개발환경은 사용자가 한 줄 입력하면, 그게 곧바로 해석되어 아랫줄에 출력된다. 사용자의 입력하는 것은 들여쓰기가 된 것으로 보이고, 아래 줄에 출력되는 결과는 들여쓰기가 없다.</p>

<pre><code>   2+2
4
</code></pre>

<p>결과가 출력되고 나면 바로 아랫줄에 다시 커서가 깜빡이고, 다른 표현식을 입력할 수 있다.</p>

<h2>1.2 산수</h2>

<p>곱셈을 위한 심볼은 <code>*</code>(asterisk)이다.</p>

<pre><code>   2*3
6
</code></pre>

<p>물론 아래와 같이 빈칸을 집어넣을 수도 있다.</p>

<pre><code>   2 * 3
6
</code></pre>

<p>결과는 똑같다. 빈칸은 있어도 되고 없어도 된다. 가독성을 위해서 필요하면 넣는다.</p>

<p>나눗셈을 위한 심볼은 <code>%</code>(percent)이다.</p>

<pre><code>   3 % 4
0.75
</code></pre>

<p>뺄셈을 위해서는 <code>-</code>를 쓴다.</p>

<pre><code>   3 - 2
1
</code></pre>

<p>다음 예제는 음수에 대한 것이다. 음수는 숫자 앞에 <code>_</code>부호가 붙는다. 숫자와 <code>_</code>사이에는 빈칸이 있어선 안 된다. <code>_</code>는 산수 할 때 쓰는 연산자가 아니라 숫자의 표현 중 하나이다. 마치 부동소수점을 표현할 때 수 중간에 <code>.</code>을 찍는 것과 같다.</p>

<pre><code>   2 - 3
_1
</code></pre>

<p><code>-</code>또한 음수를 만들어내기는 한다. 하지만 음수를 '만들어낸다'고 한 것에 주의해야 한다. <code>_</code>는 숫자를 표현하는 방식 중 하나이지만 <code>-</code>는 연산자라는 뜻이다.</p>

<pre><code>   - 3
_3
</code></pre>

<p>거듭제곱을 위해서는 <code>^</code>(caret)을 쓴다. 2의 3 제곱을 계산하면 아래와 같다.</p>

<pre><code>   2 ^ 3
8
</code></pre>

<p>그냥 제곱을 위한 연산자는 <code>*:</code>(asterisk colon)이다.</p>

<pre><code>   *: 4
16
</code></pre>

<h2>1.3 몇몇 용어들: 함수, 인자, 적용, 값</h2>

<p><code>2 * 3</code>을 한번 보자. 이건 <strong>두 인자에 곱하기 함수인 <code>*</code>가 적용되었다</strong> 라고 말할 수 있다. 왼쪽 인자는 <code>2</code>이고 오른쪽 인자는 <code>3</code>이다. 그리고 <code>2</code>와 <code>3</code>은 각 인자의 값이다.</p>

<h2>1.4 리스트</h2>

<p>리스트는 <code>1 2 3 4</code>와 같이 쓸 수 있다. 숫자 사이에 빈칸이 들어있음에 주의하자. 리스트에 있는 각 숫자의 제곱을 알고 싶으면 다음과 같이 쓴다.</p>

<pre><code>   *: 1 2 3 4
1 4 9 16
</code></pre>

<p>위 예제에서 "Square" 함수(<code>*:</code>)가 리스트의 각 아이템에 적용되었음을 알 수 있다. 리스트로 이루어진 두 개의 인자와 <code>+</code>같은 함수가 주어지면 그 함수는 두 리스트에서 서로 대응되는 아이템에 적용된다.</p>

<pre><code>   1 2 3 + 10 20 30
11 22 33
</code></pre>

<p>만약 한 인자는 리스트이고 다른 인자는 숫자 하나 라면, 숫자 하나는 리스트의 각 아이템에 대응된다.</p>

<pre><code>   1 + 10 20 30
11 21 31

   1 2 3 + 10
11 12 13
</code></pre>

<p>이런 식의 실험은 새로운 함수가 여러 인자 패턴에 어떻게 동작하는지 알아보는 데에 효과적이다. </p>

<p>예를 들어서 7을 2로 나누면, 몫이 3이고 나머지가 1이다. 나머지를 계산하는 J의 내장 함수는 <code>|</code>(vertical bar)이다. <code>|</code>의 이름은 "Residue"이다. 여러 패턴이 들어왔을 때 아래와 같은 결과가 나온다.</p>

<pre><code>   2 | 0 1 2 3 4 5 6 7
0 1 0 1 0 1 0 1

   3 | 0 1 2 3 4 5 6 7
0 1 2 0 1 2 0 1
</code></pre>

<p>Residue 함수는 "mod"(modulo)함수와 같다. 다만 이건 <code>2|7</code>이라고 쓰고, mod 함수는 7mod2라고 쓰는게 다르다.</p>

<h2>1.5 괄호</h2>

<p>필요하다면 표현식은 괄호를 포함할 수 있다. 괄호 안의 표현식은 따로 계산된다.</p>

<pre><code>   (2+1)*(2+2)
12
</code></pre>

<p>괄호는 항상 필요하지는 않다. <code>3*2+1</code>이라는 표현식을 보자. 이 식이 <code>(3*2)+1</code>로 해석되어 7이 될까, 아니면 <code>3*(2+1)</code>이 되어 9가 될까?</p>

<pre><code>   3 * 2 + 1
9
</code></pre>

<p>학교에서 수학을 배울 때에는 곱셈을 덧셈보다 연산을 먼저 한다고 배웠다. 이런 규칙이 있어서 괄호를 적게 쓸 수 있다.</p>

<p>J에는 그런 규칙이 없다. 먼저 따로 계산해야 할 부분이 필요하다면 괄호를 쓰면 된다. 하지만 괄호가 없다면 뒤부터(오른쪽부터) 계산된다. 다시 말하자면 자연스레 읽었을 때에 연산자의 오른쪽 인자부터 계산된다. 따라서 <code>3*2+1</code>의 경우에는 <code>*</code>의 오른쪽 인자인 <code>2+1</code>부터 계산된다. 다른 예제를 보자.</p>

<pre><code>   1 + 3 % 4 
1.75
</code></pre>

<p>여기서 <code>%</code>가 <code>+</code>보다 먼저 적용되는 것을 볼 수 있다. 즉 "제일 오른쪽 먼저" 연산이 시작되었다.</p>

<p>이 "제일 오른쪽 먼저" 규칙은 일반 수학의 "덧셈보다 곱셈 먼저"규칙하고는 다르다. 이 규칙이 별로 편하지 않다면 그냥 괄호를 쓰면 된다. 하지만 이 규칙을 사용하면 함수나 숫자가 엄청나게 많이 사용된 문장에서도 어디에서부터 계산해나가야 할지 쉽게 알 수 있다.</p>

<p>이 책에서는 "제일 오른쪽 먼저" 규칙을 적용 시킬 필요가 없다면 괄호를 쓸 것이다. 지금 여기서 중요한 건 코드를 잘 읽을 수 있을 정도로 표현식의 구조를 아는 것이다.</p>

<h2>1.6 변수와 할당</h2>

<p>영어 표현으로 'let <code>x</code> be <code>100</code>'라는 문장은 J로</p>

<pre><code>   x =: 100
</code></pre>

<p>로 나타낼 수 있다.</p>

<p>우리가 할당문이라고 불리는 이 표현식은 <code>100</code>이라는 값을 <code>x</code>라는 이름에 할당한다. 이 말은 즉 <code>x</code>라는 이름의 변수가 생성되고 이 변수에 <code>100</code>이라는 값을 넣었다고 할 수 있다. 만약 사용자가 입력한 한 라인에 할당문만 있다면 그 아래 결과가 출력되는 줄에는 아무런 값도 출력되지 않는다.</p>

<pre><code>   x - 1
99
</code></pre>

<p>값이 할당된 변수는 다른 표현식에서 가져다 쓸 수 있다.</p>

<pre><code>   y =: x - 1
</code></pre>

<p>여기서 <code>y</code>는 <code>x-1</code>의 결과 값을 저장하는 데에 쓰였다. 변수에 저장된 값을 살펴보고 싶다면 그냥 변수의 이름을 입력하면 된다. 그것만으로도 다른 표현식처럼 하나의 표현식이 된다. </p>

<pre><code>   y
99
</code></pre>

<p>같은 변수에 반복해서 할당이 가능하다. 마지막에 할당한 것이 변수에 담긴다.</p>

<pre><code>   z =: 6
   z =: 8
   z
8
</code></pre>

<p>변수는 그 변수에 할당된 값을 이용해서 자기 자신에게 새로운 값을 할당할 때에도 사용할 수 있다.</p>

<pre><code>   z =: z + 1
   z
9
</code></pre>

<p>위의 예제는 한 라인이 할당문으로만 이루어졌을 때에 결과 줄에 아무것도 출력되지 않음을 보여준다. 그럼에도 할당문 역시 하나의 표현식이다. 할당문이 어떤 표현식의 부분에 쓰였을 때에는 값으로 사용할 수 있다.</p>

<pre><code>   1 + (u =: 99)
100
   u
99
</code></pre>

<p>아래는 어떤 이름을 변수명으로 사용할 수 있는지에 대한 예제이다.</p>

<pre><code>   x                       =: 0
   X                       =: 1
   K9                      =: 2
   finaltotal              =: 3
   FinalTotal              =: 4
   average_annual_rainfall =: 5
</code></pre>

<p>변수명은 반드시 알파벳으로 시작해야 한다. 그리고 변수명은 알파벳(대문자, 소문자), 숫자(0-9), 밑줄(_)로 이루어진다. 그리고 대소문자를 가린다. 즉, <code>x</code>와 <code>X</code>는 다른 변수이다.</p>

<pre><code>   x
0
   X
1
</code></pre>

<h2>1.7 용어: 모나드와 다이아드(Monads and Dyads)</h2>

<p>오른쪽에 하나의 인자만 받는 함수를 모나딕 함수(monadic function)이라고 부른다. 줄여서 모나드라고 한다. 예를 들자면 "Square"(<code>*:</code>)함수가 있다. 함수의 오른쪽과 왼쪽에 인자를 하나씩 두어 총 두 개의 인자를 받는 함수를 다이아딕(dyadic) 함수라 부른다. 이 역시 줄여서 다이아드라고 한다. 위에서 봤던<code>+</code>가 그 예가 될 수 있겠다.</p>

<p>"Subtraction"(빼기) 함수와 "negation"(부정)함수는 같은 심볼(<code>-</code>)로 두가지 다른 기능을 하는 함수 중 하나이다. 다른 말로, <code>-</code>는 모나딕으로도 다이아딕으로도 사용할 수 있다는 것이다. 사실 J의 거의 모든 내장 함수가 모나딕과 다이아딕으로 사용될 수 있다. 아까 배웠던 나누기 함수, <code>%</code>도 그렇다. <code>%</code>는 다이아딕으로는 나누기이지만 모나딕으로 사용될 때는 역수 함수가 된다.</p>

<pre><code>   % 4
0.25
</code></pre>

<h2>1.8 내장 함수들 더 보기</h2>

<p>이 섹션의 목적은 J의 내장 함수 중 몇 개를 더 소개해서 J로 프로그래밍하는 걸 맛 보는데 있다.</p>

<p>영어로 "add together the numbers  2, 3, and 4, or more"말을 살펴보자. 이건 더 간단하게 다음과 같이 표현할 수 있다.</p>

<pre><code>add together 2 3 4
</code></pre>

<p>이걸 계산하면 9이다. 이걸 J로 표현하면 다음과 같다.</p>

<pre><code>   + / 2 3 4
9
</code></pre>

<p>영어 표현과 J의 표현을 비교해보자. "add"는 <code>+</code>에 대응되고 "together"는 <code>/</code>에 대응된다. 비슷하게 다음 표현을 생각해보자.</p>

<pre><code>multiply together 2 3 4
</code></pre>

<p>이걸 계산하면 24이다. 이건 J로 다음과 같이 표현한다.</p>

<pre><code>   * / 2 3 4
24
</code></pre>

<p><code>+/2 3 4</code>는 <code>2+3+4</code>와 같은 의미이고 <code>*/2 3 4</code>는 <code>2*3*4</code>와 같은 의미임을 알 수 있다. <code>/</code>는 "Insert"라고 한다. 이 녀석은 왼쪽에 있는 함수를 오른쪽의 리스트의 각 아이템 사이에 끼워 넣는 역할을 하기 때문이다. 일반화하여 말하자면, F가 임의의 다이아딕 함수이고, L이 숫자로 이루어진 리스트 a, b, c, .... y, z 라면</p>

<pre><code>F / L    은   a F b F .... F y F z   이다.
</code></pre>

<p>또 다른 함수를 더 알아보자. <br />아래에 세 가지 명제가 있다.</p>

<pre><code>2 는 1보다 크다     (명백히 참이다)
2 는 1과 같다          (거짓)
2 는 1보다 작다        (거짓)
</code></pre>

<p>J에서 "참"은 1로 표현하고, "거짓"은 0으로 표현한다. 그래서 위의 세 명제는 다음과 같이 쓸 수 있다.</p>

<pre><code>   2 &gt; 1
1

   2 = 1
0

   2 &lt; 1
0
</code></pre>

<p>만약 x가 수열이라면,</p>

<pre><code>   x =: 5 4 1 9
</code></pre>

<p>'x의 어떤 수가 2보다 큰가?' 라고 J에게 물어볼 수 있다.</p>

<pre><code>   x &gt; 2
1 1 0 1
</code></pre>

<p>위에서 보면, '어떤 게 2보다 큰가?'라는 물음에 첫 번째, 두 번째, 네 번째가 1로 표현되었다. x에서 2보다 더 큰 숫자가 존재하는지 알려면 이렇게 쓰면 될까?</p>

<pre><code>   * / x &gt; 2
0
</code></pre>

<p>틀렸다. <code>x&gt;2</code> 는 <code>1 1 0 1</code>인데 곱셈에(1<em>1</em>0*1) 0("거짓")이 들어있으면 죽어도 1이 될 수 없다.<br />x에 2보다 큰 수가 얼마나 많은지 알려면 어떻게 해야 할까? <code>x&gt;2</code>의 결과를 전부 더하면 된다!</p>

<pre><code>   + / x &gt; 2
3
</code></pre>

<p>x에 숫자가 몇 개 있는지 알려면? <code>x=x</code>의 결과를 모두 더하면 된다.</p>

<pre><code>   x
5 4 1 9

   x = x
1 1 1 1

   +/ x = x
4
</code></pre>

<p>그런데 이미 리스트의 길이를 반환하는 <code>#</code>이라는 내장 함수가 있다. </p>

<pre><code>   # x
4
</code></pre>

<h2>1.9 옆으로 늘어 놓아 표시하기</h2>

<p>우리가 컴퓨터에 J를 입력할 때, 입력한 문장과 결과 값은 아래로 주욱 내려가면서 붙어 표시된다. 아까 입력했던 몇 줄을 보면 알 수 있다.</p>

<pre><code>   x
5 4 1 9
   x = x
1 1 1 1
   +/ x = x
4
   # x
4
</code></pre>

<p>이제부터는 종종 옆으로 늘어놓아서 표시할 것이다. 밑의 표처럼 말이다.</p>

<table cellpadding="10" style="margin:20px 0px;" border="1">
<tbody><tr valign="TOP">
<td><tt> x </tt></td>
<td><tt>x = x</tt></td>
<td><tt>+/ x = x</tt></td>
<td><tt># x</tt></td>
</tr><tr valign="TOP">
<td><tt>5 4 1 9</tt></td>
<td><tt>1 1 1 1</tt></td>
<td><tt>4</tt></td>
<td><tt>4</tt></td>
</tr></tbody></table>

<p>이 표는 코드가 수행되는 순서에 따라서, <code>x</code>를 입력하면 <code>5 4 1 9</code>가 나오고, <code>x=x</code>를 입력하면 <code>1 1 1 1</code>이 나오고... 그런 의미이다. 이런 표시방식은 J에서 제공하는 것은 아니다. 하지만 여기에선 자주 쓸 거다. 첫째 줄에는 입력들이, 그 아래 줄에는 출력들이 나온다.</p>

<p>할당문(<code>x=:something</code>)을 입력했을 때에는 아무것도 표시되지 않은 것을 봤을 것이다. 그래도 할당문은 표현식이기 때문에 값을 가진다. 할당문의 값을 보거나, 뭔가를 기억하거나 보기에 쉽도록 종종 차례로 문장이 완성되는 것을 보여줄 거다. 예를 들자면 아래와 같다.</p>

<table cellpadding="10" style="margin:20px 0px;" border="1">
<tbody><tr valign="TOP">
<td><tt>x =: 1 + 2 3 4</tt></td>
<td><tt>x = x</tt></td>
<td><tt>+/ x = x</tt></td>
<td><tt># x</tt></td>
</tr><tr valign="TOP">
<td><tt>3 4 5</tt></td>
<td><tt>1 1 1</tt></td>
<td><tt>3</tt></td>
<td><tt>3</tt></td>
</tr></tbody></table>

<p>이제 다시 내장 함수로 돌아가자. 리스트가 하나 있다고 하자. 그럼 우리는 그 리스트를 차례대로 보면서 "통과, 통과, 아니, 통과, 아니" 하면서 특정 아이템들만 고를 수 있다. 리스트를 선택하기 위한 리스트(아까 말했던 "통과, 아니"의 리스트)는 J로는 <code>1 1 0 1 0</code>으로 표현할 수 있다. 이렇게 1과 0으로만 이루어진 리스트를 비트-스트링(bit-string)이라고 부른다. (비트-리스트나 비트-벡터라고 부르기도 한다.) <code>#</code>함수가 다이아딕으로 사용되면 왼쪽 인자로 들어온 비트-스트링을 이용해서 오른쪽 인자의 아이템을 골라서 새로운 리스트를 만든다.</p>

<table style="margin:20px 0px;" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt>y =: 6 7 8 9 10</tt></td>
<td><tt>1 1 0 1 0 # y</tt></td>
</tr><tr valign="TOP">
<td><tt>6 7 8 9 10</tt></td>
<td><tt>6 7 9</tt></td>
</tr></tbody></table>

<p>이제 y에서 특정한 조건을 만족하는 아이템만 고를 수도 있다. 예를 들자면 7보다 큰 수들 같은 것.</p>

<table style="margin:20px 0px;" cellpadding="10" border="1">
<tbody><tr valign="TOP">
<td><tt> y </tt></td>
<td><tt>y &gt; 7</tt></td>
<td><tt>(y &gt; 7) # y</tt></td>
</tr><tr valign="TOP">
<td><tt>6 7 8 9 10</tt></td>
<td><tt>0 0 1 1 1</tt></td>
<td><tt>8 9 10</tt></td>
</tr></tbody></table>

<h2>1.10 주석</h2>

<p>J에서 <code>NB.</code>심볼은 주석을 나타낸다. <code>NB.</code>심볼 부터 그 라인의 끝까지는 평가되지 않는다. 예를 들자면 아래와 같다.</p>

<pre><code>   NB.   여기는 라인 전체가 주석입니다.

   6 + 6   NB. 12가 출력돼야 합니다.
12
</code></pre>

<h2>1.11 내장 함수가 가진 이름의 구조</h2>

<p>J의 각 내장 함수들은 공식적인 이름과 비공식 이름이 있다. 예를 들어 공식적인 이름이 <code>+</code>인 함수는 비공식 이름이 "Plus"이다. 게다가 모나딕과 다이아딕의 경우도 생각해야 한다. 공식 이름이 <code>-</code>인 함수는 비공식 이름이 "Negate"와 "Minus"가 있다.<br />비공식적인 이름은 보통 한 단어 정도로 짧다. 이 이름은 J가 인식하지 못하기때문에 J에서는 반드시 공식적인 이름을 사용해야 한다. 이 책에서는 비공식 이름은 큰따옴표로 감싸서 표현한다. ("Minus"처럼)</p>

<p>거의 모든 내장 함수가 한 글자 내지 두 글자로 이루어진 공식적인 이름을 가지고 있다. (<code>*</code>나 <code>*:</code> 등등...) 두 번째 글자는 항당 <code>:</code>(colon)나 <code>.</code>(dot, full stop, period)이다.</p>

<p>두 글자로 이루어진 이름은 한 글자로 이루어진 함수와 뭔가 관련이 있다. "Square"(<code>*:</code>)는 "Times"(<code>*</code>)와 관련성이 있다. 느껴지는가?</p>

<p>따라서 J의 내장언어는 한 함수에 보통 6개 정도의 관련 함수들이 있다. 기본 함수에 더해서 위에서 말한 <code>:</code>와 <code>.</code>가 붙은 두 가지 변형과 각각에 대한 모나딕, 다이아딕까지 있다. 예제로 <code>&gt;</code>패밀리를 보자.</p>

<p>다이아딕 '<code>&gt;</code>'은 위에서 봤듯이 "Larger Than"이다.</p>

<p>모나딕 '<code>&gt;</code>'은 뒤에 나올 것이다.</p>

<p>모나딕 '<code>&gt;.</code>'은 올림 연산을 한다. 올림은 자기 자신보다 큰 정수 중 가장 가까운 수이다. 이것의 이름은 "Ceiling"이다.</p>

<pre><code>   &gt;. _1.7 1 1.7
_1 1 2
</code></pre>

<p>다이아딕 '<code>&gt;.</code>'은 두 인자 중 큰 녀석을 선택한다. ("Larger Of")</p>

<pre><code>   3 &gt;. 1 3 5 
3 3 5
</code></pre>

<p><code>/</code>를 이용해서 "Larger Of"를 리스트의 아이템 사이에 끼워 넣으면, 리스트에서 가장 큰 수를 뽑아낼 수 있다. 예를 들어서 리스트 <code>1 6 5</code>에서 가장 큰 수를 알아내려면 <code>&gt;. / 1 6 5</code>를 입력하면 된다. 아래 예제를 통해 어떻게 해서 <code>6</code>이 나오는지 확인할 수 있다. 주석은 왜 이전 입력과 같은 결과가 나오는지 이유를 설명한다.</p>

<pre><code>   &gt;. / 1 6 5
6
   1 &gt;. 6 &gt;. 5      NB. /의 의미에 따라서
6
   1 &gt;. (6 &gt;. 5)    NB. 제일 오른쪽 먼저 규칙에 따라서
6
   1 &gt;. (6)         NB. &gt;.의 의미에 따라서
6
   1 &gt;. 6           NB. ()의 의미에 따라서
6
   6                NB. &gt;.의 의미에 따라서
6
</code></pre>

<p>모나딕 '<code>&gt;:</code>'은 비공식적으로 "Increment"라고 부른다. 인자의 값에 1을 더한다.</p>

<pre><code>   &gt;: _2 3 5 6.3
_1 4 6 7.3
</code></pre>

<p>다이아딕 '<code>&gt;:</code>'은 "Larger or Equal"이다.</p>

<pre><code>   3 &gt;: 1 3 5 
1 1 0
</code></pre>

<p>이 책의 1장을 마친다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ SMACSS: Brief Notes - Part 2 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss-part2.html" />
    <updated>2012-03-31T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss-part2.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://smacss.com/">SMACSS</a>('smacks', 아마도 '스맥스'로 읽는다)에는 '<a href="http://snook.ca/">Jonathan Snook</a>'의 오랜 경험과 통찰이 담겨 있다. SMACSS는 프레임워크라기 보다는 스타일 가이드에 가까워서 만드는 사이트에 따라 그때그때 유연하게 사용할 수 있다.</p>

<p><em>Back-End 출신이라 CSS를 사용할 때마다 '이 많은 스타일은 어떻게 관리해야 할까?'라는 궁금증을 늘 가지고 있었다. 이 책은 그 궁금증을 해결해 준다.</em></p>

<p><a href="/articles/2012/smacss.html">Part 1</a>은 CSS Rule에 대하여 다루었고, Part 2는 SMACSS의 나머지 부분을 다룬다. <a href="/articles/2012/smacss.html">Part 1</a>에서 SMACSS는 4가지 중요한 Rule이 있다고 했는데 여기 하나가 더 추가되었다.</p>

<ul>
<li>Base - 기본 스타일</li>
<li>Layout - 엘리먼트를 나열하는 것과 관련된 스타일</li>
<li>Module - 재사용 위해 하나로 묶는 스타일</li>
<li>State - Hidden/Expand나 Active/Inactive 같은 상태를 스타일</li>
<li><strong>Theme - 사이트 전체가 보이는 느낌에 대한 스타일</strong></li>
</ul>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="SMACSS" title="" /></p>

<h2>테마 Rule</h2>

<p>우리가 <a href="/articles/2012/smacss.html">Part 1</a>을 쓸 당시 저자는 사실 이 부분을 SMACSS Rule에 넣기에는 부족하지만 어쨌든 한번은 다루어야 겠다는 생각을 했다고 언급했다. 결국은 SMACSS Rule에 들아갔다.</p>

<p>테마는 웹사이트에 따라 사용할수도 사용하지 않을수도 있다. 테마를 지원하는 사이트를 살펴보면 Google 메일이나 Yahoo 메일 같은 사이트가 있다. 비록 그대가 지금 만들고 있는 웹사이트가 테마를 지원하지 않더라도 알아둘 필요가 있다고 생각한다.</p>

<h3>테마</h3>

<p>딱히 설명이 필요 없지만 굳이 정의하자면 테마라는 것은 색상 및 이미지를 사용하여 사이트의 전체적인 Look and Feel을 결정한다. 테마와 관련된 부분을 따로 하나의 CSS로 분리해두면 나중에 새로운 테마를 만들거나 테마를 서로 바꿀 때 아주 적절하게 사용할 수 있다.</p>

<p>테마는 모든 스타일을 재정의 할 수 있다. 예를 들어 링크의 색상을 바꾼다거나 사이트 전체의 레이아웃을 변경할 수도 있다. 테마와 스타일을 분리하기 위해 클래스 이름을 쓰는 방법도 있지만 대개 테마를 하나의 파일로 분리하여 사용하면 될 것이다.</p>

<h3>타이포그러피</h3>

<p>마지막으로 중요한 것이 타이포그러피(역주: 활자라 부르고 싶다)이다. 종종 사이트의 타이포그러피를 전체적으로 변경해야 할 상황이 있다. 또한 예를 들어 여러 나라의 언어를 지원할 때 만약 한국어나 중국어의 글자는 크기가 작으면 읽기가 매우 힘들다. 이러한 경우에도 전반적인 글자 크기 조정이 필요하다.</p>

<p>타이포그러피는 Base, Module, State Rule에 영향을 미치지만 Layout에는 영향을 주지 않는다. 글자의 크기를 조절할 때 약 3가지 정도의 다른 크기를 정해서 사용하는 것이 좋다. 만약 여러 단계의 글자 크기가 있다면 사용자는 구별하기 힘들어 할 것이다.</p>

<h2>상태 변경</h2>

<p>사이트를 만들 때 어떤 부분은 처음부터 보이는 부분이 있고 어떤 부분은 어떤 상태가 변경이 되어야만 보이는 부분이 있다. 상태라는 것을 무엇으로 나타내고 어떻게 변경할 수 있을까?</p>

<p><strong>클래스 이름</strong></p>

<p>마우스를 움직이거나 키보드를 누르거나하는 이벤트가 발생하면 JavaScript를 사용하여 클래스 이름을 변경할 수 있다. 클래스 이름이 변경되면 스타일이 변경되고 그에 따라 보여지는 모습도 바뀔 것이다.</p>

<p><strong>Pseudo 클래스</strong></p>

<p>Pseudo 클래스를 사용하면 JavaScript를 사용하지 않고도 상태 변경을 보여줄 수 있다. 하자만 보통 인접한 엘리먼트만 변경할 수 있는 제한이 있다.</p>

<p><strong>미디어 쿼리</strong></p>

<p>페이지가 보여지는 화면의 크기에 따라 스타일을 변경할 수 있다.</p>

<h3>상태 변경 해보기</h3>

<p><a href="http://smacss.com/book/state">SMACSS - Changing State</a> 사이트에서 저자는 상태를 변경하는 여러 코드를 직접 보여주고 있다. '클래스 이름으로 상태 변경하기', 'Pseudo 클래스로 상태 변경하기', '미디어 쿼리로 상태 변경하기' 등의 예제를 볼 수 있다.</p>

<h2>SMACSS를 쓰면...</h2>

<p>이어지는 아래의 여러 내용은 SMACSS를 적용했을 때 기대할 수 있는 부분을 설명하고 있다.</p>

<h2>적용도(Depth of Applicability)</h2>

<p>깊이는 쉽게 말해 CSS 셀렉터의 길이를 의미한다. CSS 깊이 문제는 이미 만들어놓은 HTML 구조에 관련있는 것이고 HTML 구조를 그대로 CSS 셀렉터에 표현하면 너무 길어진다. 예를 들어 다음과 같은 CSS Rule이 있으면:</p>

<pre><code>#sidebar div, #footer div {
    border: 1px solid #333;
}

#sidebar div h3, #footer div h3 {
    margin-top: 5px;
}

#sidebar div ul, #footer div ul {
    margin-bottom: 5px;
}
</code></pre>

<p>div 엘레멘트를 기본으로 하여 다음과 같이 바꿀 수 있다.</p>

<pre><code>.pod {
    border: 1px solid #333;
}

.pod &gt; h3 {
    margin-top: 5px;
}

.pod &gt; ul {
    margin-bottom: 5px;
}
</code></pre>

<p>엘리먼트 마다 Class 셀렉터를 만들지 않고 <code>.pod</code> 하나만 만들었다. 깊이도 간단해졌고 문서 구조에 따라 의도하지 않은 CSS 적용도 피할 수 있다. 문서 구조는 변하지 않았지만 대신 적용해야 하는 부분마다 <code>.pod</code> 클래스를 지정해줘야 한다 이런 점이 고민할 부분이다. 한 쪽으로 치우치면 다른 한 쪽이 아쉬워진다.</p>

<p>이렇게 얕은 깊이의 CSS은 템플릿 엔진을 사용할 때 효과적이다. 이 CSS를 따르는 <a href="http://mustache.github.com/">Mushache</a>의 템플릿 코드를 살펴보자:</p>

<pre><code>&lt;div class="pod"&gt;
    &lt;h3&gt;{{heading}}&lt;/h3&gt;
    &lt;ul&gt;
        {{#items}}
        &lt;li&gt;{{item}}&lt;/li&gt;
        {{/items}}
    &lt;/ul&gt;
&lt;/div&gt;
</code></pre>

<p>중요한 점은 관리성, 성능, 가독성을 잘 조화시켜야 한다. CSS 셀렉터 길이가 너무 길면 HTML 여기저기 클래스 속성이 남발하는 것을 낮출 수 있지만 관리성과 가독성을 포기해야 한다. 반대로 모든 엘리먼트에 Class 셀렉터를 새로 만들어 줄 수도 있다. 이 예제에서 h3, h1에 까지 class 셀렉터를 부여하는 것은 불필요하다.</p>

<p>Container는 보통 Header, Body, Footer 영역으로 나눈다. 이 것은 일종의 디자인 패턴이라고 할 수 있다. 그래서 <code>.pod &gt; ul</code>을 다음과 같은 CSS Rule을 만들고 HTML에 적용시면:</p>

<pre><code>.pod-body {
    margin-bottom: 5px;
}
</code></pre>

<p>Container 안에서 ul, ol, div에서 클래스 지정만으로 같은 효과를 사용할 수 있다.</p>

<p>이렇게 단일 셀렉터를 사용하면 결국 '어떤 CSS 셀렉터를 사용해야 할지?' 더는 고민하지 않아도 된다. 특별한 이유가 없으면 이렇게 단일 셀렉터를 사용하는게 장땡이다.</p>

<h2>셀렉터 성능 고려</h2>

<p>성능을 위해 CSS 셀렉터를 어떻게 적용할 지 몇가지 팁을 제시하고 있다. 성능 측정을 위해 몇 가지 도구를 사용한다고 말하는데 <a href="http://css-tricks.com/efficiently-rendering-css/">Google Page Speed</a>같은 프로그램으로 한번 측정해보는 것이 적당할 것이다.</p>

<p>우선 스타일은 HTML의 엘리먼트가가 생성되는 시점에 적용이 된다. 브라우저는 HTML문서를 일종의 Stream으로 다룬다. 그러니까 먼저 들어온 엘리먼트를 먼저 생성한다. 다음 예제를 보면:</p>

<pre><code>&lt;body&gt;
    &lt;div id="content"&gt;
        &lt;div class="module intro"&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class="module"&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
            &lt;p&gt;Lorem Ipsum&lt;/p&gt;
            &lt;p&gt;Lorem Ipsum &lt;span&gt;Test-&lt;/span&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p><code>body, div#content, div.module.intro ...</code> 순으로 엘리먼트를 생성하고 스타일을 evaluate한다는 말이다. 각 엘리먼트를 Evaluate할 때 Font는 뭐고, 컬러는 뭐고, 높이나 넓으는 얼마인지 브라우저는 정리한 스타일대로 적용하고 그린다. 그리고 하위 엘리먼트의 크기가 바뀌면 브라우저는 Body를 다시 그려야(Repaint)한다고 생각한다(저자는 다른 변수가 있는 사례가 있다고 의심하지만 확실한 것은 보통 width와 height값이 바뀌면 다시 그린다는 것이다).</p>

<p>HTML이 실제로 Render되는 영상을 소개하고 있다. <a href='http://youtu.be/ZTnIxIA5KGw'>http://youtu.be/ZTnIxIA5KGw</a> 는 Firefox의 reflow/repaint 영상이다.</p>

<h3>Right to Left</h3>

<p>CSS는 오른쪽 부터 Evaluate한다. <code>#content &gt; div &gt; p</code> 같은 셀렉터가 있다면 <code>p</code> 엘리먼트가 그려질 때 마다 상위 <code>div</code>를 찾고 상위 <code>#content</code>를 찾는다. 스타일이 적용되기 위해 셀렉터가 찾아봐야 하는 엘리먼트의 갯수가 얼마나 될지 생각해봐야 한다.</p>

<h3>그외 다른 규칙은?</h3>

<p>Google Page Speed는 다음 네 가지 셀렉터 Rule은 비효율적이라고 말한다.</p>

<ul>
<li><code>#content h3</code>와 같은 Descendant Selector</li>
<li><code>#content &gt; h3</code>와 같은 Child Selector</li>
<li><code>div#content &gt; h3</code>와 같이 불필요한 엘리먼트까지 정의하는 Selector</li>
<li><code>div#content:hover</code>와 같이 link 엘리먼트가 아닌 엘리먼트에 :hover를 정의하는 Selector</li>
</ul>

<p>자세한 내용은 <a href="http://code.google.com/speed/page-speed/docs/rendering.html">Google Page Speed의 조언</a>을 참고하는 것이 좋다.</p>

<p><a href="http://css-tricks.com/efficiently-rendering-css/">Efficiently Rendering CSS</a> 사이트를 참고해 보는 것도 좋다.</p>

<h2>HTML5와 SMACSS</h2>

<p><a href="http://smacss.com/">SMACSS</a>는 당근 HTML5에 잘 들어맞는다. 사실 HTML4에도 잘 들어맞는다. <a href="http://smacss.com/">SMACSS</a>는 다음 두 가지 목표를 위해 노력하기 때문이다.</p>

<ol>
<li>증가: HTML과 Content에서 Section의 의미</li>
<li>감소: 특정 구조로 HTML을 만들거라는 기대</li>
</ol>

<p>특히 HTML5에서 새로 추가된 의미 태그는 1번 항목을 도와준다. 하지만 HTML5라고 해서 충분히 모든 의미를 포함할수는 없다. 클래스 속성을 통해서 아주 구체적인 의미를 밝힐 수 있다. 아래의 두 <code>&lt;nav&gt;</code> 엘리먼트는 클래스로 그 의미를 밝혀두고 있다. 클래스 속성에 따라 <code>nav-primary</code> 클래스는 가로 메뉴로, <code>nav-secondary</code> 세로메뉴로 만들수도 있다.</p>

<pre><code>&lt;nav class="nav-primary"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;…&lt;/ul&gt;
&lt;/nav&gt;

&lt;nav class="nav-secondary"&gt;
    &lt;h1&gt;External Links&lt;/h1&gt;
    &lt;ul&gt;…&lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h3>2단계 메뉴 목록</h3>

<p>SMACSS의 목표는 최대한 얕은 깊이의 셀렉터를 사용하는 것이다. 만약 아래와 같은 마크업이 있을 때 2단계를 어떻게 다르게 처리할 수 있을까.</p>

<pre><code>&lt;nav class="nav-primary"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;About Us
            &lt;ul&gt;
                &lt;li&gt;Team&lt;/li&gt;
                &lt;li&gt;Location&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<p>CSS 셀렉터를 중첩해서 쓰면 아래와 같다:</p>

<pre><code>nav.nav-primary li { 
    display: inline-block; 
}

nav.nav-secondary li,
nav.nav-primary li li {
    display: block;
}
</code></pre>

<p>자 여기서 엘리먼트를 제한하는 <code>nav</code>를 제거하고 셀렉터의 깊이도 더 얕게 만들어보면:</p>

<pre><code>.l-inline &gt; * { 
    display: inline-block;
}

.l-stacked &gt; * {
    display: block;
}
</code></pre>

<p>요렇게 만들어볼 수 있다. 마크업은 아래와 같이 수정되어야 한다.</p>

<pre><code>&lt;nav class="l-inline"&gt;
    &lt;h1&gt;Primary Navigation&lt;/h1&gt;
    &lt;ul&gt;
        &lt;li&gt;About Us
            &lt;ul class="l-stacked"&gt;
                &lt;li&gt;Team&lt;/li&gt;
                &lt;li&gt;Location&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h2>프로토타입</h2>

<p>좋은 프로그래머는 패턴을 좋아해~ 좋은 디자이너도 패턴을 좋아해~</p>

<p>패턴으로서 재사용성을 높일 수 있다. SMACSS는 코드에서도 디자인에서도 패턴을 찾아내려 애쓴다. 프로토타입을 써서 전체적인 혹은 빌딩 블록 각 부분의 코드와 디자인이 제대로 되었는가를 확인할 수 있다. 잘 만든 디자인과 코드는 재사용하기가 매우매우 좋다. <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> 과 <a href="http://960.gs/">960.gs</a>를 보라.</p>

<h3>프로토타입</h3>

<p>프로토타입을 통해 다음 사항을 확인해볼 수 있다.</p>

<p><strong>상태</strong></p>

<p>프로토타입에서는 정의해 둔 모든 상태에 대해서 테스트해 볼 수 있어야 한다. 데이터를 필요로 한다면 JSON이든 실제 서버든 간에 만들어서 테스트해보아야 한다.</p>

<p><strong>지역화</strong></p>

<p>사이트가 여러 언어를 지원하면 프로토타입을 통해 지역화를 지원하는지, 지역화를 통해 레이아웃이 손상되지 않는지 테스트 해볼 수 있다.</p>

<p><strong>의존관계</strong></p>

<p>프로토타입을 통해 각 모듈이 잘 보여지기 위한 최소의 필요조건을 테스트해볼 수 있다. 사이트가 커질수록 불필요한 부분을 줄이는것이 중요하다.</p>

<h3>퍼즐 맞추기</h3>

<p>야후처럼 아주 큰 사이트의 경우 프로토타입을 만들기 위한 시스템을 구축하여 부분적인 또한 전체적인 스타일을 테스트 해볼 수 있다. 운영하는 사이트가 규모가 작다면 이런 시스템은 오히려 배보다 배꼽이 더 클수도 있다. 사이트에 적당한 프로토타입을 정하는것이 중요하다.</p>

<p>좋은 모듈을 만들고 패턴을 재사용하기 좋게 만드는 것이 추구해야할 목적이다. <a href="http://www.flickr.com/photos/aarronwalter/5579386649/">MailChimp의 디자인 패턴 깜지</a>처럼 한눈에 보기쉽게 정리해두면 좋을 것이다.</p>

<p>패턴은 락(樂)이다. 패턴을 코드로 만듦도 락(樂)이다. 패턴을 리뷰하고 테스트 하는 프로세스를 만듦은 극락(極樂)이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ GitHub로 남의 프로젝트에 감놓고 배놓기 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/how-to-github.html" />
    <updated>2012-03-31T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/how-to-github.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://github.com/">GitHub</a>를 사용하여 오픈소스 프로젝트에 어떻게 참여할 수 있는 방법을 정리한다. GitHub에 계정이 있어야 하고 <a href="http://git-scm.org/">Git</a>을 어느정도 써 본 사람이어야 한다. </p>

<p><em>원문은 <a href="http://gun.io/">Rich Jones</a>의 <a href="http://gun.io/blog/how-to-github-fork-branch-and-pull-request/">How to GitHub: Fork, Branch, Track, Squash and Pull Request</a> 이다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/how-to-github/banner_ul2.png" alt="gun.io" title="" /></p>

<h2>저자 공지사항</h2>

<p><a href="http://github.com/">GitHub</a>에서 활동하는 개발자 중 저자의 <a href="http://gun.io/contracts/new/">구인구직 사이트</a>에 등록하면 구직하는 사람과 연결해준다고 한다. 관심있는 사람은 둘러보시길!</p>

<h2>자 시작!</h2>

<p><a href="http://github.com/">GitHub</a>에서 저장소를 새로 하나 만들면 아래와 같은 설명을 보여준다.</p>

<p><img src="/articles/2012/how-to-github/LiEI3.png" alt="GitHub" title="" /></p>

<p>GitHub은 새로운 프로젝트와 새로운 저장소를 만들었을 경우에 대한 설명은 친절하게 해주고 있다. 하지만 다른 프로젝트를 개선하고 참여하는 방법에 대해서는 그다지 좋은 설명을 해주고 있지 않다. 이 글은 그러한 점에서 도움이 될 것이다.</p>

<p>우선 시작하기 전에 고쳐보고 싶은 프로젝트를 하나 골라보자. GitHub에서 프로젝트를 찾아서 코드도 둘러보고 익숙한 개발방식을 갖고 있는지 확인도 해보고 커밋 로그도 살펴보고 참여하는 사람이 어떤 사람인지도 살펴들 보자.</p>

<h2>네트워크</h2>

<p><img src="/articles/2012/how-to-github/naZ6I.png" alt="GitHub Network" title="" /></p>

<p>네트워크 그림이다. 'mobile' 이라는 브랜치에서 누군가 열심히 작업을 하고 있기 때문에 'mobile'에 대한 일을 하는 수고는 하지 않는것이 좋을듯 하다.</p>

<p>우선 해야할 일은 프로젝트의 네트워크를 확인해보는 것이다. 네트워크를 확인함으로서 누가 어떤일을 하고 있는지를 살펴볼 수 있다. 네트워크를 한참 들여다보면 고쳐보고자 하던 부분도 이미 다른이가 하고 있는지 알수도 있다. 프로젝트 활동상황도 알 수 있으며 고친 부분이 어떻게 프로젝트에 Merge되는지도 알 수 있다.</p>

<h2>이슈 등록</h2>

<p><img src="/articles/2012/how-to-github/oksQI.png" alt="GitHub Issue" title="" /><br /><em>이슈가 왔어요!</em></p>

<p>프로젝트 화면에서 이슈메뉴로 가 봅시다. 얼마나 많은 이슈가 있는지 그리고 내가 고쳐보고픈 부분이 이미 이슈로 등록이 되어있는지 알 수 있다.</p>

<p>많은 사람들이 잊기 쉬운 이 과정이 왜 중요하냐면 고친점을 보내는 사람들은 보통 프로젝트의 관리자 즉 메인테이너가 같은 문제로 고민중이라는 점을 전혀 고려하지 않기 때문이다.</p>

<p>고쳐볼 부분이 아직 이슈로 등록이 안되어있다면 새로 하나 등록하자. 이슈를 등록할때는 메인테이너에게 공손히 프로젝트에 감사하다는 마음을 갖고 고쳐보고자 하는 버그나 개선사항을 적는거다.</p>

<p>메인테이너가 만들어진 이슈에 대한 댓글로 도움이 될 만한 점을 달아줄지도 모른다.</p>

<h2>Fork로 저장소 분리</h2>

<p><img src="/articles/2012/how-to-github/VWFCB.png" alt="Hardcore Fork" title="" /></p>

<p>'Fork' 버튼을 누르는 희열!! 복제된 저장소가 내 가슴속으로 들어왔다. 나의 복제된 저장소 페이지로 가보라! Clone해서 내려받을 수 있는 주소가 적혀있을 것이다. 바로 그냥 내려받는거다.</p>

<pre><code>git clone **your ssh/git url**
</code></pre>

<h2>Fork로 만든 저장소와 원본 저장소 연결</h2>

<p><img src="/articles/2012/how-to-github/bbNRs.png" alt="Fork" title="" /><br /><em>Fork가 이거냥!</em></p>

<p>이 과정이 꼭 필요한건 아니다. 하지만 단 한번만 이 프로젝트에 참여할 것이 아니라면 이 과정을 해두면 정말 쓸모있다. 아래 명령을 실행하여 원래 프로젝트 저장소를 'upstream'으로 등록해두면 원래 프로젝트의 변경사항을 계속 받아볼 수 있다. 'upstreamname'과 'projectname' 부분을 실제 프로젝트에 맞게 적당히 바꿔서 명령을 실행한다.</p>

<pre><code>git remote add --track master upstream git://github.com/upstreamname/projectname.git
</code></pre>

<p>자 이렇게 하면 <code>upstream</code> 이라는 리모트로 등록이 된다.</p>

<pre><code>git fetch upstream
</code></pre>

<p>이렇게 하면 원래 프로젝트의 최신 내용을 받아오고</p>

<pre><code>git merge upstream/master
</code></pre>

<p>이렇게 하면 최신 내용을 현재 작업하고 있는 브랜치에 Merge하게 된다. 짜잔!</p>

<h2>개발용 브랜치</h2>

<p><img src="/articles/2012/how-to-github/fI9qT.gif" alt="Old Internet" title="" /><br /><em>그 옛날의 인터넷이 생각나지 않나요들?</em></p>

<p>자 이제 고쳐야 할 부분에 집중하기 위해 <code>master</code> 브랜치에서 새로운 브랜치로 <code>checkout</code>할 때가 왔다. Pull Request는 Branch 단위로 하기 때문에 브랜치를 잘 만들어두는게 중요하다. 고쳐야 할 이슈가 여럿이라면 브랜치도 여러개 이어야 겠다. 아래처럼 해서 브랜치를 만들자:</p>

<pre><code>git branch newfeature
</code></pre>

<p>해당 브랜치로 바꾸려면 즉 <code>checkout</code> 하려면:</p>

<pre><code>git checkout newfeature
</code></pre>

<p>새로 만든 브랜치로 변경했다. 현재 위치한 브랜치를 확인하려면 <code>git branch</code>를 실행해보라.</p>

<h2>Hack!</h2>

<p>이제 실제 고치는 작업을 하자. 계획했던 고칠점이 맘에 들 때 까지 될대로 코드를 고쳐보고 테스트해보고 행복의 경지에 이르러보자. 음하하하~</p>

<h2>커밋 하나로 합치기</h2>

<p><img src="/articles/2012/how-to-github/FgOPu.png" alt="Squash" title="" /><br /><em>이게 '스쿼시'냥!</em></p>

<p>여러분도 나처럼 엄청나게 커밋을 해댄다면 커밋 메시지는 안봐도 거지같을게('동작함!', '안돌아감', '열여덟', '후아~', 등등) 뻔하다. 사실 이런 습관은 좋지 않지만 고치고 싶은 생각도 없고 이런 습관을 가진 사람도 많이 봤다.</p>

<p>Pull Request를 보내기 전에 여러 커밋을 하나 혹은 몇 개의 커밋으로 모아서 정리하고 싶을 수도 있다. 하여 <code>git rebase</code> 명령을 써 볼 것이다. 우선 <code>git log</code>로 커밋 메시지를 확인해보고 어떻게 정리할 지 생각해둔다. 마지막 3개의 커밋을 하나로 합치려면 아래와 같은 명령을 실행한다:</p>

<pre><code>git rebase -i HEAD~3
</code></pre>

<p>명령을 실행하면 Git은 기본 편집기를 불러내서 아래같은 내용을 보여준다.</p>

<pre><code>pick df94881 Allow install to SD 
pick a7323e5 README Junkyism 
pick 3ead26f rm classpath from git 
</code></pre>

<p>각 줄이 각 커밋에 해당하는데 하나로 합치려면 아래와 같이 내용을 수정한다.</p>

<pre><code>pick df94881 Allow install to SD 
squash a7323e5 README Junkyism 
squash 3ead26f rm classpath from git 
</code></pre>

<p>내용을 저장하고 편집기를 종료하면, 새로운 내용으로 편집기가 다시 뜰텐데 그때는 새로 하나로 만들어진 커밋 메시지를 입력하는 것이다. 거지같은 커밋이 깔끔하게 정리된 새 커밋으로 재탄생했다. 만쉐이~ 이제 Pull Request를 해도 부끄럽지 않겠다.</p>

<h2>Pull Request 보내기</h2>

<p>단장하고 커밋해놓은 브랜치를 서버 저장소로 아래와 같은 명령으로 보낸다:</p>

<pre><code>git push origin newfeature
</code></pre>

<p>그리고 GitHub 사이트로 가서 새로 만든 브랜치로 이동한다. 보통 기본으로 master 브랜치로 되어있을 것이다.</p>

<p><img src="/articles/2012/how-to-github/aAd2v.png" alt="Pull Request" title="" /><br /><em>Pull Request를 보내자</em></p>

<p>브랜치로 이동한 것을 확인하고 'Pull Request' 버튼을 누르자. 다음과 같은 화면이 나오는데 브랜치에서 변경한 내용에 대한 설명을 적어주고 'Submit Pull Request' 버튼을 눌러준다.</p>

<p><img src="/articles/2012/how-to-github/5Euiy.png" alt="Pull Request" title="" /><br /><em>Pull Request 설명 달기</em></p>

<p>룰루랄라~ 끝났다. 사실 완전히 다 끝난건 아니다. 'Pull Request' 보낸 커밋에 고칠점이 있다면 메인테이너는 'Pull Request'를 바로 받아주지 않고 해당사항을 고쳐달라고 할 것이다. 메인테이너가 'Pull Request'를 닫지(Clone) 않는 한 해당 브랜치로 커밋을 Push하면 다행히도 'Pull Request' 속으로 들어간다.</p>

<h2>Pull Request 받아서 Merge하기</h2>

<p>보너스! Pull Request를 받았을 때에는 어떻게 Merge하면 되는가! 그냥 버튼 하나만 누르면 된다. 쉽네. GitHub이 버튼 한 번만 누르면 모든게 자동으로 되도록 잘 만들어놨다. 간혹, 자동으로 되지 않을때가 있는데 그때는 직접 명령어를 써서 Merge해야 한다.</p>

<pre><code>git checkout master
git remote add contributor git://github.com/contributor/project
git fetch contributor
git merge contributor/newfeature
git push origin master
</code></pre>

<p>이렇게 하면 다른사람이 수정한 내용을 메인 master 브랜치로 merge하게 된다.</p>

<h2>Pull Request를 받아주지 않는 이유</h2>

<p>이 부분은 <a href="http://gun.io/blog/how-to-github-fork-branch-and-pull-request/">원본 페이지</a>를 확인하시라!</p>]]>
    </content>
  </entry>
</feed>
