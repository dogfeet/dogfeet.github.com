<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-02-28T06:14:41Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <entry>
    <title><![CDATA[ Login Popup & Captive Network ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/login-popup-captive-network.html" />
    <updated>2012-02-26T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/login-popup-captive-network.html</id>
    <content type="html">
<![CDATA[
<p>스마트폰이나 노트북을 항상 들고다니는 사람이 늘어남에 따라 모바일AP(즉, 핫스팟)을 이용하는 사람도 많이 늘어났다. 아직 회원가입이나 인증하지 않은 접속장치가 핫스팟에 접속하고 인터넷을 하면 핫스팟 제공자의 안내페이지나 로그인 페이지가 뜬다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/captive-network/firstwifi.jpg" alt="firstwifi" title="" /></p>

<h2>Captive Network &amp; Problem</h2>

<p>위의 화면은 한국에 가장 많이 사용되는 핫스팟 서비스인 ollehWifi(구, 네스팟)에 접속한 화면이다. 수 많은 호텔이나 큰 규모의 건물 혹은 장소들에서 위와 같은 핫스팟 사용 안내 페이지 혹은 인증 페이지를 볼 수 있다. 이러한 페이지를 Captive Portal이라고 한다.</p>

<p>물론 위에서 ollehWifi 서비스에 가입을 했고 해당 장치가 적절히 인증을 받았다면 위와 같은 화면이 뜨지 않고 바로 원하는 사이트로 이동한다. 인터넷에는 연결했지만, 사용자가 원하는 사이트가 아니라 다른 사이트가 나온다는 점에서 작은 문제가 생긴다.</p>

<p>Wifi를 통해 네트워크에 접속은 되었지만 모바일 어플리케이션이나 웹브라우저가 인터넷에 데이터를 요청하면 실제로 받는 데이터는 원하는 데이터가 아닌 Captive Network의 안내페이지의 데이터를 받아오게 된다. 예를 들어, Captive 네트워크에 스마트폰이 Wifi로 접속해 있다면 http 프로토콜로 JSON 데이터를 요청하는 어플리케이션에서는 html로 된 Captive Portal의 페이지 정보를 받게 될 가능성이 높다. 이러한 데이터 에러를 제대로 처리하지 못하면 어플리케이션에 심각한 문제가 발생할수도 있다.</p>

<h2>Captive Network Detection</h2>

<p>앞서 살펴본 ollehWifi 인증 화면 iOS에 설치된 Captive Network 에 대한 Portal 화면이다. 이 화면은 브라우저를 띄우지 않아도 Captive Network에 접속하게 되면 OS가 자동으로 띄워준다. OS는 이러한 환경을 어떻게 찾아낼 수 있는것일까? </p>

<p><img src="/articles/2012/captive-network/panera-captive.png" alt="panera-captive" title="" /><br /><sup><a href='http://www.docstechnotes.com/2011/07/os-x-lion-learns-wi-fi-login-trick-from.html'>http://www.docstechnotes.com/2011/07/os-x-lion-learns-wi-fi-login-trick-from.html</a></sup></p>

<p>모바일뿐만 아니라 요즘은 데스크톱 OS에서도 적용되어 있다. iOS의 경우 3.0부터, Mac의 경우 Lion부터, Win의 경우 Win7부터 적용된 것 같다. Lion의 경우 브라우저 말고 이런 팝업창에서 입력한 Captive Network에 대한 사용자ID와 패스워드를 OS 차원에서 저장해주기도 한다.</p>

<p><img src="/articles/2012/captive-network/mac-captive.png" alt="mac-captive" title="" /><br /><sup><a href='http://www.apple.com/macosx/whats-new/features.html#networking'>http://www.apple.com/macosx/whats-new/features.html#networking</a></sup></p>

<p>Captive Network인지를 확인하기 위해 Lion의 경우 Captive Service가 항상 동작하고 있으며 수시로 네트워크 상황을 확인한다. Captive Network인지 확인하기 위해서 다음과 같은 URL의 데이터를 불러와본다.</p>

<pre class="prettyprint"><code>$ curl <a href='http://www.apple.com/library/test/success.html'>http://www.apple.com/library/test/success.html</a>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;TITLE&gt;Success&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
Success
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

<p><code><a href='http://www.apple.com/library/test/success.html'>http://www.apple.com/library/test/success.html</a></code>의 데이터를 불러왔을 때 진짜로 원하는 데이터가 들어있는지 확인하는 <a href="http://erratasec.blogspot.com/2010/09/apples-secret-wispr-request.html">방식</a>이다. 간단하다. Windows또한 비슷한 방식을 사용하며 <a href="http://blog.superuser.com/2011/05/16/windows-7-network-awareness/">NCSI:Network Connectivity Status Indicator</a>라고 부른다.</p>

<h2>적용 및 참고</h2>

<p>어플리케이션이 네트워크를 통해 데이터를 불러와서 사용할 때 확인해야할 것으로 다음과 같은 것이 있다.</p>

<ul>
<li>장치가 네트워크를 사용할 수 있는지</li>
<li>네트워크를 통해 데이터를 불러올 수 있는지</li>
<li>불러온 데이터가 원하는 형식인지</li>
</ul>

<p>Captive Network의 경우 위에서 확인할 사항 중 세 번째 사항에 해당할 것이다. Captive Network에 대하여 알아보려면 다음과 같은 사이트를 더 참고해 볼 수 있다.</p>

<ul>
<li><a href="http://erratasec.blogspot.com/2010/09/apples-secret-wispr-request.html">Apple's secret "wispr" request</a></li>
<li><a href="http://www.mactalk.com.au/31/66812-iphone-3-0-wireless-captive-portal-support.html">iOS 3.0에서 Captive Network 찾기</a></li>
<li><a href="http://tools.ietf.org/html/draft-nottingham-http-portal-02">Web-based 인증을 위한 표준 제안</a></li>
<li><a href="http://blog.superuser.com/2011/05/16/windows-7-network-awareness/">Windows 7의 NCSI(Network Connectivity Status Indicator)</a></li>
</ul>

<h2>사족</h2>

<p>Captive Network에서 인증을 하지 않으면 원하는 사이트에 접근할 수 없고 접속할 수 있는 포트 또한 제한된다. 인증을 거쳐야만 제대로 사용할 수 있다. 하지만 보통 인증을 위하여 DNS 프로토콜 53번 포트는 열려있는 경우가 있으므로 이를 잘 활용해(SSH 터널링, Proxy) 볼 수도 있을 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ node: npm-tricks ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/npm-tricks.html" />
    <updated>2012-02-24T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/npm-tricks.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 Guillermo Rauch의 <a href="http://www.devthought.com/2012/02/17/npm-tricks/">NPM tricks</a>을 번역한 것이다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/npm/npm.png" alt="npm" title="" /></p>

<p>나는 매일매일 NPM을 사용한다. 왠지 사람들이 잘 모를 것 같아서 쓸만한 NPM 팁을 정리했다.</p>

<h2>Dev dependencies</h2>

<p>테스트 프레임워크같이 개발할 때만 필요한 '개발용' 모듈은 <code>devDependencies</code>에 넣는다:</p>

<pre class="prettyprint"><code>"devDependencies": {
    "module": "0.1.0"
}
</code></pre>

<h2>Introspecting package.json</h2>

<p>Node 0.6부터는 <code>require()</code>로 JSON 파일을 자동으로 읽어 준다. 그래서 쉽게 모듈의 package.json 파일을 이용할 수 있다:</p>

<pre class="prettyprint"><code>// considering the module lives in lib/module.js:
exports.version = require('../package').version;
</code></pre>

<p>특정 모듈의 package.json을 읽어 오려면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>require('my-module/package').name
</code></pre>

<h2>Linking</h2>

<p>동시에 모듈을 여러 개 개발해야 할 때에는 보통 모듈들이 서로 의존하게 된다. 문제가 없는 모듈만 NPM에 Publish하기 때문에 이 때에는 다른 방법이 필요하다.</p>

<p>이때 <code>npm link</code>로 NPM에 올리지 않고도 의존성을 해결할 수 있다. 의존하는 모듈에서 <code>npm link &lt;package&gt;</code>를 실행하면 <code>global</code>에 있는 모듈을 끌어다 놓는다(link). 예를 들어, <code>moduleB</code>가 아직 개발 중인 <code>moduleA</code>에 의존하는 상황을 살펴보자:</p>

<p>You can leverage <code>npm link</code> to generate a global reference to a module, and then run <code>npm link &lt;package&gt;</code> to install it in other modules. Consider the following example, in which <code>moduleB</code> depends on the version of <code>moduleA</code> you’re currently developing, and <code>moduleB</code> specifies <code>"moduleA"</code> as a dependency in its <code>package.json</code></p>

<pre class="prettyprint"><code>$ cd moduleA/
$ npm link
$ cd ../moduleB

# moduleB의 package.json에는 
# 아직 publish하지 않은 버전의 moduleA가 필요하다고 적혀 있기 때문에
# 'npm install'은 실패한다.
$ npm install

# global에 있는 moduleA를 local에 설치한다.
$ npm link moduleA

# moduleA는 이미 설치했으니까 'npm install'이 무시한다:
$ npm install
</code></pre>

<h2>Production flags</h2>

<p><code>npm install</code>할 때 <code>--production</code> 옵션을 주지 않으면 <code>devDependencies</code>에 있는 모듈을 설치해서 시간을 낭비하게 된다:</p>

<pre class="prettyprint"><code>$ npm install --production
</code></pre>

<p>설치하면서 발생하는 로그도 볼 수 있는데, 필요한 로그를 골라 볼 수 있다:</p>

<pre class="prettyprint"><code>$ npm install --loglevel warn
</code></pre>

<h2>Git dependencies</h2>

<p>NPM에 Publish하는 대신 <code>package.json</code>에 버전 대신 URI를 넣을 수 있다. Private 모듈이든 Public 모듈이든 <code>git://</code>로 시작하는 URI를 명시할 수 있다:</p>

<pre class="prettyprint"><code>"dependencies": {
    "public": "git://github.com/user/repo.git#ref"
    , "private": "git+ssh://<a href='mailto:git@github.com'>git@github.com</a>:user/repo.git#ref"
}
</code></pre>

<p><code>#ref</code>는 생략할 수 있지만 <code>master</code>같은 브랜치, <code>0.0.1</code>같은 태그, SHA 값을(짧은 SHA도 됨) 넣을 수 있다. 태그로 사용하는 것이 좋은데, <code>npm install</code>이 항상 최신 버전을 사용하도록 하는 태그를 사용하는 것이 좋다.</p>

<h2>Local binaries</h2>

<p>가끔은 의존하는 모듈의 <code>bin</code>을 가져다 써야 할 때가 있다. 이것은 테스트를 실행하거나 컴파일을 하려고 <code>Makefile</code> 만드는 것과 비슷하다.</p>

<p>다음과 같이 다른 곳에 설치된 프로그램을 사용하는 것이 아니라:</p>

<pre class="prettyprint"><code>test:
  mocha mytest.js
</code></pre>

<p>숨겨진 <code>node_mdoules/.bin</code> 디렉토리에 있는 local 모듈을 사용한다:</p>

<pre class="prettyprint"><code>test:
  node_modules/.bin/mocha mytest.js
</code></pre>

<p>여기서는 <code>"mocha"</code>를 사용하여 테스트한다. <code>mocha</code>를 <code>package.json</code>의 <code>devDependencies</code>에 넣는다. 그러면 <code>npm install</code>을 실행할 때 모듈이 설치된다.</p>

<p>Makefile을 따로 만들지 않을 거라면 <code>npm run-script</code> 명령어를 사용할 수 있다. <code>package.json</code>의 <code>scripts</code>에 다음과 같이 정의한다:</p>

<pre class="prettyprint"><code>"scripts": {
        "test": "mocha mytest.js"
          , "build": "uglify mycode.js
}
</code></pre>

<p>그러면 다음과 같이 실행할 수 있다:</p>

<pre class="prettyprint"><code>$ npm run-script test
$ npm run-script build
$ npm test # shortcut for `run-script test`
</code></pre>

<p>게다가, 환경변수 <code>$PATH</code>에 <code>./node_modules/.bin/</code>를 추가하면 어디서나 스크립트를 직접 실행할 수 있다!</p>

<h2>Private repositories</h2>

<p>개발 중인 모듈을 Publish하지 않을 때 <code>package.json</code>에 <code>private</code> 설정을 하면 실수로 Publish하는 일을 방지할 수 있다:</p>

<pre class="prettyprint"><code>"private": true
</code></pre>

<p>Private 저장소가 있으면 package.json에 registry로 등록할 수 있다:</p>

<pre class="prettyprint"><code>"publishConfig": { "registry": "<a href='https://yourregistry:1337/'>https://yourregistry:1337/</a>" }
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ 예제로 설명하는 자바스크립트에서의 Continuation-passing style ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html" />
    <updated>2012-02-24T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 <a href="http://matt.might.net/articles/by-example-continuation-passing-style/">By example: Continuation-passing style in JavaScript</a>를 번역한 것이다. CPS에 대해 열심히 적어놨는데 간단히 말하자면 함수 호출의 끝에 원래의 context로 돌아가지 않고, 새로이 불릴 함수를 caller가 넘겨주는 프로그래밍 스타일을 말한다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript/279433682_23ac618518.jpg" alt="recursive" title="" /></p>

<p>(Photo by <a href="http://www.flickr.com/photos/gadl/279433682/">gadl</a>)</p>

<p>컨티뉴에이션-패싱 스타일(CPS)은 1970년대에 프로그래밍 스타일의 하나로 생겨났고, 1980, 1990년대에 고급 프로그래밍 언어 컴파일러의 중간 표현으로써 주목받았다.</p>

<p>이 프로그래밍 스타일은 논 블로킹 시스템(그리고 보통 분산 시스템)에서 다시 조명받기 시작했다.</p>

<p>내가 박사 과정일 때에 CPS는 비밀무기였다. 그래서 난 CPS를 좋아한다. 아마 그 덕분에 난 2년 정도를 아낄 수 있었고, 끝없는 고통에서 벗어날 수 있었다.</p>

<p>이 글은 자바스크립트에서의 논 블로킹 프로그래밍 스타일로서의 CPS와 함수형 언어의 중간 형태로서의 CPS, 이렇게 두 가지 관점에서 CPS를 소개하는 글이다.</p>

<p>주제는 다음과 같다. </p>

<ul>
<li>자바스크립트에서의 CPS</li>
<li>Ajax 프로그래밍을 위한 CPS</li>
<li>(node.js에서) 논 블로킹 프로그래밍을 위한 CPS </li>
<li>분산 프로그래밍을 위한 CPS </li>
<li>CPS를 이용해서 예외처리하는 방법 </li>
<li>미니말 Lisp을 위한 CPS 컨버터 </li>
<li><strike>Lisp에서 call/cc 구현하는 방법</strike><sup>이 섹션은 이해가 모자라 제거했다.</sup></li>
<li>자바스크립트에서 call/cc 구현하는 방법 </li>
</ul>

<p>시작하자.</p>

<h2>'컨티뉴에이션-패싱 스타일'이 뭐야?</h2>

<p>만약 컨티뉴에이션을 지원하는 언어을 사용한다는 것은 프로그래머가 예외와 백트래킹, 스레드, 제네레이터(generator)등의 제어 구조를 추가할 수 있다는 것을 의미한다.</p>

<p>많은 컨티뉴에이션에 대한 설명은 막연하고 불충분하다. 뭔가 정말 도움이 되는 설명이 필요하다. 이 컨티뉴에이션-패싱 스타일이 바로 그런 것들을 해결해줄 것이다.</p>

<p>컨티뉴에이션-패싱 스타일은 코드라는 측면에서 컨티뉴에이션과 같다.</p>

<p>하지만, 다음의 원리만 깨우치면 프로그래머는 컨티뉴에이션-패싱 스타일을 스스로 깨달은 것이나 마찬가지다.</p>

<pre class="prettyprint"><code>어떠한 프로시저도 caller에 리턴(return)하지 않는다.
</code></pre>

<p>아래 힌트는 CPS로 프로그래밍하는 데 도움이 된다:</p>

<pre class="prettyprint"><code>프로시저는 리턴 값으로 호출 가능한 콜백을 받는다.
</code></pre>

<p>프로시저가 caller로 "리턴" 해야 할 때, 프로시저는 return 대신 "현재 컨티뉴에이션(current continuation)" 콜백을 호출한다. (이 콜백은 caller가 넘겨줬다.)</p>

<p>컨티뉴에이션은 퍼스트-클래스 리턴 포인트(first-class return point)이다.</p>

<h3>예제: 항등 함수</h3>

<p>항등 함수가 하나 있다:</p>

<pre class="prettyprint"><code>function id(x) {
    return x ;
}
</code></pre>

<p>이 것을 CPS로 하면 다음과 같다:</p>

<pre class="prettyprint"><code>function id(x,cc) {
    cc(x) ;
}
</code></pre>

<p>가끔 현재 컨티뉴에이션 인자를 ret로 명명해서 코드를 좀 더 명확하게 할 수 있다:</p>

<pre class="prettyprint"><code>function id(x,ret) {
    ret(x) ;
}
</code></pre>

<h3>예제: 단순무식한 팩토리얼</h3>

<p>아래는 보통의 단순무식한 팩토리얼이다:</p>

<pre class="prettyprint"><code>function fact(n) {
    if(n == 0)
        return 1 ;
    else
        return n * fact(n-1) ;
}
</code></pre>

<p>그리고 이를 CPS로 작성하면 다음과 같다:</p>

<pre class="prettyprint"><code>function fact(n,ret) {
    if(n == 0)
        ret(1) ;
    else
        fact(n-1,function(t0) { ret(n * t0) }) ;
}
</code></pre>

<p>그리고 이 함수를 실제로 "사용"할 때에는 다음과 같이 콜백을 넘겨준다:</p>

<pre class="prettyprint"><code>fact (5,function(n) {
    console.log(n); // 콘솔에 120이 출력된다.
})
</code></pre>

<h3>예제: Tail-recursive 팩토리얼</h3>

<p>아래는 tail-recursive 팩토리얼의 구현이다.</p>

<pre class="prettyprint"><code>function fact(n) {
    return tail_fact(n,1) ;
}

function tail_fact(n,a) {
    if(n == 0)
        return a ;
    else
        return tail_fact(n-1,n*a) ;
}
</code></pre>

<p>그리고 아래는 CPS.</p>

<pre class="prettyprint"><code>function fact(n,ret) {
    tail_fact(n,1,ret) ;
}

function tail_fact(n,a,ret) {
    if(n == 0)
        ret(a) ;
    else
        tail_fact(n-1,n*a,ret) ;
}
</code></pre>

<h2>CPS와 Ajax</h2>

<p>Ajax는 자바스크립트의 XMLHttpRequest 객체를 이용해 비동기적으로 서버에서 데이터를 가져오는 웹 프로그래밍 기술이다.</p>

<p>(데이터가 꼭 XML일 필요는 없다.)</p>

<p>CPS는 Ajax 프로그래밍을 우아하게 하는 방법을 제공한다.</p>

<p>XMLHttpRequest를 이용하면 블로킹 프로시저인 'fetch(url)'을 작성할 수 있다. 이 프로시저는 url이 가리키는 페이지의 내용을 변수에 담아 문자열로 리턴한다.</p>

<p>이런 방식의 문제는 자바스크립트가 단일 스레드만 지원하는 언어라는 점이다. 자바스크립트가 블럭되면 그동안 브라우저가 멈춰버린다.</p>

<p>그러면 사용자 경험이 망가진다.</p>

<p>더 나은 방식은 프로시저를 'fetch(url, callback)' 형식으로 만드는 것이다. 이 프로시저는 블로킹 되지 않기 때문에, 코드 실행이나 브라우저 렌더링을 막지 않는다. 이 프로시저에는 http 요청이 끝나고 호출되야 할 콜백을 넘겨준다.</p>

<p>이렇게 코딩하는 과정에서 부분적으로 코딩 스타일이 CPS로 자연스레 변한다.</p>

<h3>fetch 구현</h3>

<p>콜백 유무에 따라 non-blocking 모드나 블러킹 모드를 스위칭하며 동작하는 fetch는 어렵지 않게 구현할 수 있다:</p>

<pre class="prettyprint"><code>/*
 fetch는 클라이언트에서 서버로 리퀘스트를
 보낼 때 블로킹될 수도 있고 안될 수도 있다.

 만약 url만 넘겨주면 프로시저는 블로킹되고
 url이 가리키는 페이지의 내용을 리턴한다.

 만약 onSuccess 콜백이 주어지면 
 프로시저는 논 블로킹이 된다. 
 콜백은 페이지의 내용을 
 인자로 받아 호출될 것이다.

 만약 onFail 콜백까지 주어지면
 요청이나 응답이 실패했을 때에 
 onFail이 fatch 프로시저에 의해서 호출된다.
*/

function fetch (url, onSuccess, onFail) {
    // 콜백을 정의했을 때만 비동기로 작동한다.
    var async = onSuccess? true: false;
    // (이 라인의 비효율성에 대해 태클 걸지 
    //  않길 바란다. 이건 중요한 게 아니다.)

    var req ; // XMLHttpRequest 객체.

    // XMLHttpRequest 콜백:
    function rocessReqChange() {
        if(req.readyState == 4) {
            if(req.status == 200) {
                if(onSuccess)
                    onSuccess(req.responseText, url, req);
            } else {
                if(onFail)
                    onFail(url, req);
            }
        }
    }

    // XMLHttpRequest 객체를 만든다:
    if(window.XMLHttpRequest)
        req =new XMLHttpRequest();
    elseif(window.ActiveXObject)
        req =new ActiveXObject("Microsoft.XMLHTTP");

    // 비동기 모드라면 콜백을 세팅한다:
    if(async)
        req.onreadystatechange = processReqChange;

    // 서버로 요청한다.
    req.open("GET", url, async);
    req.send(null);

    // 비동기 모드라면,
    //  요청 객체를 리턴한다; 아니라면
    //  응답을 리턴하다.
    if(async)
        return req ;
    else
        return req.responseText ;
}
</code></pre>

<h3>예제: 데이터 가져오기</h3>

<p>UID의 이름을 가져오는 프로그램이 필요하다고 치고, fetch를 이용해서 두 버전(동기, 비동기)을 다 만들어보자.</p>

<pre class="prettyprint"><code>// 요청이 끝날 때까지 블로킹된다:
var someName = fetch("./1031/name") ;

document.write ("someName: "+ someName +"&lt;br&gt;") ;

// 블로킹되지 않는다:
fetch("./1030/name",function(name) {
    document.getElementById("name").innerHTML = name ;
}) ;
</code></pre>

<p>(<a href="http://matt.might.net/articles/by-example-continuation-passing-style/code/client.html">예제</a>)</p>

<h2>CPS and non-blocking programming</h2>

<p><a href="http://nodejs.org/">node.js</a>는 블로킹 프로시저가 없는 자바스크립트를 위한 고성능, 서버사이드 플랫폼이다. </p>

<p>node.js에서는 보통의 블로킹되는 프로시저(e.g. 네트워크, 파일 I/O)가 전부 콜백을 받고 결과는 콜백을 실행하는 것을 반환한다.</p>

<p>프로그램을 CPS로 변환하는 것으로 node.js 프로그래밍 다운 프로그래밍이 뭔지 살펴보자.</p>

<h3>예제 : 간단한 웹 서버</h3>

<p>node.js 웹 서버는 파일을 읽는 프로시저에 컨티뉴에이션을 넘긴다. select를 이용하는 것보다 CPS를 이용하는 것이 더 간단한 non-blocking IO이다.</p>

<pre class="prettyprint"><code>var sys = require('sys') ;
var http = require('http') ;
var url = require('url') ;
var fs = require('fs') ;

// 웹 서버 루트 경로:
var DocRoot ="./www/";

// 콜백을 넘겨주면서 웹 서버를 만든다:
var httpd = http.createServer(function(req, res) {
    sys.puts(" request: "+ req.url) ;

    // url 파싱:
    var u = url.parse(req.url,true) ;
    var path = u.pathname.split("/") ;

    // 경로에서 .. 를 없앤다.
    var localPath = u.pathname ;
    //  "&lt;dir&gt;/.." =&gt; ""
    var localPath = localPath.replace(/[^/]+\/+[.][.]/g,"") ;
    //  ".." =&gt; "."
    var localPath = DocRoot + 
    localPath.replace(/[.][.]/g,".") ;

    sys.puts(" local path: "+ localPath) ;

    // 요청받은 파일을 읽어서 되돌려 보낸다.
    // Note: readFile은 현재 컨티뉴에이션을 넘겨받는다.
    fs.readFile(localPath,function(err,data) {
        var headers = {} ;

        if(err) {
            headers["Content-Type"] ="text/plain";
            res.writeHead(404, headers);
            res.write("404 File Not Found\n") ;
            res.end() ; 
        } else {
            var mimetype = MIMEType(u.pathname) ;

            // 만약 'content type'을 못 찾으면
            // 클라이언트가 알아서 하도록 놔두자.
            if(mimetype)
                headers["Content-Type"] = mimetype ;

            res.writeHead(200, headers) ;
            res.write(data) ;
            res.end() ;
        }
    }) ;
}) ;

// 확장자와 MIME 타입을 매핑 시킨다:
var MIMETypes = {
    "html" :"text/html",
    "js"   :"text/javascript",
    "css"  :"text/css",
    "txt"  :"text/plain"
} ;

function MIMEType(filename) {
    var parsed = filename.match(/[.](.*)$/) ;
    if(!parsed)
        return false;
    var ext = parsed[1] ;
    return MIMEType[ext] ;
}

// 8000번 포트를 리스닝(listening) 포트로 하여 서버를 시작한다:
httpd.listen(8000) ;
</code></pre>

<h2>분산 컴퓨팅을 위한 CPS</h2>

<p>CPS를 사용하면 로컬과 분산에서 처리하는 것이 더 간단해진다.</p>

<p>조합(combination)을 계산해주는 함수인 choose를 작성해보자. 우선 일반적인 방법:</p>

<pre class="prettyprint"><code>function choose (n,k) {
    return fact(n) /
        (fact(k) * fact(n-k)) ;
}
</code></pre>

<p>이제 이 코드가 로컬 컴퓨터가 아닌 서버에서 동작해야 하면</p>

<p>fact 프로시저가 블로킹되어 서버에서 응답이 오기까지 기다리도록 작성할 수도 있지만, 이 방법은 좋지 않다.</p>

<p>대신 CPS로 choose를 작성해보자:</p>

<pre class="prettyprint"><code>function choose(n,k,ret) {
    fact (n,  function(factn) {
    fact (n-k,function(factnk) {
    fact (k,  function(factk) {
    ret  (factn / (factnk * factk)) }) }) })
}
</code></pre>

<p>이제 비동기적으로 팩토리얼을 계산하는 fact 프로시저 만들기가 쉬워졌다. 아래와 같이 말이다:</p>

<pre class="prettyprint"><code>function fact(n,ret) {
    fetch ("./fact/"+ n,function(res) {
        ret(eval(res))
    }) ;
}
</code></pre>

<h2>CPS로 예외처리하기</h2>

<p>프로그램을 CPS로 작성하면, 언어의 표준 예외처리 매커니즘이 쓸모없어진다. 하지만, CPS로 예외처리를 구현하는 것은 어렵지 않다.</p>

<p>예외처리는 컨티뉴에이션의 특수한 케이스다.</p>

<p>'현재 예외적 컨티뉴에이션(current exceptional continuation)'을 '현재 컨티뉴에이션(current continuation)'과 함께 던지는 것으로 try/catch 구문을 없앨 수 있다.</p>

<p>다음 예제는 Exception을 이용해서 팩토리얼 "total" 버전을 정의한다:</p>

<pre class="prettyprint"><code>function fact (n) {
    if(n &lt; 0)
        throw "n &lt; 0";
    else if(n == 0)
        return 1 ;
    else
        return n * fact(n-1) ;
}

function total_fact (n) {
    try{
        return fact(n) ;
    }catch(ex) {
        return false;
    }
}

document.write("total_fact(10): "+ total_fact(10)) ;
document.write("total_fact(-1): "+ total_fact(-1)) ;
</code></pre>

<p>예외를 처리하는 컨티뉴에이션을 추가해서 throw, try, catch 를 제거할 수 있다:</p>

<pre class="prettyprint"><code>function fact (n,ret,thro) {
    if(n &lt; 0)
        thro ("n &lt; 0");
    else if(n == 0)
        ret(1);
    else
        fact(n-1,
            function(t0) {
                ret(n*t0);
            }, thro);
}

function total_fact (n,ret) {
    fact (n,ret,
        function(ex) {
            ret(false);
        });
}

total_fact(10,function(res) {
    document.write("total_fact(10): "+ res);
});

total_fact(-1,function(res) {
    document.write("total_fact(-1): "+ res);
});
</code></pre>

<h2>컴파일에서 CPS</h2>

<p>지난 30년간 CPS는 함수형 언어 컴파일러에서 사용하는 강력한 중간 표현식이었다.</p>

<p>CPS는 함수의 리턴, 예외, <a href="http://en.wikipedia.org/wiki/Continuation#First-class_continuations">퍼스트-클래스 컨티뉴에이션(first-class continuation)</a>을 제거한다. 함수 호출은 그냥 하나의 점프 명령어로 치환된다.</p>

<p>다시 말해서, CPS는 컴파일러 대신에 많은 것들을 해결해준다. </p>

<h3>람다 계산법을 CPS로 바꾸기</h3>

<p>람다는 보편적인 계산을 할 수 있는 표현식(어플리케이션, 익명함수 변수 레퍼런스)을 가진 Lisp의 축소판이다. </p>

<pre class="prettyprint"><code>exp ::= (expexp)           ; 함수 어플리케이션
    |  (lambda (var) exp)  ; 익명 함수
    |  var                 ; 변수 레퍼런스
</code></pre>

<p>아래의 코드는 이 언어를 CPS로 변환해주는 도구다:</p>

<pre class="prettyprint"><code>(define (cps-convert term cont)
    (match term
        [`(,f ,e)
            ; =&gt;
            (let (($f (gensym 'f))
                    ($e (gensym 'e)))
               (cps-convert f `(lambda (,$f)
                    ,(cps-convert e `(lambda (,$e)
                        (,$f ,$e ,cont))))))]

        [`(lambda (,v) ,e)
            ; =&gt;
             (let (($k (gensym 'k)))
               `(,cont (lambda (,v ,$k)
                    ,(cps-convert e $k))))]

        [(? symbol?)
            ; =&gt;
            `(,cont ,term)]))

(define (cps-convert-program term)
    (cps-convert term '(lambda (ans) ans)))
</code></pre>

<p>관심 있는 사람은, <a href="http://www.brics.dk/~danvy/">올리비에 댄비(Olivier Danvy)</a>가 효과적인 CPS 변환기에 관한 많은 논문을 써냈으니 참고하길 바란다.</p>

<h2>JavaScript에서 call/cc 구현하기</h2>

<p>만약 어떤 자바스크립트 코드를 CPS로 바꾸고 싶다면 call/cc는 간단하게 정의할 수 있다.</p>

<pre class="prettyprint"><code>function callcc (f,cc) { 
    f(function(x,k) { cc(x) },cc)
}
</code></pre>

<h2>더 읽어 볼 것</h2>

<ul>
<li><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596101996">JavaScript: The Definitive Guide</a>, the best book on JavaScript.</li>
<li><a href="http://www.amazon.com/gp/product/0596517742?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596517742">JavaScript: The Good Parts</a>, the only other good JavaScript book.</li>
<li>Andrew Appel's timeless classic <a href="http://www.amazon.com/gp/product/052103311X?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=052103311X">Compiling with Continuations</a>.</li>
<li><a href="http://library.readscheme.org/page1.html">The Lambda Papers</a>.</li>
<li>My post <a href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">on programming with continuations by example</a>.</li>
<li><a href="http://faculty.cs.byu.edu/~jay/home/">Jay McCarthy</a> et al.'s papers on a continuation-based web-server.</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Backbone.js by example - Part 1 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/backbonejs-by-example.html" />
    <updated>2012-02-17T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/backbonejs-by-example.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 <a href="http://www.javageneration.com/">Chaker Nakhli</a>의 '<a href="http://www.javageneration.com/?p=839">Backbone.js by example</a>'을 번역한 것이다. Backbone.js를 처음 접하는 사람이 다른 자료를 보기 전에 보면 좋다.</em></p>

<p><a href="http://documentcloud.github.com/backbone/">Backbone.js</a>는 JavaScript MVC 라이브러리다. 클라이언트 코드를 깔끔하고 쉽게 만들고 관리할 수 있도록 도와준다. 나는 Backbone.js가 가볍고(~4.5kb) 내가 애플리케이션 관리하는 방식을 해치지 않아서 좋다. Backbone.js는 심지어 <a href="http://itsnat.sourceforge.net/php/spim/spi_manifesto_en.php">Single Page Interfaces</a>나 JavaScript Heavy 애플리케이션에도 사용할 수 있다. Backbone.js로는 클라이언트 코드를 확장하기 쉽고 관리하기도 쉬운 구조를 만들 수 있다.</p>

<p>나는 Backbone.js를 만난 지 몇 주 밖에 안됐지만, 사랑에 빠졌다. 이 글에서 단계별로 짚어가며 그래픽 편집기를 하나 만들어 볼 거다. 어떤 편집기인지 궁금하면 <a href="http://www.javageneration.com/wp-content/uploads/2012/01/editor.html">Demo</a>를 먼저 보자. 이 편집기의 JavaScript 코드는 100밖에 안된다. 우선 Model과 View에 집중할 거고 서버와 통신하기, 라우팅은 다음 글에서 다루겠다.</p>

<h2>Before we start</h2>

<p>이 그래픽 편집기는 파일을 3개로 구성한다. 파일은 editor.js, editor.css, editor.html 인 데 아직 editor.js, edtior.css는 빈 파일이다. 먼저 editor.html 파일을 보자:</p>

<pre class="prettyprint"><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" type="text/css" href="editor.css"&gt;
        &lt;script src="<a href='http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7/jquery.min.js'>http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7/jquery.min.js</a>"&gt;&lt;/script&gt;
        &lt;script src="<a href='http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.2.1/underscore-min.js'>http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.2.1/underscore-min.js</a>"&gt;&lt;/script&gt;
        &lt;script src="<a href='http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.5.3/backbone-min.js'>http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.5.3/backbone-min.js</a>"&gt;&lt;/script&gt;
        &lt;script src="editor.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="page" style="width:2000px;height:2000px;"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>나는 <a href="https://www.cloudflare.com/">cloudflare</a>가 제공하는 <a href="http://www.cdnjs.com/">cdnjs</a>를 사용했다. cloudflare에는 Google이나 Microsoft CDN이 제공하지 않는 것도 있다.</p>

<p><a href="http://jsfiddle.net/nakhli/td6Eg/5/">jsfiddle</a>에도 코드를 올려놓았으니 편한 대로 보면 된다. 각 절의 코드를 jsfiddle에 올려놓았다. 그러니 즉시 살펴보고, 테스트하고, Fork해 볼 수 있다.</p>

<p>이제 준비 운동은 끝냈으니 시작하자!</p>

<h2>Models</h2>

<p>간단한 도형을 나타내는 Model인 Shape 클래스를 만든다:</p>

<pre class="prettyprint"><code>var Shape = Backbone.Model.extend({
    defaults: { x:50, y:50, width:150, height:150, color:'black' },
    setTopLeft: function(x,y) {
        this.set({ x:x, y:y });
    },
    setDim: function(w,h) {
        this.set({ width:w, height:h });
    },
});
</code></pre>

<p>Shape 클래스는 Backbone.Model 클래스를 확장해서 만든다. 클래스를 확장하는 extend 메소드에 어떤 Model인지에 대한 정보를 인자로 넘긴다. 이 Model에 대한 설정은 defaults, setTopLeft, setDim 프로퍼티가 있다:</p>

<ul>
<li>defaults는 특별한 프로퍼티다. 이 프로퍼티에 Model의 기본 프로퍼티와 기본 값을 정의한다. 그래서 모든 Shape 인스턴스에는 x, y, width, height, color 프로퍼티가 있고 기본 값도 할당된다. 중요한 건 Backbone.js가 프로퍼티를 감싸준다는(encapsulation) 것이다. 직접 프로퍼티를 접근하기(getting/setting)보다 Backbone Model에서 상속한 get/set 메소드를 사용한다. Encapsulation 덕에 Model 프로퍼티가 수정되는 것을 관리할 수 있다. set 메소드가 호출되면 event가 발생한다. 그래서 이벤트 리스너를 등록하면 Model이 변경되는 것을 관리할 수 있다.</li>
<li>setTopLeft와 setDim은 Helper 메소드로 Backbone의 set 메소드를 호출한다. 이 메소드로 Shape의 크기와 위치를 좀 더 쉽게 설정한다.</li>
</ul>

<p>Model 클래스는 정의했으니 이제, 인스턴스를 만들고 프로퍼티에 이벤트를 바인딩하는 예제를 살펴보자(<a href="http://jsfiddle.net/nakhli/td6Eg/1/">jsfiddle</a>):</p>

<pre class="prettyprint"><code>var shape = new Shape();

shape.bind('change', function() { alert('changed!'); });
shape.bind('change:width', function() { alert('width changed! ' + shape.get('width')); });

shape.set({ width: 170 });
shape.setTopLeft(100, 100);
</code></pre>

<p>3번째 줄은 Model 프로퍼티가 변경될 때 발생하는 change 이벤트를 처리하도록 Listener를 등록하는 것이다. 4번째 줄의 코드는 'width' 프로퍼티만 Listen하는 거다. 6번째 줄에서 width 값을 바꾸면 두 Callback이 모두 실행된다. 하지만, 7번째 줄에서처럼 'setTopLeft' 메소드로 Shape의 위치를 변경하면 'change' 이벤트만 발생한다.</p>

<h2>Binding page elements to model changes</h2>

<p>Model을 정의하고 Change 이벤트 리스너를 등록하는 방법을 살펴봤다. 이제, 이 이벤트를 활용하는 방법을 살펴보자. html 페이지에 div 엘리먼트를 정의한다:</p>

<pre class="prettyprint"><code>&lt;div class='shape' /&gt;
</code></pre>

<p>Model이 바뀌면 엘리먼트도 바뀌게 묶는다(jQuery로 DOM 정보를 바꾼다).</p>

<pre class="prettyprint"><code>shape.bind('change', function() {
    $('.shape').css({ left:       shape.get('x'),
                      top:        shape.get('y'),
                      width:      shape.get('width'),
                      height:     shape.get('height'),
                      background: shape.get('color') });
});
</code></pre>

<p>매우 쉽다! Model을 수정하면 DOM도 바뀐다. Firebug 같은 브라우저 콘솔을 열어서 다음과 같이 실행해 본다:</p>

<pre class="prettyprint"><code>shape.setTopLeft(10, 10);
shape.setDim(500, 500);
</code></pre>

<p>그러면 페이지가 자동으로 업데이트되고 그 Shape 객체의 위치/크기가 새로 바뀐다. 여기서 중요한 것은 DOM을 직접 관리하지 않는다는 것이다. Model이 바뀌면 Model의 Listener가 페이지도 바꾼다. <a href="http://jsfiddle.net/nakhli/td6Eg/1/">jsfiddle</a>에서 한번 실행해 보자.</p>

<p>사용자가 뭔가 입력하는 상황을 살펴보자. 사용자가 입력해서 Model이 수정되면 간접적으로 페이지도 수정된다.</p>

<h2>Basic user input handling</h2>

<p>이 절에서는 사용자가 Shape 객체를 드래그할 수 있게 한다. mousedown, mouseup, mousemove 이벤트를 지켜보다가 Model을 업데이트하는 코드를 살펴보자(<a href="http://jsfiddle.net/nakhli/td6Eg/2/">jsfiddle</a>):</p>

<pre class="prettyprint"><code>var dragging = false;

$('.shape').mousedown(function (e) {
    dragging = true;
    shape.set({ color: 'gray' });
});

$('#page').mouseup(function () {
    dragging = false;
    shape.set({ color: 'black'});
});

$('#page').mousemove(function(e) {
    if(dragging) {
        shape.setTopLeft(e.pageX, e.pageY);
    }
});
</code></pre>

<p>여기서 보면 shape의 div 엘리먼트가 아니라 page 엘리먼트의 mousemove와 mouseup 이벤트를 Listen한다. 마우스가 div 개체의 영역에서 벗어나도 div 객체가 마우스 포인터를 따라다녀야 하기 때문에 그렇게 한다.</p>

<p>사용자 입력을 jQuery로 간단하게 처리한다는 게 포인트이다. 여기에 DOM을 수정하는 코드는 하나도 없다. 단지 이벤트를 지켜보다가 Model을 바꾼다. 그러면 신기하게도 페이지는 업데이트된다.</p>

<p>정리하자. 사용자 입력을 처리하는 코드, Model을 관리하는 코드, Model이 바뀌면 View도 바꾸는 코드를 분리시켰다. 이제 막 우리는 MVC(Model-View-Controller)를 구현했다.</p>

<p>관련된 것끼리 따로 모으는 방법은 좋다. JQuery Callback이 매우 많은 페이지에서 Callback 스파게티로 만들지 않을 수 있다. 하지만, 아직 더 개선할 수 있다. 아직 Controller 코드와 View 코드가 마구 섞여 있는데 View 클래스 정의해서 해결할 수 있다.</p>

<h2>Model Collections</h2>

<p>Backbone Model에는 Collection이라는 Model이 있다. Collection은 Model을 정렬된 집합으로 관리할 수 있게 도와주는 Container다. 이 Collection은 add, remote 이벤트가 있고 이 이벤트를 Listen할 수 있다.</p>

<p>Model 컬렉션을 사용한다. Shape 객체를 담는 Collection인 'Document' Model를 만들자:</p>

<pre class="prettyprint"><code>var Document = Backbone.Collection.extend({ model: Shape });
</code></pre>

<p>Document 객체를 만들고 add, remote 이벤트 리스너를 등록한다:</p>

<pre class="prettyprint"><code>var document = new Document();

document.bind('add', function(model) { alert('added'); });
document.bind('remove', function(model) { alert('removed'); });

document.add(shape); // fires add event
document.remove(shape); // fires remove event
</code></pre>

<h2>Views</h2>

<p>Backbone.js에서 View는 Model(이나 Collection)과 함께 사용한다. View의 역할은 다음과 같다:</p>

<ul>
<li>Model을 DOM 엘리먼트로 렌더링한다. Model의 change 이벤트를 지켜보고 있다가 바뀌면 페이지도 바꾼다.</li>
<li>DOM 엘리먼트의 이벤트를 처리하고 다시 Model을 업데이트한다.</li>
</ul>

<p>MVC 이론과 비교했을 때, Backbone의 View는 View와 Controller의 역할을 둘 다 떠맡는다. Backbone의 View는 사용자 입력(DOM 이벤트)을 처리하고 Model도 업데이트한다. 게다가 Model 이벤트를 Listen하다가 바뀌면 다시 화면을 업데이트한다. 하지만, 실제로 구현할 때 다른 메소드에 구현할 거라서 이 점은 별로 중요하지 않다. </p>

<h3>Shape View</h3>

<p>Shape Model을 사용하는 Shape View 코드를 살펴보자. 이 View는 Shape을 표현하는 Html 엘리먼트와 그 Html 엘리먼트를 감싸는(Decorate) 'control' 엘리먼트를 관리한다. 'control' 엘리먼트는 사용자가 Shape을 드레그하고, Shape의 크기를 바꾸고, Shape을 삭제하고, Shape의 색을 바꿀 수 있게 해준다.</p>

<pre class="prettyprint"><code>var ShapeView = Backbone.View.extend({
    initialize: function() {
        this.model.bind('change', this.updateView, this);
    },
    render: function() {
        $('#page').append(this.el);
        $(this.el)
            .html('&lt;div class="shape"/&gt;'
                  + '&lt;div class="control delete hide"/&gt;'
                  + '&lt;div class="control change-color hide"/&gt;'
                  + '&lt;div class="control resize hide"/&gt;')
            .css({ position: 'absolute', padding: '10px' });
        this.updateView();
        return this;
    },
    updateView: function() {
        $(this.el).css({
            left:       this.model.get('x'),
            top:        this.model.get('y'),
            width:      this.model.get('width') - 10,
            height:     this.model.get('height') - 10 });
        this.$('.shape').css({ background: this.model.get('color') });
    },
    events: {
        'mousemove'               : 'mousemove',
        'mouseup'                 : 'mouseup',
        'mouseenter .shape'       : 'hoveringStart',
        'mouseleave'              : 'hoveringEnd',
        'mousedown .shape'        : 'draggingStart',
        'mousedown .resize'       : 'resizingStart',
        'mousedown .change-color' : 'changeColor',
        'mousedown .delete'       : 'deleting',
    },
    hoveringStart: function () {
        this.$('.control').removeClass('hide');
    },
    hoveringEnd: function () {
        this.$('.control').addClass('hide');
    },
    draggingStart: function (e) {
        this.dragging = true;
        this.initialX = e.pageX - this.model.get('x');
        this.initialY = e.pageY - this.model.get('y');
        return false; // prevents default behavior
    },
    resizingStart: function() {
        this.resizing = true;
        return false; // prevents default behavior
    },
    changeColor: function() {
        this.model.set({ color: prompt('Enter color value', this.model.get('color')) });
    },
    deleting: function() {
        this.remove();
    },
    mouseup: function () {
        this.dragging = this.resizing = false;
    },
    mousemove: function(e) {
        if (this.dragging) {
            this.model.setTopLeft(e.pageX - this.initialX, e.pageY - this.initialY);
        } else if (this.resizing) {
            this.model.setDim(e.pageX - this.model.get('x'), e.pageY - this.model.get('y'));
        }
    }
});
</code></pre>

<p>코드는 좀 길지만 매우 간단하다. 중요한 것만 짚어보자:</p>

<ul>
<li>initialize는 View가 생성될 때 실행되는 함수다. Model의 이벤트 리스너를 등록하려면 여기서 해야 한다. View에서 Model change 이벤트를 등록한다.</li>
<li>render는 View를 초기화하고 나서 실행된다. 여기서 View에 필요한 Html 엘리먼트를 초기화하고 DOM에 추가한다. View의 Html 엘리먼트를 el 프로퍼티에 할당시켜 놓는다. 이 el 프로퍼티는 Backbone View에서 상속받은 거다. 먼저 '#page'에 el을 추가하고 그다음 줄에서 shape과 control 엘리먼트를 추가한다. 그리고 마지막 줄에서 Model을 View에 적용한다.</li>
<li>View에서 events 해시는 매우 중요하다. 이 부분이 이벤트와 리스너를 연결하는 부분이다. <code>{ 'event selector': 'handler' }</code> 형식으로 정의한다. 예를 들어 <code>{ 'mousedown .shape': 'draggingStart' }</code>는 '.shape' 에 mousedown 이벤트가 Fire되면 draggingStart 메소드를 실행시킨다. 이 events 해시는 사용자 입력을 어떻게 처리할지를 정의하는 것인데 이 부분이 Controller 역할에 해당한다.</li>
</ul>

<p>사실 여기에 기술적인 문제가 조금 있다. 'Basic user input handling' 절에서도 말했지만, Shape Div 그 자체가 아니라 부모인 page 엘리먼트의 mousemove와 mouseup 이벤트를 Listen하고 있어야 더 나은 UX를 얻을 수 있다. 현 코드는 사용자가 마우스를 너무 빨리 움직일 때 부드럽지 못하다. 이 코드는 <a href="http://jsfiddle.net/nakhli/td6Eg/4/">jsfiddle</a>에 구현했다.</p>

<h3>Document View</h3>

<p>먼저 만들었던 Document Model를 위한 DocumentView도 만들어야 한다. 그래야 Shape View를 관리할 수 있다:</p>

<pre class="prettyprint"><code>var DocumentView =  Backbone.View.extend({
    id: 'page',
    views: {},
    initialize: function() {
        this.collection.bind('add', this.added, this);
        this.collection.bind('remove', this.removed, this);
    },
    render: function() {
        return this;
    },
    added: function(m) {
        this.views[m.cid] = new ShapeView({
            model: m,
            id:'view_' + m.cid
        }).render();
    },
    removed: function(m) {
        this.views[m.cid].remove();
        delete this.views[m.cid];
    }
});
</code></pre>

<p>id 프로퍼티는 View에 묶인 DOM의 id다. Backbone은 이 값으로 DOM을 찾아 el 프로퍼티를 설정한다. 이미 html 페이지에 있는 엘리먼트를 사용하기 때문에 render 메소드에서 새로 만들지 않는다.</p>

<p>initailize 메소드에서 Collection View의 add, remove 이벤트 Listener를 등록한다. Add 이벤트에서 Shape Model과 View를 만들고 렌더링한다. Shape View는 모두 views 프로퍼티에서 관리한다. 그리고 remove 이벤트가 발생하면 document에서 해당 Shape을 페이지에서도 삭제하고 views 프로퍼티에서도 삭제한다.</p>

<p>이 코드는 <a href="http://jsfiddle.net/nakhli/td6Eg/4/">jsfiddle</a>에 있다.</p>

<h2>Conclusion</h2>

<p>이 소스는 <a href="https://gist.github.com/1596813">github</a>와 <a href="http://jsfiddle.net/nakhli/td6Eg/5/">jsfiddle</a>에 있다. 그리고 <a href="http://www.javageneration.com/wp-content/uploads/2012/01/editor.html">데모</a>도 있다.</p>

<p>이 튜토리얼은 Backbone.js의 MVC와 이벤트 시스템이 어떻게 생겼는지 보여준다. 앞에서도 언급했지만, 아직 서버와 통신하기, 라우팅에 대해서 다루지 않았다. Backbone.js는 CRUD를 쉽게 처리할 수 있도록 돕는다. 다음 글에서는 이 내용을 다룰 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: Global Ignore ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-global-ignore.html" />
    <updated>2012-02-09T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-global-ignore.html</id>
    <content type="html">
<![CDATA[
<p>GitHub에서 관리하는 <code>.gitignore</code> 패턴 템플릿이 있어 소개한다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-global-ignore/ignorelo.png" alt="무시로" title="" /></p>

<h2>gitignore</h2>

<p>파일을 무시하는 패턴을 설정하는 방법은 세 가지이다:</p>

<ol>
<li><code>.git/info/exclude</code>는 해당 저장소에만 적용되고 전송되지 않는다. 그러니까 Clone되지 않고 Push할 수 없다.</li>
<li><code>.gitignore</code>는 해당 저장소에만 적용되지만 전송된다.</li>
<li><code>core.exlcudesfile</code> 설정</li>
</ol>

<p>파일 형식은 모두 같고, 세 파일은 있는 대로 동시에 적용될 수 있다. 우선순위는 나열한 순서대로다.</p>

<p><code>core.exlcudesfile</code> 설정은 다음과 같다:</p>

<pre class="prettyprint"><code>$ git config --global core.excludesfile ~/.global_ignore
</code></pre>

<h2>gitignore 프로젝트</h2>

<p>Github는 친절하게도 '언어 및 환경'마다 권장 gitignore 파일 템플릿을 모아 두었다. GitHub의 <a href="https://github.com/github/gitignore">gitignore 저장소</a>에 가서 Clone하고 필요한 템플릿을 사용해보자.</p>

<p>저장소에는 루트 디렉토리에 있는 것과 <code>Global/</code> 디렉토리에 있는 것으로 나누어져 있는데 Global/ 디렉토리에 있는 것은 'OS-specific, editor-specific'인 것이다.</p>

<p>예를 들어 자바라면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>$ cat Maven.gitignore &gt;&gt; ~/.global_ignore
$ cat Java.gitignore &gt;&gt; ~/.global_ignore
$ cat Global/Eclipse.gitignore &gt;&gt; ~/.global_ignore
$ cat Global/vim.gitignore &gt;&gt; ~/.global_ignore
$ cat Global/OSX.gitignore &gt;&gt; ~/.global_ignore
$ git config --global core.excludesfile ~/.global_ignore
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Ladybucks: A Chrome extension for Starbucks WI-FI ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/ladybucks.html" />
    <updated>2012-02-08T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/ladybucks.html</id>
    <content type="html">
<![CDATA[
<p>Ladybucks는 Chrome extension으로 스타벅스에서 WI-FI를 편하게 사용하기 위해 만들었다. 단순히 스타벅스에서 요구하는 정보를 저장했다가 해당 페이지가 뜨면 정해진 페이지 흐름대로 자동으로 입력하고 처리해준다.</p>

<p>이 프로그램은 실제로 한국 Starbucks 매장에서 사용할 수 있지만 JavaScript Example로 만들고 싶었다. 그래서 <code>Chrome Extension</code>에서 <code>BootStrap</code>과 <code>Backbone.js</code>를 사용하는 예제로 참고할 수 있도록 만들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/ladybucks/intro.png" alt="logo" title="" /></p>

<p>Ladybucks는 원래 <a href="https://twitter.com/#!/lethee">@lethee</a>가 Safari 버전으로 만들었고 <a href="https://twitter.com/#!/lnyarl">@lnyarl</a>가 Chrome 버전으로 포팅하였다. 그걸 <a href="http://uniquenoun.tumblr.com">@uniquenoun</a>이 디자인하고 <a href="https://twitter.com/#!/pismute">@pismute</a>가 다시 패키징했다.</p>

<h2>설치하기</h2>

<p>소스는 <a href="https://github.com/pismute/ladybucks">저장소</a>에서 확인할 수 있고 <a href="https://pismute.github.com/ladybucks/ladybucks.cpk">ladybucks.cpk</a>를 내려받는다.</p>

<p>패키지 파일을 Chrome에서 열면 설치할 수 있다.</p>

<h3>사용하기</h3>

<p>'tools/extensions' 메뉴를 클릭해서 extensions 페이지(<code>chrome://settings/extensions</code>)를 열고 Ladybucks Extension의 options을 클릭해서 option 페이지를 연다.</p>

<p><img src="/articles/2012/ladybucks/extensions.png" alt="extentions" title="" /></p>

<p>이 페이지에서 Starbucks Wi-Fi 이용 시 사용할 신상정보(이름, 주민번호)를 입력한다.</p>

<p><img src="/articles/2012/ladybucks/option.png" alt="option" title="" /></p>

<p>그리고 Starbucks에서 Wi-Fi 접속 페이지가 열리면 자동으로 신상정보를 입력하고 클릭해서 Wi-Fi에 연결해 준다.</p>

<p><img src="/articles/2012/ladybucks/success.png" alt="success" title="" /></p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ SMACSS: Brief Notes - Part 1 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss.html" />
    <updated>2012-02-03T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://smacss.com/">SMACSS</a>('smacks', 아마도 '스맥스'로 읽는다)에는 '<a href="http://snook.ca/">Jonathan Snook</a>'의 오랜 경험과 통찰이 담겨 있다. SMACSS는 프레임워크라기 보다는 스타일 가이드에 가까워서 만드는 사이트에 따라 그때그때 유연하게 사용할 수 있다.</p>

<p><em>Back-End 출신이라 CSS를 사용할 때마다 '이 많은 스타일은 어떻게 관리해야 할까?'라는 궁금증을 늘 가지고 있었다. 이 책은 그 궁금증을 해결해 준다.</em></p>

<p>이 책은 두 번으로 나눠서 정리할 것인데 Part 1은 CSS Rule에 대하여, Part 2는 SMACSS의 나머지 부분을 다룰 예정이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="SMACSS" title="" /></p>

<h2>Introduction</h2>

<p>저자인 Snook가 경험했던 Best Practice를 SMACSS라는 책으로 정리했다. 이 방법은 규모에 상관없이 효과적이라서 프로젝트 초반부터 성장하는 내내 유용하다고 설명한다.</p>

<p>Snook도 말하고 있지만 SMACSS는 프레임워크가 아니라 스타일 가이드다. 그래서 어떤 라이브러리나 도구도 제공하지 않는다. SMACSS는 CSS를 어떻게 구성하고 사용해야 하는가를 설명한다.</p>

<p>SMACSS은 다음과 같은 주제를 다룬다:</p>

<ul>
<li>Four Types of CSS Rules - SMACSS의 핵심, CSS를 네 가지로 분류하고 어떻게 구분해 사용하는지 설명</li>
<li>Themes and Typography - Theme와 Font에 대해 설명</li>
<li>Depth of Applicability - Selector를 길게 만드는 것이 좋은지 짧게 만드는 것이 좋은지 설명. 즉, tradeoff에 대한 설명.</li>
<li>Selector Performance - 브라우저가 Selector를 어떻게 찾는지 설명</li>
<li>State Representation - 상태에 대한 표현 기법</li>
<li>HTML5 and SMACSS - HTML5와 함께 사용하는 법</li>
<li>Prototyping - 만들어놓은 CSS를 실제 사용하기 전에 테스트해 보는 과정</li>
<li>Formatting Code - CSS 코드 형식을 정리하는 법</li>
</ul>

<p>이 중 <code>Four Types of CSS Rules</code>이 핵심인데 이 규칙은 다음과 같다:</p>

<ul>
<li>Base Rule</li>
<li>Layout Rule</li>
<li>Module Rule</li>
<li>State Rule</li>
</ul>

<p><a href="http://mondaybynoon.com/20120109/book-review-smacss/">SMACSS Review</a>를 작성한 'Jonathan Christopher'는 몇 시간이면 다 읽는다고 했는데 난 며칠 걸렸다. 영어인데다가 분명히 흥미로운 내용인데도 이상하게 읽어도 읽어도 머릿속에 잘 들어오지 않았다.</p>

<p>이 책은 CSS를 관리하는 법에 대해서 설명한다. 표현에 대해서 다루는 CSS 책은 무수히 많지만 이런 책은 드물다.</p>

<p>SMACSS는 유료 컨텐츠도 있지만, 기본적으로 무료다. 만약 ebook 포멧으로 읽거나 숨겨진 컨텐츠를 읽고 싶으면 결제해야 하지만 책의 내용 대부분을 웹에서 무료로 읽을 수 있다. 하지만, 구매하길 바란다. 무료로도 읽을 수 있지만 그만한 가치가 있다. 지금 유료 컨텐츠는 'The Icon Module', 'Screencast: Applying the Principles' 둘뿐이지만 저자는 계속 추가한다고 한다.</p>

<p>다음은 공부한 내용을 정리한 것이다. 읽고 해석한 대로 정리한 것이니 원문과 다를 수도 있다. </p>

<h2>Four Types of CSS Rules</h2>

<p>SMACSS는 CSS Rule을 네 가지로 나눈다.</p>

<ul>
<li>Base - 기본 스타일</li>
<li>Layout - 엘리먼트를 나열하는 것과 관련된 스타일</li>
<li>Module - 재사용 위해 하나로 묶는 스타일</li>
<li>State - Hidden/Expand나 Active/Inactive 같은 스타일</li>
</ul>

<p>그 외 Theme와 Font Rule에 대해서 거론하지만, 특별히 분류하지는 않았다. 대신 위 네 가지 Rule을 이용해서 Theme와 Font Rule을 만든다.</p>

<h3>Base</h3>

<p>Base Rule을 쉽게 말하자면 id, class가 없는 스타일들을 말한다. 다음과 같은 것들이 Base Rule이다:</p>

<pre class="prettyprint"><code>html, body, form { margin: 0; padding: 0; }
input[type=text] { boarder: 1px solid #999; }
a { color: #039; }
a:hover { color: #03C; }
</code></pre>

<p>Base Rule은 직접 이름 지을 수 없는 element, attribute, psedo 셀렉터 등으로만 만든다.</p>

<h4>CSS Reset</h4>

<p>기본 margin, padding 등의 것을 규정하는 Base Rule을 CSS Reset이라고 부른다. 사실 Base Rule을 사용할 만한 데가 CSS Reset밖에 없어 보인다. SMACSS는 element 셀렉터를 권장하지 않아서 element 셀렉터를 사용해도 된다고 허용하는 부분은 Base Rule로 CSS Reset을 만들 때와 <code>.mod &gt; input</code>처럼 child 셀렉터를 함께 쓸 때뿐이다.</p>

<h3>Module</h3>

<p>Module 스타일이 필요한 이유는 스타일을 Module 단위로 묶어서 재사용하기 위함이다. 사이드바나 제품 목록 등의 반복적으로 재사용하는 것들이 이에 해당된다. </p>

<p>Module 스타일 이름은 3자로 제한해 사용한다. 하지만, 스타일 가이드이니까 4자도 되고 글자제한이 없어도 된다:</p>

<pre class="prettyprint"><code>/* Example Module */
.exm { }

/* Callout Module */
.cli { }

/* Form field module */
.fld { }
</code></pre>

<p>Exmaple Module에서 하위 스타일을 하나 만든다면 다음과 같이 하면 된다:</p>

<pre class="prettyprint"><code>.exm-caption { }
</code></pre>

<p>Module은 재사용할 수 있어야 하기 때문에 id 셀렉터를 사용하지 않는다. 그리고 element 셀렉터도 사용하지 않는다. 다음과 같은 스타일과 html을 보자:</p>

<pre class="prettyprint"><code>&lt;div class="fld"&gt;
    &lt;span&gt;Folder Name&lt;/span&gt;
&lt;/div&gt;

.fld &gt; span {
    padding-left: 20px;
    background: url(icon.png);
}
</code></pre>

<p>이렇게 사용해도 무방하지만, 프로젝트 규모가 커질수록 다른 element로 바꿔야 할 수도 있고 element 본연의 특징을 유지하기 어려울 수 있다. <code>span</code>을 제거하고 다음과 같이 변경한다:</p>

<pre class="prettyprint"><code>&lt;div class="fld"&gt;
    &lt;span class="fld-name"&gt;Folder Name&lt;/span&gt;
&lt;/div&gt;

.fld &gt; .fld-name {
    padding-left: 20px;
    background: url(icon.png);
}
</code></pre>

<p>그래도 element 셀렉터를 꼭 사용해야겠다면 <code>.fld &gt; span</code>처럼 child 셀렉터를 꼭 함께 사용하라.</p>

<h3>Layout</h3>

<p>Layout Rule이 엘리먼트를 어떻게 나열하는지 결정한다. 로그인 폼, 내비게이터 등부터 header, footer 같은 부분을 구분하는 것이 모두 Layout Rule이다.</p>

<p><code>.l-fixed</code> 유무에 따라 가변 폭으로 할지 고정 폭으로 할지 결정하는 Layout은 다음과 같이 만든다:</p>

<pre class="prettyprint"><code>#article {
    width: 80%;
    float: left;
}

#sidebar {
    width: 20%;
    float: right;
}

.l-fixed #article {
    width: 600px;
}

.l-fixed #sidebar {
    width: 200px;
}
</code></pre>

<p>id 셀렉터에는 'l'을 붙이지 않고 class 셀렉터에만 'l'을 붙인다. 전체 Layout처럼 큼직큼직한 Layout은 id 셀렉터로 스타일을 만들고 로그인 폼 같이 작은 부분의 스타일은 class 셀렉터로 만든다.</p>

<p>성능 등을 이유로 class 셀럭터 없이 전부 id 셀렉터로 만들어도 되지만 꼭 그래야 할 이유는 없다. CSS에서는 id 셀렉터와 class 셀렉터 이 둘의 성능은 거의 같다. id 셀렉터가 Javascript에서 빠를지 모르겠지만, CSS는 아니다. </p>

<p>그리고 Layout Rule만 id 셀렉터를 사용한다. 다른 스타일은 id 셀렉터 사용하지 않는다.</p>

<p>id 셀렉터에 tag 셀렉터와 함께 사용하지 않는다. 자식이면 child 셀렉터(>)를 꼭 사용한다.</p>

<h3>State</h3>

<p>상태와 관련된 스타일을 말하고 이름을 지을 때 's'를 붙인다. 예를 들면 이런 거다:</p>

<pre class="prettyprint"><code>.s-hidden { display: none; }
</code></pre>

<p><code>!important</code>를 사용해도 되는 Rule은 State Rule뿐이다. 다른 Rule에는 <code>!important</code>를 사용해서는 절대 안된다. 하지만, State Rule에서도 권장하지 않는다. 되도록 안 쓰는 것이 좋다. 뭥미:) 그냥 사용하지 말자.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git:번역 Workflow ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-translate-flow.html" />
    <updated>2012-02-01T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-translate-flow.html</id>
    <content type="html">
<![CDATA[
<p>Git으로 번역한다는 것은 아마도 CCL을 따르는 영문 자료를 우리말로 번역하는 것을 의미할 것이다. Pro Git 번역도 그랬다. Pro Git을 번역하면서 정리한 Workflow를 소개한다. 다른 번역 프로젝트에 도움을 줄 수 있으면 좋겠다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/translation-flow/translation-flow.png" alt="image" title="" /></p>

<h2>번역</h2>

<p>Git을 사용하는 데 있어서 번역 프로젝트는 개발 프로젝트와 다르다. 훨씬 더 정적이다. 만들어야 하는 브랜치 수도 적고 버그를 발견해도 좀 더 느슨하게 대처해도 된다. 며칠 늦었다고 해서 수갑을 차는 것도 아니고 경찰이 출동하지도 않는다.</p>

<p>Git은 번역 작업을 관리하는데도 좋다. 특히 원문 자체가 계속 수정되는 진행 중인 자료들이기 때문에 번역도 완성된 상태라고 볼 수 없고 항상 진행 중이라고 봐야 한다. Git은 이 상태를 추적하고 관리하는데 최상의 도구다.</p>

<p>Pro Git을 번역할 때 Git을 어떻게 사용해야 할지 몰랐기 때문에 헤매고 시간을 낭비했었다. 번역할 때는 어떤 브랜치가 필요한지 그리고 어떻게 사용하는 것이 좋은지 그동안 고민한 Workflow를 공개한다.</p>

<h2>브랜치</h2>

<p>몇 번의 삽질을 거쳐서 지금과 같은 번역 Workflow를 만들었다.</p>

<p>여기서는 사용한 브랜치는 다음과 같다:</p>

<ul>
<li>master - progit/master를 Tracking하는 브랜치</li>
<li>topic - 작업 브랜치들</li>
<li>ko - 번역이 완료되면 이 브랜치에 Merge하고 Pull Request를 보낸다.</li>
<li>ko-base - 원문, 어느 시점을 기준으로 번역했는지 기록하는 브랜치</li>
<li>private - 절대 Pull Request를 보내지 않을 브랜치들</li>
</ul>

<h3>master</h3>

<p>progit/master를 Tracking하는 브랜치이다. master 브랜치를 직접 수정하지 않는다.</p>

<p>이 브랜치를 progit/master를 Tracking하도록 한 이유는 별로 쓸모가 없어서다. Pull Request하는 브랜치를 ko 브랜치로 해야 했고 원문의 master 브랜치가 가리키는 커밋을 가리키는 로컬 브랜치가 하나 있는 게 편하기도 했다.</p>

<p>이 브랜치는 항상 progit/master를 따라가는 것이니까 항상 Fast-forward Merge된다.</p>

<p><img src="translation-flow/progit-master--master.png" alt="progit/master-master" title="" /></p>

<h3>토픽들</h3>

<p>Pro Git을 번역할 때는 Chapter 별로 브랜치를 만들었다. 01, 02, ..., 09 브랜치를 만들고 번역했다. 이 브랜치를 그대로 Push해서 다른 사람에게 리뷰를 요청했다. 책에 Chapter가 없어도 섹션 별로 만들 수도 있다.</p>

<p>책 내용뿐만 아니라 보통 ebook을 빌드하는 구조를 가진 책들은 설정 파일과 빌드 스크립트도 수정해야 한다. 이것을 위한 토픽 브랜치도 만든다. 이때는 꼭 브랜치 이름이 ko-build로 시작하게 했다.</p>

<p><img src="translation-flow/topics--ko.png" alt="topics-ko" title="" /></p>

<h3>ko</h3>

<p>이 브랜치가 핵심 브랜치다. Git-flow에 비교하자면 develop 브랜치에 해당한다고 할 수 있다. 토픽 브랜치에서 작업을 완료하면 커밋과 커밋 메시지를 정리하고 ko 브랜치에 Merge했다. </p>

<p>곧 Pull Request를 보낼 브랜치이기 때문에 토픽 브랜치를 Merge할 때 커밋을 잘 정리해서 Merge한다.</p>

<p>브랜치 이름을 <code>ko</code>라고 해야 하는 이유는 Merge 커밋에 브랜치 이름이 기록되기 때문이다. 보통 Git의 Merge 커밋은 다음과 같다:</p>

<pre class="prettyprint"><code>Merge branch 'ko' into master
</code></pre>

<p>Github에서 Pull Request를 Merge했을 때의 커밋 메시지는 거의 같지만 다르게 생겼다:</p>

<pre class="prettyprint"><code>Merge pull request #158 from dogfeet/ko
</code></pre>

<p>해당 Pull Request의 이슈 번호와 저장소 이름/브랜치 이름이 기록된다. 그래서 한국어를 나타낼 수 있도록 ko라는 이름으로 만든다.</p>

<p>Pull Request를 보내고 나서 원문 저장소에 Merge되면 다시 히스토리를 맞춰 주어야 한다. 원문 저장소는 한글뿐만 아니라 스페인어, 불어, 독어 등등의 커밋이 계속 업데이트된다. ko 브랜치를 삭제하고 다시 만들어도 되지만 reset 명령으로 ko 브랜치 포인터를 옮길 수 있다:</p>

<pre class="prettyprint"><code>$ git checkout master
$ git merge progit/master #Fast-forward Merge
$ git checkout ko
$ git reset --hard master
</code></pre>

<p>원문 저장소의 리모트 이름이 progit라고 가정한다:</p>

<p><img src="translation-flow/progit-master--ko.png" alt="progit/master-ko" title="" /></p>

<h4>ko-build</h4>

<p>어떤 커밋은 확실히 메인 저장소에 Push해야 하지만 어떤 커밋은 Dictator(원문 저장소 관리자)가 검토하고 Merge해 주길 바랄 것이다. 그런데 번역은 언어 문제로 Dictator가 검토할 수 없다. 빌드 스크립트 로직 문제를 제외하고는 원문 Dictator가 해줄 수 있는 게 없다.</p>

<p>빌드 스크립트나 관련 설정을 Pull Request로 보낼 때에도 <code>ko</code> 브랜치에 Merge해서 보냈다. 하지만, 빌드 스크립트 로직을 수정해야 한다면 Merge하는 것이 옳은지 Dictator가 검토해주길 바랄 테니까 본문과 별도로 보냈다. Pull Request는 브랜치 단위로 요청하는 것이니까 본문을 위한 브랜치 'ko'말고 다른 브랜치가 필요하다.</p>

<p><strong>Note:</strong> 하지만 Dictator가 검토하는지 알 수 없다. 영어 폰트를 임의로 수정해서 Pull Request를 보냈는데 Dictator인 <a href="https://github.com/schacon">schacon</a>은 그대로 Merge했다.</p>

<p>Dictator가 검토해주길 바라는 내용은 ko-build 브랜치를 만들어 Pull Request를 보낸다. 스크립트는 한번 고치면 다시 고쳐야 할 일은 거의 없다.</p>

<p><img src="translation-flow/progit-master--ko-build.png" alt="progit/master-ko-build" title="" /></p>

<h3>ko-base</h3>

<p>ko-base 브랜치가 가리키는 시점이 번역한 원문 시점을 나타낸다. 원본이 수정되면 이 브랜치를 이용해서 살펴보고 추가 번역해서 ko 브랜치에 반영하고 ko-base 브랜치는 최신으로 옮겨 놓는다. 그래서 master 브랜치처럼 항상 Fast-forward Merge된다.</p>

<p>master가 있는데 ko-base가 필요할까? 이 부분은 논쟁이 될 수 있다. ko-base 없이 master를 이용해도 된다. 분명한 근거를 제시할 수는 없지만, 목적을 스스로 설명하는 이름으로 된 브랜치를 사용하는 것이 옳다고 판단했고 확실히 구분해 사용했다.</p>

<p>이 브랜치도 항상 progit/master를 따라가는 것이니까 항상 Fast-forward Merge된다.</p>

<p>ko-base를 브랜치가 아닌 Tag로 만들어도 된다. 하지만, Tag는 가리키는 커밋을 옮길 수 없다. 삭제하고 다시 만들어야 한다. 시점이 옮기는 것이니까 Fast-forward Merge가 적당하다고 생각한다.</p>

<p><img src="translation-flow/progit-master--ko-base.png" alt="progit/master-ko-base" title="" /></p>

<h3>private</h3>

<p>중앙 저장소에 Merge하지 않을 커밋을 담아둘 브랜치도 필요하다. 확신이 없거나 중앙 저장소에 Merge했을 때 구조적으로 문제가 생길 수도 있는 것을 이 브랜치에 넣는다. 즉, 절대 Pull Request를 보내지 않을 커밋은 private으로 시작하는 브랜치에 넣는다.</p>

<p>dogfeet/progit에서는 'private-ko-build-ebook', 'private-ko-build-ubuntu'라는 브랜치를 만들어 사용했다. 'private-ko-build-ubuntu'는 Jenkins가 설치된 ubuntu 환경에 맞춘 코드를 넣었고, 원문에는 없는 오타와 오역 신고를 부탁한다는 글은 'private-ko-build-ebook'에 넣어 두었다.</p>

<p>private으로 시작하는 브랜치 규칙을 만든 이유는 실제로 실수를 저질렀기 때문이다. @lethee가 빌드 스크립트와 설정을 수정했다. 그리고 그 수정한 것을 내가 다시 정리해서 Pull Request를 보냈는데, 커뮤니케이션이 미숙해서 @lethee의 의도대로 Pull Request하지 않았다. 그래서 영어 폰트를 수정한 커밋이 progit 저장소에 들어가 버렸다. 그래서 이런 규칙을 만들었다.</p>

<h4>요약</h4>

<p>Pull Request를 보내는 브랜치:</p>

<ul>
<li><strong>ko</strong> - 번역 브랜치, 각 토픽 브랜치 별로 Pull Request를 보낼 수도 있지만, Dictator가 Merge하기 편리하도록 정리해서 보낸다.</li>
<li><strong>ko-build</strong> - 빌드 스크립트용 브랜치. Dictator가 검토해주길 바라는 내용.</li>
</ul>

<p>Tracking 브랜치:</p>

<ul>
<li><strong>master</strong> - progit/master를 Tracking하는 브랜치</li>
<li><strong>ko-base</strong> - 어느 시점을 기준으로 번역했는지 기록해 두는 브랜치</li>
</ul>

<p>Pull Request를 보내지 않을 브랜치:</p>

<ul>
<li>'<strong>private</strong>'으로 시작하는 브랜치.</li>
</ul>

<p>그 외:</p>

<ul>
<li>토픽 브랜치 – 브랜치 대부분은 실제 번역을 하는 토픽 브랜치다. 깔끔하게 작업하는 것은 ko 브랜치에 Merge할 때까지 미뤄도 된다.</li>
</ul>

<h2>커밋 메시지</h2>

<p>번역을 시작하면서 기존의 커밋 메시지를 훑어 봤는데 대부분 사람은 일정 규칙을 지키고 있었다. 물론 규칙을 지키지 않는 커밋들도 계속 올라왔고 강제하는 것처럼 보이진 않았다.</p>

<p>커밋 메시지는 첫 줄은 다음과 같은 형식을 따른다.</p>

<pre class="prettyprint"><code>[ko] Chapter 1: 오타 수정

본문...
</code></pre>

<h2>GitHub 저장소의 기본 브랜치.</h2>

<p>Pull Request를 보낼 때 Request마다 어느 브랜치에 Merge해야 하는지 선택해서 보낼 수 있다. 하지만, 기본 값은 저장소의 기본 브랜치이다.</p>

<p>그러니 GitHub의 번역 저장소의 기본 브랜치를 <code>ko</code>로 해야 다른 사람이 번역본에 기여할 때 <code>ko</code> 브랜치로 Pull Request를 보내기 쉬워진다:</p>

<h2>예제</h2>

<p>수정된 원문을 번역에 적용하는 예제를 살펴보자. 여기서 설명하는 예제는 <a href="/articles/2012/progit.html">Pro Git</a>이 아니라 <a href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript-Garden</a>의 예이다. 이 글을 쓰는 동안에 마침 BonsaiDen이 원문을 수정해줬다. 그동안 변경된 원문을 찾아 번역도 수정하는 것을 설명한다.</p>

<h3>브랜치 확인</h3>

<p>원문 저장소의 리모트 이름은 owner고 번역 저장소의 리모트 이름은 origin이다.</p>

<h4>로컬 저장소</h4>

<p><code>git todo</code>를 실행해서 브랜치 상태를 확인한다. <a href="/articles/2012/git-todo.html">git-todo</a> 사용법은 따로 설명해 놓았다:</p>

<pre class="prettyprint"><code>$ git todo
      [@] ko - 09b4f9c - ...
[-1] ko-base - e7c00d8 - ...
 [-1] master * e7c00d8 - ...
</code></pre>

<p>다시 설명하지만 <code>master</code>는 <code>owner/master</code>를 Tracking한다. 그리고 ko-base는 마지막으로 번역할 때 기준으로 삼은 시점을 기록해 둔 것이다. 그리고 ko는 새로 번역을 수정해 놓은 브랜치다.</p>

<p><code>[-1]</code>은 <code>[@]</code> 표시가 있는 브랜치 보다 커밋이 하나 적다는 것을 말한다. ko 브랜치에 JavaScript-Garden 한글 버전을 퇴고해서 Pull Request를 보냈다. 그래서 master보다 커밋이 하나 더 많다. BonsaiDen은 이 Pull Request를 Merge했다. 이제 owner 저장소를 확인하자.</p>

<h4>owner 저장소</h4>

<p>owner 저장소를 fetch한다:</p>

<pre class="prettyprint"><code>$git fetch owner
remote: Counting objects: 164, done.
remote: Compressing objects: 100% (44/44), done.
remote: Total 101 (delta 65), reused 80 (delta 45)
Receiving objects: 100% (101/101), 41.53 KiB | 42 KiB/s, done.
Resolving deltas: 100% (65/65), completed with 32 local objects.
From <a href='https://github.com/BonsaiDen/JavaScript-Garden'>https://github.com/BonsaiDen/JavaScript-Garden</a>
   962617e..67775b0  gh-pages   -&gt; owner/gh-pages
   e7c00d8..01fe309  master     -&gt; owner/master
</code></pre>

<p>그리고 나서 브랜치 상태를 확인한다:</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko - 09b4f9c - ...
              [-1] ko-base - e7c00d8 - ...
               [-1] master * e7c00d8 - ...
                 origin/ko - 09b4f9c - ...
       [-1] origin/ko-base - e7c00d8 - ...
        [-1] origin/master - e7c00d8 - ...
        [-388] origin/next - c204a58 - ...
[+84][-143] owner/gh-pages - 67775b0 - ...
        [+14] owner/master - 01fe309 - ...
         [-388] owner/next - c204a58 - ...
</code></pre>

<p><code>owner/master</code>에 새로운 커밋이 생겼다. master는 단순히 <code>owner/master</code>를 Tracking하는 브랜치니까 master에 Merge한다:</p>

<pre class="prettyprint"><code>$ git co master
$ git merge owner/master
</code></pre>

<p>ko 브랜치가 Merge됐는지 확인한다. 히스토리를 보면 다음과 같은 커밋이 들어 있다:</p>

<pre class="prettyprint"><code>34c3271 Merge pull request #121 from pismute/ko
09b4f9c [ko] proofreading
</code></pre>

<p>Merge됐으므로 ko 브랜치가 owner/master를 가리키게 한다:</p>

<pre class="prettyprint"><code>$ git co ko
$ git reset --hard owner/master
</code></pre>

<p>그리고 나서 브랜치 상태를 확인해보자:</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko * 01fe309 - ...
             [-15] ko-base - e7c00d8 - ...
                    master - 01fe309 - ...
           [-14] origin/ko - 09b4f9c - ...
      [-15] origin/ko-base - e7c00d8 - ...
       [-15] origin/master - e7c00d8 - ...
        [-402] origin/next - c204a58 - ...
[+84][-157] owner/gh-pages - 67775b0 - ...
              owner/master - 01fe309 - ...
         [-402] owner/next - c204a58 - ...
</code></pre>

<p><code>owner/master</code>에 맞추어 브랜치를 정리했다. <code>owner/master</code>, <code>master</code>, <code>ko</code> 브랜치는 이제 같은 커밋을 가리킨다.</p>

<p>원문에서 무엇이 변경됐는지 살펴보고 번역을 수정해보자</p>

<h3>무엇이 변경됐는지 찾아 번역한다.</h3>

<p>먼저 변경된 커밋 중에서 어떤 파일들이 변경됐는지 확인해보자. ko-base 브랜치가 이미 번역한 번역본의 기준이므로 master와 ko-base 브랜치를 비교한다. 이때 브랜치 순서가 중요하다. <code>ko-base...master</code> 같이 <code>ko-base</code>를 먼저 사용한다. 순서를 반대로 쓰면 diff 명령에서 헷갈리기 쉽다.</p>

<pre class="prettyprint"><code>$ git log --pretty=oneline --abbrev-commit --left-right --name-only ko-base...master
&gt; 01fe309 Finally get around and start fixing some issues
doc/en/core/undefined.md
doc/en/function/constructors.md
doc/en/function/scopes.md
doc/en/object/hasownproperty.md
&gt; 98a1f31 Merge pull request #114 from krawaller/master
&gt; 65f0d9e Merge pull request #77 from xavierm02/master
&gt; 27b4b2f Merge pull request #117 from oozcitak/tr
&gt; 666edda Merge pull request #116 from szTheory/patch-1
&gt; 34c3271 Merge pull request #121 from pismute/ko
&gt; 09b4f9c [ko] proofreading
doc/ko/array/constructor.md
doc/ko/array/general.md
doc/ko/core/delete.md
doc/ko/core/eval.md
doc/ko/core/semicolon.md
doc/ko/core/undefined.md
doc/ko/function/arguments.md
doc/ko/function/closures.md
doc/ko/function/constructors.md
doc/ko/function/general.md
doc/ko/function/scopes.md
doc/ko/function/this.md
doc/ko/intro/index.md
doc/ko/object/forinloop.md
doc/ko/object/general.md
doc/ko/object/hasownproperty.md
doc/ko/object/prototype.md
doc/ko/other/timeouts.md
doc/ko/types/casting.md
doc/ko/types/equality.md
doc/ko/types/typeof.md
&gt; 919b581 [tr] Fixed typo
doc/tr/core/delete.md
&gt; 753fd78 Added delete to index
doc/tr/index.json
&gt; c8258d1 [tr] Translated delete
doc/tr/core/delete.md
&gt; cd06184 [tr] Fixed type
doc/tr/function/scopes.md
&gt; be27b01 grammar
doc/en/function/this.md
&gt; 103ca5d removed trailing whitespace in comment on line 55 which caused line to spill outside code container
doc/fi/function/arguments.md
&gt; 0a894c1 Stored the biggest timeout ID to avoid infinite loop.
doc/en/other/timeouts.md
&gt; 53decce Added another way to clear "all" timeouts and replaced the "is is" by "it is".
doc/en/other/timeouts.md
</code></pre>

<p>그동안 수정된 커밋이 좀 있다. 영어로 된 것을 번역한 것이니 이 중에서 <code>doc/en</code> 파일이 수정된 것만 확인한다. <code>doc/en</code> 디렉토리에 있는 파일만 조회하자:</p>

<pre class="prettyprint"><code>$ git log --pretty=oneline --abbrev-commit --left-right --name-only ko-base...master doc/en
&gt; 01fe309 Finally get around and start fixing some issues
doc/en/core/undefined.md
doc/en/function/constructors.md
doc/en/function/scopes.md
doc/en/object/hasownproperty.md
&gt; 65f0d9e Merge pull request #77 from xavierm02/master
&gt; 666edda Merge pull request #116 from szTheory/patch-1
&gt; be27b01 grammar
doc/en/function/this.md
&gt; 0a894c1 Stored the biggest timeout ID to avoid infinite loop.
doc/en/other/timeouts.md
&gt; 53decce Added another way to clear "all" timeouts and replaced the "is is" by "it is".
doc/en/other/timeouts.md
</code></pre>

<p>커밋 정보 없이 수정된 파일만 볼 수도 있다:</p>

<pre class="prettyprint"><code>$ git diff --name-only ko-base..master doc/en
doc/en/core/undefined.md
doc/en/function/constructors.md
doc/en/function/scopes.md
doc/en/function/this.md
doc/en/object/hasownproperty.md
doc/en/other/timeouts.md
</code></pre>

<p>파일 내용까지 보려면 <code>--name-only</code> 옵션을 빼면 된다. 그러면 diff 내역을 모두 보여준다. 한 번에 보면 너무 많으니 하나씩 diff를 확인해 볼 수 있다. <code>doc/en/core/undefined.md</code> 파일의 diff 내용을 살펴보자:</p>

<pre class="prettyprint"><code>$ git diff ko-base..master doc/en/core/undefined.md
diff --git a/doc/en/core/undefined.md b/doc/en/core/undefined.md
index d27761f..c819920 100644
--- a/doc/en/core/undefined.md
+++ b/doc/en/core/undefined.md
@@ -19,11 +19,13 @@ overwritten.
 Some examples for when the value `undefined` is returned:

  - Accessing the (unmodified) global variable `undefined`.
+ - Accessing a declared *but not* yet initialized variable
  - Implicit returns of functions due to missing `return` statements.
  - `return` statements which do not explicitly return anything.
  - Lookups of non-existent properties.
  - Function parameters which do not had any explicit value passed.
  - Anything that has been set to the value of `undefined`.
+ - Any expression in the form of `void(expression)`

 ### Handling Changes to the Value of `undefined`
</code></pre>

<p>파일을 하나씩 diff해보면서 번역을 수정한다. 수정하고 커밋한 후에 브랜치를 살펴보자.</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko * c712143 - ...
             [-16] ko-base - e7c00d8 - ...
               [-1] master - 01fe309 - ...
           [-15] origin/ko - 09b4f9c - ...
      [-16] origin/ko-base - e7c00d8 - ...
       [-16] origin/master - e7c00d8 - ...
        [-403] origin/next - c204a58 - ...
[+84][-158] owner/gh-pages - 67775b0 - ...
         [-1] owner/master - 01fe309 - ...
         [-403] owner/next - c204a58 - ...
</code></pre>

<p><code>ko</code> 브랜치에 번역을 수정하고 커밋했기 때문에 <code>owner/master</code>보다 커밋이 한 개 많다.</p>

<h3>ko-base 옮겨 놓고 Pull Request 보내기</h3>

<p>다음에 원문이 수정됐을 때 다시 참고 할 수 있도록 ko-base가 owner/master를 가리키도록 한다.</p>

<pre class="prettyprint"><code>$ git checkout ko-base
$ git reset --hard owner/master
</code></pre>

<p>그리고 저장소를 origin에 Push한다. Push하고 나면 브랜치 상태는 다음과 같아진다:</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko - c712143 - ...
              [-1] ko-base * 01fe309 - ...
               [-1] master - 01fe309 - ...
                 origin/ko - c712143 - ...
       [-1] origin/ko-base - 01fe309 - ...
        [-1] origin/master - 01fe309 - ...
        [-403] origin/next - c204a58 - ...
[+84][-158] owner/gh-pages - 67775b0 - ...
         [-1] owner/master - 01fe309 - ...
         [-403] owner/next - c204a58 - ...
</code></pre>

<p>이제 원문이 수정된 만큼 번역도 수정했으니 Pull Request를 보내면 된다. 그리고 다음에 추가로 수정된 부분이 있으면 이어서 다시 번역할 수 있다.</p>

<h2>결론</h2>

<p>번역 작업에도 Git은 매우 훌륭하다. 번역은 개발과 달라서 다른 Workflow가 필요하다. <a href="/articles/2011/a-successful-git-branching-model.html">git-flow</a>처럼 번역 시 참고할 만한 자료가 있으면 좋을 것 같아서 정리했다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Optimize browser rendering ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/optimize-browser-rendering.html" />
    <updated>2012-01-27T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/optimize-browser-rendering.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>에 있는 <a href="http://code.google.com/speed/page-speed/docs/rendering.html">Optimize browser rendering</a>를 정리한 것이다. 이 글과 이 글에 주렁주렁 달린 글을 모두 독파하면 '한 브라우저 렌더링'한다고 말할 수 있을 것 같다.</p>

<p>브라우저의 특징을 잘 살려서 코딩하면 성능이 빨라진다. 이 글은 다음과 같은 주제에 대해 설명한다:</p>

<ul>
<li>효율적인 CSS 셀렉터</li>
<li>CSS Expression 안 쓰기</li>
<li>CSS는 Document head에 넣기</li>
<li>이미지 크기 명시하기</li>
<li>Charset 명시하기</li>
</ul>

<p><img src="http://dogfeet.github.com/articles/2012/optimize-browser-rendering/google-page-speed.png" alt="google-page-speed" title="" /></p>

<h2>효율적인 CSS 셀렉터</h2>

<p>찾아볼 엘리먼트가 많은 셀렉터만 사용치 않아도 렌더링 성능이 대폭 향상된다.</p>

<p>브라우저는 HTML을 파싱하는 대로 화면에 표시할 엘리먼트를 모두 생성하면서 내부에 도큐먼트 트리를 만든다. 브라우저의 CSS 엔진은 정해진 규칙에 따라 엘리먼트마다 맞는 스타일이 있는지 찾는다. 그 규칙은 표준 CSS cascade, 상속, 정열 규칙에 따른다. "셀렉터"는 어떤 엘리먼트에 스타일을 적용할지를 나타내는 것인데 CSS 엔진은 제일 오른쪽에 있는 셀렉터부터 찾는다. 가장 오른쪽에 있는 셀렉터를 "Key 셀렉터"라고 부르고 필요한 스타일을 찾거나 못 찾을 때까지 계속 Evaluate한다.</p>

<p>이런 시스템이라서 Rule이 적을수록 성능이 좋다. 그러니까 <a href="http://code.google.com/speed/page-speed/docs/payload.html#RemoveUnusedCSS">사용하지 않는 CSS</a>를 삭제하는 것만으로도 성능이 대폭 향상된다. 일단 안 쓰는 CSS를 모두 삭제하고 나서 엘리먼트나 CSS Rule이 많은 페이지를 최적화한다. CSS Rule을 손보는 것만으로도 성능을 향상시킬 수 있다. Rule을 가능한 정확하게 만들고 불필요한 군더더기를 제거하는 게 최적화의 핵심이다. 그래서 스타일 엔진이 사용하지도 않을 Rule까지도 일일이 검사하지 않게끔 해야 한다.</p>

<h4>Descendant 셀렉터</h4>

<pre class="prettyprint"><code>ul li a {...}
</code></pre>

<p>Descendant 셀렉터는 비효율적이다. 브라우저는 Key를 찾고 나서 정확히 일치하는 것을 찾거나 더는 찾을 수 없을 때까지 그 상위 DOM 트리를 전부 뒤진다. Key가 덜 구체적일수록 Evaluate해 봐야 하는 엘리먼트의 수는 많아진다.</p>

<h4>Child 셀렉터</h4>

<pre class="prettyprint"><code>ul &gt; li &gt; a {...}
</code></pre>

<p>Child 셀렉터도 비효율적이다. 브라우저가 엘리먼트를 Evaluate할 때마다 노드를 하나 더 Evaluate해야 한다. 다시 말해서 Child 셀렉터를 사용한 Rule은 비용이 두 배 더 든다. 게다가 Key 셀렉터가 가리키는 엘리먼트가 많을수록 더 많은 엘리먼트를 Evaluate해야 한다. 비효율적이지만 Descendant 셀렉터 보다는 훨씬 빨라서 꽤 사용되는 편이다.</p>

<h4>쓸데없이 셀렉터를 더 사용할 때</h4>

<pre class="prettyprint"><code>ul#top_blue_nav {...}
</code></pre>

<p>정의에 따르면 ID 셀렉터는 중복될 수 없다. 그래서 class나 tag 셀렉터와 함께 사용하면 필요 없는 Evaluate을 추가로 하게 만든다. 노파심을 달래줄 뿐 하지 않아도 될 Evaluate만 더 하는 것이다.</p>

<h4>Pseudo 셀렉터 <code>:hover</code>를 링크가 아닌 엘리먼트에 사용할 때</h4>

<pre class="prettyprint"><code>.foo:hover {...}
</code></pre>

<p><code>:hover</code> 셀렉터를 Non-anchor 엘리먼트에 사용하면 <a href="http://connect.microsoft.com/IE/feedback/ViewFeedback.aspx?FeedbackID=391387">IE7, IE8는 느려질 때가 있다</a>고 알려졌다. Strict Doctype을 사용하지 않을 때 IE7, IE8은 Non-Anchor 엘리먼트에 사용된 <code>:hover</code>를 무시한다. 하지만, Strict Doctype이 사용할 때 Non-Anchor 엘리먼트에 <code>:hover</code>를 사용하면 성능을 저하된다.</p>

<h3>기억할 것.</h3>

<ul>
<li><p>Universal 셀렉터를 Key로 사용하지 말 것.</p>

<ul><li>여러 가지 엘리먼트에 적용해야 할 때는 Class 셀렉터를 사용하자.</li></ul></li>
<li><p>가능한 구체적으로 사용하라.</p>

<ul><li>Tag 셀렉터 보다는 ID나 Class 셀렉터를 사용하라.</li></ul></li>
<li><p>Redundant Qualifier를 제거할 것.</p>

<ul><li>ID 셀렉터와 Tag, Class 셀렉터를 사용하지 말 것.</li>
<li>Class 셀렉터에 추가로 Tag 셀렉터를 사용하지 말 것.</li></ul></li>
<li><p>Descendant 셀렉터를 사용하지 말 것 - 특히 Redundant 때문에 Ancestor를 명시하지 말 것.</p>

<ul><li><code>body ul li a</code> 같은 Rule에서 body는 Redundant 때문에 사용한 것인데 아무 의미 없다.</li></ul></li>
<li><p>Descendant 셀렉터 대신 Class 셀렉터를 사용하라.</p>

<ul><li><code>ul li {color: blue;}</code> 이런 스타일은 <code>.unordered-list-item {color: blue;}</code>으로 바꾼다.</li>
<li><code>ol li {color: red;}</code> 이런 스타일은 <code>.ordered-list-item {color: red;}</code>으로 바꾼다.</li></ul></li>
<li><p>Descendant 셀렉터를 사용할 바에는 Child 셀렉터를 사용해라.</p>

<ul><li>여러 단계를 다 Evaluate하는 것보다 한 단계만 더 Evaluate하는 게 낫다.</li></ul></li>
<li><p>IE를 위해 <code>:hover</code>를 Non-Anchor(non-link) 엘리먼트에 사용하지 말 것.</p>

<ul><li>Non-Anchor 엘리먼트에 <code>:hover</code>를 사용하면 IE7, IE8에서 꼭 해당 페이지를 테스트해야 한다. <code>:hover</code> 때문에 성능에 문제가 생기면 IE에서는 JavaScript의 onmouseover 이벤트 핸들러를 사용하라.</li></ul></li>
</ul>

<h2>CSS expression 안 쓰기.</h2>

<p>CSS expression은 렌더링 성능을 떨어트린다. CSS expression은 IE5, IE6, IE7만 지원하는 것이고 IE 8부터는 deprecated 됐다. 게다가 다른 브라우저는 아예 지원하지 않는다. 정리하지 않음.</p>

<h2>CSS는 document head에 두기</h2>

<p>브라우저는 <code>&lt;link&gt;</code> 엘리먼트의 CSS 파일을 모두 내려받을 때까지 웹 페이지를 렌더링하지 않기 때문에 <code>&lt;link&gt;</code> 엘리먼트를 도큐먼트 헤드에 넣어서 무엇보다 CSS 파일을 먼저 내려받을 수 있도록 해줘야 한다.</p>

<p>브라우저는 도큐먼트를 스트림처럼 다루기 때문에 내려받은 만큼 먼저 렌더링한다. 렌더링하고 나서 스타일이 바뀌면 다시 해야 하기 때문에 인라인 스타일 블럭(<code>&lt;style&gt;</code> 엘리먼트)도 도큐먼트 헤드에 넣어줘야 한다.</p>

<h3>기억할 것</h3>

<ul>
<li><code>&lt;link&gt;</code> 엘리먼트는 항상 <code>&lt;head&gt;</code>에 넣어라.</li>
<li><a href="http://www.clearboth.org/css-link-vs-import/"><code>@import</code>는 사용하지 마라</a></li>
<li><code>&lt;style&gt;</code> 블럭도 <code>&lt;head&gt;</code>에 넣어라.</li>
</ul>

<h2>이미지 크기 명시하기</h2>

<p>이미지 크기를 명시하면 이미지 파일을 다 내려받고 나서 다시 그리지(reflow와 repaint) 않는다. 크기를 명시하지 않았거나 명시한 크기가 실제 이미지 크기와 다르면 브라우저는 내려받고서 다시 그린다.</p>

<h3>기억할 것</h3>

<ul>
<li>실제 이미지 크기로 명시하라.</li>
<li>img 엘리먼트나 그 부모 중에서 block 엘리먼트에 크기를 명시해야 한다. block 엘리먼트가 아니면 명시한 크기 값은 무시된다.</li>
</ul>

<h2>Charset 명시하기</h2>

<p>HTML 문서의 HTTP Response 헤더에 캐릭터 셋을 항상 넣어주면 브라우저는 바로 HTML 파싱하고 스크립트를 실행한다. </p>

<p>Charset을 명시하지 않으면 브라우저는 일정 크기만큼 버퍼링하고 그 버퍼에서 charset 정보를 찾는다. </p>

<p>브라우저마다 버퍼링하는 바이트 수와 Charset을 명시하지 않았을 때 사용하는 기본 Encoding이 다르다. 하지만, 일단 버퍼링하면 바로 렌더링한다. 그리고 만약 기본 Encoding과 버퍼링하고 나서 찾아낸 Charset이 서로 다르면 다시 파싱하고 페이지를 다시 그린다.</p>

<h3>기억할 것</h3>

<ul>
<li>Content Type을 빠트리지 마라. - HTTP 헤더나 HTML meta tag 두 곳에 모두 적어 준다. 브라우저는 Content Type을 "sniff"하는데 알고리즘이 여러 가지 사용된다. 그래서 추가적인 Delay도 생기고 보안에 구멍도 생긴다. 'text/html'이라고 할지라도 반드시 적어준다.</li>
<li>제대로 된 Charset을 명시한다.  - HTTP 헤더와 HTML meta tag 두 곳에 모두 명시한다.</li>
</ul>

<p>HTTP 헤더에 명시하는 예제:</p>

<pre class="prettyprint"><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>HTML meta tag에 명시하는 예제:</p>

<pre class="prettyprint"><code>&lt;meta http-equiv="content-type" content="text/html;charset=UTF-8" /&gt;
</code></pre>

<h2>결론</h2>

<p><a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>를 한번 돌려보자. 굉장히 잘 만들었다. 문제가 무엇인지 알려주고 어떻게 해결해야 하는지도 알려준다.</p>]]>
    </content>
  </entry>
</feed>
