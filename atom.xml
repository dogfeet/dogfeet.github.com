<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title><![CDATA[ 개발새발 ]]></title><link href="http://dogfeet.github.io/atom.xml" rel="self" /><link href="http://dogfeet.github.io" /><updated>2013-07-19T22:28:07.037Z</updated><id>http://dogfeet.github.io</id><author><name>Changwoo Park</name><email>pismute@gmail.com</email></author><author><name>Sean Lee</name><email>sean@weaveus.com</email></author><author><name>Yongjae Choi</name><email>mage@weaveus.com</email></author><entry><title><![CDATA[ git: Useful GitHub Patterns ]]></title><link href="http://dogfeet.github.io/articles/2013/git-useful-github-pattern.html" /><updated>2013-07-19T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/git-useful-github-pattern.html</id><content type="html"><![CDATA[
<p>Jake Benilov님이 쓴 <a href="http://blog.quickpeople.co.uk/2013/07/10/useful-github-patterns/">Useful Github Patterns</a>를 번역한 글이다. Jake님은 글이라기보다 요약이나 정리에 가까운 형식으로 썼기 때문에 번역이 어려웠다. 같은 의미로 글을 새로 쓴 게 많아서 오역이 첨가됐을 것 같다.</p>

<p>특히 <code>Pull Request</code>를 글로 정리하는 일은 쉽지 않았는데 Jake님이 잘 설명하신 것 같다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-useful-github-pattern/pattern.jpg" alt="너의 패턴은 파악되었다!"/></p>

<h2>USEFUL GITHUB PATTERNS</h2>

<p>내 <a href="http://blog.quickpeople.co.uk/2013/05/17/the-uk-government-pays-me-to-write-open-source-all-day/">직업</a>이나 <a href="http://benilovj.github.io/dbfit/">오픈소스 활동</a>을 하다 보면 git과 GitHub 컨설팅도 하게 된다. 그러면서 git과 GitHub을 일정한 패턴에 따라 사용하는 나를 발견했다.</p>

<p>(여기부터는, &lsquo;Pull Request'를 PR로 사용한다).</p>

<h3>1. The peel-off PR</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>Feature 브랜치에서 뭔가 하는 도중에</li>
<li>문제를 발견하자마자 바로 수정하고 싶은데, 현재 추가하는 기능과 관련이 없을 때( 작은 버그, 오타, 코딩 규칙 위반을 발견했을 때)</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>하던 일을 저장(Commit하거나 Stash한다)</li>
<li>checkout master</li>
<li>브랜치를 만든다.</li>
<li>문제를 수정하고 PR을 보낸다.</li>
<li>다시 원래의 Feature 브랜치로 돌아와 하던 일을 계속한다.</li>
<li>나중에 그 PR을 보냈던 브랜치가 Merge된 후에 Rebase한다.</li>
</ul>

<p>전혀 다른 문제를 빨리 고치고 싶은 욕망과 Feature 브랜치를 정갈하게 해서 리뷰하기 쉽게 만들고 싶은 욕망을 모두 만족하게 할 수 있다.</p>

<h3>2. The optimistic branch</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>지금은 Merge할 수 없는 브랜치(branch-A)가 있는데(CI 빌드가 깨질 수도 있고, 리뷰어가 바쁠 수도 있다).</li>
<li>내가 당장 구현해야 하는 기능은 branch-A의 코드가 필요하다.</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>branch-A에서 branch-B 브랜치를 만든다.</li>
<li>branch-A가 master에 Merge되면, branch-B를 master에 대해 Rebase하고 충돌 나는 게 있으면 해결한다.</li>
<li>branch-A에 대한 버그픽스 브랜치들은 branch-B에 대해서 Rebase한다.</li>
</ul>

<p>branch-A에서 코드를 많이 수정하면 충돌 날 확률이 높아진다. 하지만, 95% 정도는 잘 된다.</p>

<h3>3. The heads-up PR</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>리뷰가 필요하지 않은 코드를 작성하고 있지만</li>
<li>동료가 알고 있으면 좋을 것 같을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>코드를 작성</li>
<li>PR을 보낸다.</li>
<li>피드백을 기다리지 않고 PR을 직접 Merge한다.</li>
</ul>

<p>GitHub은 PR에 대한 이메일을 동료에게 보낸다. 그래서 맘에 들지 않은 코드를 발견한 동료는 코멘트를 달거나 할 수 있다. 내가 할 일이 별로 없다.</p>

<h3>4. The sneaky commit</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>코드를 리뷰하고 master에 Merge까지 한 다음에</li>
<li>수정할 것이 발견되었는데 너무 사소한 수정(버그픽스나 copy change같은 것)이라서 다른 사람이 알 가치도 없을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>master 브랜치에 바로 커밋한다.</li>
</ul>

<h3>5. The roger roger comment</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>코드 리뷰 중에 바로 적용할만한 피드백을 받았을 때</li>
<li>그 피드백에 따라서 고쳤을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>고친 커밋의 Ref가 포함된 PR에 코멘트를 한다.</li>
<li>Ref를 클릭하면 GitHub은 Diff로 다른 부분만 보여준다. 그래서 내 동료는:

<ul>
<li>Email로 내가 수정했다는 것을 통보받고</li>
<li>클릭만 하면 간단하게 커밋 Diff를 볼 수 있고</li>
<li>이런 식으로 코드 리뷰를 할 수 있다는 것을 안다.</li>
</ul></li>
</ul>

<h3>6. The creepin’ commit</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>내가 만든 사소한 포매팅 버그를 발견했을 때(불필요한 공백이나 파일 끝에 한 줄 남기는 것을 빼먹었을 때)나</li>
<li>이전 커밋과 논리적으로 같은 커밋이 돼야 할 때</li>
<li>(실패하는 테스트가 있거나 해서) 아직 커밋할 만한 코드가 아닌 상태에서 하나씩 실험해보고 다시 현재 코드로 되돌리거나 진행하고 싶을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>첫 번째나 두 번째는 그냥 이전 커밋을 수정한다(Amend)</li>
<li>마지막은 일단 (Creeping) 커밋을 하나 만들어 놓고 실험하면서 점진적으로 Amend한다. 실험 결과가 안 좋으면 그냥 버린다. 커밋할만한 단계에 도달할 때까지 계속한다.</li>
</ul>

<h3>7. The forced branch</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>남이 Push한 Feature 브랜치를 Amend해야 할 때. 예를 들어, 커밋 메시지에 이유를 남기고 싶을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>로컬에서 커밋을 Amend한다.</li>
<li>Feature 브랜치를 리모트 저장소에 강제로(-f 옵션을 주고) Push한다.</li>
</ul>

<p>보통 리모트 브랜치에 강제로 Push하는 것은 금단의 영역으로 취급된다. master 브랜치가 아니라면 내 경험상 별로 문제 되지 않았다(역주 - Long-Running 브랜치가 아니면 별로 문제 될 게 없다). GitHub은 PR 브랜치가 강제로 Push돼도 잘 처리한다. 이전 커밋에 있던 코멘트를 잃어버리거나 하지 않는다.</p>

<h3>8. The reformat peel-off</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>코드를 수정하면서 코드 포멧도 수정할 계획이라면</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>포멧을 수정한 커밋은 master 브랜치에 직접 한다.</li>
<li>코드를 수정한 커밋이 들어 있는 브랜치는 master대해 Rebase한다.</li>
</ul>

<p>이럴 때 코드 리뷰하는 사람은 코드를 수정한 브랜치에 Dill 하는 것이 더 좋다. 코드 수정 커밋이 있는 브랜치에는 포멧 수정 커밋이 없어서 Diff 결과가 더 깔끔하다.</p>

<h3>9. The prototype PR</h3>

<p><strong>언제 사용하나?:</strong></p>

<ul>
<li>본격적으로 구현하기 전에 아이디어에 대해 피드백을 받고 싶을 때</li>
</ul>

<p><strong>어떻게 하나?:</strong></p>

<ul>
<li>브랜치에 뭔가 수정을 한다.</li>
<li>아직 완성된 코드가 아니라고 해도 일단 PR을 하면 토론의 시작점이 된다.</li>
<li>다음 단계로 뭘 할지 합의가 이루어지면 PR을 닫고 브랜치도 삭제한다.</li>
<li>다시 브랜치를 만들고 제대로 구현해서 PR을 한다.</li>
</ul>

<p>나는 PR이 코드를 다 완성하고 나서 하는 것으로 생각했었다. 지금은 &ldquo;Pull Request는 대화의 시작점&quot;이라는 것을 깊이 공감한다. PR과 관련된 GitHub의 기능은(Inline Comment, Reply, Notification, Diff) 매우 훌륭하다. 코드와 설계에 대해 토론을 많이 하게 해서 개발자가 너무 멀리 가거나 벼랑 끝으로 향하는 일을 미리 방지해준다.</p>
]]>
</content></entry><entry><title><![CDATA[ git: ckw Solarized!  ]]></title><link href="http://dogfeet.github.io/articles/2013/git-msysgit-ckw-solarized.html" /><updated>2013-07-10T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/git-msysgit-ckw-solarized.html</id><content type="html"><![CDATA[
<p><a href="http://ethanschoonover.com/solarized">Solarized</a>는 적당히 이쁜데다가 다양한 도구에서 사용할 수 있도록 이미 만들어진 테마가 많기 때문에 매우 편리하다. 문득 윈도우에서도 <a href="http://ethanschoonover.com/solarized">Solarized</a>를 사용하고 싶다는 생각이 들었다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-msysgit-ckw-solarized/be-autiful.jpg" alt=""/></p>

<h2>ckw</h2>

<p>cmd 터미널은 너무 구려서 <a href="http://d.hatena.ne.jp/hideden/20071115/1195229532">ckw</a>를 사용하고 있는데 찾아보니 <a href="https://gist.github.com/cd01/4307522">ckw용 Solarized 테마</a>를 만들어 놓은 훌륭한 분이 있었다.</p>

<p>바로 내 설정에 적용했다:</p>

<p><img src="/articles/2013/git-msysgit-ckw-solarized/git-msysgit-ckw-solarized.png" alt="ckw-solarized"/></p>

<p>Putty에도 <a href="http://ethanschoonover.com/solarized">Solarized</a>를 쓰고 있는데 ckw에도 적용했더니 둘이 많이 비슷해졌다.</p>

<p>하지만 미묘하게 이 ckw의 색감이 떨어진다. <a href="https://github.com/brantb/solarized">Solarized 저장소</a>에서 배포하고 있는 것 만큼 색감이 좋지는 않다. 눈에 거슬리는 색은 조금씩 변경해서 쓰는게 좋겠다.</p>

<p>위 설정을 적용한 내 설정은 아래와 같다:</p>
<pre><code>!
! ckw setting
!

Ckw<span class="variable">*title</span>: Powershell
Ckw<span class="variable">*exec</span>:  powershell -ExecutionPolicy RemoteSigned
Ckw<span class="variable">*chdir</span>: C:\Users\pismute\git

Ckw<span class="variable">*scrollHide</span>:  <span class="keyword">no</span>
Ckw<span class="variable">*scrollRight</span>: yes
Ckw<span class="variable">*internalBorder</span>: <span class="number">1</span>
Ckw<span class="variable">*lineSpace</span>: <span class="number">0</span>
Ckw<span class="variable">*topmost</span>: <span class="keyword">no</span>

Ckw<span class="variable">*font</span>: NanumGothicCoding
Ckw<span class="variable">*fontSize</span>: <span class="number">22</span>

Ckw<span class="variable">*geometry</span>:  <span class="number">80</span>x26
Ckw<span class="variable">*saveLines</span>: <span class="number">10000</span>

!! theme
!! Solarized dark
!!

!Ckw<span class="variable">*foreground</span>:     <span class="comment">#657b83</span>
Ckw<span class="variable">*background</span>:     <span class="comment">#073642</span>
!Ckw<span class="variable">*cursorColor</span>:    <span class="comment">#657b83</span>
Ckw<span class="variable">*cursorImeColor</span>: <span class="comment">#dc322f</span>
!Ckw<span class="variable">*backgroundBitmap</span>: background.bmp
!Ckw<span class="variable">*transp</span>:           <span class="number">220</span>
!Ckw<span class="variable">*transpColor</span>:      <span class="comment">#000000</span>

Ckw<span class="variable">*color1</span>:  <span class="comment">#586e75</span>
Ckw<span class="variable">*color2</span>:  <span class="comment">#859900</span>
Ckw<span class="variable">*color3</span>:  <span class="comment">#2aa198</span>
Ckw<span class="variable">*color4</span>:  <span class="comment">#cb4b16</span>
Ckw<span class="variable">*color5</span>:  <span class="comment">#6c71c4</span>
Ckw<span class="variable">*color6</span>:  <span class="comment">#859900</span>

Ckw<span class="variable">*color8</span>:  <span class="comment">#839496</span>
Ckw<span class="variable">*color9</span>:  <span class="comment">#268bd2</span>
Ckw<span class="variable">*color10</span>: <span class="comment">#859900</span>
Ckw<span class="variable">*color11</span>: <span class="comment">#2aa198</span>
Ckw<span class="variable">*color12</span>: <span class="comment">#dc322f</span>
Ckw<span class="variable">*color13</span>: <span class="comment">#d33682</span>
Ckw<span class="variable">*color14</span>: <span class="comment">#b58900</span>
Ckw<span class="variable">*color15</span>: <span class="comment">#fdf6e3</span>
</code></pre>]]>
</content></entry><entry><title><![CDATA[ 프로 Git 한글책 출간 ]]></title><link href="http://dogfeet.github.io/articles/2013/progit-ko-book-published.html" /><updated>2013-05-20T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/progit-ko-book-published.html</id><content type="html"><![CDATA[
<p>Pro Git 한글 번역이 <a href="http://www.insightbook.co.kr/">인사이트</a>의 도움을 받아 종이책으로 <a href="http://www.insightbook.co.kr/post/5633">프로 Git</a> 으로 출간되었습니다. 학생분들은 도서관에 직장인은 도서구매부에 얼른얼른 구매 신청해주세요! ㅎㅎ</p>

<p><img src="http://dogfeet.github.io/articles/2013/progit-ko-book-published/progit.jpg" alt=""/> <img src="/articles/2013/progit-ko-book-published/devops.png" alt=""/></p>

<h2>프로 Git 출간 이야기</h2>

<p>이미 Pro Git의 한글 번역 전문이 이 블로그 및 github을 통해 오픈소스로 공개되어 있지만, 인사이트 출판사의 도움으로 종이책으로 출간되었습니다. 종이책으로 나올 수 있었던 뒷 이야기는 인사이트 블로그의 <a href="http://www.insightbook.co.kr/post/5633"><프로 Git>, 이미 공개된 내용을 왜 책으로 만들었냐고요?</a> 글을 통해 살펴보실 수 있습니다.</p>

<p>종이책으로 출간된 책의 기본 내용은 동일하지만 몇 번의 교정 과정을 더 거쳤고 이미지도 업데이트 되었으며 부록으로 미처 다루지 못한 몇 가지 내용을 더 담아두었습니다.</p>

<p>주요 오프라인이나 온라인 서점을 통해 구입하실 수 있구요 출간된 것은 4월 중순인데 이렇게 글로 소식을 올리는 것이 늦어졌습니다. <sup>^</sup></p>

<h2>또 다른 번역서, 데브옵스 출간 소식</h2>

<p>또 하나, &lsquo;프로 Git'에 이어 저희 팀원분이 번역한 <a href="http://www.wikibook.co.kr/wiki/Wiki.jsp?page=DevOps">데브옵스</a>도 5월 말에 출간됩니다. 데브옵스에 대한 다양한 문제 상황과 해결법을 다루고 있어 관심있는 분께는 많은 도움이 되리라 생각합니다. 현재 예약판매 중이며 곧 온라인과 오프라인 서점에서 구입하실 수 있습니다.</p>
]]>
</content></entry><entry><title><![CDATA[ git: password caching ]]></title><link href="http://dogfeet.github.io/articles/2013/git-password-caching.html" /><updated>2013-03-27T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/git-password-caching.html</id><content type="html"><![CDATA[
<p>요즘은 뭐든 Smart한 시대인지라 http(s) 프로토콜도 Smart하지 않을 수 없다(<a href="http://git-scm.com/2010/03/04/smart-http.html">Smart http</a>). <a href="http://git-scm.com/book/ko">Pro Git</a>에서는 http(s)가 Smart하지 않다고 설명하지만 그건 <a href="http://git-scm.com/book/ko">Pro Git</a>이 출간되고 나서 만들어진 거라 책에는 내용이 빠져 있다. 이제는 ssh를 사용하든 http(s)를 사용하든 효율의 차이는 없다.</p>

<p>ssh는 회사 방화벽에서 막아버릴 수도 있고 익명접근도 허용하지 않지만, http(s)는 그런 게 없다. GitHub도 이제는 ssh가 아닌 http(s)가 기본이다(https 주소를 먼저 보여준다):</p>

<p><img src="http://dogfeet.github.io/articles/2013/git-password-caching/http-ssh.png" alt=""/></p>

<p>그런데 ssh는 인증서를 사용하면 ssh-agent를 사용하면 암호를 한 번만 입력할 수 있는데, http(s)에서는 Basic 인증을 통해서 인증하는지라 다른 메커니즘이 필요하다. 이 글은 GitHub help 페이지에 있는 Password Caching을 요약한 글이다.</p>

<h2>Password Caching.</h2>

<p><em>Git버전이 1.7.10 이상 돼야 한다. 그래야 이 기능을 사용할 수 있다.</em></p>

<p>나는 주로 ssh를 사용하므로 http(s)를 잘 사용하지 않는다. ssh에 익숙해져서 http(s)가 더 어색하다. 하지만, gist에서는 http(s)를 사용하는 것이 편하다. GitHub이 Gist에서는 git 프로토콜 주소를 안내하지 않고 있다:</p>

<p><img src="/articles/2013/git-password-caching/gist-clone.png" alt=""/></p>

<p>화면의 주소는 다음과 같은 형태다:</p>
<pre><code><span class="label">https:</span>//gist<span class="preprocessor">.github</span><span class="preprocessor">.com</span>/xxxxxxxxxxxxxxxxxxxx<span class="preprocessor">.git</span>
</code></pre>
<p>ssh 프로토콜로도 사용할 수 있긴 하다. 단지 복사해서 붙여 넣을 수 없을 뿐이다:</p>
<pre><code>git@gist<span class="variable">.github</span><span class="variable">.com</span>:xxxxxxxxxxxxxxxxxxxx<span class="variable">.git</span>
</code></pre>
<p>gist는 git을 이용하지만 전문 버전관리 도구가 아니라 프로토타이핑 도구라서 http(s) 프로토콜만으로도 충분할 수 있다. 그래도 명령을 실행할 때마다 암호를 입력하는 일은 좀 불편하다. http(s)에도 ssh처럼 사용할 수 있는 매우 편리한 방법이 있다.</p>

<h3>Linux</h3>

<p>다음과 같이 설정하면 한번 입력한 암호가 저장된다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">credential</span>.<span class="comment">helper</span> <span class="comment">cache</span>
</code></pre>
<p>기본적으로 15분 저장해주는데 다음과 같이 기간을 수정할 수 있다:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">credential</span>.<span class="comment">helper</span> <span class="comment">'cache</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">timeout=3600'</span>
</code></pre>
<p>&lsquo;ssh-agent'로 하는 것과 거의 비슷하다.</p>

<h3>Mac</h3>

<p>Mac에서는 'osxkeychain credential helper'라는 게 있어서 ssh처럼 keychain을 사용할 수 있다.</p>

<p>먼저 osxkeychain이 잘 동작하는지 확인하고:</p>
<pre><code>% git credential-osxkeychain
Usage: git credential-osxkeychain <span class="tag">&lt;<span class="title">get|store|erase</span>&gt;</span>
</code></pre>
<p>설치돼 있지 않으면 아래와 같이 설치한다:</p>
<pre><code>% git credential-osxkeychain
git: <span class="string">'credential-osxkeychain'</span> <span class="keyword">is</span> <span class="keyword">not</span> a git command. See <span class="string">'git --help'</span>.

% curl -s -O http:<span class="regexp">//gi</span>thub-media-downloads.s3.amazonaws.com<span class="regexp">/osx/gi</span>t-credential-osxkeychain
% chmod u+x git-credential-osxkeychain
% sudo mv git-credential-osxkeychain `<span class="javascript">dirname \</span>`which git\`<span class="javascript"></span>`
</code></pre>
<p>'credential helper'로 osxkeychain을 사용할 것이라고 알린다.:</p>
<pre><code><span class="comment">%</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">credential</span>.<span class="comment">helper</span> <span class="comment">osxkeychain</span>
</code></pre>
<p>이제 ssh를 사용할 때는 ssh 인증서가 사용되고 http(s)를 사용할 때는 'osxkeychain credential helper'가 사용된다.</p>

<p>이렇게 설정하면 CLI뿐만 아니라 <a href="http://www.sourcetreeapp.com/">SourceTree</a>같은 GUI에서도 매번 암호를 입력하지 않을 수 있다.</p>

<h3>Windows</h3>

<p><a href="http://blob.andrewnurse.net/gitcredentialwinstore/git-credential-winstore.exe">git-credential-winstore</a>를 내려받아서 실행경로에 넣고 한번 실행해준다. 그러면 msysgit 에서 잘 사용할 수 있다. 'GitHub for Windows'에는 이미 포함돼 있어서 별도로 설치할 필요가 없다.</p>

<p>Windows XP에서는 SourceTree를 설치할 수 없어서 확인하지 못했다.</p>
]]>
</content></entry><entry><title><![CDATA[ mac: java-web-start ]]></title><link href="http://dogfeet.github.io/articles/2013/mac-java-web-start.html" /><updated>2013-03-07T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/mac-java-web-start.html</id><content type="html"><![CDATA[
<p>언제부터 안되더라? 왜 안되더라? 그런건 잘 모르겠고 Mac에서는 Java Web Start가 그냥 실행되지 않는다. Apple이 막은 건데, Oracle이 미운 이유는 뭘까! 아무튼 다시 켜는 방법이 있다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/mac-java-web-start/mung-me.jpg" alt=""/></p>

<h2>Java web start</h2>

<p>윈도에서 처럼 매끄럽게 브라우저 안에서 Java App이 실행되지 않더라도 jnlp 파일을 다운로드 받아서 javaws 명령으로 실행시키면 실행해야 하는데 다음과 같은 에러를 내뱉는다:</p>
<pre><code>% javaws my.jnlp
Java Web Start splash screen process exiting <span class="keyword">...</span>
Can not find message file: No such file or directory
</code></pre>
<p>Google님께 물어보면 Java7을 설치하라는 얘기가 많다. 그래서 설치하고 이것 저것 해봤는데도 됐다가 안됐다가 했다. 자세한 히스토리는 알고 싶지 않았고 그냥 실행만 됐으면 했는데, 그래도 그냥 Java7을 설치했었다. Oracle Java7을 설치하라고 하니 왠지 내 Mac을 욕보이는 것 같았지만 그냥 설치했다.</p>

<p>어짜피 안돼서 Java7을 삭제했는데 Mac이 먹통ㅜㅜ. Mac까지 다시 설치해야 하나 싶었는데 이유는 모르겠지만 복구 됐다(야호!). 욕하고 싶은 상대가 Apple이 아닌 Oracle인건 왜일까!</p>

<p>아래와 같이 파일을 열고:</p>
<pre><code>% sudo vi /System/Library/CoreServices/CoreTypes<span class="variable">.bundle</span>/Contents/Resources/XProtect<span class="variable">.meta</span><span class="variable">.plist</span>
</code></pre>
<p>주석처리를 좀 하고:</p>
<pre><code class="lang-xml"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="doctype">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span>
<span class="tag">&lt;<span class="title">plist</span> <span class="attribute">version</span>=<span class="value">"1.0"</span>&gt;</span>
<span class="tag">&lt;<span class="title">dict</span>&gt;</span>
<span class="comment">&lt;!--
  &lt;key&gt;JavaWebComponentVersionMinimum&lt;/key&gt;
  &lt;string&gt;1.6.0_41-b02-446&lt;/string&gt;
--&gt;</span>
  <span class="tag">&lt;<span class="title">key</span>&gt;</span>LastModification<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
  <span class="tag">&lt;<span class="title">string</span>&gt;</span>Mon, 04 Mar 2013 21:47:02 GMT<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
  <span class="tag">&lt;<span class="title">key</span>&gt;</span>PlugInBlacklist<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
  <span class="tag">&lt;<span class="title">dict</span>&gt;</span>
    <span class="tag">&lt;<span class="title">key</span>&gt;</span>10<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
    <span class="tag">&lt;<span class="title">dict</span>&gt;</span>
      <span class="tag">&lt;<span class="title">key</span>&gt;</span>com.macromedia.Flash Player.plugin<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
      <span class="tag">&lt;<span class="title">dict</span>&gt;</span>
        <span class="tag">&lt;<span class="title">key</span>&gt;</span>MinimumPlugInBundleVersion<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
        <span class="tag">&lt;<span class="title">string</span>&gt;</span>11.6.602.171<span class="tag">&lt;/<span class="title">string</span>&gt;</span>
      <span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
<span class="comment">&lt;!--
      &lt;key&gt;com.oracle.java.JavaAppletPlugin&lt;/key&gt;
      &lt;dict&gt;
        &lt;key&gt;MinimumPlugInBundleVersion&lt;/key&gt;
        &lt;string&gt;1.7.15.04&lt;/string&gt;
      &lt;/dict&gt;
--&gt;</span>
    <span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
  <span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
  <span class="tag">&lt;<span class="title">key</span>&gt;</span>Version<span class="tag">&lt;/<span class="title">key</span>&gt;</span>
  <span class="tag">&lt;<span class="title">integer</span>&gt;</span>2033<span class="tag">&lt;/<span class="title">integer</span>&gt;</span>
<span class="tag">&lt;/<span class="title">dict</span>&gt;</span>
<span class="tag">&lt;/<span class="title">plist</span>&gt;</span>
</code></pre>
<p>리부팅한다. 그리고 아래와 같이 실행한다:</p>
<pre><code>% javaws <span class="filename">my.jnlp
</code></pre>
<p>Apple이 Flash와 Java Applet을 BlackList로까지 분류하고 있는 줄은 몰랐다.</p>

<p>그리고 Mac update를 하면 다시 Disable된다. Disable되면 jre가 설치돼 있는데도 불구하고 javaws를 실행했을 때 아래와 같은 에러를 뱉는다:</p>
<pre><code>% javaws <span class="keyword">my</span>.jnlp
No Java runtime present, requesting install.
Unable <span class="keyword">to</span> locate a Java Runtime <span class="keyword">to</span> invoke.
</code></pre>
<p>아래와 같이 실행하면 다시 javaws를 사용할 수 있다:</p>
<pre><code>su<span class="operator"><span class="keyword">do</span> ln -sf /System/Library/Frameworks/JavaVM.framework/Commands/javaws /usr/bin/javaws
</code></pre>
<p>수동으로 다시 disable하고 싶으면 아래와 같이 실행한다:</p>
<pre><code>% su<span class="operator"><span class="keyword">do</span> ln -sf /System/Library/Frameworks/JavaVM.framework/Versions/<span class="keyword">Current</span>/Commands/javaws /usr/bin/javaws
</code></pre>]]>
</content></entry><entry><title><![CDATA[ grunt: node-coffee 템플릿 ]]></title><link href="http://dogfeet.github.io/articles/2013/grunt-init-node-coffee.html" /><updated>2013-02-20T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/grunt-init-node-coffee.html</id><content type="html"><![CDATA[
<p><a href="https://twitter.com/Outsideris">@Outsideris</a>님의 <a href="http://blog.outsider.ne.kr/892">자바스크립트 빌드 도구 Grunt</a>와 <a href="http://blog.outsider.ne.kr/894">Grunt에 사용자 템플릿 추가하기</a>를 읽고 <a href="https://github.com/pismute/grunt-init-node-coffee">node-coffee</a> 템플릿을 만들었다. <a href="https://twitter.com/docpad">@docpad</a> 덕에 coffeescript에 익숙해졌고 항상 Compile해서 실행하기만 하면 디버그도 할 수 있기 때문에 node를 사용할 때는 coffee를 사용하려고 하는 편이다. 그동안 make를 사용해서 좀 불편했었는데, grunt를 적용하니 정말 편하다. 좀 더 편하려고 Coffeescript에 Mocha를 기본으로 하는 템플릿을 하나 만들었다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/grunt-init-node-coffee/gruntjs.png" alt=""/></p>

<h2>grunt 0.4</h2>

<p>갑자기 0.4 버전이 배포되는 바람에 <a href="https://twitter.com/Outsideris">@Outsideris</a>님의 글이 내용이 틀리게 됐다. 하지만 정리가 잘돼 있어서 grunt를 이해하기에는 여전히 좋은 글이다.</p>

<p><a href="https://twitter.com/Outsideris">@Outsideris</a>님의 글을 읽고 0.3 버전용 <a href="https://github.com/pismute/grunt-init-node-coffee">node-coffee</a>를 만들었다가 나중에 글을 써야지 하고 있었는데, 0.4가 나와 버렸다. <a href="http://gruntjs.com/upgrading-from-0.3-to-0.4">upgrading-from-0.3-to-0.4</a>을 잘 읽고 적용하는 게 좋다. 나는 길어서 대충 읽었다가 삽질을 좀 했다. 다 읽기 귀찮으면 새 템플릿으로 만든 코드를 좀 읽어보고 시작하는 것이 시간을 절약해줄 것 같다.</p>

<h2>node-coffee 템플릿</h2>

<p>이 템플릿은 특징을 요약하면 아래와 같다:</p>

<ul>
<li>Coffeescript

<ul>
<li>Gruntfile.coffee</li>
<li><code>/src/lib/**/*.coffee</code>를 <code>/out/lib/**/*.js</code>로 컴파일</li>
<li><code>/src/test/**/*.coffee</code>를 <code>/out/test/**/*.js</code>로 컴파일</li>
<li>coffeelint</li>
</ul></li>
<li>Javascript

<ul>
<li><code>/src/lib/**/*.js</code>를 <code>/out/lib/**/*.js</code>로 복사</li>
<li><code>/src/test/**/*.js</code>를 <code>/out/test/**/*.js</code>로 복사</li>
<li>jshint 그대로 포함</li>
</ul></li>
<li>Mocha + Should로 변경</li>
</ul>

<p>그 외는 <a href="https://github.com/gruntjs/grunt-init-node">node</a> 템플릿을 수정한 것이기 때문에 node 템플릿과 같다.</p>

<h3>사용법</h3>

<p>다음과 같이 설치한다:</p>
<pre><code>git clone git@github<span class="variable">.com</span>:pismute/grunt-init-node-coffee<span class="variable">.git</span> ~/<span class="variable">.grunt</span>-init/node-coffee
</code></pre>
<p><a href="https://github.com/gruntjs/grunt-init">grunt-init</a>이 설치된 상태에서 다음과 같이 프로젝트를 만든다:</p>
<pre><code><span class="title">mkdir</span> my-project
<span class="title">cd</span> my-project
<span class="title">grunt</span>-init node-coffee
</code></pre>]]>
</content></entry><entry><title><![CDATA[ 그와 그녀의 tryios ]]></title><link href="http://dogfeet.github.io/articles/2013/he-she-codeschool-tryios.html" /><updated>2013-01-19T15:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2013/he-she-codeschool-tryios.html</id><content type="html"><![CDATA[
<p><a href="http://www.codeschool.com/">codeschool</a>에 <a href="http://www.codeschool.com/courses/try-ios">tryios</a>가 올라오자마자 노리고 있었다. 왠지 재미도 있고 쉬울 것 같았다. 이 글은 iOS 초보인 <a href="https://twitter.com/pismute">그</a>와 코딩 초보인 <a href="http://uniquenoun.tumblr.com/">그녀</a>가 함께 <a href="http://www.codeschool.com/courses/try-ios">tryios</a>를 해보고 난 후기다.</p>

<p><img src="http://dogfeet.github.io/articles/2013/codeschool-tryios/tryios.png" alt="tryios"/></p>

<h2>tryios</h2>

<p>이 강의는 제목에서처럼 정말 iOS를 소개하는 수준의 강의다. <a href="https://twitter.com/greggpollack">@greggpollack</a> 선생님이 천천히 쉬운 영어로 설명해주는 것 같지만 뭐라고 말하는지는 들을 수 없다. 내용이 쉬워서 슬라이드로도 충분하긴 하지만 그래도 영어를 알아듣고 싶다.</p>

<p>무료인 <a href="http://www.codecademy.com/">codecademy</a>보다 퀄리티가 높을 거라고는 생각했지만 이렇게 친절할 줄은 생각도 못했다. 처음 접하는 사람이 쉽게 따라 할 수 있도록 기초적인 커리큘럼에 필요한 내용만 가르쳐준다. 거기다가 동영상도 공을 들인 티가 난다. 슬라이드도 아주 예쁘다.</p>

<p>이 강의를 만드는데 무려 12명이나 참여했다:</p>

<p><img src="/articles/2013/codeschool-tryios/credit.png" alt="tryios-credit"/></p>

<p>&lsquo;Mr. Higgie'라는 캐릭터 까지 있다:</p>

<p><img src="/articles/2013/codeschool-tryios/higgie.png" alt="higgie"/></p>

<p>설명을 듣고, 코딩해서, 바로 검사하는 구조는 너무 매력적인 학습방법이다. <a href="https://class.coursera.org/progfun-2012-001/">Coursera의 Scala 강의</a>도 그런 방식이였는데 굉장히 잼있었다. 무엇보다 바로 내가 틀렸는지 알 수 있기 때문에 될 때까지 버티면 정말 된다.</p>

<p>Gamification이 잘 돼있어서 강의를 하나씩 끝날 때 마다 뱃지를 준다:</p>

<p><img src="/articles/2013/codeschool-tryios/badge.png" alt="badge"/></p>

<p><a href="http://beta.openbadges.org/">http://beta.openbadges.org/</a> 에 연계도 된다. <a href="http://openbadges.org/">Open Badges</a>라는 거 처음 봤는데, 뭔지 모르겠다.</p>

<p>Coursera Scala 강의에서는 오덕스키 선생님의 사인이 든 수료증도 줬는데 <a href="https://twitter.com/greggpollack">@greggpollack</a> 선생님의 사인이든 수료증을 별도로 주지 않는다. 하지만 'Report Card'라는 게 있다:</p>

<p><img src="/articles/2013/codeschool-tryios/report-card.png" alt="report-card"/></p>

<p>이 'Report Card'는 공개할 수도 있고 비공개로 설정할 수도 있다. 하지만 타인의 Report Card를 보는 페이지는 찾지 못했다.</p>

<p><a href="http://www.codeschool.com/">CodeSchool</a>은 한달에 $25 단위로 결제해야 한다. $25 결제하면 원하는 대로 강의를 들을 수 있다. 무료 강의도 몇개 있어서 <a href="http://www.codeschool.com/courses/try-git">trygit</a>같은 것을 무료로 해볼 수 있다.</p>

<p>뭔가 처음이라면 codeschool의 강의를 들어보는 게 좋겠다. 유료지만 한달에 $25이 아깝지 않다.</p>

<p>Kickstarter에서 $152,912를 펀딩받아 제작됐다고 한다(<a href="http://www.codeschool.com/2012">http://www.codeschool.com/2012</a>). <a href="http://macminicolo.net/">http://macminicolo.net/</a> 사람들이 만든 것 같은데(추측임), 강의 처음에 나오는 광고도 귀엽다. 앞으로도 재미난 iOS 강의가 많을 것 같아 기대된다.</p>

<h3>code TV</h3>

<p><a href="http://www.codeschool.com/">CodeSchool</a>은 <a href="http://www.codeschool.com/code_tv">Code TV</a>라는 podcast도 제공한다. podcast 링크는 iTunes에서 찾을 수 있다. 좀 잼있어 보이는 강의가 몇개 있다. 영어를 못 들으니 영어 자막을 함께 제공해 줬으면 좋겠는데 영어 자막을 제공하지는 않는다.</p>

<h3>수료</h3>

<p><a href="http://www.codeschool.com/courses/try-ios">tryios</a>를 수료하면 3가지 보상을 준다. 일단 $5에 이르는 <a href="http://www.codeschool.com/">CodeSchool</a> Cash와 'iOS SDK Development'라는 책의 25% 할인권 그리고 <a href="https://www.tinkerlearn.com/xray">TinkerLearn</a>의 50% 할인권을 준다. 지원해주는 회사가 있으면 재밌게 공부도하고 수익 남는ㅋㅋㅋ:</p>

<p><img src="/articles/2013/codeschool-tryios/reward.png" alt="reward"/></p>

<p><a href="https://www.tinkerlearn.com/xray">TinkerLearn</a>은 무료 Lesson만 다운받았는데 해당 Lesson과 관련된 pdf와 샘플 코드가 들어 있다. <a href="http://www.codeschool.com/courses/try-ios">tryios</a>를 끝낸 후 다음에 뭘해야 할지 고민할 필요도 없다:</p>

<p><img src="/articles/2013/codeschool-tryios/tinkerlearn.png" alt="tinkerlearn"/></p>

<h2>그녀</h2>

<p>그녀의 개발툴은 Illustrator와 Photoshop으로 프로그래밍은 잘 모른다. 디자이너도 코드를 읽을 줄 알아야 한다는 드립을 한 5년간 쳤는데, 드디어 일진보 했다.</p>

<p>내가 그녀에게 친 뻥은 아래와 같다:</p>

<ol>
<li>인생은 학습이다. 뭘 배우는지 중요치 않다. 뭐든 배우는 거다.</li>
<li>실무자가 의사 결정을 직접 해야 작업 속도가 빠르고 퀄리티도 높다. 소프트웨어 디자인을 한다면 소프트웨어에서 디자인을 어떻게 표현하는지 사람들이 어떻게 작업하는지 알아야 한다.</li>
<li>결정권이 없는 실무자는 우울해진다. 동료를 위해 디자인과 관계된 실무를 익혀라.</li>
</ol>

<p>그녀에 대답은 대체로 아래와 같았다:</p>

<ol>
<li>너부터 디자인을 배워라.</li>
<li>소프트웨어 싫다.</li>
<li>동료가 없다.</li>
</ol>

<p>그렇게 줄다리기를 하다가 <a href="http://www.codeschool.com/">CodeSchool</a> 덕택에 함께 공부를 해보게 됐다.</p>

<p>뭐든 상관 없지만, iOS를 배워보기로 했다. iOS, web, Android를 제안했는데 그녀는 iOS를 골랐다. iPhone의 완성도는 역시 너무 매력적이다.</p>

<p><a href="http://www.codeschool.com/courses/try-ios">tryios</a>를 시작하기 전에 그녀는 Objective-C를 좀 먼저 읽었다. 분명 제대로 공부를 하고 있다면 질문이 많았을 텐데 질문이 많지 않은 거로 봐서 멘붕 상태에 있다는 걸 알 수 있었다. 그녀는 <a href="http://www.codeschool.com/courses/try-ios">tryios</a> 강의를 수료한 지금도 멘붕 상태다.</p>

<p>들리지도 않는 동영상 교재를 끝까지 듣고, 처음보는 외계어로 가득찬 슬라이드를 끝까지 감내한 그녀에게 경의를 표한다.</p>

<p>총 6 챕터로 구성된 강의는 매 챕터마다 3~4시간 가량 걸렸다. tryios는 아주 기본적인 내용만 다루기 때문에 하루 정도면 충분하다. 나는 좀 불친절한 성격이라 그녀가 묻는 질문에만 대답해서 오래걸렸다.</p>

<p>내 느낌은 이렇다:</p>

<p><img src="/articles/2013/codeschool-tryios/haksan.png" alt="haksan"/></p>

<p>내가 그녀라면 인내할 수 있었을까? 훌륭하다. 그녀는 이왕 결재한 거라고 하면서 <a href="http://www.codeschool.com/courses/functional-html5-css3">Functional HTML5 & CSS3</a>와 <a href="http://www.codeschool.com/courses/functional-html5-css3">CSS Cross-Country</a> 강의도 시작했다:</p>

<p><img src="/articles/2013/codeschool-tryios/functional-html5-css3.png" alt="functional-html5-css3"/></p>

<p><img src="/articles/2013/codeschool-tryios/css-cross-country.png" alt="css-cross-country"/></p>

<p><a href="http://www.codeschool.com/courses/try-ios">tryios</a> 강의를 끝내고 받은 퀘스트 보상때문에 나도 이 두 강의를 시작했다. 찬찬히 <a href="http://www.codeschool.com/">CodeSchool</a>의 강의를 전부 해보려한다.</p>

<h2>영어</h2>

<p>영어라는 장벽이 없었으면 나도 그녀도 좀 더 쉽게 따라 했을 것 같다. 영어로 표현된 외계어로 가득찬 자료를 끝까지 참아줘서 고맙다. 그덕에 나도 많은 것을 배웠다.</p>

<p><a href="http://www.codeschool.com/">CodeSchool</a> 강의 중에서는 영어자막을 제공하는 강의도 있다. <a href="http://www.codeschool.com/courses/try-ios">tryios</a>는 제공하지 않았는데 <a href="http://www.codeschool.com/courses/functional-html5-css3">Functional HTML5 & CSS3</a>와 <a href="http://www.codeschool.com/courses/functional-html5-css3">CSS Cross-Country</a>는 영어자막이 있다.</p>

<p>영어가 되는 사람들은 좋겠다. 쉽고 재밌는 학습 도구가 많아서 좋겠다. 글래머 금발이랑 코딩할 수 있어서 좋겠다. 앞으로는 영어를 좀 더 to-the-core하게 해서 그런 삶을 살아야 겠다.</p>
]]>
</content></entry><entry><title><![CDATA[ Git: GitHub secrets ]]></title><link href="http://dogfeet.github.io/articles/2012/git-github-secrets.html" /><updated>2012-12-29T00:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2012/git-github-secrets.html</id><content type="html"><![CDATA[
<p>이글은 <a href="https://twitter.com/holman">@holman</a>님이 싱가폴에서 열린 <a href="http://reddotrubyconf.com/">RedDotRubyConf</a>에서 발표한 <a href="http://zachholman.com/talk/git-github-secrets">Git and GitHub Secrets</a>에 설명을 달았다. 내용이 길어서 둘로 나눴는데 이 글은 <code>GitHub Secetets</code> 부분을 정리한 글이다. <a href="/articles/2012/git-secrets.html">Git Secrets</a>은 다른 글에서 정리한다.</p>

<p><img src="http://dogfeet.github.io/articles/2012/git-github-secrets/holman.png" alt="holman"/></p>

<p>이 글을 정리하면서 그림을 많이 삽입하지 않았다. <code>GitHub Secrets</code> 부분은 그림이 너무 많아서 생략했다. 이 글을 읽고서 슬라이드를 한번 보는게 좋을 것 같다.</p>

<h2>숨겨진 기능</h2>

<p>GitHub은 단순함을 추구한다. 그래서 GitHub에는 기능이 많은 데도 불구하고 굳이 화면에 보여주지 않는다.</p>

<h3>.patch, .diff</h3>

<p>커밋 URL 뒤에 .patch나 .diff 붙이면 해당 포멧의 파일이 나온다. 정확하게는 &lsquo;Compare View, Pull Requests, Commit Pages&rsquo; 화면에서 사용할 수 있다.</p>

<ul>
<li><a href="https://github.com/dogfeet/dogit/commit/a1f156b6415439a8a84c3d2fa89ea975fb3a7ac2.diff">.diff 예제</a></li>
<li><a href="https://github.com/dogfeet/dogit/commit/a1f156b6415439a8a84c3d2fa89ea975fb3a7ac2.patch">.patch 예제</a></li>
</ul>

<h2>공백문자는 무시하고 diff를 보여준다.</h2>

<p>diff URL끝에 <code>?w=1</code>를 붙이면 공백문자를 무시한 결과를 보여준다.</p>

<p><img src="/articles/2012/git-github-secrets/ignore-whitespace.png" alt="ignore_whitespace"/></p>

<h3>SVN 클라이언트도 지원.</h3>

<p>&lsquo;SVN/Git 서비스 레이어'가 있어서 SVN 요청을 Git 요청으로 변환해준다.</p>

<p>당연히 Git 클라이언트를 사용할 수 있지만:</p>
<pre><code>$ git <span class="keyword">clone</span> https:<span class="comment">//github.com/dogfeet/dogit.git</span>
</code></pre>
<p>SVN 클라이언트도 사용할 수 있다:</p>
<pre><code><span class="char">$ </span>svn checkout <span class="method">https:</span>//github.com/dogfeet/dogit.git
</code></pre>
<h3>SSH & HTTP => HTTP & SSH</h3>

<p>GitHub은 기본 프로토콜을 SSH에서 HTTP로 바꿨다. 원래 HTTP 프로토콜을 사용하는 방식은 성능이 후져서 SSH를 권장했는데 이제 SmartHTTP 덕택에 HTTP도 효율적이다.</p>

<p>원래 SSH를 먼저 보여줬었지만:</p>

<p><img src="/articles/2012/git-github-secrets/ssh-http.png" alt="before"/></p>

<p>지금은 HTTP를 먼저 보여준다:</p>

<p><img src="/articles/2012/git-github-secrets/http-ssh.png" alt="after"/></p>

<p>이제 HTTP도 효율적이기 때문에 1) 회사 방화벽 뒤에서도 맘껏 GitHub을 즐길 수 있고 2) SSH Key를 사용하기 힘든 Windows 환경에서도 사용하기 쉬워졌다. SSH key없이도 암호를 메모리에 저장해서 사용할 수 있다. 이 방법은 git 1.7.10부터 사용할 수 있고 GitHub의 <a href="https://help.github.com/articles/set-up-git">패스워드 캐싱하는 방법</a>에 잘 설명돼 있다.</p>

<h4>SmartHTTP</h4>

<p>SmartHTTP는 git 1.6.6부터 지원한다. git 1.6.6은 2009년 말에 배포됐다.</p>

<p>Git은 개체를 'Packfile'이라는 덩어리에 묶어서 관리한다. 이전 버전에서는 사용자가 'Packfile'에 들어 있는 개체 한 개가 필요해도 <code>Packfile</code>을 통째로 전송해야 했다. 그래서 HTTP를 더미 프로토콜이라고 불렀다. 이제는 SmartHTTP가 있어서 'Packfile'에서 필요한 개체만 꺼내서 전송할 수 있다.</p>

<p>progit 책을 집필할 때에는 SmartHTTP가 없었기 때문에 이를 설명하지 않았다. SmartHTTP에 대해서 자세히 알아보려면 progit 9장과 <a href="http://git-scm.com/2010/03/04/smart-http.html">Smart HTTP Transport</a>를 읽는게 좋다.</p>

<h3>URL에서 &rsquo;.git'은 생략해도 된다.</h3>
<pre><code>git <span class="keyword">clone</span> https:<span class="comment">//github.com/holman/boom.git</span>
git <span class="keyword">clone</span> https:<span class="comment">//github.com/holman/boom</span>
</code></pre>
<h3>GitHub HD&trade;</h3>

<p>GitHub 페이지의 아이콘이 HD 벡터 아이콘이라서 계속 확대해도 깨지지 않는다.</p>

<h3>Auditing</h3>

<p>우리말로 하자면 &lsquo;감사로그&rsquo; 쯤 되는 건데, GitHub에서 일어난 중요한 액션은 로그가 남는다:</p>

<p><a href="https://github.com/settings/security">https://github.com/settings/security</a></p>

<h3>Octocat</h3>

<p><a href="https://twitter.com/defunkt">@defunkt</a>님이 에러페이지에 사용할 이미지를 찾다가 <a href="http://www.istockphoto.com/">Istockphoto</a>에서 싸게 산 이미지였는데 사람들이 좋아해서 지금은 GitHub의 마스코드가 됐다. 처음에는 아니였지만 지금은 GitHub이 저작권을 가지고 있다.</p>

<p><a href="http://www.quora.com/GitHub/What-is-the-story-behind-GitHub%E2%80%99s-octocat-mascot">Octocat 스토리</a>는 Quora에서 참고.</p>

<p><a href="http://octodex.github.com/">http://octodex.github.com/</a> 에 가면 Octocat 이미지가 많다.</p>

<h3>git.io</h3>

<p>GitHub용 URL Shortner이다. 작은 <a href="git.io/nxVVig">쉘 스크립트</a>로 구현돼 있고 다음과 같이 사용한다.</p>
<pre><code>$ gitio <span class="tag">&lt;<span class="title">url</span>&gt;</span> <span class="tag">&lt;<span class="title">name</span>&gt;</span>
</code></pre>
<p><a href="https://chrome.google.com/webstore/detail/gitio-url-shortener/baceaeopmlhkjbljoiinmbnnmpokgiml">Chrome Extension</a>도 있다.</p>

<h3>Linguist</h3>

<p>저장소에 든 언어가 뭔지 찾아서 직접 그 저장소에서 개발된 파일만 추려서 &lsquo;Syntax Highlighting'도 해준다. GitHub은 이 Linguist를 다음과 같은 걸 만들어 내는데 사용한다:</p>

<p><img src="/articles/2012/git-github-secrets/linguist.png" alt="linguist"/></p>

<p>기능:</p>

<ul>
<li>'Language Detection&rsquo; - 어떤 언어가 사용됐는지 찾는다.</li>
<li>&lsquo;Stats&rsquo; - 언어 통계를 알려준다.</li>
<li>&lsquo;Syntax Highlighting&rsquo; - Pygments를 사용한다.</li>
<li>&lsquo;Vendored Files&rsquo; - 저장소에 들어 있는 파일 중 다른 프로젝트에서 가져온 파일. ex) jquery.js</li>
<li>&lsquo;Generated file detection&rsquo; - 생성되는 파일을 알아서 제외한다.</li>
</ul>

<h3>email reply</h3>

<p>이메일로 comments에 답변을 달 수 있다.</p>

<h3>gist</h3>

<p>단순히 코드 snippet을 공유하는 도구가 아니다. 코멘트, 스크린샷, 코드를 공유를 할 수 있기 때문에 프로토타이핑 도구로 사용하기에도 좋다. 개발자와 디자이너 모두에게 유용하다.</p>

<p>gist 자체가 git 저장소이기 때문에 clone할 수도 있다:</p>
<pre><code><span class="title">git</span> clone <span class="url">git://gist.github.com/2720312</span>
</code></pre>
<p>간단하게 만들어서 프로토타이핑을 해보기에 아주 좋다.</p>

<h4>microgems.</h4>

<p>Ruby Gem으로도 사용할 수 있는 것 같다. 나는 Ruby를 몰라서 알 수 없다.</p>

<p><a href="http://jeffkreeftmeijer.com/2011/microgems-five-minute-rubygems/">http://jeffkreeftmeijer.com/2011/microgems-five-minute-rubygems/</a></p>

<h3>Image View Mode</h3>

<p>Gist에 이미지를 올리고 비교하면 비교해보기 좋게 나열해준다. 정말 쩐다. 데모 페이지에 가서 클릭해보자.</p>

<p>이 기능은 <a href="http://www.kaleidoscopeapp.com/">KaleidoScope</a>같은 도구에서 있는 건데 GitHub도 된다. <a href="http://www.sourcetreeapp.com/">SourceTree</a>같은 데서도 가능하면 좋겠다.</p>

<p>GitHub의 <a href="https://github.com/blog/817-behold-image-view-modes">Behold: Image view modes</a>에 잘 소개돼 있다.</p>

<h3>Command Line GitHub - hub</h3>

<p><a href="https://github.com/defunkt/hub">hub</a>라는 프로그램이 있다. Command Line에서 GitHub을 사용할 수 있는 명령이다. git + github 명령이라고 생각하면 된다. GitHub을 사용하면서 자동화한다면 꼭 필요한 툴이라고 생각된다. 나중에 따로 정리해야 겠다.</p>

<h3>Keyboard Shortcuts</h3>

<p>GitHub의 모든 페이지에서 <code>?</code>를 누르면 그 페이지에서 사용할 수 있는 단축키를 보여준다.</p>

<h3>Subscribing People</h3>

<p>GitHub에서 글쓸때 <code>@pismute</code>쓰면 해당 사용자에게 알림이 간다. <code>@org/team</code>라는 팀 표현식도 있어서 팀 전체한테 노티를 줄수도 있다.</p>

<h3>GitHub Flavored Markdown</h3>

<p><a href="http://github.github.com/github-flavored-markdown/">GFM</a>에 대한 설명도 있다.</p>

<h3>Auto-Closing Issues</h3>

<p>커밋메시지에 <code>CLOSES/CLOSED/CLOSE #1</code>나 <code>FIXES/FIXED/FIX #1</code>라고 쓰면 해당 이슈가 자동으로 닫힌다.</p>

<h3>Commit by Author</h3>

<p>GitHub의 커밋 페이지에서 <code>?author=holman</code> 처럼 파라미터를 넘기면 해당 사용자의 커밋만 볼 수 있다:</p>

<ul>
<li><a href="https://github.com/progit/progit/commits/master?author=pismute">https://github.com/progit/progit/commits/master?author=pismute</a></li>
</ul>

<h3>Branch-to-Branch</h3>

<p>Pull Request는 브랜치 단위로 하는 거라는 얘기. 그래서 원 저장소가 아니라 Clone 저장소에도 Pull Request를 보낼 수 있다.</p>

<h3>emoji!</h3>

<p>GitHub에서 emoji 이모티콘을 사용할 수 있다. 사용할 수 있는 이모티콘은 <a href="http://www.emoji-cheat-sheet.com/">http://www.emoji-cheat-sheet.com/</a> 에서 참고.</p>

<h3>Link Linking</h3>

<p>GitHub 페이지에서 파일 보기 화면에서 URL 뒤에 <code>#L16</code>을 붙이면 16라인이 노랗게 보인다. <code>#L16-32</code>를 붙이면 16라인부터 32라인까지 노랗게 보인다. 다른 사람과 코드에 대해 수다떨 때 어떤 라인에 대해서 얘기하는 건지 콕 집어 줄 수 있다.</p>

<h3>Advanced Compare View</h3>

<p><code>github.com/user/repo/compare/{range}</code>과 같은 형식의 URL을 사용하면 되고 <code>{range}</code>부분에 다음과 같이 넣을 수 있다:</p>

<ul>
<li><code>master@{1.day.ago}...master</code></li>
<li><code>master@{yesterday}...master</code></li>
<li><code>master@{2012-02-25}...master</code></li>
</ul>

<p>아래와 같이 사용한다:</p>

<p><a href="https://github.com/dogfeet/dogit/compare/master@%7B60.day.ago%7D...master">https://github.com/dogfeet/dogit/compare/master@{60.day.ago}&hellip;master</a></p>
]]>
</content></entry><entry><title><![CDATA[ Git: git secrets ]]></title><link href="http://dogfeet.github.io/articles/2012/git-secrets.html" /><updated>2012-12-19T00:00:00.000Z</updated><id>http://dogfeet.github.io/articles/2012/git-secrets.html</id><content type="html"><![CDATA[
<p>이글은 <a href="https://twitter.com/holman">@holman</a>님이 싱가폴에서 열린 <a href="http://reddotrubyconf.com/">RedDotRubyConf</a>에서 발표한 <a href="http://zachholman.com/talk/git-github-secrets">Git and GitHub Secrets</a>에 설명을 달았다. 내용이 길어서 둘로 나눴는데 이 글은 <code>Git Secetets</code>부분을 정리한 글이다. <a href="/articles/2012/git-github-secrets.html">GitHub Secrets</a>은 다른 글에 정리한다.</p>

<p>Git은 명령과 옵션이 굉장히 많은데, 그 중에서 <a href="https://twitter.com/holman">@holman</a>님이 추천하는 쓸만한 것이라고 생각하면 되겠다.</p>

<p><img src="http://dogfeet.github.io/articles/2012/git-secrets/holman.png" alt="holman"/></p>

<h2>Git secret</h2>

<h3>&ndash;allow-empty</h3>

<p>파일없이 커밋할 수 있다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">commit</span> <span class="literal">-</span><span class="comment">m</span> <span class="comment">"LOOK</span> <span class="comment">AT</span> <span class="comment">ME</span> <span class="comment">TROLOLOL"</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">allow</span>-<span class="comment">empty</span>
</code></pre>
<p><code>git log</code>를 하면 아무내용없이 그냥 커밋 개체만 달랑 생긴다.</p>
<pre><code>$ git log
<span class="operator"><span class="keyword">commit</span> <span class="number">6</span>eb28f645174fba20d819f40da4ca822c7c67b2a
Author: Changwoo Park &lt;pismute@gmail.com&gt;
<span class="keyword">Date</span>:   Tue Nov <span class="number">12</span> <span class="number">20</span>:<span class="number">32</span>:<span class="number">25</span> <span class="number">2012</span> +<span class="number">0900</span>

    LOOK <span class="keyword">AT</span> ME TROLOLOL
</code></pre>
<p>히스토리에 뭔가 표식을 남기고 싶을 때 유용하다.</p>

<h3>Staging Hunk</h3>

<p>파일에서 한 부분? 덩어리?를 Hunk라고 부른다. <code>git add -p</code> 명령으로 파일을 통째로 Staging Area에 넣는게 아니라 일정 부분만(hunk만) 골라서 넣는다.</p>

<p>자세한 설명은 <a href="https://twitter.com/semtlnori">@semtlnori</a>님의 <a href="http://npcode.com/blog/archives/449">깔끔하게 커밋하기</a>를 보자.</p>

<h3>git show :/query</h3>

<p>특정 질의가 들어간 커밋 중에서 가장 최근 커밋 하나를 찾아 준다. 로그를 분석할때 매우 유용하다. 커밋 메시지, 파일 이름, 파일 내용에서 찾는다.</p>

<p><code>git log</code> 명령에도 있어서 <code>git log :/query</code>라고 실행해도 된다. <code>:/query</code> 만족하는 커밋을 골라서 보여준다.</p>

<h3>go back</h3>

<p><code>cd -</code>라고 실행하면 이전 디렉토리로 되돌아 간다. <code>cd</code>명령 처럼 <code>git checkout -</code>라고 하면 이전 브랜치를 checkout한다.</p>

<h3>merged branch</h3>

<p>브랜치나 커밋이 다른 브랜치에 Merge됐는지 확인하는 명령들.</p>

<ul>
<li><code>git branch --merged</code> : 이미 다른 브랜치에 머지된 것만 보여준다.</li>
<li><code>git branch --no-merged</code> : 아직 다른 브랜치에 머지되지 않는 것만 보여준다.</li>
<li><code>git branch --contains 838ad46</code> : 특정 커밋이 포함된 브랜치만 보여준다.</li>
</ul>

<h3>Content Copy</h3>

<p>브랜치를 변경하지 않고도 다른 브랜치에 들어 있는 파일을 복사해 올 수 있다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">checkout</span> <span class="comment">BRANCH</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">path/to/file</span>.<span class="comment">rb</span>
</code></pre>
<p><code>path/to/file.rb</code>에 파일이 복사된다.</p>

<p>Reset과 Checkout은 비슷해보여서 구분하기 쉽지 않다. Checkout은 데이터베이스에서 뭔가를 꺼낼때 사용하는 명령이다. 옵션도 스냅샷과 파일이름 등 그와 관련된 옵션으로 구성돼있다. 반대로 Reset은 워킹 디렉토리, Staging Area, 브랜치 등을 스냅샷으로 Reset하는 명령이다.</p>

<p>이렇게 구분하면 쉽다. 데이터베이스에서 뭔가를 꺼낼때는 Checkout을 사용하고 그외는 Reset을 사용한다.</p>

<h3>Reachable Commits</h3>

<p>특정 브랜치에만 있는 커밋이 보고 싶을 때는 다음과 같이 한다:</p>

<p><code>git log branchA ^branchB</code></p>

<p>branchA에는 있고 branchB에는 없는 커밋을 보여준다.</p>

<h3>FINDING LOST COMMITS</h3>

<p>어떤 브랜치에도 들어 있지 않은 커밋을 보여준다. git의 커밋은 개체는 실제로 전부 immutable이라서 커밋을 수정하면 새로운 커밋 개체가 등록된다. 잘 못 수정했으면 아래 명령으로 커밋을 찾아서 복구한다:</p>
<pre><code>$ git fsck <span class="comment">--lost-found</span>
Checking object directories: 100% (256/256), done.
dangling <span class="operator"><span class="keyword">commit</span> <span class="number">4</span>a7f2e89a480d3af0ccfdf71f76f4149f25fb0fb
dangling <span class="keyword">commit</span> d3ad9f17532109d12084646c306e9d7748c2f791
</code></pre>
<p>어떤 브랜치에도 속하지 않은 커밋이 두 개있다.</p>

<h2>DIFFSTATS</h2>

<p>델타(diff)를 다 보여주는 게 기본인데 통계만 볼 수도 있다:</p>

<p><code>git diff HEAD^ --stat</code></p>

<p><img src="/articles/2012/git-secrets/git-diff--stat.png" alt="git-diff--stat"/></p>

<h3>BLAME</h3>

<p><code>git blame</code>은 기본적으로 어떤 라인을 누가 고쳤는지 확인하는 명령이다.</p>

<p><strong>blame이니까</strong></p>

<p><code>git blame</code>은 기본적으로 어떤 라인을 <strong>어떤 새끼</strong>가 고쳤는지 확인하는 명령이다.</p>

<h4>git blame -w</h4>

<p>정말 내용을 수정한 <strong>새끼</strong>를 찾는다. 공백만 추가한 경우는 무시한다. <code>git diff HEAD~</code> 명령으로 공백이 어디에 추가됐는지 보자:</p>

<p><img src="/articles/2012/git-secrets/git-blame-w-diff.png" alt="git-blame-w-diff"/></p>

<p>히스토리를 보면 마지막에 &ldquo;BBB&quot;가 공백을 추가했다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-w-lg.png" alt="git-blame-w-lg"/></p>

<p>다음은 <code>git blame -w</code>의 결과다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-w.png" alt="git-blame-w"/></p>

<p>단순히 공백만 추가한 &quot;BBB&quot;는 무시된다. <code>-w</code>을 옵션을 빼고 <code>git blame</code>만 실행하면 공백만 추가한 &quot;BBB&quot;도 나온다.</p>

<p><img src="/articles/2012/git-secrets/git-blame.png" alt="git-blame"/></p>

<h4>git blame -M</h4>

<p>해당 라인을 실질적으로 마지막에 수정한 사람을 보여준다. 이 옵션을 주면 같은 파일 내에서 단순히 라인을 옮긴 사람이 아니라 마지막으로 내용을 수정한 사람이 표시된다:</p>

<p>텍스트를 옮긴 후에 <code>git blame</code> 명령을 실행하면 다음과 같이 나온다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-m-before.png" alt="git-blame"/></p>

<p><code>-M</code> 옵션을 추가하면 단순히 옮긴 사람이 아니라 원래 그 코드를 추가한 사람을 보여준다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-m.png" alt="git-blame"/></p>

<p>원래 의도는 측근 <code>all.md</code> 파일에서 친구 끼리, 가족 끼리 모아서 <code>-M</code> 옵션을 설명할 계획이였다. Git이 정확히 어떤 알고리즘을 사용하는 건지 나중에 살펴봐야 겠다.</p>

<h4>git blame -C</h4>

<p><code>-M</code>와 비슷하게 실제로 마지막에 수정한 사람을 보여준다. 한 파일 내에서의 이동만 감지하는 것이 아니라. 같은 커밋에서의 다른 파일간 이동도 감지한다.</p>

<p><code>all.md</code>라는 파일에서 친구는 <code>friends.md</code>라는 파일로 옮기고 가족은 <code>family.md</code> 파일로 옮겼다. 아래는 <code>git blame -f family.md</code>의 결과다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-c-f.png" alt="git-blame"/></p>

<p><code>-f</code>는 원래 파일이름을 보여주는 옵션이다. <code>git blame -fC family.md</code>의 결과는 아래와 같다:</p>

<p><img src="/articles/2012/git-secrets/git-blame-c-cf.png" alt="git-blame"/></p>

<h4>git blame -CC</h4>

<p><code>-C</code> 처럼 다른 파일에서 옮긴 것을 감지해주는데 해당 파일을 생성한 커밋내에서도 감지한다.</p>

<h4>git blame -CCC</h4>

<p>다른 파일에서 옮긴 것도 감지하는데 커밋을 가리지 않고 전체에서 찾는다.</p>

<h4>MULTI-REMOTE FETCHES</h4>

<p>원래는 하나씩 fetch해야 하지만 group을 만들어서 한번에 fetch할 수 있다.</p>
<pre><code><span class="variable">$ </span>git config remotes.mygroup <span class="string">'remote1 remote2'</span>
<span class="variable">$ </span>git fetch mygroup
</code></pre>
<h4>A BETTER STATUS</h4>

<p>status의 결과를 더 간략하게 볼 수 있다.</p>

<p><code>git status</code>:</p>

<p><img src="/articles/2012/git-secrets/git-status.png" alt="git-status"/></p>

<p><code>git status -sb</code>:</p>

<p><img src="/articles/2012/git-secrets/git-status-sb.png" alt="git-status-sb"/></p>

<h4>WORD DIFFING</h4>

<p>라인 단위로 비교하는 것이 아니라 단어 단위로 비교해서 볼 수 있다.</p>

<p><code>git diff HEAD^</code>:</p>

<p><img src="/articles/2012/git-secrets/git-diff-head-1.png" alt="diff-head-1"/></p>

<p><code>git diff HEAD^ --word-diff</code>:</p>

<p><img src="/articles/2012/git-secrets/git-diff-head-1--word-diff.png" alt="diff-head-1--word-diff"/></p>

<h4>CONFIG: SPELLING</h4>

<p><code>git comit</code>이라고 실행하면 <code>commit</code>이라고 할려고 했냐? 라고 물어봐 주는 게 기본설정이다. 명령을 실행할 때 오타를 내면 자동으로 인식해서 실행하게 할 수 있다. 다음과 같이 설정하면 된다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">help</span>.<span class="comment">autocorrect</span> <span class="comment">1</span>
</code></pre>
<p>이 옵션이 설정되면 <code>git comit</code>이라고 실행하면 그냥 <code>git commit</code>이 실행된다:</p>

<h4>CONFIG: GIT RERERE(REUSE RECORDED RESOLUTION)</h4>

<p><a href="/articles/2012/git-rerere.html">Git: rerere</a>에서 확인한다.</p>

<h4>CONFIG: COLOR!</h4>

<p>다음과 같이 설정하면 결과가 칼라로 나온다.</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">color</span>.<span class="comment">ui</span> <span class="comment">1</span>
</code></pre>
<h4>ALIAS: GIT-AMEND</h4>

<p>아래와 같이 alias를 등록하면 <code>git amend</code>라고 실행해서 HEAD 커밋을 수정할 수 있다. <code>-C</code> 옵션이 있기 때문에 커밋 메시지는 수정하지 않는다. 항상 커밋 메시지를 확인하고 싶으면 <code>-C HEAD</code>를 빼면 된다.</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">alias</span>.<span class="comment">amend</span> <span class="comment">"commit</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">amend</span> <span class="literal">-</span><span class="comment">C</span> <span class="comment">HEAD"</span>
</code></pre>
<h4>ALIAS: GIT-UNDO</h4>

<p>가장 최근 커밋을 되돌린다. <code>--soft</code>이기 때문에 그 커밋의 개체는 Staged 상태로 남는다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">alias</span>.<span class="comment">undo</span> <span class="comment">"reset</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">soft</span> <span class="comment">HEAD^"</span>
</code></pre>
<h4>ALIAS: GIT-COUNT</h4>

<p>누가 얼마나 커밋했는지 보여준다:</p>
<pre><code><span class="comment">$</span> <span class="comment">git</span> <span class="comment">config</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">global</span> <span class="comment">alias</span>.<span class="comment">count</span> <span class="comment">"shortlog</span> <span class="literal">-</span><span class="comment">sn"</span>
</code></pre>
<p><img src="/articles/2012/git-secrets/git-shortlog-sn.png" alt="git-shortlog-sn"/></p>

<h4>SCRIPT: GIT-CREDIT</h4>

<p>가장 마지막 커밋 author 정보를 바꿀일은 종종 생긴다. 실수일 수도 있고 아닐 수도 있지만 뭐 어찌됐건 최근 커밋의 author를 마음대로 바꾸고 싶을 때가 있다. 다음과 같이 config에 등록한다:</p>
<pre><code><span class="shebang">#!/bin/sh</span>

git commit --amend --author <span class="string">"<span class="variable">$1</span> &lt;<span class="variable">$2</span>&gt;"</span> -C HEAD
</code></pre>
<p><code>git credit &quot;Zach Holman&quot; zach@example.com</code>이라고 실행하면 최근 커밋의 author 정보가 변경된다.</p>

<p><a href="https://twitter.com/holman">@holman</a>님은 <a href="https://twitter.com/holman">@holman</a>님의 <a href="https://github.com/holman/dotfiles/tree/master/bin">dotfile</a> 프로젝트에 가면 <a href="https://twitter.com/holman">@holman</a>님이 사용하는 <code>git-credit</code> 스크립트가 있다.</p>

<h4>Octocat</h4>

<p>이 슬라이드로 옥토캣은 다리가 4개고 꼬리가 1개라는 비밀을 알게 됐다. 맨날 보는 그림이지만 문어니까 그냥 다리가 8개라고 생각했었다.</p>

<p><img src="/articles/2012/git-secrets/pusheencat.png" alt="octocat"/></p>
]]>
</content></entry></feed>