<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>개발새발</title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-02-05T07:28:17Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <entry>
    <title>SMACSS: Brief Notes - Part 1</title>
    <link href="http://dogfeet.github.com/articles/2012/smacss.html" />
    <updated>2012-02-03T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss.html</id>
    <content type="html">
<![CDATA[
<p><a href="http://smacss.com/">SMACSS</a>('smacks', 아마도 '스맥스'로 읽는다)에는 '<a href="http://snook.ca/">Jonathan Snook</a>'의 오랜 경험과 통찰이 담겨 있다. SMACSS는 프레임워크라기 보다는 스타일 가이드에 가까워서 만드는 사이트에 따라 그때그때 유연하게 사용할 수 있다.</p>

<p><em>Back-End 출신이라 CSS를 사용할 때마다 '이 많은 스타일은 어떻게 관리해야 할까?'라는 궁금증을 늘 가지고 있었다. 이 책은 그 궁금증을 해결해 준다.</em></p>

<p>이 책은 두 번으로 나눠서 정리할 것인데 Part 1은 CSS Rule에 대하여, Part 2는 SMACSS의 나머지 부분을 다룰 예정이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="SMACSS" title="" /></p>

<h2>Introduction</h2>

<p>저자인 Snook가 경험했던 Best Practice를 SMACSS라는 책으로 정리했다. 이 방법은 규모에 상관없이 효과적이라서 프로젝트 초반부터 성장하는 내내 유용하다고 설명한다.</p>

<p>Snook도 말하고 있지만 SMACSS는 프레임워크가 아니라 스타일 가이드다. 그래서 어떤 라이브러리나 도구도 제공하지 않는다. SMACSS는 CSS를 어떻게 구성하고 사용해야 하는가를 설명한다.</p>

<p>SMACSS은 다음과 같은 주제를 다룬다:</p>

<ul>
<li>Four Types of CSS Rules - SMACSS의 핵심, CSS를 네 가지로 분류하고 어떻게 구분해 사용하는지 설명</li>
<li>Themes and Typography - Theme와 Font에 대해 설명</li>
<li>Depth of Applicability - Selector를 길게 만드는 것이 좋은지 짧게 만드는 것이 좋은지 설명. 즉, tradeoff에 대한 설명.</li>
<li>Selector Performance - 브라우저가 Selector를 어떻게 찾는지 설명</li>
<li>State Representation - 상태에 대한 표현 기법</li>
<li>HTML5 and SMACSS - HTML5와 함께 사용하는 법</li>
<li>Prototyping - 만들어놓은 CSS를 실제 사용하기 전에 테스트해 보는 과정</li>
<li>Formatting Code - CSS 코드 형식을 정리하는 법</li>
</ul>

<p>이 중 <code>Four Types of CSS Rules</code>이 핵심인데 이 규칙은 다음과 같다:</p>

<ul>
<li>Base Rule</li>
<li>Layout Rule</li>
<li>Module Rule</li>
<li>State Rule</li>
</ul>

<p><a href="http://mondaybynoon.com/20120109/book-review-smacss/">SMACSS Review</a>를 작성한 'Jonathan Christopher'는 몇 시간이면 다 읽는다고 했는데 난 며칠 걸렸다. 영어인데다가 분명히 흥미로운 내용인데도 이상하게 읽어도 읽어도 머릿속에 잘 들어오지 않았다.</p>

<p>이 책은 CSS를 관리하는 법에 대해서 설명한다. 표현에 대해서 다루는 CSS 책은 무수히 많지만 이런 책은 드물다.</p>

<p>SMACSS는 유료 컨텐츠도 있지만, 기본적으로 무료다. 만약 ebook 포멧으로 읽거나 숨겨진 컨텐츠를 읽고 싶으면 결제해야 하지만 책의 내용 대부분을 웹에서 무료로 읽을 수 있다. 하지만, 구매하길 바란다. 무료로도 읽을 수 있지만 그만한 가치가 있다. 지금 유료 컨텐츠는 'The Icon Module', 'Screencast: Applying the Principles' 둘뿐이지만 저자는 계속 추가한다고 한다.</p>

<p>다음은 공부한 내용을 정리한 것이다. 읽고 해석한 대로 정리한 것이니 원문과 다를 수도 있다. </p>

<h2>Four Types of CSS Rules</h2>

<p>SMACSS는 CSS Rule을 네 가지로 나눈다.</p>

<ul>
<li>Base - 기본 스타일</li>
<li>Layout - 엘리먼트를 나열하는 것과 관련된 스타일</li>
<li>Module - 재사용 위해 하나로 묶는 스타일</li>
<li>State - Hidden/Expand나 Active/Inactive 같은 스타일</li>
</ul>

<p>그 외 Theme와 Font Rule에 대해서 거론하지만, 특별히 분류하지는 않았다. 대신 위 네 가지 Rule을 이용해서 Theme와 Font Rule을 만든다.</p>

<h3>Base</h3>

<p>Base Rule을 쉽게 말하자면 id, class가 없는 스타일들을 말한다. 다음과 같은 것들이 Base Rule이다:</p>

<pre class="prettyprint"><code>html, body, form { margin: 0; padding: 0; }
input[type=text] { boarder: 1px solid #999; }
a { color: #039; }
a:hover { color: #03C; }
</code></pre>

<p>Base Rule은 직접 이름 지을 수 없는 element, attribute, psedo 셀렉터 등으로만 만든다.</p>

<h4>CSS Reset</h4>

<p>기본 margin, padding 등의 것을 규정하는 Base Rule을 CSS Reset이라고 부른다. 사실 Base Rule을 사용할 만한 데가 CSS Reset밖에 없어 보인다. SMACSS는 element 셀렉터를 권장하지 않아서 element 셀렉터를 사용해도 된다고 허용하는 부분은 Base Rule로 CSS Reset을 만들 때와 <code>.mod &gt; input</code>처럼 child 셀렉터를 함께 쓸 때뿐이다.</p>

<h3>Module</h3>

<p>Module 스타일이 필요한 이유는 스타일을 Module 단위로 묶어서 재사용하기 위함이다. 사이드바나 제품 목록 등의 반복적으로 재사용하는 것들이 이에 해당된다. </p>

<p>Module 스타일 이름은 3자로 제한해 사용한다. 하지만, 스타일 가이드이니까 4자도 되고 글자제한이 없어도 된다:</p>

<pre class="prettyprint"><code>/* Example Module */
.exm { }

/* Callout Module */
.cli { }

/* Form field module */
.fld { }
</code></pre>

<p>Exmaple Module에서 하위 스타일을 하나 만든다면 다음과 같이 하면 된다:</p>

<pre class="prettyprint"><code>.exm-caption { }
</code></pre>

<p>Module은 재사용할 수 있어야 하기 때문에 id 셀렉터를 사용하지 않는다. 그리고 element 셀렉터도 사용하지 않는다. 다음과 같은 스타일과 html을 보자:</p>

<pre class="prettyprint"><code>&lt;div class="fld"&gt;
    &lt;span&gt;Folder Name&lt;/span&gt;
&lt;/div&gt;

.fld &gt; span {
    padding-left: 20px;
    background: url(icon.png);
}
</code></pre>

<p>이렇게 사용해도 무방하지만, 프로젝트 규모가 커질수록 다른 element로 바꿔야 할 수도 있고 element 본연의 특징을 유지하기 어려울 수 있다. <code>span</code>을 제거하고 다음과 같이 변경한다:</p>

<pre class="prettyprint"><code>&lt;div class="fld"&gt;
    &lt;span class="fld-name"&gt;Folder Name&lt;/span&gt;
&lt;/div&gt;

.fld &gt; .fld-name {
    padding-left: 20px;
    background: url(icon.png);
}
</code></pre>

<p>그래도 element 셀렉터를 꼭 사용해야겠다면 <code>.fld &gt; span</code>처럼 child 셀렉터를 꼭 함께 사용하라.</p>

<h3>Layout</h3>

<p>Layout Rule이 엘리먼트를 어떻게 나열하는지 결정한다. 로그인 폼, 내비게이터 등부터 header, footer 같은 부분을 구분하는 것이 모두 Layout Rule이다.</p>

<p><code>.l-fixed</code> 유무에 따라 가변 폭으로 할지 고정 폭으로 할지 결정하는 Layout은 다음과 같이 만든다:</p>

<pre class="prettyprint"><code>#article {
    width: 80%;
    float: left;
}

#sidebar {
    width: 20%;
    float: right;
}

.l-fixed #article {
    width: 600px;
}

.l-fixed #sidebar {
    width: 200px;
}
</code></pre>

<p>id 셀렉터에는 'l'을 붙이지 않고 class 셀렉터에만 'l'을 붙인다. 전체 Layout처럼 큼직큼직한 Layout은 id 셀렉터로 스타일을 만들고 로그인 폼 같이 작은 부분의 스타일은 class 셀렉터로 만든다.</p>

<p>성능 등을 이유로 class 셀럭터 없이 전부 id 셀렉터로 만들어도 되지만 꼭 그래야 할 이유는 없다. CSS에서는 id 셀렉터와 class 셀렉터 이 둘의 성능은 거의 같다. id 셀렉터가 Javascript에서 빠를지 모르겠지만, CSS는 아니다. </p>

<p>그리고 Layout Rule만 id 셀렉터를 사용한다. 다른 스타일은 id 셀렉터 사용하지 않는다.</p>

<p>id 셀렉터에 tag 셀렉터와 함께 사용하지 않는다. 자식이면 child 셀렉터(>)를 꼭 사용한다.</p>

<h3>State</h3>

<p>상태와 관련된 스타일을 말하고 이름을 지을 때 's'를 붙인다. 예를 들면 이런 거다:</p>

<pre class="prettyprint"><code>.s-hidden { display: none; }
</code></pre>

<p><code>!important</code>를 사용해도 되는 Rule은 State Rule뿐이다. 다른 Rule에는 <code>!important</code>를 사용해서는 절대 안된다. 하지만, State Rule에서도 권장하지 않는다. 되도록 안 쓰는 것이 좋다. 뭥미:) 그냥 사용하지 말자.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:번역 Workflow</title>
    <link href="http://dogfeet.github.com/articles/2012/git-translate-flow.html" />
    <updated>2012-02-01T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-translate-flow.html</id>
    <content type="html">
<![CDATA[
<p>Git으로 번역한다는 것은 아마도 CCL을 따르는 영문 자료를 우리말로 번역하는 것을 의미할 것이다. Pro Git 번역도 그랬다. Pro Git을 번역하면서 정리한 Workflow를 소개한다. 다른 번역 프로젝트에 도움을 줄 수 있으면 좋겠다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/translation-flow/translation-flow.png" alt="image" title="" /></p>

<h2>번역</h2>

<p>Git을 사용하는 데 있어서 번역 프로젝트는 개발 프로젝트와 다르다. 훨씬 더 정적이다. 만들어야 하는 브랜치 수도 적고 버그를 발견해도 좀 더 느슨하게 대처해도 된다. 며칠 늦었다고 해서 수갑을 차는 것도 아니고 경찰이 출동하지도 않는다.</p>

<p>Git은 번역 작업을 관리하는데도 좋다. 특히 원문 자체가 계속 수정되는 진행 중인 자료들이기 때문에 번역도 완성된 상태라고 볼 수 없고 항상 진행 중이라고 봐야 한다. Git은 이 상태를 추적하고 관리하는데 최상의 도구다.</p>

<p>Pro Git을 번역할 때 Git을 어떻게 사용해야 할지 몰랐기 때문에 헤매고 시간을 낭비했었다. 번역할 때는 어떤 브랜치가 필요한지 그리고 어떻게 사용하는 것이 좋은지 그동안 고민한 Workflow를 공개한다.</p>

<h2>브랜치</h2>

<p>몇 번의 삽질을 거쳐서 지금과 같은 번역 Workflow를 만들었다.</p>

<p>여기서는 사용한 브랜치는 다음과 같다:</p>

<ul>
<li>master - progit/master를 Tracking하는 브랜치</li>
<li>topic - 작업 브랜치들</li>
<li>ko - 번역이 완료되면 이 브랜치에 Merge하고 Pull Request를 보낸다.</li>
<li>ko-base - 원문, 어느 시점을 기준으로 번역했는지 기록하는 브랜치</li>
<li>private - 절대 Pull Request를 보내지 않을 브랜치들</li>
</ul>

<h3>master</h3>

<p>progit/master를 Tracking하는 브랜치이다. master 브랜치를 직접 수정하지 않는다.</p>

<p>이 브랜치를 progit/master를 Tracking하도록 한 이유는 별로 쓸모가 없어서다. Pull Request하는 브랜치를 ko 브랜치로 해야 했고 원문의 master 브랜치가 가리키는 커밋을 가리키는 로컬 브랜치가 하나 있는 게 편하기도 했다.</p>

<p>이 브랜치는 항상 progit/master를 따라가는 것이니까 항상 Fast-forward Merge된다.</p>

<p><img src="translation-flow/progit-master--master.png" alt="progit/master-master" title="" /></p>

<h3>토픽들</h3>

<p>Pro Git을 번역할 때는 Chapter 별로 브랜치를 만들었다. 01, 02, ..., 09 브랜치를 만들고 번역했다. 이 브랜치를 그대로 Push해서 다른 사람에게 리뷰를 요청했다. 책에 Chapter가 없어도 섹션 별로 만들 수도 있다.</p>

<p>책 내용뿐만 아니라 보통 ebook을 빌드하는 구조를 가진 책들은 설정 파일과 빌드 스크립트도 수정해야 한다. 이것을 위한 토픽 브랜치도 만든다. 이때는 꼭 브랜치 이름이 ko-build로 시작하게 했다.</p>

<p><img src="translation-flow/topics--ko.png" alt="topics-ko" title="" /></p>

<h3>ko</h3>

<p>이 브랜치가 핵심 브랜치다. Git-flow에 비교하자면 develop 브랜치에 해당한다고 할 수 있다. 토픽 브랜치에서 작업을 완료하면 커밋과 커밋 메시지를 정리하고 ko 브랜치에 Merge했다. </p>

<p>곧 Pull Request를 보낼 브랜치이기 때문에 토픽 브랜치를 Merge할 때 커밋을 잘 정리해서 Merge한다.</p>

<p>브랜치 이름을 <code>ko</code>라고 해야 하는 이유는 Merge 커밋에 브랜치 이름이 기록되기 때문이다. 보통 Git의 Merge 커밋은 다음과 같다:</p>

<pre class="prettyprint"><code>Merge branch 'ko' into master
</code></pre>

<p>Github에서 Pull Request를 Merge했을 때의 커밋 메시지는 거의 같지만 다르게 생겼다:</p>

<pre class="prettyprint"><code>Merge pull request #158 from dogfeet/ko
</code></pre>

<p>해당 Pull Request의 이슈 번호와 저장소 이름/브랜치 이름이 기록된다. 그래서 한국어를 나타낼 수 있도록 ko라는 이름으로 만든다.</p>

<p>Pull Request를 보내고 나서 원문 저장소에 Merge되면 다시 히스토리를 맞춰 주어야 한다. 원문 저장소는 한글뿐만 아니라 스페인어, 불어, 독어 등등의 커밋이 계속 업데이트된다. ko 브랜치를 삭제하고 다시 만들어도 되지만 reset 명령으로 ko 브랜치 포인터를 옮길 수 있다:</p>

<pre class="prettyprint"><code>$ git checkout master
$ git merge progit/master #Fast-forward Merge
$ git checkout ko
$ git reset --hard master
</code></pre>

<p>원문 저장소의 리모트 이름이 progit라고 가정한다:</p>

<p><img src="translation-flow/progit-master--ko.png" alt="progit/master-ko" title="" /></p>

<h4>ko-build</h4>

<p>어떤 커밋은 확실히 메인 저장소에 Push해야 하지만 어떤 커밋은 Dictator(원문 저장소 관리자)가 검토하고 Merge해 주길 바랄 것이다. 그런데 번역은 언어 문제로 Dictator가 검토할 수 없다. 빌드 스크립트 로직 문제를 제외하고는 원문 Dictator가 해줄 수 있는 게 없다.</p>

<p>빌드 스크립트나 관련 설정을 Pull Request로 보낼 때에도 <code>ko</code> 브랜치에 Merge해서 보냈다. 하지만, 빌드 스크립트 로직을 수정해야 한다면 Merge하는 것이 옳은지 Dictator가 검토해주길 바랄 테니까 본문과 별도로 보냈다. Pull Request는 브랜치 단위로 요청하는 것이니까 본문을 위한 브랜치 'ko'말고 다른 브랜치가 필요하다.</p>

<p><strong>Note:</strong> 하지만 Dictator가 검토하는지 알 수 없다. 영어 폰트를 임의로 수정해서 Pull Request를 보냈는데 Dictator인 <a href="https://github.com/schacon">schacon</a>은 그대로 Merge했다.</p>

<p>Dictator가 검토해주길 바라는 내용은 ko-build 브랜치를 만들어 Pull Request를 보낸다. 스크립트는 한번 고치면 다시 고쳐야 할 일은 거의 없다.</p>

<p><img src="translation-flow/progit-master--ko-build.png" alt="progit/master-ko-build" title="" /></p>

<h3>ko-base</h3>

<p>ko-base 브랜치가 가리키는 시점이 번역한 원문 시점을 나타낸다. 원본이 수정되면 이 브랜치를 이용해서 살펴보고 추가 번역해서 ko 브랜치에 반영하고 ko-base 브랜치는 최신으로 옮겨 놓는다. 그래서 master 브랜치처럼 항상 Fast-forward Merge된다.</p>

<p>master가 있는데 ko-base가 필요할까? 이 부분은 논쟁이 될 수 있다. ko-base 없이 master를 이용해도 된다. 분명한 근거를 제시할 수는 없지만, 목적을 스스로 설명하는 이름으로 된 브랜치를 사용하는 것이 옳다고 판단했고 확실히 구분해 사용했다.</p>

<p>이 브랜치도 항상 progit/master를 따라가는 것이니까 항상 Fast-forward Merge된다.</p>

<p>ko-base를 브랜치가 아닌 Tag로 만들어도 된다. 하지만, Tag는 가리키는 커밋을 옮길 수 없다. 삭제하고 다시 만들어야 한다. 시점이 옮기는 것이니까 Fast-forward Merge가 적당하다고 생각한다.</p>

<p><img src="translation-flow/progit-master--ko-base.png" alt="progit/master-ko-base" title="" /></p>

<h3>private</h3>

<p>중앙 저장소에 Merge하지 않을 커밋을 담아둘 브랜치도 필요하다. 확신이 없거나 중앙 저장소에 Merge했을 때 구조적으로 문제가 생길 수도 있는 것을 이 브랜치에 넣는다. 즉, 절대 Pull Request를 보내지 않을 커밋은 private으로 시작하는 브랜치에 넣는다.</p>

<p>dogfeet/progit에서는 'private-ko-build-ebook', 'private-ko-build-ubuntu'라는 브랜치를 만들어 사용했다. 'private-ko-build-ubuntu'는 Jenkins가 설치된 ubuntu 환경에 맞춘 코드를 넣었고, 원문에는 없는 오타와 오역 신고를 부탁한다는 글은 'private-ko-build-ebook'에 넣어 두었다.</p>

<p>private으로 시작하는 브랜치 규칙을 만든 이유는 실제로 실수를 저질렀기 때문이다. @lethee가 빌드 스크립트와 설정을 수정했다. 그리고 그 수정한 것을 내가 다시 정리해서 Pull Request를 보냈는데, 커뮤니케이션이 미숙해서 @lethee의 의도대로 Pull Request하지 않았다. 그래서 영어 폰트를 수정한 커밋이 progit 저장소에 들어가 버렸다. 그래서 이런 규칙을 만들었다.</p>

<h4>요약</h4>

<p>Pull Request를 보내는 브랜치:</p>

<ul>
<li><strong>ko</strong> - 번역 브랜치, 각 토픽 브랜치 별로 Pull Request를 보낼 수도 있지만, Dictator가 Merge하기 편리하도록 정리해서 보낸다.</li>
<li><strong>ko-build</strong> - 빌드 스크립트용 브랜치. Dictator가 검토해주길 바라는 내용.</li>
</ul>

<p>Tracking 브랜치:</p>

<ul>
<li><strong>master</strong> - progit/master를 Tracking하는 브랜치</li>
<li><strong>ko-base</strong> - 어느 시점을 기준으로 번역했는지 기록해 두는 브랜치</li>
</ul>

<p>Pull Request를 보내지 않을 브랜치:</p>

<ul>
<li>'<strong>private</strong>'으로 시작하는 브랜치.</li>
</ul>

<p>그 외:</p>

<ul>
<li>토픽 브랜치 – 브랜치 대부분은 실제 번역을 하는 토픽 브랜치다. 깔끔하게 작업하는 것은 ko 브랜치에 Merge할 때까지 미뤄도 된다.</li>
</ul>

<h2>커밋 메시지</h2>

<p>번역을 시작하면서 기존의 커밋 메시지를 훑어 봤는데 대부분 사람은 일정 규칙을 지키고 있었다. 물론 규칙을 지키지 않는 커밋들도 계속 올라왔고 강제하는 것처럼 보이진 않았다.</p>

<p>커밋 메시지는 첫 줄은 다음과 같은 형식을 따른다.</p>

<pre class="prettyprint"><code>[ko] Chapter 1: 오타 수정

본문...
</code></pre>

<h2>GitHub 저장소의 기본 브랜치.</h2>

<p>Pull Request를 보낼 때 Request마다 어느 브랜치에 Merge해야 하는지 선택해서 보낼 수 있다. 하지만, 기본 값은 저장소의 기본 브랜치이다.</p>

<p>그러니 GitHub의 번역 저장소의 기본 브랜치를 <code>ko</code>로 해야 다른 사람이 번역본에 기여할 때 <code>ko</code> 브랜치로 Pull Request를 보내기 쉬워진다:</p>

<h2>예제</h2>

<p>수정된 원문을 번역에 적용하는 예제를 살펴보자. 여기서 설명하는 예제는 <a href="/articles/2012/progit.html">Pro Git</a>이 아니라 <a href="http://bonsaiden.github.com/JavaScript-Garden/">JavaScript-Garden</a>의 예이다. 이 글을 쓰는 동안에 마침 BonsaiDen이 원문을 수정해줬다. 그동안 변경된 원문을 찾아 번역도 수정하는 것을 설명한다.</p>

<h3>브랜치 확인</h3>

<p>원문 저장소의 리모트 이름은 owner고 번역 저장소의 리모트 이름은 origin이다.</p>

<h4>로컬 저장소</h4>

<p><code>git todo</code>를 실행해서 브랜치 상태를 확인한다. <a href="/articles/2012/git-todo.html">git-todo</a> 사용법은 따로 설명해 놓았다:</p>

<pre class="prettyprint"><code>$ git todo
      [@] ko - 09b4f9c - ...
[-1] ko-base - e7c00d8 - ...
 [-1] master * e7c00d8 - ...
</code></pre>

<p>다시 설명하지만 <code>master</code>는 <code>owner/master</code>를 Tracking한다. 그리고 ko-base는 마지막으로 번역할 때 기준으로 삼은 시점을 기록해 둔 것이다. 그리고 ko는 새로 번역을 수정해 놓은 브랜치다.</p>

<p><code>[-1]</code>은 <code>[@]</code> 표시가 있는 브랜치 보다 커밋이 하나 적다는 것을 말한다. ko 브랜치에 JavaScript-Garden 한글 버전을 퇴고해서 Pull Request를 보냈다. 그래서 master보다 커밋이 하나 더 많다. BonsaiDen은 이 Pull Request를 Merge했다. 이제 owner 저장소를 확인하자.</p>

<h4>owner 저장소</h4>

<p>owner 저장소를 fetch한다:</p>

<pre class="prettyprint"><code>$git fetch owner
remote: Counting objects: 164, done.
remote: Compressing objects: 100% (44/44), done.
remote: Total 101 (delta 65), reused 80 (delta 45)
Receiving objects: 100% (101/101), 41.53 KiB | 42 KiB/s, done.
Resolving deltas: 100% (65/65), completed with 32 local objects.
From <a href='https://github.com/BonsaiDen/JavaScript-Garden'>https://github.com/BonsaiDen/JavaScript-Garden</a>
   962617e..67775b0  gh-pages   -&gt; owner/gh-pages
   e7c00d8..01fe309  master     -&gt; owner/master
</code></pre>

<p>그리고 나서 브랜치 상태를 확인한다:</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko - 09b4f9c - ...
              [-1] ko-base - e7c00d8 - ...
               [-1] master * e7c00d8 - ...
                 origin/ko - 09b4f9c - ...
       [-1] origin/ko-base - e7c00d8 - ...
        [-1] origin/master - e7c00d8 - ...
        [-388] origin/next - c204a58 - ...
[+84][-143] owner/gh-pages - 67775b0 - ...
        [+14] owner/master - 01fe309 - ...
         [-388] owner/next - c204a58 - ...
</code></pre>

<p><code>owner/master</code>에 새로운 커밋이 생겼다. master는 단순히 <code>owner/master</code>를 Tracking하는 브랜치니까 master에 Merge한다:</p>

<pre class="prettyprint"><code>$ git co master
$ git merge owner/master
</code></pre>

<p>ko 브랜치가 Merge됐는지 확인한다. 히스토리를 보면 다음과 같은 커밋이 들어 있다:</p>

<pre class="prettyprint"><code>34c3271 Merge pull request #121 from pismute/ko
09b4f9c [ko] proofreading
</code></pre>

<p>Merge됐으므로 ko 브랜치가 owner/master를 가리키게 한다:</p>

<pre class="prettyprint"><code>$ git co ko
$ git reset --hard owner/master
</code></pre>

<p>그리고 나서 브랜치 상태를 확인해보자:</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko * 01fe309 - ...
             [-15] ko-base - e7c00d8 - ...
                    master - 01fe309 - ...
           [-14] origin/ko - 09b4f9c - ...
      [-15] origin/ko-base - e7c00d8 - ...
       [-15] origin/master - e7c00d8 - ...
        [-402] origin/next - c204a58 - ...
[+84][-157] owner/gh-pages - 67775b0 - ...
              owner/master - 01fe309 - ...
         [-402] owner/next - c204a58 - ...
</code></pre>

<p><code>owner/master</code>에 맞추어 브랜치를 정리했다. <code>owner/master</code>, <code>master</code>, <code>ko</code> 브랜치는 이제 같은 커밋을 가리킨다.</p>

<p>원문에서 무엇이 변경됐는지 살펴보고 번역을 수정해보자</p>

<h3>무엇이 변경됐는지 찾아 번역한다.</h3>

<p>먼저 변경된 커밋 중에서 어떤 파일들이 변경됐는지 확인해보자. ko-base 브랜치가 이미 번역한 번역본의 기준이므로 master와 ko-base 브랜치를 비교한다. 이때 브랜치 순서가 중요하다. <code>ko-base...master</code> 같이 <code>ko-base</code>를 먼저 사용한다. 순서를 반대로 쓰면 diff 명령에서 헷갈리기 쉽다.</p>

<pre class="prettyprint"><code>$ git log --pretty=oneline --abbrev-commit --left-right --name-only ko-base...master
&gt; 01fe309 Finally get around and start fixing some issues
doc/en/core/undefined.md
doc/en/function/constructors.md
doc/en/function/scopes.md
doc/en/object/hasownproperty.md
&gt; 98a1f31 Merge pull request #114 from krawaller/master
&gt; 65f0d9e Merge pull request #77 from xavierm02/master
&gt; 27b4b2f Merge pull request #117 from oozcitak/tr
&gt; 666edda Merge pull request #116 from szTheory/patch-1
&gt; 34c3271 Merge pull request #121 from pismute/ko
&gt; 09b4f9c [ko] proofreading
doc/ko/array/constructor.md
doc/ko/array/general.md
doc/ko/core/delete.md
doc/ko/core/eval.md
doc/ko/core/semicolon.md
doc/ko/core/undefined.md
doc/ko/function/arguments.md
doc/ko/function/closures.md
doc/ko/function/constructors.md
doc/ko/function/general.md
doc/ko/function/scopes.md
doc/ko/function/this.md
doc/ko/intro/index.md
doc/ko/object/forinloop.md
doc/ko/object/general.md
doc/ko/object/hasownproperty.md
doc/ko/object/prototype.md
doc/ko/other/timeouts.md
doc/ko/types/casting.md
doc/ko/types/equality.md
doc/ko/types/typeof.md
&gt; 919b581 [tr] Fixed typo
doc/tr/core/delete.md
&gt; 753fd78 Added delete to index
doc/tr/index.json
&gt; c8258d1 [tr] Translated delete
doc/tr/core/delete.md
&gt; cd06184 [tr] Fixed type
doc/tr/function/scopes.md
&gt; be27b01 grammar
doc/en/function/this.md
&gt; 103ca5d removed trailing whitespace in comment on line 55 which caused line to spill outside code container
doc/fi/function/arguments.md
&gt; 0a894c1 Stored the biggest timeout ID to avoid infinite loop.
doc/en/other/timeouts.md
&gt; 53decce Added another way to clear "all" timeouts and replaced the "is is" by "it is".
doc/en/other/timeouts.md
</code></pre>

<p>그동안 수정된 커밋이 좀 있다. 영어로 된 것을 번역한 것이니 이 중에서 <code>doc/en</code> 파일이 수정된 것만 확인한다. <code>doc/en</code> 디렉토리에 있는 파일만 조회하자:</p>

<pre class="prettyprint"><code>$ git log --pretty=oneline --abbrev-commit --left-right --name-only ko-base...master doc/en
&gt; 01fe309 Finally get around and start fixing some issues
doc/en/core/undefined.md
doc/en/function/constructors.md
doc/en/function/scopes.md
doc/en/object/hasownproperty.md
&gt; 65f0d9e Merge pull request #77 from xavierm02/master
&gt; 666edda Merge pull request #116 from szTheory/patch-1
&gt; be27b01 grammar
doc/en/function/this.md
&gt; 0a894c1 Stored the biggest timeout ID to avoid infinite loop.
doc/en/other/timeouts.md
&gt; 53decce Added another way to clear "all" timeouts and replaced the "is is" by "it is".
doc/en/other/timeouts.md
</code></pre>

<p>커밋 정보 없이 수정된 파일만 볼 수도 있다:</p>

<pre class="prettyprint"><code>$ git diff --name-only ko-base..master doc/en
doc/en/core/undefined.md
doc/en/function/constructors.md
doc/en/function/scopes.md
doc/en/function/this.md
doc/en/object/hasownproperty.md
doc/en/other/timeouts.md
</code></pre>

<p>파일 내용까지 보려면 <code>--name-only</code> 옵션을 빼면 된다. 그러면 diff 내역을 모두 보여준다. 한 번에 보면 너무 많으니 하나씩 diff를 확인해 볼 수 있다. <code>doc/en/core/undefined.md</code> 파일의 diff 내용을 살펴보자:</p>

<pre class="prettyprint"><code>$ git diff ko-base..master doc/en/core/undefined.md
diff --git a/doc/en/core/undefined.md b/doc/en/core/undefined.md
index d27761f..c819920 100644
--- a/doc/en/core/undefined.md
+++ b/doc/en/core/undefined.md
@@ -19,11 +19,13 @@ overwritten.
 Some examples for when the value `undefined` is returned:

  - Accessing the (unmodified) global variable `undefined`.
+ - Accessing a declared *but not* yet initialized variable
  - Implicit returns of functions due to missing `return` statements.
  - `return` statements which do not explicitly return anything.
  - Lookups of non-existent properties.
  - Function parameters which do not had any explicit value passed.
  - Anything that has been set to the value of `undefined`.
+ - Any expression in the form of `void(expression)`

 ### Handling Changes to the Value of `undefined`
</code></pre>

<p>파일을 하나씩 diff해보면서 번역을 수정한다. 수정하고 커밋한 후에 브랜치를 살펴보자.</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko * c712143 - ...
             [-16] ko-base - e7c00d8 - ...
               [-1] master - 01fe309 - ...
           [-15] origin/ko - 09b4f9c - ...
      [-16] origin/ko-base - e7c00d8 - ...
       [-16] origin/master - e7c00d8 - ...
        [-403] origin/next - c204a58 - ...
[+84][-158] owner/gh-pages - 67775b0 - ...
         [-1] owner/master - 01fe309 - ...
         [-403] owner/next - c204a58 - ...
</code></pre>

<p><code>ko</code> 브랜치에 번역을 수정하고 커밋했기 때문에 <code>owner/master</code>보다 커밋이 한 개 많다.</p>

<h3>ko-base 옮겨 놓고 Pull Request 보내기</h3>

<p>다음에 원문이 수정됐을 때 다시 참고 할 수 있도록 ko-base가 owner/master를 가리키도록 한다.</p>

<pre class="prettyprint"><code>$ git checkout ko-base
$ git reset --hard owner/master
</code></pre>

<p>그리고 저장소를 origin에 Push한다. Push하고 나면 브랜치 상태는 다음과 같아진다:</p>

<pre class="prettyprint"><code>$ git todo -r
                    [@] ko - c712143 - ...
              [-1] ko-base * 01fe309 - ...
               [-1] master - 01fe309 - ...
                 origin/ko - c712143 - ...
       [-1] origin/ko-base - 01fe309 - ...
        [-1] origin/master - 01fe309 - ...
        [-403] origin/next - c204a58 - ...
[+84][-158] owner/gh-pages - 67775b0 - ...
         [-1] owner/master - 01fe309 - ...
         [-403] owner/next - c204a58 - ...
</code></pre>

<p>이제 원문이 수정된 만큼 번역도 수정했으니 Pull Request를 보내면 된다. 그리고 다음에 추가로 수정된 부분이 있으면 이어서 다시 번역할 수 있다.</p>

<h2>결론</h2>

<p>번역 작업에도 Git은 매우 훌륭하다. 번역은 개발과 달라서 다른 Workflow가 필요하다. <a href="/articles/2011/a-successful-git-branching-model.html">git-flow</a>처럼 번역 시 참고할 만한 자료가 있으면 좋을 것 같아서 정리했다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Optimize browser rendering</title>
    <link href="http://dogfeet.github.com/articles/2012/optimize-browser-rendering.html" />
    <updated>2012-01-27T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/optimize-browser-rendering.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>에 있는 <a href="http://code.google.com/speed/page-speed/docs/rendering.html">Optimize browser rendering</a>를 정리한 것이다. 이 글과 이 글에 주렁주렁 달린 글을 모두 독파하면 '한 브라우저 렌더링'한다고 말할 수 있을 것 같다.</p>

<p>브라우저의 특징을 잘 살려서 코딩하면 성능이 빨라진다. 이 글은 다음과 같은 주제에 대해 설명한다:</p>

<ul>
<li>효율적인 CSS 셀렉터</li>
<li>CSS Expression 안 쓰기</li>
<li>CSS는 Document head에 넣기</li>
<li>이미지 크기 명시하기</li>
<li>Charset 명시하기</li>
</ul>

<p><img src="http://dogfeet.github.com/articles/2012/optimize-browser-rendering/google-page-speed.png" alt="google-page-speed" title="" /></p>

<h2>효율적인 CSS 셀렉터</h2>

<p>찾아볼 엘리먼트가 많은 셀렉터만 사용치 않아도 렌더링 성능이 대폭 향상된다.</p>

<p>브라우저는 HTML을 파싱하는 대로 화면에 표시할 엘리먼트를 모두 생성하면서 내부에 도큐먼트 트리를 만든다. 브라우저의 CSS 엔진은 정해진 규칙에 따라 엘리먼트마다 맞는 스타일이 있는지 찾는다. 그 규칙은 표준 CSS cascade, 상속, 정열 규칙에 따른다. "셀렉터"는 어떤 엘리먼트에 스타일을 적용할지를 나타내는 것인데 CSS 엔진은 제일 오른쪽에 있는 셀렉터부터 찾는다. 가장 오른쪽에 있는 셀렉터를 "Key 셀렉터"라고 부르고 필요한 스타일을 찾거나 못 찾을 때까지 계속 Evaluate한다.</p>

<p>이런 시스템이라서 Rule이 적을수록 성능이 좋다. 그러니까 <a href="http://code.google.com/speed/page-speed/docs/payload.html#RemoveUnusedCSS">사용하지 않는 CSS</a>를 삭제하는 것만으로도 성능이 대폭 향상된다. 일단 안 쓰는 CSS를 모두 삭제하고 나서 엘리먼트나 CSS Rule이 많은 페이지를 최적화한다. CSS Rule을 손보는 것만으로도 성능을 향상시킬 수 있다. Rule을 가능한 정확하게 만들고 불필요한 군더더기를 제거하는 게 최적화의 핵심이다. 그래서 스타일 엔진이 사용하지도 않을 Rule까지도 일일이 검사하지 않게끔 해야 한다.</p>

<h4>Descendant 셀렉터</h4>

<pre class="prettyprint"><code>ul li a {...}
</code></pre>

<p>Descendant 셀렉터는 비효율적이다. 브라우저는 Key를 찾고 나서 정확히 일치하는 것을 찾거나 더는 찾을 수 없을 때까지 그 상위 DOM 트리를 전부 뒤진다. Key가 덜 구체적일수록 Evaluate해 봐야 하는 엘리먼트의 수는 많아진다.</p>

<h4>Child 셀렉터</h4>

<pre class="prettyprint"><code>ul &gt; li &gt; a {...}
</code></pre>

<p>Child 셀렉터도 비효율적이다. 브라우저가 엘리먼트를 Evaluate할 때마다 노드를 하나 더 Evaluate해야 한다. 다시 말해서 Child 셀렉터를 사용한 Rule은 비용이 두 배 더 든다. 게다가 Key 셀렉터가 가리키는 엘리먼트가 많을수록 더 많은 엘리먼트를 Evaluate해야 한다. 비효율적이지만 Descendant 셀렉터 보다는 훨씬 빨라서 꽤 사용되는 편이다.</p>

<h4>쓸데없이 셀렉터를 더 사용할 때</h4>

<pre class="prettyprint"><code>ul#top_blue_nav {...}
</code></pre>

<p>정의에 따르면 ID 셀렉터는 중복될 수 없다. 그래서 class나 tag 셀렉터와 함께 사용하면 필요 없는 Evaluate을 추가로 하게 만든다. 노파심을 달래줄 뿐 하지 않아도 될 Evaluate만 더 하는 것이다.</p>

<h4>Pseudo 셀렉터 <code>:hover</code>를 링크가 아닌 엘리먼트에 사용할 때</h4>

<pre class="prettyprint"><code>.foo:hover {...}
</code></pre>

<p><code>:hover</code> 셀렉터를 Non-anchor 엘리먼트에 사용하면 <a href="http://connect.microsoft.com/IE/feedback/ViewFeedback.aspx?FeedbackID=391387">IE7, IE8는 느려질 때가 있다</a>고 알려졌다. Strict Doctype을 사용하지 않을 때 IE7, IE8은 Non-Anchor 엘리먼트에 사용된 <code>:hover</code>를 무시한다. 하지만, Strict Doctype이 사용할 때 Non-Anchor 엘리먼트에 <code>:hover</code>를 사용하면 성능을 저하된다.</p>

<h3>기억할 것.</h3>

<ul>
<li><p>Universal 셀렉터를 Key로 사용하지 말 것.</p>

<ul><li>여러 가지 엘리먼트에 적용해야 할 때는 Class 셀렉터를 사용하자.</li></ul></li>
<li><p>가능한 구체적으로 사용하라.</p>

<ul><li>Tag 셀렉터 보다는 ID나 Class 셀렉터를 사용하라.</li></ul></li>
<li><p>Redundant Qualifier를 제거할 것.</p>

<ul><li>ID 셀렉터와 Tag, Class 셀렉터를 사용하지 말 것.</li>
<li>Class 셀렉터에 추가로 Tag 셀렉터를 사용하지 말 것.</li></ul></li>
<li><p>Descendant 셀렉터를 사용하지 말 것 - 특히 Redundant 때문에 Ancestor를 명시하지 말 것.</p>

<ul><li><code>body ul li a</code> 같은 Rule에서 body는 Redundant 때문에 사용한 것인데 아무 의미 없다.</li></ul></li>
<li><p>Descendant 셀렉터 대신 Class 셀렉터를 사용하라.</p>

<ul><li><code>ul li {color: blue;}</code> 이런 스타일은 <code>.unordered-list-item {color: blue;}</code>으로 바꾼다.</li>
<li><code>ol li {color: red;}</code> 이런 스타일은 <code>.ordered-list-item {color: red;}</code>으로 바꾼다.</li></ul></li>
<li><p>Descendant 셀렉터를 사용할 바에는 Child 셀렉터를 사용해라.</p>

<ul><li>여러 단계를 다 Evaluate하는 것보다 한 단계만 더 Evaluate하는 게 낫다.</li></ul></li>
<li><p>IE를 위해 <code>:hover</code>를 Non-Anchor(non-link) 엘리먼트에 사용하지 말 것.</p>

<ul><li>Non-Anchor 엘리먼트에 <code>:hover</code>를 사용하면 IE7, IE8에서 꼭 해당 페이지를 테스트해야 한다. <code>:hover</code> 때문에 성능에 문제가 생기면 IE에서는 JavaScript의 onmouseover 이벤트 핸들러를 사용하라.</li></ul></li>
</ul>

<h2>CSS expression 안 쓰기.</h2>

<p>CSS expression은 렌더링 성능을 떨어트린다. CSS expression은 IE5, IE6, IE7만 지원하는 것이고 IE 8부터는 deprecated 됐다. 게다가 다른 브라우저는 아예 지원하지 않는다. 정리하지 않음.</p>

<h2>CSS는 document head에 두기</h2>

<p>브라우저는 <code>&lt;link&gt;</code> 엘리먼트의 CSS 파일을 모두 내려받을 때까지 웹 페이지를 렌더링하지 않기 때문에 <code>&lt;link&gt;</code> 엘리먼트를 도큐먼트 헤드에 넣어서 무엇보다 CSS 파일을 먼저 내려받을 수 있도록 해줘야 한다.</p>

<p>브라우저는 도큐먼트를 스트림처럼 다루기 때문에 내려받은 만큼 먼저 렌더링한다. 렌더링하고 나서 스타일이 바뀌면 다시 해야 하기 때문에 인라인 스타일 블럭(<code>&lt;style&gt;</code> 엘리먼트)도 도큐먼트 헤드에 넣어줘야 한다.</p>

<h3>기억할 것</h3>

<ul>
<li><code>&lt;link&gt;</code> 엘리먼트는 항상 <code>&lt;head&gt;</code>에 넣어라.</li>
<li><a href="http://www.clearboth.org/css-link-vs-import/"><code>@import</code>는 사용하지 마라</a></li>
<li><code>&lt;style&gt;</code> 블럭도 <code>&lt;head&gt;</code>에 넣어라.</li>
</ul>

<h2>이미지 크기 명시하기</h2>

<p>이미지 크기를 명시하면 이미지 파일을 다 내려받고 나서 다시 그리지(reflow와 repaint) 않는다. 크기를 명시하지 않았거나 명시한 크기가 실제 이미지 크기와 다르면 브라우저는 내려받고서 다시 그린다.</p>

<h3>기억할 것</h3>

<ul>
<li>실제 이미지 크기로 명시하라.</li>
<li>img 엘리먼트나 그 부모 중에서 block 엘리먼트에 크기를 명시해야 한다. block 엘리먼트가 아니면 명시한 크기 값은 무시된다.</li>
</ul>

<h2>Charset 명시하기</h2>

<p>HTML 문서의 HTTP Response 헤더에 캐릭터 셋을 항상 넣어주면 브라우저는 바로 HTML 파싱하고 스크립트를 실행한다. </p>

<p>Charset을 명시하지 않으면 브라우저는 일정 크기만큼 버퍼링하고 그 버퍼에서 charset 정보를 찾는다. </p>

<p>브라우저마다 버퍼링하는 바이트 수와 Charset을 명시하지 않았을 때 사용하는 기본 Encoding이 다르다. 하지만, 일단 버퍼링하면 바로 렌더링한다. 그리고 만약 기본 Encoding과 버퍼링하고 나서 찾아낸 Charset이 서로 다르면 다시 파싱하고 페이지를 다시 그린다.</p>

<h3>기억할 것</h3>

<ul>
<li>Content Type을 빠트리지 마라. - HTTP 헤더나 HTML meta tag 두 곳에 모두 적어 준다. 브라우저는 Content Type을 "sniff"하는데 알고리즘이 여러 가지 사용된다. 그래서 추가적인 Delay도 생기고 보안에 구멍도 생긴다. 'text/html'이라고 할지라도 반드시 적어준다.</li>
<li>제대로 된 Charset을 명시한다.  - HTTP 헤더와 HTML meta tag 두 곳에 모두 명시한다.</li>
</ul>

<p>HTTP 헤더에 명시하는 예제:</p>

<pre class="prettyprint"><code>Content-Type: text/html; charset=utf-8
</code></pre>

<p>HTML meta tag에 명시하는 예제:</p>

<pre class="prettyprint"><code>&lt;meta http-equiv="content-type" content="text/html;charset=UTF-8" /&gt;
</code></pre>

<h2>결론</h2>

<p><a href="http://code.google.com/speed/page-speed/">Google Page Speed</a>를 한번 돌려보자. 굉장히 잘 만들었다. 문제가 무엇인지 알려주고 어떻게 해결해야 하는지도 알려준다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:Todo Plugin</title>
    <link href="http://dogfeet.github.com/articles/2012/git-todo.html" />
    <updated>2012-01-21T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-todo.html</id>
    <content type="html">
<![CDATA[
<p>branch 정보를 요약해주는 Plugin을 만들었다. 각 브랜치에 마지막 커밋 정보(SHA, 메시지, 시각, 커밋터)를 보여주고 그 브랜치가 기준 브랜치에서 얼마나 멀어졌는지 보여준다.</p>

<p><a href="/articles/2012/git-branch-a-v.html"><code>git branch -a -v</code> 명령에 대한 글</a>을 썼었는데 그 글에 설명한 것을 발전시켜 구현했다. <code>git-todo</code> 같이 규모가 작은 프로젝트에서는 별도로 Issue를 관리하고 싶지 않아서 만들었다. </p>

<p>브랜치 이름과 커밋 메시지를 잘 다듬으면 브랜치 정보를 요약해 보는 것만으로도 해야 할 일이 무엇이고 최근 어디까지 진행했는지 알 수 있다.</p>

<p>Pro Git 저장소를 예제로 사용하여 설명한다:</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-todo/git-todo.png" alt="git-todo" title="" /></p>

<h2>Usage</h2>

<ul>
<li><img src="/articles/2012/git-todo/checkouted.png" alt="checkouted" title="" />가 표기된 ko 브랜치가 Checkcout한 브랜치다.</li>
<li><img src="/articles/2012/git-todo/base_branch.png" alt="base_branch" title="" />가 표기된 ko 브랜치가 기준 브랜치다. 이 브랜치를 기준으로 다른 브랜치의 <img src="/articles/2012/git-todo/ahead.png" alt="ahead" title="" />이나 <img src="/articles/2012/git-todo/behind.png" alt="behind" title="" />을 계산한다.</li>
<li><img src="/articles/2012/git-todo/ahead.png" alt="ahead" title="" />가 표기된 private-ko-build-ebook 브랜치는 ko 브랜치에 없는 커밋이 3개 있다는 것을 의미한다.</li>
<li><img src="/articles/2012/git-todo/behind.png" alt="behind" title="" />가 표기된 private-ko-build-ebook 브랜치는 ko 브랜치에 있는 커밋이 23개 없다는 것을 의미한다.</li>
</ul>

<p>기본적으로 로컬 브랜치만 보여준다.</p>

<h3>기준 브랜치</h3>

<p>이 기준 브랜치가 <code>git branch -a -v</code>를 쓰지 않고 Plugin을 만든 진짜 이유다. 원하는 브랜치를 기준으로 두고 토픽 브랜치를 만들어 작업할 수 있다.</p>

<p>설정하지 않으면 master 브랜치가 기준 브랜치다. 이 브랜치를 기준으로 다른 브랜치의 거리를 계산한다. 이 브랜치는 다음과 같이 설정한다:</p>

<pre class="prettyprint"><code>git config todo.base ko
</code></pre>

<p>여기서 보여주는 예제는 Pro Git 저장소를 캡처한 것이기 때문에 기준 브랜치가 ko이다.</p>

<h3>옵션</h3>

<p>기본적으로 로컬 브랜치만 보여주지만, 리모트 브랜치와 tag도 보여준다</p>

<h4>git todo -r</h4>

<p>리모트 브랜치는 노란(똥)색으로 보여준다:</p>

<p><img src="/articles/2012/git-todo/git-todo-r.png" alt="git-todo-r" title="" /></p>

<h4>git todo -t</h4>

<p>Tag는 흰색으로 보여준다:</p>

<p><img src="/articles/2012/git-todo/git-todo-t.png" alt="git-todo-t" title="" /></p>

<h4>git todo -a</h4>

<p>로컬 브랜치, 리모트 브랜치, Tag를 모두 보여준다:</p>

<p><img src="/articles/2012/git-todo/git-todo-a.png" alt="git-todo-a" title="" /></p>

<h2>설치</h2>

<p><a href="https://github.com/pismute/git-tles">git-todo 저장소</a>를 적당한데다 클론하고 git-todo 파일을 실행 경로에 넣는다:</p>

<pre class="prettyprint"><code>cd ~
git clone <a href='https://github.com/pismute/git-tles'>https://github.com/pismute/git-tles</a>
echo "export PATH=~/bin:$PATH" &gt;&gt; ~/.bash_profile
mkdir ~/bin
cd ~/bin
ln -s ~/git-tles/git-todo git-todo
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title>Pro Git 번역 회고</title>
    <link href="http://dogfeet.github.com/articles/2012/progit-retro.html" />
    <updated>2012-01-14T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/progit-retro.html</id>
    <content type="html">
<![CDATA[
<p>허접하게 나마 <a href="http://progit.org">Pro Git</a>을 번역했다. 시간도 부족하고 경험도 부족했다. 부족한 점을 극복하기 위해 번역관련 책도 사서 읽고 새로운 도구와 방법도 찾아서 익혔다. 이 포스트에서는 어떻게 번역을 했는지 그리고 무엇을 배웠는지 얘기하고자 한다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/progit/progit.book-big.jpg" alt="progit" title="" /></p>

<h2>힘들구나 번역. 알면서도 왜 했었나?</h2>

<p><strong>Lee</strong> &raquo; 번역은 그 길이가 짧든 길든 간에 쉽지 않은 작업이다. 짧으면 짧은 대로 길면 긴 대로…. Pro Git 번역 프로젝트는 적지 않은 양이었다. 전에도 함께 했었던 <a href="http://dogfeet.github.com/grails-doc/guide/">Grails User Manual 번역</a>이나, 시작했다가 포기한 과거 번역 작업을 생각해 봤을 때 스스로에 대한 큰 보상 없이 시작하기가 쉽지는 않았다.</p>

<p><strong>Lee</strong> &raquo; Pro Git은 Git에 대한 다른 좋은 Article들도 수없이 많지만, Git을 사용하는 데 있어서 정말 정리가 잘 되어 있는 책이라고 함께 번역을 한 창우형이 매우 칭찬을 했다. 읽어보니 확실히 궁금한 부분, 몰랐던 부분에 대한 빠짐없는 정리가 잘 되어 있다. 게다가 알아야 할 부분에 대한 내용이 깊지만 쉬운 글로 잘 풀어져 있다. 게다가 감사하게도 무료!</p>

<p><strong>Lee</strong> &raquo; 또한 Pro Git의 출력물도 한 번 짚어볼 만하다. 앞서 책을 번역했던 프로젝트에서는 각 프로젝트에 맞게 한 가지 형태 즉 HTML로만 혹은 epub으로만, pdf로만 출력을 뽑아냈었다. Pro Git은 하나의 Source로 한 번에 여러 형태로 출력물을 뽑아내는 재밌는 프로젝트이다. 배워두면 쓸 일 있지 않을까?</p>

<p><strong>Park</strong> &raquo; 2010년에 SVN 쓰면서 브랜치 관리로 골머리를 앓았었다. Spring+Maven으로 나름 갖은 트릭은 다 부렸는데도 잘 안되더라. 사실 그때도 Git이 좋다는 것은 알고 있었다. 그런데 위험요소를 회피하느라 피했지만 후회했다. SVN으로 브랜치 여러 개를 동시에 관리하는 게 더 힘들다.</p>

<p><strong>Park</strong> &raquo; Git은 정말 기능도 많고 설명도 많다. 일단 사다리를 그려줄 자료가 필요했다. 그래서 몇 가지를 검토하고 나서 progit을 읽었다. Chapter 순으로 읽으면 결국 이해되도록 잘 쓴 책이라 꼭 번역해야겠다고 생각했다.</p>

<h2>뭘 가지고 어디에서 작업했나?</h2>

<p><strong>Lee</strong> &raquo; 무엇부터 이야기해야 하나…. 우선 나는 작은 13인치 MBP와 iMac을 주로 사용하였다. 집이나 카페(주로 스타벅스)에서는 MBP를 사용했으며 일터에서는 틈틈이 iMac을 사용하였다. MBP의 사용이 4/5 이상일 것이다. </p>

<p><img alt="MBP" width="500" src="/articles/2012/progit/mbp.jpg" /></p>

<p><strong>Park</strong> &raquo; 나도 주로 집과 카페에서 했다. 특히 죽치고 않고 있기엔 스타벅스가 커피가 싸다. '싱글 벤티 드립'을 시키면 4~5시간은 버틸 수 있다. 다른 카페에서는 양이 적어서 두 잔 마셔야 한다.</p>

<p><strong>Park</strong> &raquo; 2007년형 white MacBook으로 작업했다. Mac을 사용할 수 없을 때도 잦아서 원격으로 접속해서 Ubuntu에서 작업하기도 했다.</p>

<p><img alt="MBP Cafe" height="500" src="/articles/2012/progit/mbp-cafe.jpg" /></p>

<p><strong>Lee</strong> &raquo; epub와 mobi 포맷을 확인하기 위해서 아이폰과 아이패드의 iBooks, Kindle 앱을 사용했다.</p>

<p><img alt="iBooks" height="500" src="/articles/2012/progit/ibooks.jpg" /></p>

<p><strong>Lee</strong> &raquo; 글쓰기를 위해서 <a href="http://www.hogbaysoftware.com/products/writeroom">WriteRoom</a>을 사용하였다. 창우형은 작업 대부분을 터미널에서 vim을 사용했다고 한다. 둘 다 모두 글쓰기에서는 고정 폭 글꼴을 사용하기 위해 <a href="http://dev.naver.com/projects/nanumfont">나눔고딕코딩폰트</a>를 사용했다.</p>

<p><img alt="Writeroom" width="500" src="/articles/2012/progit/writeroom.png" /></p>

<p><strong>Park</strong> &raquo; 터미널에서 vim으로 작업했다. vim은 익숙하기도 했고 언제 어디서는 인터넷만 연결되면 되기 때문에 좋다.</p>

<p><strong>Lee</strong> &raquo; 번역을 도와줄 사전으로는 맥 기본 사전, 아이폰에서 <a href="http://itunes.apple.com/us/app/dictionary-universal/id312088272?mt=8">Dictionary Universal</a>, <a href="http://wiktionary.org">Wiktionary</a>를 이용하였다. 맥이나 아이폰에서는 사용자 사전을 추가할 수 있어서 한영/영한사전 및 시소러스 사전을 유용하게 사용했다. 온라인 한글 맞춤법 검사기와 워드프로세서 한글을 종종 사용하기도 했다.</p>

<p><img alt="Universal Dictionary" height="500" src="/articles/2012/progit/ubdic.jpg" /></p>

<p><strong>Park</strong> &raquo; 나보다 구글 번역기가 나을 때도 많더라.</p>

<p><strong>Park</strong> &raquo; <a href="http://urimal.cs.pusan.ac.kr/urimal_new/">우리말 배움터</a>에 감사드린다. 오래전부터 사용해왔지만, 이번에는 정말 고마웠다.</p>

<p><strong>Lee</strong> &raquo; 번역 소스 관리를 위해서 윈래 Pro Git이 호스팅되고 있는 <a href="http://github.com">GitHub</a>에서 프로젝트를 dogfeet/progit로 Fork하여 작업했다. 개인적으로 iMac과 MBP를 옮겨다닐 때는 BitBucket의 Private 저장소를 사용했다. GitHub가 좋긴 하지만 결재하지 않아서 Private 저장소가 없었다. 소스의 Branch와 Commit을 관리하기 위해 GitX를 사용했다. 번역 소스를 관리하기 위해 전에는 Subversion을 사용했는데 Git은 번역을 위한 프로젝트에서도 정말 괜찮았다! 아니 Git이 유일한 도구처럼 느껴졌다. 번역하면서 사용한 Git-Flow Pattern를 따로 정리할 예정이다.</p>

<p><strong>Park</strong> &raquo; GitHub만 사용했다. BitBucket도 써보고 싶지만, 아직 GitHub도 다 모른다. 나는 Git 때문에 GitHub을 사용하는 것인지 GitHub 때문에 Git을 사용하는 것인지 모를 정도로 GitHub가 맘에 든다.</p>

<p><img src="/articles/2012/progit/gitx-progit.png" alt="GitX" width="500" /></p>

<p><strong>Lee</strong> &raquo; HTML, ePub, Mobi, PDF 출력물을 빌드하기 위해 따로 Ubuntu 서버를 하나 사용했다. x-server를 사용하지 않고 빌드하기 위해 약간의 빌드 스크립트를 수정해서 사용하였으며 주로 pandoc과 xelatex 관련 패키지와 한글 폰트 패키지를 설치하고, <a href="http://jenkins-ci.org">Jenkins</a>(구 Hudson)에 빌드 스크립트를 등록하여 원격으로 빌드하곤 했다.</p>

<p><strong>Park</strong> &raquo; 나는 Mac에서 빌드했다. 처음에는 무척이나 골치 아팠지만 결국 방법을 찾아내고 버그도 수정했다. schacon님이 이 fix도 accept해주었다. GitHub로 번역을 진행하면서 이런 소소한 즐거움도 알게 됐다.</p>

<p><img alt="Jenkins" width="500" src="/articles/2012/progit/jenkins-progit.png" /></p>

<p><strong>Lee</strong> &raquo; 번역을 함께 진행하기 위해서 커뮤니케이션 도구로 <a href="http://yammer.com">Yammer</a>를, 서로 출력물을 항상 최신 것으로 공유하고자 <a href="http://dropbox.com">Dropbox</a>를 사용하였다. 업무용 커뮤니케이션 도구로 메신저도 좋고 메일도 좋지만, Yammer를 강추하는 바이다!</p>

<p><strong>Park</strong> &raquo; yammer는 정말 좋은 도구다. 4년 정도 같이 공부해오면서 2011년과 같이 알찬 해는 없었다. 거기에는 yammer에 힘이 컸다고 생각한다. 위키도 사용해보고 이슈 트레커도 사용해봤지만 모두 실패하고 지금은 그냥 yammer로 토론하고 yammer에 메모한다.</p>

<p><img alt="Yammer" width="500" src="/articles/2012/progit/yammer-progit.png" /></p>

<h2>닥치고 번역에 중요한 거</h2>

<p><strong>Lee</strong> &raquo; 우선 배가 항해를 하는데 좋든 좀 모자라든 선장이나 항해사 없이 제대로 된 길을 가는 것은 불가능하다. 이번 프로젝트는 일꾼 두 명이 땀을 뻘뻘 흘리면서 열심히 노를 젓는 일만 할 줄 알기에 자주 방향을 잃어가며 작업할 수밖에. 틈틈이 Yammer로 대화하며 방향을 잡아갔지만 적당한 경험 있는 편집자가 틀을 잡아줄 수 있었다면 좀 더 좋은 번역을 할 수 있지 않았을까.</p>

<p><strong>Park</strong> &raquo; 특히 중요하게 생각한 점은 최종 결정은 마지막에 수정하는 사람이 결정하기로 했다. 그래서 아쉬운 사람이 한 번 더 검토했다.</p>

<p><strong>Park</strong> &raquo; 번역도 일종의 모험이다. 훌륭한 선장과 항해사를 갖추고 출발했었으면 더 좋았겠지만 그렇지 못했다. 그래서 애초에 목표를 크게 잡지도 않았다. 영어로 읽는 것보다는 쉽게 읽을 수 있게 하자는 것. Git은 내용이 많아서 어차피 영문으로 또 읽어볼 필요도 있으니 처음 사다리를 그릴 때 한글로 좀 더 쉽게 그릴 수 있게 하자는 것 정도였다. 한글판을 읽었으면 영문으로도 한 번 더 읽거나 영문으로 된 다른 자료를 더 읽기를 권한다.</p>

<p><img alt="Translation" width="500" src="/articles/2012/progit/tran.jpg" /></p>

<p style="text-align: center; font-size: 80%">출처: [casaubon](<a href='http://casaubon.tv'>http://casaubon.tv</a>)</p>

<p><strong>Lee</strong> &raquo; 영어의 표현을 틀리지 않게 이해하는 것도 어려웠지만, 한글로 옮겨적는 것이 더 어려웠다. 용어번역표를 제대로 정리하지 못해서 전체적으로 어휘 일관성을 지키지 못한 점도 많이 부끄럽다.</p>

<p><strong>Park</strong> &raquo; 국어 실력이 제일 중요한 것 같다. 자신 있게 문장을 만들어야 한다. 틀릴 때는 그냥 확실히 틀려주는 것이 결국은 더 빠르다. 초반에 이렇게 신경 쓰지 못해서 나중에 다 다시 리뷰해야 했다. 그리고 그 질도 떨어진 것 같다. 시간도 더 들고 질도 떨어진다.</p>

<p><strong>Park</strong> &raquo; 공부가 제일이다. 이렇게 긴 글을 번역할 기회가 적은데 번역에 대한 공부를 더 못한 것이 아쉽다.</p>

<h2>나는 뭘 얻었나</h2>

<p><strong>Lee</strong> &raquo; 물론 제대로 출력된 책은 Amazon에서 돈을 받고 팔기도 하지만 Pro Git 책은 기본적으로 무료다. 저자인 schacon님은 Git 에반젤리스트이기도 하고 GitHub의 CIO이기도 하다. 사람들이 Git을 많이 써서 GitHub를 많이 사용하게 된다면 좋은 일 아닌가 ^^ 하지만 우리 역자들은 ... ^^</p>

<p><strong>Lee</strong> &raquo; 적지않은 노력과 부끄러움을 드러내며 읽고 또 읽는 과정에서 Git에 대해서 그리고 번역에 대해서 경험(이라고 쓰고 삽질)과 노하우를 얻은 것은 나름의 성과라고 할 수 있겠다. 행여나 같은 업종의 동지분들께 아까운 삽질로 시간을 낭비하지 않고 조금이라도 한숨 돌릴 수 있는 여유시간을 만들어 줄 수 있다면 보람 있겠다(윗사람은 Git 같은 거 몰라도 되지 싶다 ^^).</p>

<p><strong>Park</strong> &raquo; 국어, 정말 한글 공부를 열심히 했다.</p>

<p><strong>Park</strong> &raquo; 완주하려면 동료가 꼭 필요하다는 것을 배웠다. 혼자 했으면 분명히 포기했을 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:branch-a-v</title>
    <link href="http://dogfeet.github.com/articles/2012/git-branch-a-v.html" />
    <updated>2012-01-14T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-branch-a-v.html</id>
    <content type="html">
<![CDATA[
<p>Git을 사용하면서 규모가 작은 프로젝트를 많이 만들게 됐다. 예제를 만들거나, 간단한 도구를 만들거나 버전관리가 필요하면 언제든지 Git 저장소를 만들어 사용한다. 몇 일만 잊었다가 다시 돌아오면 어디까지 작업했는지 헷갈린다. 이 때 <code>git branch -a -v</code> 명령은 현 저장소 상태를 알아 보는데 좋다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-todo/todoly.png" alt="todo.ly" title="" /></p>

<p>(todo.ly은 본 글과 아무 상관없다.)</p>

<h2>git branch -a -v</h2>

<p>Git을 사용하면서 가장 많이 사용하는 명령어 중 하나가 <code>git branch -a -v</code>이다. Fetch한 원격 브랜치를 포함해서 모든 브랜치 목록을 볼 수 있을 뿐만 아니라 각 브랜치의 마지막 커밋 정보도 보여준다. 그뿐만 아니라 해당 브랜치가 Remote Tracking 브랜치이면 Tracking 브랜치에서 얼마나 멀어졌는지도 보여준다.</p>

<p>merge를 설명할 때 사용했던 ship 저장소를 다시 살펴보자. 이 저장소를 clone하고 <code>git branch -a -v</code>를 실행한다:</p>

<pre class="prettyprint"><code>$ git branch -a -v
ship                             3f129b5 Fix anchor
remotes/origin/ship              3f129b5 Fix anchor
</code></pre>

<p><code>-a</code>의 는 원격 브랜치를 포함한 모든 브랜치를 보여준다. 그리고 <code>-v</code>는 해당 브랜치의 마지막 커밋을 보여준다.</p>

<p>'origin/ship'을 Tracking하는 'feature/kitchen'라는 브랜치를 만들고 싱크대를 추가한다:</p>

<pre class="prettyprint"><code>$ git co -b feature/kitchen origin/ship
$ touch sink_unit
$ git add sink_unit
$ git commit
[feature/kitchen e054c7e] Add sink unit
 0 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 sink_unit
</code></pre>

<p>그리고 누군가 ship 브랜치에 커밋을 추가했다. 그래서 다시 Fetch를 하고 나서 <code>git branch -a -v</code>를 실행한다:</p>

<pre class="prettyprint"><code>feature/kitchen                  e054c7e [ahead 1, behind 1] Add sink unit
ship                             3f129b5 [behind 1] Fix anchor
remotes/origin/ship              3f129b5 Fix anchor
</code></pre>

<p>'feature/kitchen' 의 커밋 메시지에 'ahead 1'를 주목하자. 'ahead 1'은 이 브랜치가 Tracking하는 브랜치에서 커밋 1개만큼 멀어져 있다는 것을 보여준다. 'feature/kitchen'은 <code>git co -b feature/kitchen origin/ship</code> 명령으로 만들었다. 이렇게 만들면 'feature/kitchen'가 'origin/ship'을 Tracking하게 된다.</p>

<p>마찬가지로 'behind 1'은 'origin/sink' 브랜치가 'feature/kitchen' 브랜치보다 커밋을 하나 더 가졌다는 것이다. <code>git log feature/kitchen...origin/ship --left-right</code>을 실행하면 다음과 같다:</p>

<pre class="prettyprint"><code>$ git lg feature/kitchen...origin/ship --left-right
&gt; 2d45d4c - (origin/ship) Add test
&lt; e054c7e - (feature/kitchen) Add sink unit
</code></pre>

<p><code>git branch</code>의 <code>-v</code> 옵션은 Tracking 브랜치의 경우 두 브랜치 사이가 얼마나 멀어졌는지도 함께 보여준다.</p>

<p><strong>UPDATE:</strong> Tracking 브랜치에 대한 내용은 잘못 정리한 것이라서 삭제했다. 나중에 따로 정리하기로 했다.</p>

<h2>todo</h2>

<p>나는 해당 프로젝트의 'todo' 목록을 별도로 관리하지 않고 그냥 토픽 브랜치로 만든다. 그리고 <code>git branch -a -v</code> 명령으로 관리한다. 나는 편의를 위해서 <code>todo</code>라는 alias를 만들어 사용한다:</p>

<pre class="prettyprint"><code>git config --global alias.todo "branch -a -v"
</code></pre>

<h2>결론</h2>

<p><code>git branch -a -v</code> 명령은 하던 일을 뭔지 기억하는데 도움이 된다. 간단하게만 관리할 수 있다면 일을 하는 것과 계획을 관리하는 것을 한 몸으로 할 수 있다.</p>

<p>그리고 커밋 메시지가 정말 중요하다. 시간이 지나서 좀 잊어버리게 된다고 해도 다시 보면 바로 알 수 있어야 한다.</p>

<p>좀 더 개선된 형태가 필요하다. 왜 꼭 Remote 브랜치만 Tracking해야 하는 걸까? 사실 Local 브랜치를 Tracking하게 하고 싶다. 관련 브랜치도 함께 보여줄 수 없을까? 다른 색으로 보여줄 수는 없을까? 좀 더 인식하기 쉬운 형태였으면 좋겠다. 틈틈이 Git 플러그인을 만들자!</p>]]>
    </content>
  </entry>
  <entry>
    <title>progit</title>
    <link href="http://dogfeet.github.com/articles/2012/progit.html" />
    <updated>2012-01-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/progit.html</id>
    <content type="html">
<![CDATA[
<p>GitHub의 CIO인 <a href="http://github.com/schacon">schacon</a>이 쓴 <a href="http://progit.org">progit</a> 번역을 완료했습니다. 부지런히 작업해서 12월 19일에 끝냈으면 가카께 헌정하고 졸라 신났을 텐데 게을러서 늦어졌습니다.--;</p>

<p><img src="http://dogfeet.github.com/articles/2011/progit/progit.book-big.jpg" alt="progit" title="" /></p>

<h2>progit</h2>

<p>다음 Format의 파일로 배포하고 있고 다운 받아서 읽으실 수 있습니다. <code>2012-01-31</code>에 빌드한 파일입니다:</p>

<ul>
<li><a href="http://dogfeet.github.com/progit/progit.ko.epub">progit.ko.epub</a></li>
<li><a href="http://dogfeet.github.com/progit/progit.ko.mobi">progit.ko.mobi</a></li>
<li><a href="http://dogfeet.github.com/progit/progit.ko.pdf">progit.ko.pdf</a></li>
<li><a href="http://dogfeet.github.com/progit/progit.ko.html">progit.ko.html</a></li>
</ul>

<p>mobi 파일은 Android Kindle App에서 띄어쓰기가 안되는 문제가 있습니다. <a href="http://calibre-ebook.com/download">Calibre</a>에서 열어보면 잘 되는데 Kindle App에서는 안되네요.</p>

<p><strong>UPDATE:</strong> Kindle Touch에서는 띄어쓰기가 된다고 합니다(ryan003님 제보).</p>

<p>번역은 <a href="https://github.com/dogfeet/progit">progit 한글 버전 저장소</a>에서 진행하고 있습니다. 오역이나 오탈자는 패치를 보내주시거나 <a href="https://github.com/dogfeet/progit/issues">이슈 트래커</a>에 신고해주세요.</p>

<p>다시 한번 동료의 힘을 몸소 체험한 프로젝트 였습니다. <a href="https://twitter.com/#!/lethee">@lethee</a>와 함께 하지 않고 혼자했다면 결코 완주하지 못했을 겁니다.</p>

<h2>힘내</h2>

<p>구글 번역기는 <code>Git</code>을 <code>힘내</code>라고 번역해 줍니다. 개발자분들 모두 <code>Git</code>으로 힘내시길 바래요.</p>

<p><img src="/articles/2011/progit/git-.png" alt="힘내" title="" /></p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:conflict</title>
    <link href="http://dogfeet.github.com/articles/2012/git-conflict.html" />
    <updated>2012-01-01T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-conflict.html</id>
    <content type="html">
<![CDATA[
<p>충돌을 해결하는 방법은 단순하다. 편집기로 충돌이 일어난 파일을 열어 적절히 편집하고 <code>git add</code> 명령으로 Staging Area에 추가하고 나서 <code>git commit</code>으로 commit하면 끝이다. 하지만, Git으로 좀 더 쉽게 하는 방법을 알아본다.</p>

<p>Git 명령어를 사용하다 보면 'ours', 'theirs'라는 옵션을 자주 보게 된다. 이 옵션은 충돌을 위해 만들어진 옵션이다. 이 글은 이 옵션에 대해 설명한다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-conflict/creation-of-adam.jpg" alt="creation of adam" title="" /></p>

<p>새해 복 많이 받으세요!!</p>

<h2>Config</h2>

<p>기본적으로 <code>git diff</code>와 같은 형식으로 보여주지만 충돌 결과를 보여주는 스타일을 변경할 수 있다:</p>

<pre class="prettyprint"><code>$ git config merge.conflictstyle diff3
</code></pre>

<h2>Checkout</h2>

<p>Checkout 명령에 <code>--ours</code>와 <code>--theirs</code> 옵션이 있다. 이 옵션은 충돌 났을 때 사용한다. <code>ours</code> 브랜치에 conflict 파일은 다음과 같다고 하자:</p>

<pre class="prettyprint"><code>$ cat conflict
ours
</code></pre>

<p><code>theirs</code> 브랜치의 conflict 파일은 다음과 같다:</p>

<pre class="prettyprint"><code>$ cat conflict
theirs
</code></pre>

<p><code>theirs</code> 브랜치를 <code>ours</code> 브랜치에 Merge하면 충돌 난다:</p>

<pre class="prettyprint"><code>$ git merge theirs
Auto-merging conflict
CONFLICT (content): Merge conflict in conflict
Automatic merge failed; fix conflicts and then commit the result.
</code></pre>

<p>diff 명령으로 어디서 충돌 났는지 확인한다:</p>

<pre class="prettyprint"><code>$ git diff
diff --cc conflict
index 1b9074b,f853c8d..0000000
--- a/conflict
+++ b/conflict
@@@ -1,1 -1,1 +1,5 @@@
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +ours
++=======
+ theirs
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; theirs
</code></pre>

<p>편집기로 conflict 파일을 손으로 수정해도 되지만 그냥 ours에 있는 파일을 사용할 수 있다:</p>

<pre class="prettyprint"><code>$ git checkout --ours -- conflict
</code></pre>

<p>theirs의 파일을 선택할 수도 있다:</p>

<pre class="prettyprint"><code>$ git checkout --theirs -- conflict
</code></pre>

<p>충돌을 해결했으면 <code>git add</code>로 추가하고 커밋한다.</p>

<h2>Diff</h2>

<p><code>git diff</code> 명령에도 <code>--ours</code>, <code>--theirs</code> 옵션이 있다. 이 옵션을 주면 <code>git diff</code> 명령은 다른 색으로 표시해준다. 예를 들어 다음과 같이 실행한다.</p>

<pre class="prettyprint"><code>$ git diff --ours --color=auto
</code></pre>

<p>그러면 ours 브랜치의 내용만 다른 색으로 표시해준다. <code>--theirs</code>도 같은 방법으로 확인할 수 있다.</p>

<p>diff 명령은 <code>--base</code> 옵션이 있어서 이 옵션을 주면 두 브랜치의 base 커밋에 있는 내용도 같이 보여준다:</p>

<pre class="prettyprint"><code># git diff --base
</code></pre>

<h2>Merge</h2>

<p>Merge할 때 아예 어느 것을 선택할지 정해줄 수 있다. ours 브랜치의 것을 선택하는 merge를 해보자.</p>

<pre class="prettyprint"><code>$ git merge -s ours theirs
Merge made by ours.
</code></pre>

<p>그리고 파일 내용을 보면 ours 브랜치의 파일로 Merge 돼 있다.</p>

<pre class="prettyprint"><code>$ cat conflict
ours
</code></pre>

<p>theirs를 선택하면 충돌 내지 않고 theirs 브랜치의 파일로 Merge된다.</p>

<h2>Attribute</h2>

<p>Attribute로 Blob 패턴마다 ours를 사용할지 their를 사용할지 설정할 수 있다.</p>

<p>Git Attribute는 Blob 패턴마다 다른 설정을 하는 것을 말하며 <code>.gitattributes</code> 파일을 만들고 거기에 작성하면 된다. </p>

<p>이 설정은 브랜치의 목적이 환경일 때 유용하다. 예를 들어 prod, test, dev라는 브랜치를 만들어 사용한다고 가정하자. prod는 실제 운영환경을 목적으로 설정돼 있고 test는 CI 등 테스트 자동화를 위해 만들었고, dev는 로컬 개발 환경을 위한 설정을 담고 있다고 하자. 그리고 환경정보는 <code>src/main/resources/env.properties</code>에 기술한다고 가정하자. 실제로 프로젝트를 해본 결과 prod, test, dev 프로파일을 만들고 개발하는 것이 <code>Maven + Spring</code> 환경에서는 꽤 유용했다. 분명히 환경을 위한 브랜치가 필요할 때가 올 것이다. </p>

<p><code>.gitattributes</code> 파일을 프로젝트 루트 디렉토리에 다음과 같이 만들고:</p>

<pre class="prettyprint"><code>src/main/resoruces/env.properties merge=ours
</code></pre>

<p><code>git merge</code> 명령을 실행하면 이 파일은 항상 ours의 파일로 Merge한다. 그래서 환경 설정이 Merge될 걱정 없이 사용할 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title>Git:diff</title>
    <link href="http://dogfeet.github.com/articles/2011/git-diff.html" />
    <updated>2011-12-24T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2011/git-diff.html</id>
    <content type="html">
<![CDATA[
<p>Git은 명령어가 엄청나게 많지만, 알면 알수록 일관적인 명령어에 감탄하게 된다.<br />(아무리 그래도 너무 많다.--;)</p>

<p>이 글에서는 <code>git diff</code> 명령어의 사용법을 간단히 정리한다.</p>

<p><img src="http://dogfeet.github.com/articles/2011/git-diff/christmas-in-jelly-village.jpg" alt="heading image" title="" /></p>

<p>산타와 함께 하는 틀린 그림 찾기 "Christmas In Jelly Village". <a href="http://blog.daum.net/_blog/BlogTypeView.do?blogid=0TE6a&amp;articleno=429&amp;categoryId=0&amp;regdt=20100512215001#ajax_history_home">출처</a></p>

<h2>Unified Format</h2>

<p><code>git diff</code>는 결과를 <a href="/articles/2011/1316924580.html">Unified Format</a>으로 보여준다. 이 형식에 익숙하지 않으면 링크를 따라가 읽어보는 것이 도움될 것이다. </p>

<h2>git diff</h2>

<p>diff를 잘 활용하자.</p>

<h3>Modified, Staged, Unmodified 사이 비교</h3>

<p>Modified(Working Directory에 있는)와 Staged(Staging Area에 있는)는 다음과 같이 비교한다:</p>

<pre class="prettyprint"><code>git diff
</code></pre>

<p>특정 파일만 비교할 수도 있다:</p>

<pre class="prettyprint"><code>git diff my-file
</code></pre>

<p>Staged와 Unmodified(HEAD의)는 다음과 같이 비교한다:</p>

<pre class="prettyprint"><code>git diff --staged/--cached
</code></pre>

<p><code>--staged</code>와 <code>--cached</code>는 똑같다. 이것도 특정 파일만 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff --staged my-file
</code></pre>

<h3>Revision 비교</h3>

<p>리비전 두 개를 골라 비교할 수도 있다:</p>

<pre class="prettyprint"><code>git diff bd976f4 59d60f9
</code></pre>

<p>그중 파일 하나만 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff bd976f4 59d60f9 my-file
</code></pre>

<p>다음처럼도 비교할 수도 있다:</p>

<pre class="prettyprint"><code>git diff bd976f4:my-file 59d60f9:my-file
</code></pre>

<h3>Modified, Staged와 Revision 비교</h3>

<p>Working Directory에 있거나 Staging Area에 수정한 파일을 HEAD의 파일이 아니라 이전 커밋하고 비교할 수도 있다. Working Directory를 <code>HEAD~18</code>에 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff HEAD~18
</code></pre>

<p>특정 파일만 비교할 수 있다:</p>

<pre class="prettyprint"><code>git diff HEAD~18 my-file
</code></pre>

<p>Staging Area와 <code>HEAD~18</code>과 비교하려면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>git diff --staged HEAD~18
</code></pre>

<p>이때도 특정 파일만 비교하려면 다음과 같다:</p>

<pre class="prettyprint"><code>git diff --staged HEAD~18 my-file
</code></pre>

<h3>파일 이름만 보기</h3>

<p><code>--name-only</code> 옵션을 주면 관련 파일을 볼 수 있다. 다음은 해당 커밋에 수정된 파일 목록을 보여준다:</p>

<pre class="prettyprint"><code>git show --name-only HEAD~4
</code></pre>

<p>다음은 Working Directory와 HEAD~4에서 변경된 파일 이름만 보여준다.</p>

<pre class="prettyprint"><code>git diff --name-only HEAD~4
</code></pre>

<p>이 옵션은 <code>git log</code> 명령에도 사용할 수 있다. 해당 commit에 수정된 파일 이름도 같이 보여준다.</p>

<pre class="prettyprint"><code>git log --name-only
</code></pre>]]>
    </content>
  </entry>
</feed>
