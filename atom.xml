<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-07-30T13:36:17.568Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: .sbt Build Definition ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-basic-def.html" />
    <updated>2012-07-29T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-basic-def.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2><code>.sbt</code> Build Definition</h2>

<p>이 페이지는 sbt 빌드를 정의하는 법을 설명한다. sbt "원리"와 <code>build.sbt</code>의 문법을 설명한다. <a href="/articles/2012/sbt-getting-started-running.html">sbt를 실행하는 방법</a>은 이미 숙지했다고 가정하고 설명한다. 아직 익히지 못했으면 이전 페이지를 읽어라.</p>

<h3><code>.sbt</code> vs. <code>.scala</code> Definition</h3>

<p>sbt 빌드는 base 디렉토리에 <code>.sbt</code> 파일을 만들고 그 파일에 정의한다. <code>.scala</code> 파일은 base 디렉토리 하위에 <code>project</code> 디렉토리에 만들고 거기에 넣는다.</p>

<p>두 파일 중 아무거나 하나만 만들어 사용할 수도 있고 함께 혼용해도 된다. 그래도 <code>.sbt</code> 파일로 할 수 없는 일만 <code>.scala</code> 파일로 구현하고 대부분은 <code>.sbt</code> 파일을 사용하는 것이 바람직하다:</p>

<ul>
<li>sbt 커스트마이즈하기(설정이나 타스크를 추가한다)</li>
<li>네스티드(nested) 서브 프로젝트를 정의한다.</li>
</ul>

<p>이 글은 <code>.sbt</code> 파일만 설명한다. <code>.scala</code> 파일을 사용하는 방법은 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala build definition</a>에서 설명한다.</p>

<h3>What is a build definition?</h3>

<p><em>* 이 부분은 반드시 절대로 꼭 읽어주세요. *</em></p>

<p>sbt는 실제로 빌드하기 전에 프로젝트를 검사하고 빌드 스크립트를 처리한다. 그 전처리를 완료하면 immutable 맵이 하나 생성되는데 그 맵에 빌드 정보가 <code>키/밸류</code> 형태로 들어간다.</p>

<p>예를 들어, 키가 <code>name</code>인 항목의 스트링 밸류는 프로젝트 이름을 의미한다.</p>

<p><em>우리가 만든 빌드 정의가 바로 sbt 맵으로 만들어지는 것이 아니다.</em></p>

<p>우선 모든 빌드 정의를 <code>Setting[T]</code> 타입의 객체를 담는 리스트로 만든다. <code>Setting[T]</code>의 T는 맵의 밸류 타입을 의미한다. Java에서 <code>Setting&lt;T&gt;</code>이라고 하는 것과 같은 표현이다. <code>Setting</code>에는 맵으로 변환하기 위한 정보가 들어간다. 예를 들어, <code>키/밸류</code> 항목을 새로 만들어야 하는지 기존의 항목의 밸류에 추가하면 되는지의 정보가 담긴다. '함수형 프로그래밍' 정신에 따라서 맵으로 변형 시 기존의 맵을 수정해서 리턴하는 것이 아니라 맵을 새로 만들어 리턴한다.  </p>

<p><code>build.sbt</code> 파일에서 다음과 같이 프로젝트 이름을 정의하면 <code>Setting[String]</code> 인스턴스가 만들어진다:</p>

<p><code>scala<br />name := "hello"<br /></code></p>

<p>키가 <code>name</code>이고 밸류가 <code>"hello"</code>인 <code>Setting[String]</code> 객체가 생성되고 sbt 맵에 키가 <code>name</code>인 항목이 있으면 그 항목의 밸류만 교체하고 없으면 해당 항목을 새로 만든다. 다시 말하지만, 이때 변형된 맵은 새로 생성된다.</p>

<p>이 맵이 만들어지는 과정을 살펴보자. sbt는 먼저 Setting 리스트을 정렬한다. 키가 같은 항목들은 하나로 합치고 밸류에서 다른 항목을 사용하고 있으면 그 항목부터 처리한다. 설정 간 의존성이 있으면 의존성부터 해결한다. sbt는 정렬된 <code>Setting</code> 리스트를 하나씩 map으로 변환한다.</p>

<p>요약: <em>빌드 정의는 먼저 <code>Setting[T]</code> 리스트로 만들고 다시 <code>Setting[T]</code> 리스트를 sbt 맵으로 변환한다. <code>T</code>는 각 밸류의 타입이다</em>.</p>

<h3>How <code>build.sbt</code> defines settings</h3>

<p><code>build.sbt</code> 파일의 자료구조는 <code>Seq[Setting[_]]</code>이다. 이 파일은 Scala Expression의 리스트인데 한 줄 띄우는 것으로 구분한다. 각 줄은 리스트의 항목 하나이고 순서대로 처리된다. <code>.scala</code> 파일에서 <code>.sbt</code> 파일의 내용을 <code>Seq(</code>와 <code>)</code>로 감싸고 빈 줄 대신에 콤마를 넣으면 <code>.sbt</code> 파일에서 한 것과 동일한 코드가 된다.</p>

<p>다음은 <code>.sbt</code> 파일 예제이다:</p>

<p>```scala<br />name := "hello"</p>

<p>version := "1.0"</p>

<p>scalaVersion := "2.9.1"<br />```</p>

<p><code>build.sbt</code> 파일은 빈 줄로 구분하는 <code>Setting</code> 객체의 리스트다. 각 <code>Setting</code>은 Scala Expression으로 정의한다. </p>

<p><code>build.sbt</code>에 있는 Expression은 서로서로 독립적이고 문법상으로 Scala Statement가 아니라 Scala Expression이다. 그래서 <code>build.sbt</code> 파일에 Scala Expresion을 정의할 때 그 Expresion 제일 앞에는 <code>val</code>, <code>object</code>, 클래스, 메소드를 정의할 수 없다.</p>

<p>왼쪽에 사용한 <code>name</code>, <code>version</code>, <code>scalaVersion</code>은 <em>키</em>다. 키는 <code>SettingKey[T]</code>, <code>TaskKey[T]</code>, <code>InputKey[T]</code>의 인스턴스이고 <code>T</code>는 밸류의 타입이다. 아래에서 키에 대해서 좀 더 설명한다.</p>

<p>키는 <code>Settings[T]</code>를 리턴하고 이름이 <code>:=</code>인 메소드를 호출한다. 이 메소드는 Java 처럼 호출할 수도 있다:</p>

<p><code>scala<br />name.:=("hello")<br /></code></p>

<p>스칼라에서는 <code>name := "hello"</code>라고 사용해도 메소드를 호출할 수 있다. 스칼라 문법에서는 이렇게 메소드를 호출하는 것도 가능하다.</p>

<p><code>name</code> 키에 있는 <code>:=</code> 메소드는 <code>Setting</code> 객체를 반환한다. 정확한 타입은 <code>Setting[String]</code>이다. <code>name</code> 키의 타입은 <code>SettingKey[String]</code>인데 여기서 <code>String</code>은 <code>name</code> 자체의 타입이다. <code>Setting[String]</code> 인스턴스가 반환되면 <code>name</code>을 키로 해서 sbt 맵에 넣는다. 이 <code>Setting[String]</code> 인스턴스의 값은 <code>"hello"</code>다.</p>

<p>타입을 틀리게 넣으면 컴파일 안 된다:</p>

<p><code>scala<br />name := 42  // will not compile<br /></code></p>

<h3>Settings are separated by blank lines</h3>

<p>다음과 같이 <code>build.sbt</code> 파일을 작성할 수 없다:</p>

<p><code>scala<br />// will NOT work, no blank lines<br />name := "hello"<br />version := "1.0"<br />scalaVersion := "2.9.1"<br /></code></p>

<p>Setting을 구분해 주는 구분자가 필요하다. sbt는 구분자가 있어야 Scala Expression을 구분할 수 있다.</p>

<p><code>.sbt</code> 파일에 구현하는 것은 Scala Expression이지 Scala 프로그램이 아니다. sbt는 각 Scala Expression을 하나씩 잘라서 개별적으로 컴파일한다.</p>

<p>Scala 프로그램을 사용하고 싶으면 <code>.sbt</code> 파일이 아니라 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala 파일</a>로 구현해야 한다. 이때에는 <code>.sbt</code> 파일이 없어도 된다. <code>.scala</code> 파일을 사용하는 방법은 나중에 설명한다. 어떻게 하는지 살짝 들춰보자면 <code>.sbt</code> 파일에서 정의하던 Setting Expression을 <code>.scala</code> 파일에서 <code>Seq[Setting]</code> 자료구조로 정의하면 된다.</p>

<h3>Keys are defined in the Keys object</h3>

<p>빌트인 키는 <a href="http://harrah.github.com/xsbt/latest/sxr/Keys.scala.html">Keys</a> 객체에 정의되 있다. <code>build.sbt</code>에는 <code>import sbt.Keys._</code>가 묵시적으로 선언돼 있어서 <code>sbt.Keys.name</code>라고 안 쓰고 <code>name</code>이라고 바로 써도 되는 것이다.</p>

<p>Key를 새로 정의하려면 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala 파일</a>이나 <a href="/articles/2012/sbt-getting-started-using-plugins.html">plugin</a>으로 정의해야 한다.</p>

<h3>Other ways to transform settings</h3>

<p><code>:=</code>으로 리플레이스 하는 것이 가장 단순한 변형 방법이지만 다른 방법도 있다. 예를 들어 <code>+=</code>으로도 Setting 밸류를 추가할 수 있다.</p>

<p>다른 방법에 대해서 <a href="/articles/2012/sbt-getting-started-scopes.html">scopes</a>과 그 다음으로 이어지는 '<a href="/articles/2012/sbt-getting-started-more-about-settings.html">More About Settings</a>'에서 자세히 설명한다.</p>

<h3>Task Keys</h3>

<p>Key는 세 종류이다:</p>

<ul>
<li><code>SettingKey[T]</code>: 이 키와 밸류는 딱 한 번 해석한다. 프로젝트를 로드할 때 해석하고 다시 해석하지 않는다.</li>
<li><code>TaskKey[T]</code>: 이 키와 밸류는 매번 다시 해석한다. 그래서 문제가 될 수도 있다.</li>
<li><code>InputKey[T]</code>: 이 가이드에서는 <code>InputKey</code>는 설명하지 않는다. 이 가이드를 다 보고 나서 <a href="https://github.com/harrah/xsbt/wiki/Input-Tasks">Input Task</a>를 봐라.</li>
</ul>

<p><em>타스크</em>를 정의한다고 sbt에 말할 때 <code>TaskKey[T]</code>를 사용한다. <code>compile</code>이나 <code>package</code> 같은 것이 타스크이다. 이 타스크는 <code>Unit</code>을 리턴하거나 해당 타스크와 관련된 어떤 밸류를 리턴한다. 스칼라에서는 <code>Unit</code>이 <code>void</code>다. 예를 들어 <code>package</code> 타스크는 타입이 <code>TaskKey[File]</code>이고 생성할 jar 파일을 리턴한다.</p>

<p>타스크를 실행할 때마다 항상 다시 실행한다. <code>compile</code> 타스크를 실행하면 <code>compile</code> 타스크에 필요한 모든 타스크가 한 번씩 다시 실행된다.</p>

<p>sbt 맵에는 프로젝트 정보가 담겨 있다. <code>name</code> 같은 게 이에 해당하고 항상 고정된 밸류를 저장한다. <code>compile</code>같은 타스크는 고정 값이 아니라 실행 코드이다. 이 실행 코드가 스트링을 리턴한다고 해도 스트링을 얻으려면 항상 다시 실행해야 한다.</p>

<p><em>타스크나 설정이나 키를 사용하는 것은 동일하다.</em> 매번 실행하는 것인지 아닌지가 타스크인지 아닌지를 구분하는 요소이며 이것은 밸류가 아니라 키의 프로퍼티에 해당한다.</p>

<p><code>:=</code>을 사용해서 타스크에 코드를 할당할 수 있다. 이 코드는 매번 실행된다:</p>

<p><code>scala<br />hello := { println("Hello!") }<br /></code></p>

<p>타스크 키로 <code>Setting</code>을 만들 때와 설정 키로 <code>Setting</code> 을 만들 때는 타입이 다르다. <code>taskKey := 42</code> 가 생성하는 결과의 타입은 <code>Setting[Task[T]]</code>이지만 <code>settingKey := 42</code>가 생성하는 결과의 타입은 <code>Setting[T]</code>이다. 타스크는 타스크를 실행해서 <code>T</code> 타입의 밸류를 생성하는 것뿐이고 그 외에는 차이가 없다.</p>

<p>내부적으로 <code>T</code>와 <code>Task[T]</code> 타입이 다른 점이 더 있다. 설정키는 프로젝트를 로드할 때 한 번만 처리하기 때문에 타스크 키에 의존하지 않는다. 곧 읽게 될 <a href="/articles/2012/sbt-getting-started-more-about-settings.html">More About Settings</a>에서 이 문제를 자세히 다룬다.</p>

<h3>Keys in sbt interactive mode</h3>

<p>대화형 모드에서 타스크 이름을 입력하면 해당 타스크가 실행된다. <code>compile</code>이라는 타스크 키가 있으니까 대화형 모드에서 <code>compile</code>이라고 입력했을 때 compile 타스크가 실행될 수 있다.</p>

<p>타스크 키가 아니라 설정 키를 입력하면 그냥 화면에 그 키의 밸류를 보여준다. <br />타스크 키를 입력하면 타스크가 실행되지만, 그 결과를 보여주진 않는다. 타스크의 결과를 보고 싶으면 <code>show &lt;task name&gt;</code>이라고 입력해야 한다.</p>

<p>키 이름은 Scala 관례에 따라 카멜케이스 방식으로 지어야 하고 sbt 명령어는 <code>하이픈 구분자</code> 방식을 사용한다. <a href="http://harrah.github.com/xsbt/latest/sxr/Keys.scala.html">Keys</a>에 정의된 키를 sbt에서 사용할 때는 하이픈 구분자를 사용해야 한다. <code>Keys.scala</code>에 정의한 것 중 한 예를 보자:</p>

<p><code>scala<br />val scalacOptions = TaskKey[Seq[String]]("scalac-options", "Options for the Scala compiler.")<br /></code></p>

<p>sbt에서 타스크를 입력할 때는 <code>scalacOptions</code>이 아니라 <code>scalac-options</code>라고 입력한다.</p>

<p>sbt 대화형 모드에서 <code>inspect &lt;keyname&gt;</code>을 입력하면 입력한 키에 대한 정보를 자세히 보여준다. <code>inspect</code>는 입력한 키의 밸류와 간략한 설명을 보여준다. 물론 처음 보는 정보들까지도 함께 보여준다.</p>

<h3>Imports in <code>build.sbt</code></h3>

<p><code>build.sbt</code> 파일에 import 구문을 사용할 수 있다. import 구문은 한 줄 띄우기를 할 필요가 없다.</p>

<p>다음을 보면 무슨 소린지 한 번에 알 수 있다:</p>

<p><code>scala<br />import sbt._<br />import Process._<br />import Keys._<br /></code></p>

<p>(<a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala build definition</a>를 보면 <code>Build</code>나 <code>Plugin</code> 객체도 임포트해서 사용하는 방법을 설명한다. <code>Build</code>나 <code>Plugin</code> 객체를 임포트해야 하면 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala build definition</a>를 보라.)</p>

<h3>Adding library dependencies</h3>

<p>라이브러리 의존성을 추가하는 방법은 두 가지다. 하나는 unmanaged 방식으로 <code>lib/</code> 디렉토리에 jar 파일을 그냥 넣으면 된다. 다른 하나는 managed 방식으로 <code>build.sbt</code> 파일에 다음과 같이 추가한다:</p>

<p><code>scala<br />libraryDependencies += "org.apache.derby" % "derby" % "10.4.1.3"<br /></code></p>

<p>이 것은 버전이 10.4.1.3인 Apache Derby 라이브러리를 managed 방식으로 추가하는 것을 보여준다. </p>

<p><code>libraryDependencies</code>에서는 <code>+=</code>와 <code>%</code> 메소드를 추가로 알아야 한다: <code>+=</code>는 기존의 밸류를 교체하는 것이 아니라 기존의 밸류에 새 밸류를 추가하는 것이다. 자세한 것은 <a href="/articles/2012/sbt-getting-started-more-about-settings.html">More About Settings</a>에서 설명한다. <code>%</code>는 Ivy 모듈 ID를 조합하는 데 사용하고 자세한 설명은 <a href="/articles/2012/sbt-getting-started-library-dependencies.html">Library Dependencies</a>에 있다.</p>

<p>라이브러리 의존성은 <a href="/articles/2012/sbt-getting-started-library-dependencies.html">Library Dependencies</a>에서 다룰 예정이다. 여기서는 이 정도로 마무리하겠다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Running ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-running.html" />
    <updated>2012-07-24T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-running.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h1>Running</h1>

<p>이 페이지는 이미 설정이 끝난 프로젝트에서 <code>sbt</code> 명령을 사용하는 법을 설명한다. <a href="/articles/2012/sbt-getting-started-setup.html">sbt를 설치</a>했고 <a href="/articles/2012/sbt-getting-started-hello.html">Hello, World</a>정도는 만들어 봤다고 간주한다.</p>

<h2>Interactive mode</h2>

<p>프로젝트 디렉토리에서 아무런 아규먼트 없이 sbt를 실행한다:</p>

<pre><code>$ sbt
</code></pre>

<p>아규먼트 없이 sbt를 실행하면 인터랙티브 모드로 실행돼서 커맨드 프롬프트가 나온다. 이 커맨드 프롬프트는 탭 완성과 히스토리까지 지원한다!</p>

<p>예를 들어 sbt 프롬프트에서 <code>compile</code>이라고 실행하고:</p>

<pre><code>&gt; compile
</code></pre>

<p><code>compile</code>을 다시 실행할 때는, 위 방향키를 누르고 엔터를 친다.</p>

<p><code>run</code>을 입력해서 프로그램을 실행한다.</p>

<p>Unix에서는 Ctrl+D 키를, Windows에서는 Ctrl+Z 키를 누르거나 <code>exit</code>라고 입력하면 인터랙티브 모드를 빠져나온다.</p>

<h2>Batch mode</h2>

<p>sbt를 배치 모드로 실행할 수도 있다. 스페이스로 구분해서 목록을 죽 나열하고 sbt 아규먼트로 넘기면 된다. sbt의 아규먼트는 sbt 명령과 그 명령의 아규먼트를 의미한다. sbt 명령어와 해당 명령의 아규먼트는 따옴표(<code>"</code>)로 묶어서 아규먼트 하나로 만든다:</p>

<pre><code>$ sbt clean compile "test-only TestA TestB"
</code></pre>

<p>이 예제에서는 <code>test-only</code> 명령에 <code>TestA와</code>TestB<code>아규먼트를 넘기면 입력한 sbt 명령어 순으로</code>clean<code>,</code>compile<code>,</code>test-only`가 실행된다.</p>

<h2>Continuous build and test</h2>

<p>소스 파일이 수정될 때 자동으로 컴파일하고 테스트를 실행하게 할 수 있으니 수정-컴파일-테스트 과정에 드는 시간을 절약할 수 있다.</p>

<p>명령을 실행할 때 앞에 <code>~</code> 라고 적어주면 소스 파일이 변경될 때마다 명령어가 실행된다. 예를 들어, 인터랙티브 모드에서는 다음과 같이 실행한다:</p>

<pre><code>&gt; ~ compile

Press enter to stop watching for changes.
</code></pre>

<p>인터랙티브 모드 뿐만 아니라 배치 모드에서도 <code>~</code>를 사용할 수 있다.</p>

<p>자세한 내용은 <a href="https://github.com/harrah/xsbt/wiki/Triggered-Execution">Triggered Execution</a>에서 있다.</p>

<h2>Common commands</h2>

<p>다음은 자주 사용하는 sbt 명령어다. 나머지 sbt 명령어는 <a href="https://github.com/harrah/xsbt/wiki/Command-Line-Reference">Command Line Reference</a>에서 설명한다.</p>

<ul>
<li><code>clean</code>
<code>target</code> 디렉토리에 생성한 파일을 모두 삭제한다.</li>
<li><code>compile</code>
<code>src/main/scala</code>와 <code>src/main/java</code> 디렉토리에 있는 소스를 컴파일한다.</li>
<li><code>test</code>
테스트를 전부 컴파일하고 실행한다.</li>
<li><code>console</code>
컴파일한 소스와 모든 의존성을 자동으로 클래스패스에 포함시켜서 Scala 인터프리터를 실행한다. sbt 콘솔에서 <code>:quit</code>를 입력하거나 Ctrl+D(Unix) 키나 Ctrl+Z(Windows)를 누르면 빠져나온다.</li>
<li><code>run &lt;argument&gt;*</code>
<code>sbt</code>가 실행되고 있는 가상 머신에서 해당 프로젝트의 메인 클래스를 실행한다.</li>
<li><code>package</code>
<code>src/main/scala</code>와 <code>src/main/java</code>에 있는 소스 파일을 컴파일한 클래스와 <code>src/main/resources</code>에 있는 파일까지도 전부 포함하는 jar파일을 생성한다. </li>
<li><code>help &lt;command&gt;</code>
해당 명령어의 도움말을 보여준다. <command>를 생략하면 모든 명령어에 대한 요약 도움말을 보여준다.</li>
<li><code>reload</code>
빌드 정의 파일인 <code>build.sbt</code>, <code>project/*.scala</code>, <code>project/*.sbt</code>을 다시 로드한다. 이 파일을 수정했을 때 필요하다.</li>
</ul>

<h2>Tab completion</h2>

<p>인터랙티브 모드에서는 탭 자동완성을 사용할 수 있다. 프롬프트에 입력한 게 없을 때에도 탭 자동완성을 사용할 수 있다. 탭 키를 한번 누르면 가능한 데까지 자동완성을 해주고 거기서 한 번더 누르면 그 다음에 선택할 수 있는 모든 명령어를 보여준다.</p>

<h2>History Commands</h2>

<p>인터랙티브 모드에서는 히스토리가 저장되는데 sbt를 종료하거나 재시작할 때도 저장된다. 방향키로 히스토리를 조회할 수 있다. 다음은 히스토리와 관련된 명령이다:</p>

<ul>
<li><code>!</code>
히스토리 명령어에 대한 도움말을 보여준다.</li>
<li><code>!!</code>
이전 명령어를 실행한다.</li>
<li><code>!:</code>
모든 이전 명령어를 보여준다.</li>
<li><code>!:n</code>
최근에 실행한 n번째 명령어를 보여준다.</li>
<li><code>!n</code>
최근에 실행한 n번째 명령어를 실행한다. <code>!:</code> 명령어는 과거 명령어를 순서에 따라 보여준다.</li>
<li><code>!-n</code>
최근에 실행한 n번째 명령어를 실행한다.</li>
<li><code>!string</code>
<code>string</code>으로 시작하는 가장 최근 명령어를 실행한다.</li>
<li><code>!?string</code>
<code>string</code>이 포함된 가장 최근 명령어를 실행한다.</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Directory Layout ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-directory-layout.html" />
    <updated>2012-07-15T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-directory-layout.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h3>Base directory</h3>

<p>sbt에서 "base 디렉토리"는 프로젝트가 들어 있는 디렉토리를 말한다. <a href="/articles/2012/sbt-getting-started-hello.html">Hello, World</a> 에서 만든 <code>hello</code> 프로젝트에는 <code>hello/build.sbt</code>와 <code>hello/hw.scala</code> 파일이 있는데 여기서 <code>hello</code> 디렉토리가 base 디렉토리이다.</p>

<h2>Source code</h2>

<p>소스는 <code>hello/hw.scala</code>처럼 프로젝트 base 디렉토리에 넣으면 된다. 하지만 보통은 그냥 넣으면 너무 지저분하기 때문에 정리해서 넣는 규칙이 있다.</p>

<p>sbt는 기본적으로 <a href="http://maven.apache.org/">Maven</a>과 같은 디렉토리 레이아웃을 사용한다(모든 경로는 base 디렉토리를 기준으로 하는 상대 경로다):</p>

<pre><code>src/
  main/
    resources/
       &lt;files to include in main jar here&gt;
    scala/
       &lt;main Scala sources&gt;
    java/
       &lt;main Java sources&gt;
  test/
    resources
       &lt;files to include in test jar here&gt;
    scala/
       &lt;test Scala sources&gt;
    java/
       &lt;test Java sources&gt;
</code></pre>

<p><code>src/</code> 안에 있는 다른 디렉토리와 숨겨진 디렉토리는 무시된다.</p>

<h2>sbt build definition files</h2>

<p><code>build.sbt</code> 파일은 base 디렉토리에 넣지만 다른 sbt 파일은 <code>project</code> 디렉토리를 만들어 넣는다.</p>

<p><code>project</code> 디렉토리에는 <code>.scala</code> 파일을 넣을 수 있고 이 <code>.scala</code> 파일은 <code>.sbt</code> 파일과 함께 빌드를 정의하는데 쓴다. 자세한건 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala Build Definition</a>를 봐라.</p>

<pre><code>build.sbt
project/
  Build.scala
</code></pre>

<p><code>project/</code> 디렉토리 안쪽에도 <code>.sbt</code> 파일을 넣을 수 있지만 base 디렉토리에 있는 <code>.sbt</code> 파일과 다르다. 이점은 몇 가지 사전지식이 필요하기 때문에 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">나중에</a>에서 설명한다.</p>

<h2>Build products</h2>

<p>기본적으로 <code>target</code> 디렉토리에 파일을(컴파일한 클래스, 패키지한 jar 파일, managed 파일, 캐시, 문서) 생성한다.</p>

<h2>Configuring version control</h2>

<p><code>.gitignore</code> 파일에 <code>target/</code> 디렉토리를 추가한다. 다른 버전관리 시스템도 git처럼 <code>target/</code> 디렉토리를 추가해야 한다:</p>

<pre><code>target/
</code></pre>

<p>이름이 <code>/</code>로 끝났다. <code>/</code> 끝나는 이름은 디렉토리만 매치하겠다는 의미다. 그리고 <code>/</code>로 시작하지 않았기 때문에 base 디렉토리에 있는 <code>target/</code> 뿐만 아니라 <code>project/target</code>처럼 하위 디렉토리 안에 있는 디렉토리도 매치된다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Hello, World ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-hello.html" />
    <updated>2012-07-07T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-hello.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2>소스 코드에 프로젝트 디렉토리 만들기</h2>

<p>어떤 디렉토리에 소스 파일이 하나라도 있으면 그 디렉토리는 sbt 프로젝트라고 할 수 있다. <code>hello</code> 디렉토리를 만들고 그 안에 다음과 같은 <code>hw.scala</code> 파일을 만들어 넣는다:</p>

<pre><code>object Hi {
    def main(args: Array[String]) = println("Hi!")
}
</code></pre>

<p><code>hello</code> 디렉토리에서 sbt를 실행하고 sbt 콘솔에서 <code>run</code>을 실행한다. Linux와 OS X에서는 다음과 같이 실행한다:</p>

<pre><code>$ mkdir hello
$ cd hello
$ echo 'object Hi { def main(args: Array[String]) = println("Hi!") }' &gt; hw.scala
$ sbt
...
&gt; run
...
Hi!
</code></pre>

<p>sbt는 관례에 따라 동작하는 것인데 다음과 같은 것을 찾는다.</p>

<ul>
<li>Base 디렉토리에 있는 소스</li>
<li><code>src/main/scala</code> 또는 <code>src/main/java</code>에 있는 소스</li>
<li><code>src/test/scala</code> 또는 <code>src/test/java</code>에 있는 테스트</li>
<li><code>src/main/resources</code> 또는 src/test/resources`에 있는 데이터 파일</li>
<li><code>lib</code>에 있는 jar 파일</li>
</ul>

<p>sbt는 sbt를 실행하는 데 사용한 Scala 버전으로 프로젝트를 빌드한다.</p>

<p><code>sbt run</code>으로 프로젝트를 실행하거나 <code>sbt console</code> 명령으로 <a href="http://www.scala-lang.org/node/2097">Scala REPL</a>을 연다. <code>sbt console</code>은 프로젝트의 클래스패스에서 실행하는 것이라서 프로젝트 소스를 이용한 Scala 코드를 라이브로 실행 수 있다.</p>

<h2>빌드 정의하기</h2>

<p>프로젝트들은 보통 손으로 설정해줘야 한다. 프로젝트 Base 디렉토리에 <code>build.sbt</code> 파일을 만들고 기본 설정을 한다.</p>

<p>예를 들어, 프로젝트 Base 디렉토리가 <code>hello</code>라면 <code>hello/build.sbt</code> 파일에 다음과 같이 만든다:</p>

<pre><code>name := "hello"

version := "1.0"

scalaVersion := "2.9.1"
</code></pre>

<p>각 아이템 사이에 빈 줄이 있는데 그냥 보기 좋으라고 넣은 것이 아니다. 아이템 사이에는 꼭 빈 줄을 넣어줘야 한다. <a href="/articles/2012/sbt-getting-started-sbt-build-definition.html">.sbt build definition</a>에서 <code>build.sbt</code> 파일을 작성하는 방법을 자세히 배운다.</p>

<p>프로젝트를 jar 파일로 패키지할 거라면 <code>build.sbt</code> 파일에 버전과 이름 정도는 설정할 것이다.</p>

<h2>sbt 버전 설정하기</h2>

<p><code>hello/project/build.properteis</code> 파일에 어떤 버전의 sbt를 사용할지 명시할 수 있다. 다음과 같이 만든다:</p>

<pre><code>sbt.version=0.11.3
</code></pre>

<p>0.10 버전부터는 버전이 올라가도 99% 이상 잘 호환된다. 하지만 <code>project/build.properties</code>에 sbt 버전을 명시하면 혹시 모를 문제를 예방할 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Setup ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-setup.html" />
    <updated>2012-07-02T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-setup.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2>Overview</h2>

<p>다음과 같은 과정을 거쳐서 sbt 프로젝트를 만든다:</p>

<ul>
<li>sbt를 설치하고 실행할 스크립트를 만든다.</li>
<li><a href="/articles/2012/sbt-getting-started-hello.html">hello-world</a> 프로젝트를 만든다.
<ul><li>프로젝트 디렉토리를 만들고 소스를 넣는다.</li>
<li>어떻게 빌드할지 정의한다.</li></ul></li>
<li><a href="/articles/2012/sbt-getting-started-running.html">running</a>을 통해 sbt를 실행하는 법을 배운다.</li>
<li><a href="/articles/2012/sbt-getting-started-sbt-build-definition.html">.sbt-build-definition</a>에서 어떻게 빌드할지 정의하는 법을 배운다.</li>
</ul>

<h2>sbt 설치</h2>

<p><code>sbt-launch.jar</code> 파일과 실행할 스크립트만 있으면 된다.</p>

<p><em>Note: 다운로드는 <a href="http://www.scala-sbt.org/download.html">다운로드 페이지</a>에서 할 수 있다.</em></p>

<h3>Yum</h3>

<p><a href="http://rpm.typesafe.com">Typesafe Yum 레파지토리</a>에 yum 패키지가 있다. <a href="http://rpm.typesafe.com/typesafe-repo-2.0.0-1.noarch.rpm">레파지토리 rpm 패키지</a>를 설치하면 typesafe yum 레파지토리가 승인된 소스 목록에 추가된다. 그리고 다음과 같이 실행한다:</p>

<pre><code>yum install sbt
</code></pre>

<p>sbt의 최신 버전이 설치된다.</p>

<p><em>Note: 이슈를 발견하면 <a href="https://github.com/sbt/sbt-launcher-package/issues">여기</a>에 신고할 수 있다.</em></p>

<h2>Apt</h2>

<p><a href="http://apt.typesafe.com">Typesafe Debian 레파지토리</a>에 sbt Debian 패키지가 있다. <a href="http://apt.typesafe.com/repo-deb-build-0002.deb">레파지토리 deb 패키지</a>를 설치하면 typesafe debian 레파지토리가 승인된 소스 목록에 추가된다. 그리고 다음과 같이 실행한다:</p>

<pre><code>apt-get install sbt
</code></pre>

<p>sbt의 최신 버전이 설치된다.</p>

<p>sbt 없으면 레파지토리에서 정보를 업데이트한다:</p>

<pre><code>apt-get update
</code></pre>

<p><em>Note: 이슈를 발견하면 <a href="https://github.com/sbt/sbt-launcher-package/issues">여기</a>에 신고할 수 있다.</em></p>

<h2>Gentoo</h2>

<p>공식 소스 안에는 sbt용 ebuild 스크립트가 없다. 하지만 <a href='https://github.com/whiter4bbit/overlays/tree/master/dev-java/sbt-bin'>https://github.com/whiter4bbit/overlays/tree/master/dev-java/sbt-bin</a> 에 sbt를 머지하는 ebuild 스크립트가 있다. 다음과 같이 ebuild 스크립트로 sbt를 머지한다:</p>

<pre><code>mkdir -p /usr/local/portage &amp;&amp; cd /usr/local/portage
git clone git://github.com/whiter4bbit/overlays.git
echo "PORTDIR_OVERLAY=$PORTDIR_OVERLAY /usr/local/portage/overlay" &gt;&gt; /etc/make.conf
emerge sbt-bin
</code></pre>

<h2>Mac</h2>

<p><a href="http://macports.org/">MacPorts</a>로 설치한다:</p>

<pre><code>$ sudo port install sbt
</code></pre>

<p><a href="http://mxcl.github.com/homebrew/">HomeBrew</a>로 설치할 수 있다:</p>

<pre><code>$ brew install sbt
</code></pre>

<p>sbt-launch.jar를 직접 다운로드할 필요 없다:</p>

<h2>Windows</h2>

<p><a href="http://scalasbt.artifactoryonline.com/scalasbt/sbt-native-packages/org/scala-sbt/sbt-launcher/0.11.3/sbt.msi">msi</a>를 다운로드한다:</p>

<p><em>아니면</em></p>

<p><code>sbt.bat</code> 배치 파일을 만든다:</p>

<pre><code>set SCRIPT_DIR=%~dp0
java -Xmx512M -jar "%SCRIPT_DIR%sbt-launch.jar" %*
</code></pre>

<p>그리고 그 디렉토리에 [sbt-launch.jar][] 파일을 넣는다. 커맨드 라인에서 'sbt'라고 실행하려면 PATH 환경 변수에 <code>sbt.bat</code>를 등록해준다.</p>

<h2>Unix</h2>

<p><a href="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.11.3-2/sbt-launch.jar">sbt-launch.jar</a>를 다운로드해서 <code>~/bin</code> 디렉토리에 넣는다.</p>

<p>이 jar 파일을 실행하는 스크립트를 'sbt'라는 이름으로 만들고 <code>~/bin</code> 디렉토리에 넣는다:</p>

<pre><code>java -Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=384M -jar `dirname $0`/sbt-launch.jar "$@"
</code></pre>

<p>그리고 스크립트를 실행할 수 있게 만든다:</p>

<pre><code>$ chmod u+x ~/bin/sbt
</code></pre>

<h2>팁, 노트</h2>

<p>문제가 생겨서 <code>sbt</code>가 실행이 안되면 <a href="https://github.com/harrah/xsbt/wiki/Setup-Notes">설치 노트</a>를 확인하라. 터미널 엔코딩, HTTP 프록시, JVM 옵션 등에 대해 나와 있다.</p>

<p>꼼꼼하게 만들어진 쉘 스크립트가 있어서 이 스크립트로 sbt를 설치할 수 있다: <a href='https://github.com/paulp/sbt-extras'>https://github.com/paulp/sbt-extras</a> (루트 디렉토리에 있는 sbt 파일). 이 스크립트로 설치하면 패키지로 설치하는 것처럼 원하는 버전의 sbt를 설치할 수 있다. 설치할 sbt의 버전을 선택한다든지 하는 유용한 옵션이 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs에서의 멍키 패칭 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-monkey-patching.html" />
    <updated>2012-06-23T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-monkey-patching.html</id>
    <content type="html">
<![CDATA[
<p>JavaScript에서 멍키 패칭이 가능할까? 'require'를 어떻게 좀 바꾸면 될 것 같은데, 그런게 가능하긴 할까해서 찾아봤다. 명색이 프로토타입 언어인데 쓸데가 있을지는 둘 째치고 가능할꺼라는 생각이 들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-monkey-patching/monkey_patch.jpg" alt="monkey-patch" title="" /></p>

<p>(from <a href='http://geargeeksreview.blogspot.kr/2008/09/milspecmonkey-monkey-patch.html'>http://geargeeksreview.blogspot.kr/2008/09/milspecmonkey-monkey-patch.html</a>)</p>

<h2>require</h2>

<p>소스에서 require를 사용할 수 있는 이유는 다음과 같은 코드로 wrapper되기 때문이다. 다음 코드는 node/src/node.js에 있는(node 소스) 코드다:</p>

<pre><code>NativeModule.wrapper = [
    '(function (exports, require, module, __filename, __dirname) { ',
    '\n});'
];
</code></pre>

<p>소스에서 exports, require, module, __filename, __dirname 변수를 사용할 수 있는 이유는 우리가 구현하는 모듈이 이 wrapper의 바디에 해당되기 때문이다.</p>

<p>모든 모듈은 Module 객체이다. <code>require('fs')</code>라고 호출하면 fs.js를 로드해서 Module 객체 인스턴스로 만들어서 반환한다. <code>node/lib/module.js</code> 코드를 보면 모든 모듈은 Module 객체로 만드는 부분이 있다.</p>

<pre><code>var module = new Module(filename, parent);
</code></pre>

<p>require는 module 객체 자체를 반환하는 것이 아니라 <code>module.exports</code>를 반환한다. 그래서 require로 Module 객체에 접근할 수 없다. </p>

<p>module 객체에는 해당 모듈에 필요한 정보를 담고 있으면서 _cached 프로퍼티에 캐시된다. 실제 module.js 소스를 보자:</p>

<pre><code>var cachedModule = Module._cache[filename];
if (cachedModule) {
    return cachedModule.exports;
}
</code></pre>

<p>require가 호출되면 먼저 _cache에 등록는지 확인하고 캐시한 것을 반환한다. 즉, 해당 모듈 객체는 딱 하나만 만든다. 이 것은 API 문서에도 잘 나와 있다.</p>

<h3>Module.prototype.require</h3>

<p>그럼 require는 어딨는 걸까? 뭘 고쳐야 require 호출을 가로챌 수 있을까? 우리가 호출하는 require는 다음과 같은 위치에 있다:</p>

<pre><code>Module.prototype.require = function(path) {
  return Module._load(path, this);
};
</code></pre>

<p>메인 모듈(실행하는 스크립트)뿐만 아니라 모든 모듈 객체의 prototype에 있는 require를 호출한다. 그리고 저걸 바꿔주는 모듈을 만들면 내가 만든 require 함수가 호출되도록 할 수 있다.</p>

<h2>멍키 패칭</h2>

<p>require 함수를 바꾸는 mp.js 모듈을 만든다:</p>

<pre><code>var Module = require('module');

// orig 함수를 두는 위치는 아무 의미없다--;
// 그냥 prototype._require__에 넣은 것이다. 실제로 사용하려면 문제가 될 수 있다.
Module.prototype.__require__ = Module.prototype.require;
Module.prototype.require = function fevent_require(id) {

    //여기에 멍키 패칭 코드를 넣을 수 있다.
    //fs나 net 모듈 같은 걸 수정할 수 있다.
    console.log('called require');

    return this.__require__(id);
}
</code></pre>

<p>mp.js 모듈을 사용해보자:</p>

<pre><code>require('fs');

require('./mp');

require('fs'); //called require
require('net'); //called require
</code></pre>

<p>잘된다.</p>

<p>그런데 여기서 한가지 의문이 든다. Module.prototype.require를 수정했지만 <code>(function (exports, require, module, __filename, __dirname)</code>라는 wrapper를 통해 파라미터로 넘겨진 require의 레퍼런스는 그대로 인데도 잘 수행된다.</p>

<p>이 wrapper를 통해 넘겨진 함수는 다음과 같다:</p>

<pre><code>var self = this;
//....
function require(path) {
    return self.require(path);
}
</code></pre>

<p>그래서 해당 모듈의 require 함수가 호출되는 것이기 때문에 잘된다.</p>

<p>require 함수를 바꿀 수 있으니 이제 원하는 모듈을 멍키 패칭할 수 있다. 이 방법의 안정성은 좀 더 다듬어야 하고--; 멍키 패칭이 필요한 이유도 아직 없지만--;; 가능하긴 하다는 것을 알아 보았다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ iamport: nodejs ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/iamport-nodejs.html" />
    <updated>2012-06-16T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/iamport-nodejs.html</id>
    <content type="html">
<![CDATA[
<p><a href="/articles/2012/iamport-python.html">iamport: python</a>에서 100개쯤되는 포트를 확인해보려고 포트가 열렸는지 확인하는 프로그램을 python으로 작성했었다. <a href="https://github.com/laverdet/node-fibers">node-fibers</a>를 살펴보면서 iamport를 nodejs로 포팅해봤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/iamport/iamport.jpg" alt="iamport" title="" /></p>

<p>(from <a href='http://www.portofamsterdam.com/'>http://www.portofamsterdam.com/</a>)</p>

<h2>iamport: CPS</h2>

<p>다음은 포트가 열렸는지 <a href="/articles/2012/by-example-continuation-passing-style-in-javascript.html">CPS</a> 방식으로 확인하는 프로그램이다:</p>

<pre><code>#!/usr/bin/env node

var net = require('net');
var fs = require('fs');

var stime=new Date().getTime();
var done=0;

function tryToConnect( ip, port ){
    done++;

    var socket = net.createConnection(port, ip);

    socket.on('error', function(err){
        console.log( ip + ' ' + port );
    }).on('connect', function(connect) {
        socket.destroy();
    }).on('close', function(had_error){
        done--;

        if(done == 0 ){
            var etime=new Date().getTime();

            console.log( "elapsed(ms) " + (etime - stime)/1000 );
        }
    });
}

fs.readFile(process.argv[2], 'utf-8', function(err, data){
    var lines = data.split('\n');

    lines.forEach(function(line){
        if( line.trim().length &lt; 1 ) return;
        var opts=line.match(/[0-9\.]+/g);

        if( opts &amp;&amp; opts.length &gt; 1 ) {
            tryToConnect(opts[0], opts[1]);
        } else {
            console.log(line);
        }
    });
});
</code></pre>

<p>테스트할 포트 목록은 다음과 같은 파일을 파라미터로 넘겨주면 된다:</p>

<pre><code>127.0.0.1       22
127.0.0.1       21
168.126.63.1    18
18.18.18.18     18
18.18.18.18
74.125.235.180  80
</code></pre>

<p>그러면 입력 값이 잘못 됐거나 열리지 않는, 아무튼 예외가 발생하는 것만 출력한다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport.js port_scan 
18.18.18.18
127.0.0.1 21
127.0.0.1 22
18.18.18.18 18
168.126.63.1 18
elapsed(ms) 21.047
</code></pre>

<h2>iamport: fiber</h2>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>의 Future을 적용한 예이다. 비동기 API를 Wrapping하는 다른 시도도 있지만 그냥 Future를 사용했다:</p>

<pre><code>#!/usr/bin/env node

var net = require('net');
var fs = require('fs');
var Future = require('fibers/future'), wait = Future.wait;

var stime=new Date().getTime();

//api(..., callback(err,data))라는 컨벤션을 따라야 한다.
function tryToConnect( ip, port, callback ){

    var socket = net.createConnection(port, ip);

    socket.on('error', function(err){
        console.log( ip + ' ' + port );
        callback(err, null);
    }).on('connect', function(connect) {
        socket.destroy();
        callback(null, connect);
    });
}

//Function.length를 이용해서 callback 파라미터의 위치를 자동으로 찾는다.
//엄밀히 말하면 마지막 파라미터를 callback으로 가정함
var connect = Future.wrap( tryToConnect );

//readFile의 프로토타입은 readfile( port, [ip], [callback])이고
//fs.readFile은 callback 파라미터의 위치가 동적이기 때문에
//명시적으로 선언한게 아니라 arguments를 이용했다.
//그래서 Function.legnth로 callback의 위치를 알 수 없다.
//두번째 파라미터 2는 callback의 위치를 알려주는 것이다.
var readFile = Future.wrap( fs.readFile, 2 );

Fiber(function(){
    var data = readFile(process.argv[2], 'utf-8').wait();
    var lines = data.split('\n');
    var jobs = [];

    lines.forEach(function(line){
        if( line.trim().length &lt; 1 ) return;

        var opts=line.match(/[0-9\.]+/g);

        if( opts &amp;&amp; opts.length &gt; 1 ) {
            jobs.push( connect(opts[0], opts[1]) );
        } else {
            console.log(line);
        }
    });

    //wait에는 Fiber 객체가 아니라 Future 객체가 필요하다.
    wait(jobs);

    var etime=new Date().getTime();

    console.log( "elapsed(ms) " + (etime - stime)/1000 );
}).run();
</code></pre>

<p><a href="/articles/2012/by-example-continuation-passing-style-in-javascript.html">CPS</a>이나 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>나 성능상에 차이날 이유가 없다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport-fiber.js port_scan 
18.18.18.18
127.0.0.1 21
127.0.0.1 22
168.126.63.1 18
18.18.18.18 18
elapsed(ms) 21.093
</code></pre>

<p>gevent와 같은 구현체가 등장하면 쓸만 할지도 모르겠지만 node에서 Coroutine은 괜한 욕심일지도 모르겠다. 그래도 node-fiber를 좀 더 쉽게 사용할 수 있도록 만들려는 시도들이 있다. <a href="https://github.com/lm1/node-fiberize">fiberize</a>, <a href="https://github.com/lm1/node-fibers-promise">fibers-promise</a>, <a href="https://github.com/0ctave/node-sync">node-sync</a>를 참고하면 node-fiber를 사용하는데 도움이 될 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: node-fibers ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-fibers.html" />
    <updated>2012-06-09T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-fibers.html</id>
    <content type="html">
<![CDATA[
<p>JavaScript는 <a href="/articles/2012/coroutine.html">Coroutine</a>을 지원하지 않기 때문에 외부 모듈이 필요하다. 이 글에서는 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>로 node에서 Coroutine을 어떻게 응용해야 할지 알아본다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-fibers/puton-fiber.jpg" alt="fiberware" title="" /></p>

<p>(from <a href='http://www.fiberbaya.blogspot.kr/'>http://www.fiberbaya.blogspot.kr/</a>)</p>

<h2>node-fibers</h2>

<p>nodejs에 포함돼지도 않았고 안정성도 검증돼지 않았지만 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>를 사용하면 Coroutine 뿐만아니라 JavaScript에는 없는 sleep()이라든지 Generator라든지를 만들어 쓸 수 있다.</p>

<p>공식 페이지에 소개된 sleep()을 구현하는 코드를 보자.</p>

<pre><code>var Fiber = require('fibers');

function sleep(ms) {
    var fiber = Fiber.current;
    setTimeout(function() {
        fiber.run(); //ms후에 다시 깨운다.
    }, ms);
    Fiber.yield(); //여기서 멈추고
}

Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
console.log('back in main');
</code></pre>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>는 강력한 도구지만 실제 힘을 발휘하려면 gevent같은 게 필요하다. 기존 API를 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>을 적용해서 다시 구현할 수는 없다.</p>

<h3>멍키 패칭하고 싶다.</h3>

<p>Python에서는 gevent를 사용하면 IO api와 thread api를 모두 멍키 패칭해주므로 투명하게 Coroutine으로 코드의 가독성을 높일 수 있었다. 하지만, node에서는 쉽지 않다. JavaScript는 플랫폼 전반에 CPS 스타일이 뼛속까지 녹아 있어서 멍키 패칭할 동기 API가 부족하다. 예를 들어, 파일 IO에는(fs 모듈) <code>xxxSync</code> 메소드가 갖춰져 있지만, 소켓 IO에는(net 모듈) 없다.</p>

<p>다시 말해서 gevent 방식이 더 낫다고 생각하지만:</p>

<p>1) 멍키 패칭할 <code>xxxSync</code> 메소드가 필요하고<br />2) 멍키 패칭을 구현한 모듈도 필요하고<br />3) 그러려면 node-fiber가 정식으로 node에 포함되든 JavaScript 표준에 Coroutine이 도입되든 안정성과 지원도 필요하고<br />4) 주렁주렁...궁시렁궁시렁...</p>

<p>gevent의 아이디어를 그대로 node에서 사용할 수는 없다.</p>

<p>멍키 패칭이든 뭐든 기존 API를 Coroutine에서 사용할 수 있도록 해주는 도우미가 필요한데, <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에는 Future라는 게 있다. Future는 Node의 비동기 API를 감싸서(wrap) Cotoutine을 사용할 수 있게 해준다.</p>

<h3>ls.js</h3>

<p>다음 예제는 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에서 Future를 설명하는데 보여주는 것이다. fs.readdir과 fs.stat를 감싸서 순차적으로 사용하는 것을 볼 수 있다:</p>

<pre><code>var Future = require('fibers/future'), wait = Future.wait;
var fs = require('fs');

// This wraps existing functions assuming the last argument of the passed
// function is a callback. The new functions created immediately return a
// future and the future will resolve when the callback is called (which
// happens behind the scenes).
var readdir = Future.wrap(fs.readdir);
var stat = Future.wrap(fs.stat);

Fiber(function() {
    // Get a list of files in the directory
    var fileNames = readdir('.').wait();
    console.log('Found '+ fileNames.length+ ' files');

    // Stat each file
    var stats = [];
    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        stats.push(stat(fileNames[ii]));
    }
    wait(stats);

    // Print file size
    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        console.log(fileNames[ii]+ ': '+ stats[ii].get().size);
    }
}).run();
</code></pre>

<p>이 코드를 CPS 스타일의 코드로 바꾸면 다음과 같다:</p>

<pre><code>var fs = require('fs');

fs.readdir('.', function(err, fileNames){
    console.log('Found '+ fileNames.length+ ' files');

    // Stat each file
    fileNames.forEach(function(fileName){
        fs.stat( fileName, function(err, stat){
            console.log( fileName + ': '+ stat.size);
        });
    });
});
</code></pre>

<p>이 예제에서 알 수 있듯이 node에서는 CPS 스타일을 사용하는 게 더 낫다. 언어에서 <a href="/articles/2012/coroutine.html">Coroutine</a>을 정식 지원하는 것도 아니고 API도 준비돼 있지 않다. 환경이 준비됐다고 가정하고 스케쥴링을 목적으로 하는 것이라면 Coroutine이 더 낫다고 볼 수 있지만 적어도 아직은 node에서 CPS가 더 나을지도...</p>

<p>아무튼 <code>for</code>문을 <code>forEach</code>로 바꿀 수밖에 없다. 예를 들어 다음과 같은 코드는 ii 값이 변하기 때문에 동작하지 않는다:</p>

<pre><code>    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        fs.stat( fileName[ii], function(err, stat){
            console.log( fileName[ii] + ': '+ stat.size);
        });
    }
</code></pre>

<p>JavaScript의 가장 큰 문제는 매일매일 단련해야 한다는 것 같다. 하루라도 안 하면 잊어버려서 꼭 다음번에 삽질한다.</p>

<h3>Future</h3>

<p>Future는 Node API 컨벤션이 일정한 것을 이용한다. node API는 <code>api(..., callback(err, ...))</code> 형식으로 돼 있기 때문에 이점을 이용한다. callback()으로 결과가 반환될 때까지 yield()시켰다가 callback()이 호출돼서 api 결과를 알게 되면 다시 resume 시킨다.</p>

<p>이 내용은 다음과 같이 생각하면 된다. 다음과 같은 코드를 추상화시킨 것이 future라고 생각하면 된다:</p>

<pre><code>function future_wrap(){
    fiber = fiber.current;

    api(..., callback(err, data){
        fiber.run();
    });

    Fiber.yield();
}
</code></pre>

<p>그러니까 (직접 구현해보지 않았지만) 자체제작 api를 만든다면 표준 컨벤션을 지켜서 구현해야 Future를 사용할 수 있고 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>도 사용하기 쉽다. 아예 api를 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에 의존하게 하여도 되지만 권하고 싶지 않다.</p>

<p>실제 Future.wrap() 코드를 보면 아예 api를 감싸버린다:</p>

<pre><code>Future.wrap = function(fn, idx) {
    idx = idx === undefined ? fn.length - 1 : idx;
    return function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length &gt; idx) {
            throw new Error('function expects no more than '+ idx+ ' arguments');
        }
        var future = new Future;
        args[idx] = future.resolver();
        fn.apply(this, args);
        return future;
    };
};
</code></pre>

<p>resolver()가 api 콜백인데 다음과 같이 생겼다:</p>

<pre><code>resolver: function() {
    return function(err, val) {
        if (err) {
            this.throw(err);
        } else {
            this.return(val);
        }
    }.bind(this);
}
</code></pre>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>의 future.js 코드는 흥미롭다. 분석해보면 재밌을 거로 생각하지만 공부했던 것을 잊어버려서(게을러서) 나중으로 미뤄야겠다.</p>

<p>지구가 멸망하기 전에 <code>Secrets of the JavaScript Ninja</code>가 출간되는 날이 오면 그때나 다시 공부하고 분석해봐야겠다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ iamport: python ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/iamport-python.html" />
    <updated>2012-06-01T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/iamport-python.html</id>
    <content type="html">
<![CDATA[
<p>포트가 열렸는지 확인하는 프로그램을 작성했다. 100개쯤되는 포트를 확인해보라고 해서 만들었는데, 이 참에 gevent를 적용해보았다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/iamport/iamport.jpg" alt="iamport" title="" /></p>

<p>(from <a href='http://www.portofamsterdam.com/'>http://www.portofamsterdam.com/</a>)</p>

<p>주 플랫폼이 Java라서 예전엔 이런일을 groovy로 했었는데 python이 훨씬 쉽다.</p>

<h2>iamport</h2>

<p>다음은 포트가 열렸는지 순차적으로 확인하는 프로그램이다.</p>

<pre><code>#!/usr/bin/env python

import socket
import sys
import time
import re

def tryToConnect( argv ):
    ip=argv[0]
    port=int(argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )

    try:
        sock.connect( (ip, port) )
    except:
        print ip, port

    sock.close()

if __name__ == '__main__':

    stime=time.time()

    file = open(sys.argv[1])

    jobs = []

    while True:
        line = file.readline()

        if not line:
            break

        opts = re.split('\s*', line)

        if len(opts) &gt; 2:
            job = tryToConnect( opts )
            jobs.append( job )
        else:
            print opts[0]

    file.close()

    etime=time.time()

    print 'elapsed %f' % (etime - stime)
</code></pre>

<p>테스트할 포트 목록은 다음과 같은 파일을 파라미터로 넘겨주면 된다:</p>

<pre><code>127.0.0.1       22
127.0.0.1       21
168.126.63.1    18
18.18.18.18     18
18.18.18.18
74.125.235.180  80
</code></pre>

<p>그러면 입력 값이 잘못 됐거나 열리지 않는, 아무튼 예외가 발생하는 것만 출력한다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport.py port_scan 
127.0.0.1 22
127.0.0.1 21
168.126.63.1 18
18.18.18.18 18
18.18.18.18
elapsed 42.215497
</code></pre>

<p>100개 정도에 한번 해봤는데 27분 걸렸다.</p>

<h2>Coroutine</h2>

<p><a href="/articles/2012/coroutine.html">Coroutine</a>은 정말 유용하다. Python이 처음이라면 다음과 같은 글을 읽는 것이 도움이 된다.</p>

<ul>
<li><a href="http://blog.dahlia.pe.kr/articles/2009/09/15/python-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EB%B0%98%EB%B3%B5%EC%9E%90%EC%9D%98-%EB%A7%88%EB%B2%95">Python 제너레이터+반복자의 마법</a></li>
<li><a href="http://pyengine.blogspot.com/2011/07/python-coroutine-1.html">파이썬 코루틴 (python coroutine) - 1</a></li>
<li><a href="http://pyengine.blogspot.com/2011/07/python-coroutine-2.html">파이썬 코루틴 (python coroutine) - 2</a></li>
</ul>

<h2>gevent</h2>

<p>gevent를 이해하려면 eventlet을 알아봐야 하고:</p>

<ul>
<li><a href="http://ricanet.com/new/view.php?id=blog/111007">greenlet은 어떻게 구현했을까?</a></li>
<li><a href="http://blog.gevent.org/2010/02/27/why-gevent/">Comparing gevent to eventlet</a></li>
</ul>

<p>gevent의 적용은 너무 쉽다. 사실 세 줄만 바꿔주면 된다:</p>

<ol>
<li>멍키패칭으로 io api를 비동기+코루틴 방식의 구현체로 바꿔주고.</li>
<li>job들을 등록(spawn)하고서</li>
<li>join으로 다 끝나길 기다리면 된다(테스트는 안해봤지만 join이 호출될때 job이 실제로 시작하는 것 같다).</li>
</ol>

<h3>gevent 버전의 iamport</h3>

<p>아무리 내가 python을 잘 모른다지만 너무 간단하다. 눈이 의심스러울 정도로 간단하다.</p>

<pre><code>#!/usr/bin/env python

import socket
import sys
import time
import re
import gevent
import gevent.monkey

def tryToConnect( argv ):
    ip=argv[0]
    port=int(argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )

    try:
        sock.connect( (ip, port) )
    except:
        print ip, port

    sock.close()

if __name__ == '__main__':

    stime=time.time()

    #멍키패칭
    gevent.monkey.patch_all()

    file = open(sys.argv[1])

    jobs = []

    while True:
        line = file.readline()

        if not line:
            break

        opts = re.split('\s*', line)

        if len(opts) &gt; 2:
            #job을 spawn
            job = gevent.spawn(tryToConnect, opts )
            jobs.append( job )
        else:
            print opts[0]

    file.close()

    #spawn한 job이 모두 종료할 때까지 join
    gevent.joinall( jobs )

    etime=time.time()

    print 'elapsed %f' % (etime - stime)
</code></pre>

<p>27분 걸렸던게 27초만에 끝났다. 만세.</p>]]>
    </content>
  </entry>
</feed>
