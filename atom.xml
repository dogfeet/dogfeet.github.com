<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-03-18T14:16:54Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ Bash: 자동완성 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/bash-completion.html" />
    <updated>2012-03-17T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/bash-completion.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 'An introduction to bash completion'(<a href="http://www.debian-administration.org/articles/316">part 1</a>, <a href="http://www.debian-administration.org/articles/317">part 2</a>)을 정리한 것이다. DocPad에 Completion이 있으면 좀 편할 것 같아서 시작했다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/bash-completion/tab-key.jpeg" alt="tab-key" title="" /></p>

<p>Bash Completion은 간단한 메커니즘으로 구현하는 것 같은데 막상 원하는 대로 조작하긴 쉽지 않다.</p>

<h2>Part 1</h2>

<p>Completion 덕에 명령어와 인자를 좀 더 쉽게 사용할 수 있다. 자주 사용하는 명령어에 Completion을 구현하려면 이 글을 읽는 것이 좋다.</p>

<p>보통 셸에서 TAB 키를 누르면 파일 이름, 디렉토리 이름, 실행경로($PATH)에 있는 명령어를 자동으로 완성해준다:</p>

<pre class="prettyprint"><code>ls /bo[TAB]
</code></pre>

<p><code>/bo</code> 다음에 TAB 키를 누르면 <code>/bo</code>가 <code>/boot</code>로 대체된다.</p>

<p><a href="http://packages.debian.org/bash">Debian bash package</a>는 <code>/etc/bash_completion</code>이라는 Completion 파일이 있고 이 파일에는 일반적인 명령어에 대한 Completion이 정의돼 있다. 아직 사용하고 있지 않으면 ". /etc/bash_completion"라고 실행해서 바로 사용하자:</p>

<pre class="prettyprint"><code>skx@lappy:~$ . /etc/bash_completion
skx@lappy:~$ 
</code></pre>

<p>이걸 한 번만 해주면 다양한 명령어에 Completion을 이용할 수 있다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ apt-get upd[TAB]
skx@lappy:~$ apt-get upg[TAB]
</code></pre>

<p>그런데, 어떻게 만들지? 직접 만들고 싶은데. Completion 루틴은 'complete' 같은 bash 내부 명령어 몇 개를 조합해서 만든다. 이 루틴을 만들어 .bash_profile에 넣거나 별도의 파일로 만들어 /etc/bash_completion.d/에 넣을 수 있다.</p>

<p>/etc/bash_completion 파일을 로드하면(sourced) /etc/bash_completion.d 디렉토리에 있는 모든 파일이 같이 로드된다. 편리하다.</p>

<p>개중에는 호스트 이름을 완성해주는 것도 있다. 이 게 유용한 명령어도 있고 아닌 명령어도 있지만 하나 살펴보자.</p>

<p>저자인 <a href="http://www.debian-administration.org/users/Steve">Steve</a>는 <a href="http://www.debian-administration.org/articles/135">VNC로 관리하는 컴퓨터가 몇 대 있다</a>. 보통 "xvncviewer hostname"이라고 실행한다.</p>

<p>다음과 같이 complete 명령을 실행해 주면 위 명령에서 hostname 부분을 Completion할 수 있다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ complete -F _known_hosts xvncviewer
</code></pre>

<p>이 complete 명령을 한번 실행하고 [TAB]을 입력하면 다음과 같이 보여 줄 거다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ xvncviewer s[TAB]
savannah.gnu.org            ssh.tardis.ed.ac.uk
scratchy                    steve.org.uk
security.debian.org         security-master.debian.org
sun
skx@lappy:~$ xvncviewer sc[TAB]
</code></pre>

<p>이 호스트들은 나한테만 이렇게 보인다.</p>

<p>_known_hosts 함수는 /etc/bash_completion에 정의돼 있다. 이런 함수가 있다는 걸 내가 어떻게 알았을까? "compete -p" 명령을 실행하면 현재 사용하고 있는 것을 모두 보여준다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ complete -p
....
complete -F _known_hosts tracepath
complete -F _known_hosts host
...
</code></pre>

<h2>Part 2</h2>

<p>이제 직접 Completion 함수를 작성해 보자.</p>

<p>'part 1'에서 아무 명령에나 hostname을 완성하는 것을 만들어 봤다:</p>

<pre class="prettyprint"><code>complete -F _known_hosts xvncviewer
</code></pre>

<p>이 명령은 xvncviewer의 인자를 Completion할 때 _known_hosts 함수를 사용하라고 알리는 것이다.</p>

<p>이제는 이미 만들어진 함수를 사용하는 것이 아니라 직접 만들어 사용하는 것을 알아보자.</p>

<h3>A Basic Example</h3>

<p>먼저 <code>foo</code>라는 명령어의 인자를 Completion하는 예제를 만들어보자. <code>foo</code>는 다음과 같은 인자를 가진 가짜 명령어다:</p>

<ul>
<li>--help
<ul><li>Shows the help options for foo, and exits.</li></ul></li>
<li>--version
<ul><li>Shows the version of the foo command, and exits.</li></ul></li>
<li>--verbose
<ul><li>Runs foo with extra verbosity</li></ul></li>
</ul>

<p>/etc/bash_comletion을 로드할 때 자동으로 로드되도록 /etc/bash_completeion.d/foo 파일을 만든다. </p>

<p>파일에 다음과 같은 내용을 넣고 저장한다:</p>

<pre class="prettyprint"><code>_foo() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="--help --verbose --version"

    if [[ ${cur} == -* ]] ; then
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
    fi
}
complete -F _foo foo
</code></pre>

<p>그리고 나서 이 파일만 읽어들여 테스트해본다: </p>

<pre class="prettyprint"><code>skx@lappy:~$ . /etc/bash_completion.d/foo
skx@lappy:~$ foo --[TAB]
--help     --verbose  --version  
</code></pre>

<p>한번 해보면 인자가 자동으로 완성되는 것을 볼 수 있다. 그리고 예를 들어, "foo --h[TAB]"라고 입력하면 '--help' 옵션을 자동으로 완성해준다</p>

<p>이제 실제로 동작하는 것을 만들어 봤고 어떻게 동작하는 것인지 뜯어보자!</p>

<h3>How Completion Works</h3>

<p>Completion에 사용할 함수를 간단하게 구현해봤다.</p>

<p>이 함수는 cur, prev, opts 옵션을 정의하면서 시작한다. cur는 '현재 입력된 단어(word)'에 사용하고, prev는 '이전에 입력된 단어'에, opts는 Completion할 옵션에 사용한다.</p>

<p>그리고 실제로 옵션을 Completion하는 것은 compgen이라는 명령어를 통해서다:</p>

<pre class="prettyprint"><code>COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
</code></pre>

<p>compgen 명령의 결과를 $COMPREPLY에 할당한다:</p>

<pre class="prettyprint"><code>compgen -W "${opts}" -- ${cur}
</code></pre>

<p>여기서 변수 대신 실제 값을 넣어보면 이 명령이 실제로 어떻게 동작하는지 이해하기 쉬울 것이다:</p>

<pre class="prettyprint"><code>compgen -W "--help --verbose --version" -- "userinput"
</code></pre>

<p>compgen은 "--help --verbose --version" 중에서 "${cur}"와 일치하는 것을 찾아 리턴한다. 잘 이해가 안되면 바로 셸에서 이 명령을 직접 실행해 보면 알 수 있다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ compgen -W "--help --verbose --version" -- --
--help
--verbose
--version
skx@lappy:~$ compgen -W "--help --verbose --version" -- --h
--help
</code></pre>

<p>"--"라고 입력하면 세 옵션 모두 일치하므로 전부 반환된다. 하지만 "--h"만 입력하면 "--help"만 일치하므로 --help만 반환한다.</p>

<p>그래서 이 결과를 "COMPREPLY" 변수에 할당하면 bash가 입력 중인 부분의 글자를 대체시킨다. bash에서 COMPREPLY는 Completion 루틴에서 결과를 반환하는 방법이라서 특별한 의미가 있는 변수다.</p>

<p><a href="http://www.gnu.org/software/bash/manual/bash.html">the bash reference manual</a>에 있는 COMPREPLY에 대한 설명을 살펴보자:</p>

<h4>COMPREPLY</h4>

<p>Completion 함수가 반환한 결과를 배열 형태로 반환하고 Bash가 이 변수를 읽는다.</p>

<p>그리고 사용자가 입력하는 단어가 무엇인지 COMP_WORDS라는 배열로 알 수 있다. 그리고 현재 단어와 이전 단어가 무엇인지도 알 수 있다.</p>

<h4>COMP_WORDS</h4>

<p>지금 Command line에 있는 각 단어가 담긴 배열이다. 이 변수는 Completion을 만들 때 사용하는 명령어를 통해 호출한 함수에서만 사용할 수 있다.</p>

<h4>COMP_CWORD</h4>

<p>${COMP_WORDS} 배열에서 현 단어를 가리키는 인덱스다. 이것도 Completion 명령어가 호출한 함수에서만 사용할 수 있다.</p>

<h3>A Complex Example</h3>

<p>옵션이 굉장히 복잡한 명령어도 많다. 이런 명령어는 상당히 정교한 작업이 필요하다.</p>

<p>Xen에 있는 xm 명령어의 예를 살펴보자(<a href="http://www.ibm.com/developerworks/kr/library/l-xen/">developerworks의 Xen 소개</a>):</p>

<ul>
<li>xm list
<ul><li>List all running Xen instances</li></ul></li>
<li>xm create ConfigName
<ul><li>Create a new Xen instances using the configuration file in /etc/xen called ConfigName.</li></ul></li>
<li>xm console Name
<ul><li>Connect to the console of the running machine named "Name".</li></ul></li>
</ul>

<p>예를 들어, "xm operation args" 라는 명령어에서 "args"는 앞에 "operation"이 무엇이냐에 따라 다르다.</p>

<p>먼저 "operation"의 Completion을 구현하는 것은 앞에서 설명했던 것과 방법이 같다. "--" 없이 구현하고 사용하면 된다. 하지만, 후속 인자를 Completion하는 것은 특별한 처리가 필요하다.</p>

<p>Completion할 때 이전 토큰을 알아야 해서 명령어마다 다르게 처리한다. 예를 들자면:</p>

<pre class="prettyprint"><code>_xm() 
{
    local cur prev opts base
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    #
    #  The basic options we'll complete.
    #
    opts="console create list"


    #
    #  Complete the arguments to some of the basic commands.
    #
    case "${prev}" in
        console)
            local running=$(for x in `xm list --long | grep \(name | grep -v Domain-0 | awk '{ print $2 }' | tr -d \)`; do echo ${x} ; done )

            COMPREPLY=( $(compgen -W "${running}" -- ${cur}) )
            return 0
            ;;
        create)
            local names=$(for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//} ; done )

            COMPREPLY=( $(compgen -W "${names}" -- ${cur}) )
            return 0
            ;;
        *)
            ;;
    esac

    COMPREPLY=($(compgen -W "${opts}" -- ${cur}))  
    return 0
}
complete -F _xm xm
</code></pre>

<p>이 코드는 "operation"을 Completion하는 것이고 "create"와 "console"이라는 "operation"에 대해서는 추가적인 코드를 더 했다. <br />사용자가 입력하는 값을 Completion하기 위해 compgen을 사용하는 것까지는 같지만, 상황에 따라 다른 목록을 사용한다.</p>

<p>"console" operation에 사용하는 목록은 다음과 같은 명령으로 만든다:</p>

<pre class="prettyprint"><code>xm list --long | grep \(name | grep -v Domain-0 | awk '{ print $2 }' | tr -d \)
</code></pre>

<p>이 명령은 지금 도는 Xen 시스템의 목록을 반환한다.</p>

<p>"creation" operation에 사용하는 목록은 다음 명령으로 만든다:</p>

<pre class="prettyprint"><code>for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//} ; done
</code></pre>

<p>이 명령은 /etc/xen 디렉토리에 있는 '*.cfg' 파일을 모두 반환한다. 예를 들면 다음과 같다:</p>

<pre class="prettyprint"><code>skx@lappy:~$ for x in `ls -1 /etc/xen/*.cfg`; do echo ${x/\/etc\/xen\//}; done
etch.cfg
root.cfg
sarge.cfg
steve.cfg
x.cfg
skx@lappy:~$ 
</code></pre>

<h3>Other Completion</h3>

<p>지금까지 compgen을 사용해서 사용자가 입력한 값과 일치하는 스트링을 찾았다. 찾을 스트링은 하드 코딩한 목록이거나 명령어가 반환하는 결과에서 찾았다. 디렉토리 이름이나 프로세스 이름등 다른 것에서 찾을 수도 있다. 자세한 내용은 "man bash"를 실행해서 살펴볼 수 있다.</p>

<p>다음은 파일과 호스트이름을 Completion하는 방법을 설명하는 예제다:</p>

<pre class="prettyprint"><code>#
#  Completion for foo:
#
#  foo file [filename]
#  foo hostname [hostname]
#
_foo() 
{
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"
    opts="file hostname"

    case "${prev}" in
        file)
        COMPREPLY=( $(compgen -f ${cur}) )
            return 0
            ;;
        hostname)
        COMPREPLY=( $(compgen -A hostname ${cur}) )
            return 0
            ;;
        *)
        ;;
    esac

    COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
}
complete -F _foo foo
</code></pre>

<p>이 예제를 활용하면 직접 Completion 함수를 만들 수 있다. 사실 Completion 함수를 만드는데 시간이 많이 들고 나머지는 매우 간단하다.</p>

<p><a href="http://www.debian-administration.org/users/Steve">Steve</a>가 작성한 <a href="http://www.cvsrepository.org/cgi-bin/trac/xen-tools/dir?d=xen-tools/misc">xm Completion 코드</a>를 읽어 볼 수 있다.</p>

<p>@pismute가 만든 <a href="https://github.com/dogfeet/docpad/blob/dogfeet/contrib/docpad-completion.bash">docpad-completion.bash</a>도 읽어 볼 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ SMACSS:The Icon Module ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/smacss-icon-module.html" />
    <updated>2012-03-07T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/smacss-icon-module.html</id>
    <content type="html">
<![CDATA[
<p>이글은 <a href="https://smacss.com/book/icon-module">The Icon Module</a>을 정리한 것이다. <a href="https://smacss.com/">SMACSS</a>를 읽고 SMACSS의 철학이 실제로 어떻게 적용되는지 알아보기에 좋다. 이글은 'CSS Sprite' 기법을 사용하는 엉성한 Icon Module을 SMACSS의 방법으로 단단한 Icon Module로 리팩토링하는 것을 보여준다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/smacss/smacss.png" alt="smacss" title="" /></p>

<p>이 글은 무료로 공개돼 있지 않다.</p>

<h2>SMACSS</h2>

<p><a href="https://smacss.com/">SMACSS</a>는 좋은 책이다. CSS '관리'에 초점을 맞추고 이렇게 일목요연하게 정리된 자료는 일찍이 보지 못했다. 이 글을 읽고 도움이 됐다면 <a href="https://smacss.com/">SMACSS</a>를 꼭 사길 바란다. $30 짜리 workshop 계정을 사면 저자인 <a href="http://snook.ca/">Jonathan Snook</a>가 지속적으로 업데이트하는 유로 컨텐츠를 계속 이용할 수 있다.</p>

<h2>The Icon Module</h2>

<p>Asset(Image)을 한 파일로 모으면 HTTP 요청 수도 줄고 이미 모든 Asset을 내려받았기 때문에 나중에 필요할 때 바로 사용할 수 있다. 이것을 <code>CSS Sprite</code>라고 부른다.</p>

<p>다음 그림을 보면 이 말이 무슨 뜻인지 알 수 있다:</p>

<p><img src="/articles/2012/smacss/icon-menu.png" alt="icon-menu" title="" /></p>

<p>Menu HTML:</p>

<pre class="prettyprint"><code>&lt;ul class="menu"&gt;
    &lt;li class="menu-inbox"&gt;Inbox&lt;/li&gt;
    &lt;li class="menu-drafts"&gt;Drafts&lt;/li&gt;
&lt;/ul&gt;
</code></pre>

<p>Menu CSS:</p>

<pre class="prettyprint"><code>.menu li {
    background: url(/img/sprite.png) no-repeat 0 0;
    padding-left: 20px;
}

.menu .menu-inbox {
    background-position: 0 -20px;
}

.menu .menu-drafts {
    background-position: 0 -40px;
}
</code></pre>

<p>모든 Icon은 Sprite 파일 하나에 다 들어 있고 아이템마다 필요한 Icon이 있는 위치를 보여준다.</p>

<p>이걸로도 되긴 되지만 좀 더 작업을 다듬을 수 있다:</p>

<ul>
<li>list 아이템이라는 특정 DOM에만 사용할 수 있다.</li>
<li>모듈마다 Sprite를 항상 다시 만들어야 한다.</li>
<li>위치가 취약하다: 폰트 크기를 늘리면 다른 부분이 살짝 보일 수 있다.</li>
<li>x가 항상 0이기 때문에 수평적으로 처리하기 까다롭다.</li>
</ul>

<p>이 이슈만 해결되면 소위 Icon Module이라 칭할 수 있다.</p>

<p>Icon Module을 사용하도록 HTML을 바꾼다:</p>

<pre class="prettyprint"><code>&lt;li&gt;&lt;i class="ico ico-16 ico-inbox"&gt;&lt;/i&gt; Inbox&lt;/li&gt;
</code></pre>

<p><code>&lt;i&gt;</code> 태그는 간단하고 시맨틱과는 거리가 먼 태그다. Icon은 다른 텍스트를 부연 설명하는 거니까 시멘틱이 없는 태그라고 볼 수 있다. Icon이 혼자 쓰일 때는 꼭 title 속성을 넣어줘서 Screen Reader나 tooltip에서 읽을 수 있도록 해주는 것이 좋다. <code>&lt;i&gt;</code> 태그가 싫다면 <code>&lt;span&gt;</code> 태그가 적당하다.</p>

<p><code>&lt;i&gt;</code>는 HTML 속 어디에 넣어도 되니까 HTML 구조의 의존성은 사라졌다고 볼 수 있다.</p>

<p>그리고 "ico ico-16 ico-inbox" 클래스는 각각 역할이 다르다. 게다가 <code>&lt;img&gt;</code> 태그와 잘 섞어 사용할 수 있다.</p>

<p>Icon Module CSS:</p>

<pre class="prettyprint"><code>.ico {
    display: inline-block;
    background: url(/img/sprite.png) no-repeat;
    line-height: 0;
    vertical-align: bottom;
}

.ico-16 {
    height: 16px;
    width: 16px;
}

.ico-inbox {
    background-position: 20px 20px;
}

.ico-drafts {
    background-position: 20px 40px;
}
</code></pre>

<p><code>ico</code> 클래스는 모듈의 기본적인 토대를 다지는 클래스다. <code>&lt;img&gt;</code>처럼 inline-block 엘리멘트로 만들고 <code>vertical-align</code>으로 Icon이 텍스트와 잘 어우러지도록 해준다. IE는 <code>inline-block</code>을 <code>block</code> 엘리먼트로 취급하기 때문에 IE에서는 <code>{ zoom:1; display:inline; }</code>로 해야 한다.</p>

<p><code>ico-16</code>은 크기 정해주기 위함이다. ico 클래스에 같이 넣어줘도 되지만 Icon마다 크기가 다를 수도 있어서 이렇게 하는 거다.</p>

<p><code>icon-inbox</code>는 Sprite 이미지에서의 Inbox용 Icon의 위치를 정의하는 것이다.</p>

<p>촘촘히 우겨넣은 이미지:</p>

<p><img src="/articles/2012/smacss/icon-menu2.png" alt="icon-menu2" title="" /></p>

<p>잘 우겨넣으면 압축 효율이 좋아진다. 그리고 파일 크기도 더 작아지므로 사이트 성능도 향상된다. 아직 <a href="http://www.smushit.com/ysmush.it/">Smush.it</a>이나 <a href="http://imageoptim.pornel.net/">ImageOptim</a>을 사용해보지 않았으면 한번 사용해보는 것이 좋다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: Remote Tracking Branch vs Tracking Branch ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking.html" />
    <updated>2012-03-02T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking.html</id>
    <content type="html">
<![CDATA[
<p>Tracking 브랜치와 Remote Tracking 브랜치는 조금 애매하다. <code>Tracking 브랜치</code> 개념은 잘 이용하지 않기 때문에 돌아서면 잊어버린다. 그래서 정리했다. 구분하고 있지 않아도 Git을 사용하는데 불편할 거라고는 생각하지 않지만, 그래도 궁금하다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-tracking-vs-remote-tracking/sensei.jpeg" alt="stalker" title="" /></p>

<p>(절망선생)</p>

<h2>Remote Tracking 브랜치</h2>

<p>Remote Tracking 브랜치는 <code>origin/master</code>와 같은 브랜치를 말한다. 이 브랜치는 origin 저장소에 있는 master 브랜치가 가리키는 커밋을 그대로 가리키는 브랜치이다. 리모트 저장소의 브랜치를 Fetch해 오면 이 브랜치가 업데이트된다.</p>

<p>Remote Tracking 브랜치는 다음과 같은 특징이 있다.</p>

<ul>
<li>이 브랜치는 사용자가 임의로 수정할 수 없다.</li>
<li><code>git fetch</code>, <code>git pull</code> 명령으로만 업데이트할 수 있다.</li>
</ul>

<h2>Tracking 브랜치</h2>

<p>Tracking 브랜치는 Remote Tracking 브랜치(이하 리모트 브랜치)보다 복잡하지만 그렇다고 어려운 것도 아니다.</p>

<p>Tracking 브랜치는 로컬 브랜치이다. 로컬 브랜치 중에서 리모트 브랜치를 Tracking하는 브랜치다.</p>

<p>Tracking 특징 다음과 같다:</p>

<ul>
<li>이 브랜치는 사용자가 임의로 수정할 수 있다.</li>
<li><code>git fetch</code>로 정보가 업데이트되지 않는다. <code>git fetch</code>는 단지 리모트 저장소의 브랜치를 Tracking하는 Remote Tracking 브랜치만 만든다.</li>
</ul>

<p>Tracking 브랜치는 도우미 같은 것으로 생각하면 된다. 몰라도 크게 불편하지 않다.</p>

<h3>Tracking 브랜치 확인</h3>

<p><code>git clone</code> 명령은 리모트 저장소를 Fetch하고 나서 master 브랜치를 만들고 Checkout 해준다. 이때 master 브랜치를 origin/master 브랜치를 Tracking하도록 만든다.</p>

<p><code>git clone</code> 명령으로 저장소를 만들고 <code>git config -l</code> 명령을 실행하면 다음과 같은 설정이 들어가 있다:</p>

<pre class="prettyprint"><code>branch.master.remote=origin
branch.master.merge=refs/heads/master
</code></pre>

<h3>Tracking 브랜치 만들기</h3>

<p>Tracking 브랜치는 설정에 이런 정보를 가지고 있다. Tracking 브랜치는 만드는 게 간단하다. 리모트 브랜치에서 브랜치를 만들면 된다.</p>

<pre class="prettyprint"><code>git br tracking origin/master
git co -b tracking origin/master
</code></pre>

<p>하지만, 로컬 브랜치에서 만들면 Tracking 브랜치가 되지 않는다:</p>

<pre class="prettyprint"><code>git br tracking master
git co -b tracking master
</code></pre>

<p>이미 만든 브랜치를 Tracking 브랜치로 만들 수도 있다:</p>

<pre class="prettyprint"><code>git branch --set-upstream master origin/master
</code></pre>

<h3>쓰임새</h3>

<p>Tracking 브랜치 정보는 로컬 브랜치와 리모트 브랜치 사이의 연결 정보이고 설정에 저장된다. Git은 이 정보를 이용해서 몇 가지 정보를 제공한다.</p>

<h4>git branch -v</h4>

<p>Tracking 브랜치의 경우 리모트 브랜치와 거리가 얼마나 되는지(다른 커밋 개수를) 보여준다:</p>

<pre class="prettyprint"><code>$ git branch -v
feature/kitchen e054c7e [ahead 1, behind 1] Add sink unit
* ship            2d45d4c Add test
</code></pre>

<p><code>[ahead 1]</code>은 feature/kitchen은 origin/feature/kitchen에 없는 커밋이 하나 있다는 것이고 [behind 1]은 feature/kitchen은 origin/feature/kitchen에 있는 커밋 하나가 없다는 것이다.</p>

<h4>git checkout</h4>

<p><code>git checkout</code>도 브랜치가 Tracking 브랜치이면 얼마나 다른지 보여준다.</p>

<pre class="prettyprint"><code>$ git checkout feature/kitchen 
Switched to branch 'feature/kitchen'
Your branch and 'origin/ship' have diverged,
and have 1 and 1 different commit(s) each, respectively.
</code></pre>

<h4>git pull</h4>

<p>Tracking 브랜치를 Checkout한 상태에서 <code>git pull</code> 명령을 실행하면 현재 Checkout과 연결된 리모트 저장소와 브랜치를 설정에서 찾아서 Fetch하고 현 브랜치에 Merge한다.</p>

<p>Tracking 브랜치가 아니면 <code>git pull</code>을 할 수 없다. 그러니까 <code>git pull</code>을 하려면 Tracking 브랜치를 Checkout하고 있어야 한다.</p>

<h4>git push</h4>

<p><code>git push</code>라고 실행하면 Checkout한 브랜치와 상관없이 Tracking 브랜치를 모두 Push한다. <code>git push origin master</code>는 Tracking 브랜치와 상관없이 master 브랜치를 origin/master로 Push한다.</p>

<h2>끝으로...</h2>

<p>자동으로 Merge하는 방식은 아름다운 히스토리를 해칠 수 있다. 히스토리는 가능한 평평하게 펴줘야 하고 여러 커밋을 묶어서 관리할 필요가 있을 때만 Merge 커밋을 히스토리에 남기는 것이 좋다.</p>

<p>물론 <code>git pull</code> 명령도 --rebase, --ff, --no-ff, --ff-only와 같은 옵션이 있고 의도대로 Merge하지 못해도 복구할 수 있지만, Fetch하고 확인하고서 Merge하는 것이 아직 마음이 더 편하다.</p>

<p><code>git pull</code> 명령은 어떨 때 유용한 걸까?</p>

<p>저장소와 모든 브랜치를 동기화하는 기능이 필요하긴 하다. 복잡하게 Tracking 브랜치에 따른 것이 아니라 걍 이름으로 했으면 좋겠는데..</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Login Popup & Captive Network ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/login-popup-captive-network.html" />
    <updated>2012-02-26T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/login-popup-captive-network.html</id>
    <content type="html">
<![CDATA[
<p>스마트폰이나 노트북을 항상 들고다니는 사람이 늘어남에 따라 모바일AP(즉, 핫스팟)을 이용하는 사람도 많이 늘어났다. 아직 회원가입이나 인증하지 않은 접속장치가 핫스팟에 접속하고 인터넷을 하면 핫스팟 제공자의 안내페이지나 로그인 페이지가 뜬다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/captive-network/firstwifi.jpg" alt="firstwifi" title="" /></p>

<h2>Captive Network &amp; Problem</h2>

<p>위의 화면은 한국에 가장 많이 사용되는 핫스팟 서비스인 ollehWifi(구, 네스팟)에 접속한 화면이다. 수 많은 호텔이나 큰 규모의 건물 혹은 장소들에서 위와 같은 핫스팟 사용 안내 페이지 혹은 인증 페이지를 볼 수 있다. 이러한 페이지를 Captive Portal이라고 한다.</p>

<p>물론 위에서 ollehWifi 서비스에 가입을 했고 해당 장치가 적절히 인증을 받았다면 위와 같은 화면이 뜨지 않고 바로 원하는 사이트로 이동한다. 인터넷에는 연결했지만, 사용자가 원하는 사이트가 아니라 다른 사이트가 나온다는 점에서 작은 문제가 생긴다.</p>

<p>Wifi를 통해 네트워크에 접속은 되었지만 모바일 어플리케이션이나 웹브라우저가 인터넷에 데이터를 요청하면 실제로 받는 데이터는 원하는 데이터가 아닌 Captive Network의 안내페이지의 데이터를 받아오게 된다. 예를 들어, Captive 네트워크에 스마트폰이 Wifi로 접속해 있다면 http 프로토콜로 JSON 데이터를 요청하는 어플리케이션에서는 html로 된 Captive Portal의 페이지 정보를 받게 될 가능성이 높다. 이러한 데이터 에러를 제대로 처리하지 못하면 어플리케이션에 심각한 문제가 발생할수도 있다.</p>

<h2>Captive Network Detection</h2>

<p>앞서 살펴본 ollehWifi 인증 화면 iOS에 설치된 Captive Network 에 대한 Portal 화면이다. 이 화면은 브라우저를 띄우지 않아도 Captive Network에 접속하게 되면 OS가 자동으로 띄워준다. OS는 이러한 환경을 어떻게 찾아낼 수 있는것일까? </p>

<p><img src="/articles/2012/captive-network/panera-captive.png" alt="panera-captive" title="" /><br /><sup><a href='http://www.docstechnotes.com/2011/07/os-x-lion-learns-wi-fi-login-trick-from.html'>http://www.docstechnotes.com/2011/07/os-x-lion-learns-wi-fi-login-trick-from.html</a></sup></p>

<p>모바일뿐만 아니라 요즘은 데스크톱 OS에서도 적용되어 있다. iOS의 경우 3.0부터, Mac의 경우 Lion부터, Win의 경우 Win7부터 적용된 것 같다. Lion의 경우 브라우저 말고 이런 팝업창에서 입력한 Captive Network에 대한 사용자ID와 패스워드를 OS 차원에서 저장해주기도 한다.</p>

<p><img src="/articles/2012/captive-network/mac-captive.png" alt="mac-captive" title="" /><br /><sup><a href='http://www.apple.com/macosx/whats-new/features.html#networking'>http://www.apple.com/macosx/whats-new/features.html#networking</a></sup></p>

<p>Captive Network인지를 확인하기 위해 Lion의 경우 Captive Service가 항상 동작하고 있으며 수시로 네트워크 상황을 확인한다. Captive Network인지 확인하기 위해서 다음과 같은 URL의 데이터를 불러와본다.</p>

<pre class="prettyprint"><code>$ curl <a href='http://www.apple.com/library/test/success.html'>http://www.apple.com/library/test/success.html</a>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"&gt;
&lt;HTML&gt;
&lt;HEAD&gt;
    &lt;TITLE&gt;Success&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
Success
&lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

<p><code><a href='http://www.apple.com/library/test/success.html'>http://www.apple.com/library/test/success.html</a></code>의 데이터를 불러왔을 때 진짜로 원하는 데이터가 들어있는지 확인하는 <a href="http://erratasec.blogspot.com/2010/09/apples-secret-wispr-request.html">방식</a>이다. 간단하다. Windows또한 비슷한 방식을 사용하며 <a href="http://blog.superuser.com/2011/05/16/windows-7-network-awareness/">NCSI:Network Connectivity Status Indicator</a>라고 부른다.</p>

<h2>적용 및 참고</h2>

<p>어플리케이션이 네트워크를 통해 데이터를 불러와서 사용할 때 확인해야할 것으로 다음과 같은 것이 있다.</p>

<ul>
<li>장치가 네트워크를 사용할 수 있는지</li>
<li>네트워크를 통해 데이터를 불러올 수 있는지</li>
<li>불러온 데이터가 원하는 형식인지</li>
</ul>

<p>Captive Network의 경우 위에서 확인할 사항 중 세 번째 사항에 해당할 것이다. Captive Network에 대하여 알아보려면 다음과 같은 사이트를 더 참고해 볼 수 있다.</p>

<ul>
<li><a href="http://erratasec.blogspot.com/2010/09/apples-secret-wispr-request.html">Apple's secret "wispr" request</a></li>
<li><a href="http://www.mactalk.com.au/31/66812-iphone-3-0-wireless-captive-portal-support.html">iOS 3.0에서 Captive Network 찾기</a></li>
<li><a href="http://tools.ietf.org/html/draft-nottingham-http-portal-02">Web-based 인증을 위한 표준 제안</a></li>
<li><a href="http://blog.superuser.com/2011/05/16/windows-7-network-awareness/">Windows 7의 NCSI(Network Connectivity Status Indicator)</a></li>
</ul>

<h2>사족</h2>

<p>Captive Network에서 인증을 하지 않으면 원하는 사이트에 접근할 수 없고 접속할 수 있는 포트 또한 제한된다. 인증을 거쳐야만 제대로 사용할 수 있다. 하지만 보통 인증을 위하여 DNS 프로토콜 53번 포트는 열려있는 경우가 있으므로 이를 잘 활용해(SSH 터널링, Proxy) 볼 수도 있을 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ node: npm-tricks ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/npm-tricks.html" />
    <updated>2012-02-24T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/npm-tricks.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 Guillermo Rauch의 <a href="http://www.devthought.com/2012/02/17/npm-tricks/">NPM tricks</a>을 번역한 것이다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/npm/npm.png" alt="npm" title="" /></p>

<p>나는 매일매일 NPM을 사용한다. 왠지 사람들이 잘 모를 것 같아서 쓸만한 NPM 팁을 정리했다.</p>

<h2>Dev dependencies</h2>

<p>테스트 프레임워크같이 개발할 때만 필요한 '개발용' 모듈은 <code>devDependencies</code>에 넣는다:</p>

<pre class="prettyprint"><code>"devDependencies": {
    "module": "0.1.0"
}
</code></pre>

<h2>Introspecting package.json</h2>

<p>Node 0.6부터는 <code>require()</code>로 JSON 파일을 자동으로 읽어 준다. 그래서 쉽게 모듈의 package.json 파일을 이용할 수 있다:</p>

<pre class="prettyprint"><code>// considering the module lives in lib/module.js:
exports.version = require('../package').version;
</code></pre>

<p>특정 모듈의 package.json을 읽어 오려면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>require('my-module/package').name
</code></pre>

<h2>Linking</h2>

<p>동시에 모듈을 여러 개 개발해야 할 때에는 보통 모듈들이 서로 의존하게 된다. 문제가 없는 모듈만 NPM에 Publish하기 때문에 이 때에는 다른 방법이 필요하다.</p>

<p>이때 <code>npm link</code>로 NPM에 올리지 않고도 의존성을 해결할 수 있다. 의존하는 모듈에서 <code>npm link &lt;package&gt;</code>를 실행하면 <code>global</code>에 있는 모듈을 끌어다 놓는다(link). 예를 들어, <code>moduleB</code>가 아직 개발 중인 <code>moduleA</code>에 의존하는 상황을 살펴보자:</p>

<p>You can leverage <code>npm link</code> to generate a global reference to a module, and then run <code>npm link &lt;package&gt;</code> to install it in other modules. Consider the following example, in which <code>moduleB</code> depends on the version of <code>moduleA</code> you’re currently developing, and <code>moduleB</code> specifies <code>"moduleA"</code> as a dependency in its <code>package.json</code></p>

<pre class="prettyprint"><code>$ cd moduleA/
$ npm link
$ cd ../moduleB

# moduleB의 package.json에는 
# 아직 publish하지 않은 버전의 moduleA가 필요하다고 적혀 있기 때문에
# 'npm install'은 실패한다.
$ npm install

# global에 있는 moduleA를 local에 설치한다.
$ npm link moduleA

# moduleA는 이미 설치했으니까 'npm install'이 무시한다:
$ npm install
</code></pre>

<h2>Production flags</h2>

<p><code>npm install</code>할 때 <code>--production</code> 옵션을 주지 않으면 <code>devDependencies</code>에 있는 모듈을 설치해서 시간을 낭비하게 된다:</p>

<pre class="prettyprint"><code>$ npm install --production
</code></pre>

<p>설치하면서 발생하는 로그도 볼 수 있는데, 필요한 로그를 골라 볼 수 있다:</p>

<pre class="prettyprint"><code>$ npm install --loglevel warn
</code></pre>

<h2>Git dependencies</h2>

<p>NPM에 Publish하는 대신 <code>package.json</code>에 버전 대신 URI를 넣을 수 있다. Private 모듈이든 Public 모듈이든 <code>git://</code>로 시작하는 URI를 명시할 수 있다:</p>

<pre class="prettyprint"><code>"dependencies": {
    "public": "git://github.com/user/repo.git#ref"
    , "private": "git+ssh://<a href='mailto:git@github.com'>git@github.com</a>:user/repo.git#ref"
}
</code></pre>

<p><code>#ref</code>는 생략할 수 있지만 <code>master</code>같은 브랜치, <code>0.0.1</code>같은 태그, SHA 값을(짧은 SHA도 됨) 넣을 수 있다. 태그로 사용하는 것이 좋은데, <code>npm install</code>이 항상 최신 버전을 사용하도록 하는 태그를 사용하는 것이 좋다.</p>

<h2>Local binaries</h2>

<p>가끔은 의존하는 모듈의 <code>bin</code>을 가져다 써야 할 때가 있다. 이것은 테스트를 실행하거나 컴파일을 하려고 <code>Makefile</code> 만드는 것과 비슷하다.</p>

<p>다음과 같이 다른 곳에 설치된 프로그램을 사용하는 것이 아니라:</p>

<pre class="prettyprint"><code>test:
  mocha mytest.js
</code></pre>

<p>숨겨진 <code>node_mdoules/.bin</code> 디렉토리에 있는 local 모듈을 사용한다:</p>

<pre class="prettyprint"><code>test:
  node_modules/.bin/mocha mytest.js
</code></pre>

<p>여기서는 <code>"mocha"</code>를 사용하여 테스트한다. <code>mocha</code>를 <code>package.json</code>의 <code>devDependencies</code>에 넣는다. 그러면 <code>npm install</code>을 실행할 때 모듈이 설치된다.</p>

<p>Makefile을 따로 만들지 않을 거라면 <code>npm run-script</code> 명령어를 사용할 수 있다. <code>package.json</code>의 <code>scripts</code>에 다음과 같이 정의한다:</p>

<pre class="prettyprint"><code>"scripts": {
        "test": "mocha mytest.js"
          , "build": "uglify mycode.js
}
</code></pre>

<p>그러면 다음과 같이 실행할 수 있다:</p>

<pre class="prettyprint"><code>$ npm run-script test
$ npm run-script build
$ npm test # shortcut for `run-script test`
</code></pre>

<p>게다가, 환경변수 <code>$PATH</code>에 <code>./node_modules/.bin/</code>를 추가하면 어디서나 스크립트를 직접 실행할 수 있다!</p>

<h2>Private repositories</h2>

<p>개발 중인 모듈을 Publish하지 않을 때 <code>package.json</code>에 <code>private</code> 설정을 하면 실수로 Publish하는 일을 방지할 수 있다:</p>

<pre class="prettyprint"><code>"private": true
</code></pre>

<p>Private 저장소가 있으면 package.json에 registry로 등록할 수 있다:</p>

<pre class="prettyprint"><code>"publishConfig": { "registry": "<a href='https://yourregistry:1337/'>https://yourregistry:1337/</a>" }
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ 예제로 설명하는 자바스크립트에서의 Continuation-passing style ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html" />
    <updated>2012-02-24T00:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 <a href="http://matt.might.net/articles/by-example-continuation-passing-style/">By example: Continuation-passing style in JavaScript</a>를 번역한 것이다. CPS에 대해 열심히 적어놨는데 간단히 말하자면 함수 호출의 끝에 원래의 context로 돌아가지 않고, 새로이 불릴 함수를 caller가 넘겨주는 프로그래밍 스타일을 말한다.</em></p>

<p><img src="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript/279433682_23ac618518.jpg" alt="recursive" title="" /></p>

<p>(Photo by <a href="http://www.flickr.com/photos/gadl/279433682/">gadl</a>)</p>

<p>컨티뉴에이션-패싱 스타일(CPS)은 1970년대에 프로그래밍 스타일의 하나로 생겨났고, 1980, 1990년대에 고급 프로그래밍 언어 컴파일러의 중간 표현으로써 주목받았다.</p>

<p>이 프로그래밍 스타일은 논 블로킹 시스템(그리고 보통 분산 시스템)에서 다시 조명받기 시작했다.</p>

<p>내가 박사 과정일 때에 CPS는 비밀무기였다. 그래서 난 CPS를 좋아한다. 아마 그 덕분에 난 2년 정도를 아낄 수 있었고, 끝없는 고통에서 벗어날 수 있었다.</p>

<p>이 글은 자바스크립트에서의 논 블로킹 프로그래밍 스타일로서의 CPS와 함수형 언어의 중간 형태로서의 CPS, 이렇게 두 가지 관점에서 CPS를 소개하는 글이다.</p>

<p>주제는 다음과 같다. </p>

<ul>
<li>자바스크립트에서의 CPS</li>
<li>Ajax 프로그래밍을 위한 CPS</li>
<li>(node.js에서) 논 블로킹 프로그래밍을 위한 CPS </li>
<li>분산 프로그래밍을 위한 CPS </li>
<li>CPS를 이용해서 예외처리하는 방법 </li>
<li>미니말 Lisp을 위한 CPS 컨버터 </li>
<li><strike>Lisp에서 call/cc 구현하는 방법</strike><sup>이 섹션은 이해가 모자라 제거했다.</sup></li>
<li>자바스크립트에서 call/cc 구현하는 방법 </li>
</ul>

<p>시작하자.</p>

<h2>'컨티뉴에이션-패싱 스타일'이 뭐야?</h2>

<p>만약 컨티뉴에이션을 지원하는 언어을 사용한다는 것은 프로그래머가 예외와 백트래킹, 스레드, 제네레이터(generator)등의 제어 구조를 추가할 수 있다는 것을 의미한다.</p>

<p>많은 컨티뉴에이션에 대한 설명은 막연하고 불충분하다. 뭔가 정말 도움이 되는 설명이 필요하다. 이 컨티뉴에이션-패싱 스타일이 바로 그런 것들을 해결해줄 것이다.</p>

<p>컨티뉴에이션-패싱 스타일은 코드라는 측면에서 컨티뉴에이션과 같다.</p>

<p>하지만, 다음의 원리만 깨우치면 프로그래머는 컨티뉴에이션-패싱 스타일을 스스로 깨달은 것이나 마찬가지다.</p>

<pre class="prettyprint"><code>어떠한 프로시저도 caller에 리턴(return)하지 않는다.
</code></pre>

<p>아래 힌트는 CPS로 프로그래밍하는 데 도움이 된다:</p>

<pre class="prettyprint"><code>프로시저는 리턴 값으로 호출 가능한 콜백을 받는다.
</code></pre>

<p>프로시저가 caller로 "리턴" 해야 할 때, 프로시저는 return 대신 "현재 컨티뉴에이션(current continuation)" 콜백을 호출한다. (이 콜백은 caller가 넘겨줬다.)</p>

<p>컨티뉴에이션은 퍼스트-클래스 리턴 포인트(first-class return point)이다.</p>

<h3>예제: 항등 함수</h3>

<p>항등 함수가 하나 있다:</p>

<pre class="prettyprint"><code>function id(x) {
    return x ;
}
</code></pre>

<p>이 것을 CPS로 하면 다음과 같다:</p>

<pre class="prettyprint"><code>function id(x,cc) {
    cc(x) ;
}
</code></pre>

<p>가끔 현재 컨티뉴에이션 인자를 ret로 명명해서 코드를 좀 더 명확하게 할 수 있다:</p>

<pre class="prettyprint"><code>function id(x,ret) {
    ret(x) ;
}
</code></pre>

<h3>예제: 단순무식한 팩토리얼</h3>

<p>아래는 보통의 단순무식한 팩토리얼이다:</p>

<pre class="prettyprint"><code>function fact(n) {
    if(n == 0)
        return 1 ;
    else
        return n * fact(n-1) ;
}
</code></pre>

<p>그리고 이를 CPS로 작성하면 다음과 같다:</p>

<pre class="prettyprint"><code>function fact(n,ret) {
    if(n == 0)
        ret(1) ;
    else
        fact(n-1,function(t0) { ret(n * t0) }) ;
}
</code></pre>

<p>그리고 이 함수를 실제로 "사용"할 때에는 다음과 같이 콜백을 넘겨준다:</p>

<pre class="prettyprint"><code>fact (5,function(n) {
    console.log(n); // 콘솔에 120이 출력된다.
})
</code></pre>

<h3>예제: Tail-recursive 팩토리얼</h3>

<p>아래는 tail-recursive 팩토리얼의 구현이다.</p>

<pre class="prettyprint"><code>function fact(n) {
    return tail_fact(n,1) ;
}

function tail_fact(n,a) {
    if(n == 0)
        return a ;
    else
        return tail_fact(n-1,n*a) ;
}
</code></pre>

<p>그리고 아래는 CPS.</p>

<pre class="prettyprint"><code>function fact(n,ret) {
    tail_fact(n,1,ret) ;
}

function tail_fact(n,a,ret) {
    if(n == 0)
        ret(a) ;
    else
        tail_fact(n-1,n*a,ret) ;
}
</code></pre>

<h2>CPS와 Ajax</h2>

<p>Ajax는 자바스크립트의 XMLHttpRequest 객체를 이용해 비동기적으로 서버에서 데이터를 가져오는 웹 프로그래밍 기술이다.</p>

<p>(데이터가 꼭 XML일 필요는 없다.)</p>

<p>CPS는 Ajax 프로그래밍을 우아하게 하는 방법을 제공한다.</p>

<p>XMLHttpRequest를 이용하면 블로킹 프로시저인 'fetch(url)'을 작성할 수 있다. 이 프로시저는 url이 가리키는 페이지의 내용을 변수에 담아 문자열로 리턴한다.</p>

<p>이런 방식의 문제는 자바스크립트가 단일 스레드만 지원하는 언어라는 점이다. 자바스크립트가 블럭되면 그동안 브라우저가 멈춰버린다.</p>

<p>그러면 사용자 경험이 망가진다.</p>

<p>더 나은 방식은 프로시저를 'fetch(url, callback)' 형식으로 만드는 것이다. 이 프로시저는 블로킹 되지 않기 때문에, 코드 실행이나 브라우저 렌더링을 막지 않는다. 이 프로시저에는 http 요청이 끝나고 호출되야 할 콜백을 넘겨준다.</p>

<p>이렇게 코딩하는 과정에서 부분적으로 코딩 스타일이 CPS로 자연스레 변한다.</p>

<h3>fetch 구현</h3>

<p>콜백 유무에 따라 non-blocking 모드나 블러킹 모드를 스위칭하며 동작하는 fetch는 어렵지 않게 구현할 수 있다:</p>

<pre class="prettyprint"><code>/*
 fetch는 클라이언트에서 서버로 리퀘스트를
 보낼 때 블로킹될 수도 있고 안될 수도 있다.

 만약 url만 넘겨주면 프로시저는 블로킹되고
 url이 가리키는 페이지의 내용을 리턴한다.

 만약 onSuccess 콜백이 주어지면 
 프로시저는 논 블로킹이 된다. 
 콜백은 페이지의 내용을 
 인자로 받아 호출될 것이다.

 만약 onFail 콜백까지 주어지면
 요청이나 응답이 실패했을 때에 
 onFail이 fatch 프로시저에 의해서 호출된다.
*/

function fetch (url, onSuccess, onFail) {
    // 콜백을 정의했을 때만 비동기로 작동한다.
    var async = onSuccess? true: false;
    // (이 라인의 비효율성에 대해 태클 걸지 
    //  않길 바란다. 이건 중요한 게 아니다.)

    var req ; // XMLHttpRequest 객체.

    // XMLHttpRequest 콜백:
    function rocessReqChange() {
        if(req.readyState == 4) {
            if(req.status == 200) {
                if(onSuccess)
                    onSuccess(req.responseText, url, req);
            } else {
                if(onFail)
                    onFail(url, req);
            }
        }
    }

    // XMLHttpRequest 객체를 만든다:
    if(window.XMLHttpRequest)
        req =new XMLHttpRequest();
    elseif(window.ActiveXObject)
        req =new ActiveXObject("Microsoft.XMLHTTP");

    // 비동기 모드라면 콜백을 세팅한다:
    if(async)
        req.onreadystatechange = processReqChange;

    // 서버로 요청한다.
    req.open("GET", url, async);
    req.send(null);

    // 비동기 모드라면,
    //  요청 객체를 리턴한다; 아니라면
    //  응답을 리턴하다.
    if(async)
        return req ;
    else
        return req.responseText ;
}
</code></pre>

<h3>예제: 데이터 가져오기</h3>

<p>UID의 이름을 가져오는 프로그램이 필요하다고 치고, fetch를 이용해서 두 버전(동기, 비동기)을 다 만들어보자.</p>

<pre class="prettyprint"><code>// 요청이 끝날 때까지 블로킹된다:
var someName = fetch("./1031/name") ;

document.write ("someName: "+ someName +"&lt;br&gt;") ;

// 블로킹되지 않는다:
fetch("./1030/name",function(name) {
    document.getElementById("name").innerHTML = name ;
}) ;
</code></pre>

<p>(<a href="http://matt.might.net/articles/by-example-continuation-passing-style/code/client.html">예제</a>)</p>

<h2>CPS and non-blocking programming</h2>

<p><a href="http://nodejs.org/">node.js</a>는 블로킹 프로시저가 없는 자바스크립트를 위한 고성능, 서버사이드 플랫폼이다. </p>

<p>node.js에서는 보통의 블로킹되는 프로시저(e.g. 네트워크, 파일 I/O)가 전부 콜백을 받고 결과는 콜백을 실행하는 것을 반환한다.</p>

<p>프로그램을 CPS로 변환하는 것으로 node.js 프로그래밍 다운 프로그래밍이 뭔지 살펴보자.</p>

<h3>예제 : 간단한 웹 서버</h3>

<p>node.js 웹 서버는 파일을 읽는 프로시저에 컨티뉴에이션을 넘긴다. select를 이용하는 것보다 CPS를 이용하는 것이 더 간단한 non-blocking IO이다.</p>

<pre class="prettyprint"><code>var sys = require('sys') ;
var http = require('http') ;
var url = require('url') ;
var fs = require('fs') ;

// 웹 서버 루트 경로:
var DocRoot ="./www/";

// 콜백을 넘겨주면서 웹 서버를 만든다:
var httpd = http.createServer(function(req, res) {
    sys.puts(" request: "+ req.url) ;

    // url 파싱:
    var u = url.parse(req.url,true) ;
    var path = u.pathname.split("/") ;

    // 경로에서 .. 를 없앤다.
    var localPath = u.pathname ;
    //  "&lt;dir&gt;/.." =&gt; ""
    var localPath = localPath.replace(/[^/]+\/+[.][.]/g,"") ;
    //  ".." =&gt; "."
    var localPath = DocRoot + 
    localPath.replace(/[.][.]/g,".") ;

    sys.puts(" local path: "+ localPath) ;

    // 요청받은 파일을 읽어서 되돌려 보낸다.
    // Note: readFile은 현재 컨티뉴에이션을 넘겨받는다.
    fs.readFile(localPath,function(err,data) {
        var headers = {} ;

        if(err) {
            headers["Content-Type"] ="text/plain";
            res.writeHead(404, headers);
            res.write("404 File Not Found\n") ;
            res.end() ; 
        } else {
            var mimetype = MIMEType(u.pathname) ;

            // 만약 'content type'을 못 찾으면
            // 클라이언트가 알아서 하도록 놔두자.
            if(mimetype)
                headers["Content-Type"] = mimetype ;

            res.writeHead(200, headers) ;
            res.write(data) ;
            res.end() ;
        }
    }) ;
}) ;

// 확장자와 MIME 타입을 매핑 시킨다:
var MIMETypes = {
    "html" :"text/html",
    "js"   :"text/javascript",
    "css"  :"text/css",
    "txt"  :"text/plain"
} ;

function MIMEType(filename) {
    var parsed = filename.match(/[.](.*)$/) ;
    if(!parsed)
        return false;
    var ext = parsed[1] ;
    return MIMEType[ext] ;
}

// 8000번 포트를 리스닝(listening) 포트로 하여 서버를 시작한다:
httpd.listen(8000) ;
</code></pre>

<h2>분산 컴퓨팅을 위한 CPS</h2>

<p>CPS를 사용하면 로컬과 분산에서 처리하는 것이 더 간단해진다.</p>

<p>조합(combination)을 계산해주는 함수인 choose를 작성해보자. 우선 일반적인 방법:</p>

<pre class="prettyprint"><code>function choose (n,k) {
    return fact(n) /
        (fact(k) * fact(n-k)) ;
}
</code></pre>

<p>이제 이 코드가 로컬 컴퓨터가 아닌 서버에서 동작해야 하면</p>

<p>fact 프로시저가 블로킹되어 서버에서 응답이 오기까지 기다리도록 작성할 수도 있지만, 이 방법은 좋지 않다.</p>

<p>대신 CPS로 choose를 작성해보자:</p>

<pre class="prettyprint"><code>function choose(n,k,ret) {
    fact (n,  function(factn) {
    fact (n-k,function(factnk) {
    fact (k,  function(factk) {
    ret  (factn / (factnk * factk)) }) }) })
}
</code></pre>

<p>이제 비동기적으로 팩토리얼을 계산하는 fact 프로시저 만들기가 쉬워졌다. 아래와 같이 말이다:</p>

<pre class="prettyprint"><code>function fact(n,ret) {
    fetch ("./fact/"+ n,function(res) {
        ret(eval(res))
    }) ;
}
</code></pre>

<h2>CPS로 예외처리하기</h2>

<p>프로그램을 CPS로 작성하면, 언어의 표준 예외처리 매커니즘이 쓸모없어진다. 하지만, CPS로 예외처리를 구현하는 것은 어렵지 않다.</p>

<p>예외처리는 컨티뉴에이션의 특수한 케이스다.</p>

<p>'현재 예외적 컨티뉴에이션(current exceptional continuation)'을 '현재 컨티뉴에이션(current continuation)'과 함께 던지는 것으로 try/catch 구문을 없앨 수 있다.</p>

<p>다음 예제는 Exception을 이용해서 팩토리얼 "total" 버전을 정의한다:</p>

<pre class="prettyprint"><code>function fact (n) {
    if(n &lt; 0)
        throw "n &lt; 0";
    else if(n == 0)
        return 1 ;
    else
        return n * fact(n-1) ;
}

function total_fact (n) {
    try{
        return fact(n) ;
    }catch(ex) {
        return false;
    }
}

document.write("total_fact(10): "+ total_fact(10)) ;
document.write("total_fact(-1): "+ total_fact(-1)) ;
</code></pre>

<p>예외를 처리하는 컨티뉴에이션을 추가해서 throw, try, catch 를 제거할 수 있다:</p>

<pre class="prettyprint"><code>function fact (n,ret,thro) {
    if(n &lt; 0)
        thro ("n &lt; 0");
    else if(n == 0)
        ret(1);
    else
        fact(n-1,
            function(t0) {
                ret(n*t0);
            }, thro);
}

function total_fact (n,ret) {
    fact (n,ret,
        function(ex) {
            ret(false);
        });
}

total_fact(10,function(res) {
    document.write("total_fact(10): "+ res);
});

total_fact(-1,function(res) {
    document.write("total_fact(-1): "+ res);
});
</code></pre>

<h2>컴파일에서 CPS</h2>

<p>지난 30년간 CPS는 함수형 언어 컴파일러에서 사용하는 강력한 중간 표현식이었다.</p>

<p>CPS는 함수의 리턴, 예외, <a href="http://en.wikipedia.org/wiki/Continuation#First-class_continuations">퍼스트-클래스 컨티뉴에이션(first-class continuation)</a>을 제거한다. 함수 호출은 그냥 하나의 점프 명령어로 치환된다.</p>

<p>다시 말해서, CPS는 컴파일러 대신에 많은 것들을 해결해준다. </p>

<h3>람다 계산법을 CPS로 바꾸기</h3>

<p>람다는 보편적인 계산을 할 수 있는 표현식(어플리케이션, 익명함수 변수 레퍼런스)을 가진 Lisp의 축소판이다. </p>

<pre class="prettyprint"><code>exp ::= (expexp)           ; 함수 어플리케이션
    |  (lambda (var) exp)  ; 익명 함수
    |  var                 ; 변수 레퍼런스
</code></pre>

<p>아래의 코드는 이 언어를 CPS로 변환해주는 도구다:</p>

<pre class="prettyprint"><code>(define (cps-convert term cont)
    (match term
        [`(,f ,e)
            ; =&gt;
            (let (($f (gensym 'f))
                    ($e (gensym 'e)))
               (cps-convert f `(lambda (,$f)
                    ,(cps-convert e `(lambda (,$e)
                        (,$f ,$e ,cont))))))]

        [`(lambda (,v) ,e)
            ; =&gt;
             (let (($k (gensym 'k)))
               `(,cont (lambda (,v ,$k)
                    ,(cps-convert e $k))))]

        [(? symbol?)
            ; =&gt;
            `(,cont ,term)]))

(define (cps-convert-program term)
    (cps-convert term '(lambda (ans) ans)))
</code></pre>

<p>관심 있는 사람은, <a href="http://www.brics.dk/~danvy/">올리비에 댄비(Olivier Danvy)</a>가 효과적인 CPS 변환기에 관한 많은 논문을 써냈으니 참고하길 바란다.</p>

<h2>JavaScript에서 call/cc 구현하기</h2>

<p>만약 어떤 자바스크립트 코드를 CPS로 바꾸고 싶다면 call/cc는 간단하게 정의할 수 있다.</p>

<pre class="prettyprint"><code>function callcc (f,cc) { 
    f(function(x,k) { cc(x) },cc)
}
</code></pre>

<h2>더 읽어 볼 것</h2>

<ul>
<li><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596101996">JavaScript: The Definitive Guide</a>, the best book on JavaScript.</li>
<li><a href="http://www.amazon.com/gp/product/0596517742?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596517742">JavaScript: The Good Parts</a>, the only other good JavaScript book.</li>
<li>Andrew Appel's timeless classic <a href="http://www.amazon.com/gp/product/052103311X?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=052103311X">Compiling with Continuations</a>.</li>
<li><a href="http://library.readscheme.org/page1.html">The Lambda Papers</a>.</li>
<li>My post <a href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">on programming with continuations by example</a>.</li>
<li><a href="http://faculty.cs.byu.edu/~jay/home/">Jay McCarthy</a> et al.'s papers on a continuation-based web-server.</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Backbone.js by example - Part 1 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/backbonejs-by-example.html" />
    <updated>2012-02-17T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/backbonejs-by-example.html</id>
    <content type="html">
<![CDATA[
<p><em>이 글은 <a href="http://www.javageneration.com/">Chaker Nakhli</a>의 '<a href="http://www.javageneration.com/?p=839">Backbone.js by example</a>'을 번역한 것이다. Backbone.js를 처음 접하는 사람이 다른 자료를 보기 전에 보면 좋다.</em></p>

<p><a href="http://documentcloud.github.com/backbone/">Backbone.js</a>는 JavaScript MVC 라이브러리다. 클라이언트 코드를 깔끔하고 쉽게 만들고 관리할 수 있도록 도와준다. 나는 Backbone.js가 가볍고(~4.5kb) 내가 애플리케이션 관리하는 방식을 해치지 않아서 좋다. Backbone.js는 심지어 <a href="http://itsnat.sourceforge.net/php/spim/spi_manifesto_en.php">Single Page Interfaces</a>나 JavaScript Heavy 애플리케이션에도 사용할 수 있다. Backbone.js로는 클라이언트 코드를 확장하기 쉽고 관리하기도 쉬운 구조를 만들 수 있다.</p>

<p>나는 Backbone.js를 만난 지 몇 주 밖에 안됐지만, 사랑에 빠졌다. 이 글에서 단계별로 짚어가며 그래픽 편집기를 하나 만들어 볼 거다. 어떤 편집기인지 궁금하면 <a href="http://www.javageneration.com/wp-content/uploads/2012/01/editor.html">Demo</a>를 먼저 보자. 이 편집기의 JavaScript 코드는 100밖에 안된다. 우선 Model과 View에 집중할 거고 서버와 통신하기, 라우팅은 다음 글에서 다루겠다.</p>

<h2>Before we start</h2>

<p>이 그래픽 편집기는 파일을 3개로 구성한다. 파일은 editor.js, editor.css, editor.html 인 데 아직 editor.js, edtior.css는 빈 파일이다. 먼저 editor.html 파일을 보자:</p>

<pre class="prettyprint"><code>&lt;!doctype html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" type="text/css" href="editor.css"&gt;
        &lt;script src="<a href='http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7/jquery.min.js'>http://cdnjs.cloudflare.com/ajax/libs/jquery/1.7/jquery.min.js</a>"&gt;&lt;/script&gt;
        &lt;script src="<a href='http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.2.1/underscore-min.js'>http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.2.1/underscore-min.js</a>"&gt;&lt;/script&gt;
        &lt;script src="<a href='http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.5.3/backbone-min.js'>http://cdnjs.cloudflare.com/ajax/libs/backbone.js/0.5.3/backbone-min.js</a>"&gt;&lt;/script&gt;
        &lt;script src="editor.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id="page" style="width:2000px;height:2000px;"&gt;&lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>나는 <a href="https://www.cloudflare.com/">cloudflare</a>가 제공하는 <a href="http://www.cdnjs.com/">cdnjs</a>를 사용했다. cloudflare에는 Google이나 Microsoft CDN이 제공하지 않는 것도 있다.</p>

<p><a href="http://jsfiddle.net/nakhli/td6Eg/5/">jsfiddle</a>에도 코드를 올려놓았으니 편한 대로 보면 된다. 각 절의 코드를 jsfiddle에 올려놓았다. 그러니 즉시 살펴보고, 테스트하고, Fork해 볼 수 있다.</p>

<p>이제 준비 운동은 끝냈으니 시작하자!</p>

<h2>Models</h2>

<p>간단한 도형을 나타내는 Model인 Shape 클래스를 만든다:</p>

<pre class="prettyprint"><code>var Shape = Backbone.Model.extend({
    defaults: { x:50, y:50, width:150, height:150, color:'black' },
    setTopLeft: function(x,y) {
        this.set({ x:x, y:y });
    },
    setDim: function(w,h) {
        this.set({ width:w, height:h });
    },
});
</code></pre>

<p>Shape 클래스는 Backbone.Model 클래스를 확장해서 만든다. 클래스를 확장하는 extend 메소드에 어떤 Model인지에 대한 정보를 인자로 넘긴다. 이 Model에 대한 설정은 defaults, setTopLeft, setDim 프로퍼티가 있다:</p>

<ul>
<li>defaults는 특별한 프로퍼티다. 이 프로퍼티에 Model의 기본 프로퍼티와 기본 값을 정의한다. 그래서 모든 Shape 인스턴스에는 x, y, width, height, color 프로퍼티가 있고 기본 값도 할당된다. 중요한 건 Backbone.js가 프로퍼티를 감싸준다는(encapsulation) 것이다. 직접 프로퍼티를 접근하기(getting/setting)보다 Backbone Model에서 상속한 get/set 메소드를 사용한다. Encapsulation 덕에 Model 프로퍼티가 수정되는 것을 관리할 수 있다. set 메소드가 호출되면 event가 발생한다. 그래서 이벤트 리스너를 등록하면 Model이 변경되는 것을 관리할 수 있다.</li>
<li>setTopLeft와 setDim은 Helper 메소드로 Backbone의 set 메소드를 호출한다. 이 메소드로 Shape의 크기와 위치를 좀 더 쉽게 설정한다.</li>
</ul>

<p>Model 클래스는 정의했으니 이제, 인스턴스를 만들고 프로퍼티에 이벤트를 바인딩하는 예제를 살펴보자(<a href="http://jsfiddle.net/nakhli/td6Eg/1/">jsfiddle</a>):</p>

<pre class="prettyprint"><code>var shape = new Shape();

shape.bind('change', function() { alert('changed!'); });
shape.bind('change:width', function() { alert('width changed! ' + shape.get('width')); });

shape.set({ width: 170 });
shape.setTopLeft(100, 100);
</code></pre>

<p>3번째 줄은 Model 프로퍼티가 변경될 때 발생하는 change 이벤트를 처리하도록 Listener를 등록하는 것이다. 4번째 줄의 코드는 'width' 프로퍼티만 Listen하는 거다. 6번째 줄에서 width 값을 바꾸면 두 Callback이 모두 실행된다. 하지만, 7번째 줄에서처럼 'setTopLeft' 메소드로 Shape의 위치를 변경하면 'change' 이벤트만 발생한다.</p>

<h2>Binding page elements to model changes</h2>

<p>Model을 정의하고 Change 이벤트 리스너를 등록하는 방법을 살펴봤다. 이제, 이 이벤트를 활용하는 방법을 살펴보자. html 페이지에 div 엘리먼트를 정의한다:</p>

<pre class="prettyprint"><code>&lt;div class='shape' /&gt;
</code></pre>

<p>Model이 바뀌면 엘리먼트도 바뀌게 묶는다(jQuery로 DOM 정보를 바꾼다).</p>

<pre class="prettyprint"><code>shape.bind('change', function() {
    $('.shape').css({ left:       shape.get('x'),
                      top:        shape.get('y'),
                      width:      shape.get('width'),
                      height:     shape.get('height'),
                      background: shape.get('color') });
});
</code></pre>

<p>매우 쉽다! Model을 수정하면 DOM도 바뀐다. Firebug 같은 브라우저 콘솔을 열어서 다음과 같이 실행해 본다:</p>

<pre class="prettyprint"><code>shape.setTopLeft(10, 10);
shape.setDim(500, 500);
</code></pre>

<p>그러면 페이지가 자동으로 업데이트되고 그 Shape 객체의 위치/크기가 새로 바뀐다. 여기서 중요한 것은 DOM을 직접 관리하지 않는다는 것이다. Model이 바뀌면 Model의 Listener가 페이지도 바꾼다. <a href="http://jsfiddle.net/nakhli/td6Eg/1/">jsfiddle</a>에서 한번 실행해 보자.</p>

<p>사용자가 뭔가 입력하는 상황을 살펴보자. 사용자가 입력해서 Model이 수정되면 간접적으로 페이지도 수정된다.</p>

<h2>Basic user input handling</h2>

<p>이 절에서는 사용자가 Shape 객체를 드래그할 수 있게 한다. mousedown, mouseup, mousemove 이벤트를 지켜보다가 Model을 업데이트하는 코드를 살펴보자(<a href="http://jsfiddle.net/nakhli/td6Eg/2/">jsfiddle</a>):</p>

<pre class="prettyprint"><code>var dragging = false;

$('.shape').mousedown(function (e) {
    dragging = true;
    shape.set({ color: 'gray' });
});

$('#page').mouseup(function () {
    dragging = false;
    shape.set({ color: 'black'});
});

$('#page').mousemove(function(e) {
    if(dragging) {
        shape.setTopLeft(e.pageX, e.pageY);
    }
});
</code></pre>

<p>여기서 보면 shape의 div 엘리먼트가 아니라 page 엘리먼트의 mousemove와 mouseup 이벤트를 Listen한다. 마우스가 div 개체의 영역에서 벗어나도 div 객체가 마우스 포인터를 따라다녀야 하기 때문에 그렇게 한다.</p>

<p>사용자 입력을 jQuery로 간단하게 처리한다는 게 포인트이다. 여기에 DOM을 수정하는 코드는 하나도 없다. 단지 이벤트를 지켜보다가 Model을 바꾼다. 그러면 신기하게도 페이지는 업데이트된다.</p>

<p>정리하자. 사용자 입력을 처리하는 코드, Model을 관리하는 코드, Model이 바뀌면 View도 바꾸는 코드를 분리시켰다. 이제 막 우리는 MVC(Model-View-Controller)를 구현했다.</p>

<p>관련된 것끼리 따로 모으는 방법은 좋다. JQuery Callback이 매우 많은 페이지에서 Callback 스파게티로 만들지 않을 수 있다. 하지만, 아직 더 개선할 수 있다. 아직 Controller 코드와 View 코드가 마구 섞여 있는데 View 클래스 정의해서 해결할 수 있다.</p>

<h2>Model Collections</h2>

<p>Backbone Model에는 Collection이라는 Model이 있다. Collection은 Model을 정렬된 집합으로 관리할 수 있게 도와주는 Container다. 이 Collection은 add, remote 이벤트가 있고 이 이벤트를 Listen할 수 있다.</p>

<p>Model 컬렉션을 사용한다. Shape 객체를 담는 Collection인 'Document' Model를 만들자:</p>

<pre class="prettyprint"><code>var Document = Backbone.Collection.extend({ model: Shape });
</code></pre>

<p>Document 객체를 만들고 add, remote 이벤트 리스너를 등록한다:</p>

<pre class="prettyprint"><code>var document = new Document();

document.bind('add', function(model) { alert('added'); });
document.bind('remove', function(model) { alert('removed'); });

document.add(shape); // fires add event
document.remove(shape); // fires remove event
</code></pre>

<h2>Views</h2>

<p>Backbone.js에서 View는 Model(이나 Collection)과 함께 사용한다. View의 역할은 다음과 같다:</p>

<ul>
<li>Model을 DOM 엘리먼트로 렌더링한다. Model의 change 이벤트를 지켜보고 있다가 바뀌면 페이지도 바꾼다.</li>
<li>DOM 엘리먼트의 이벤트를 처리하고 다시 Model을 업데이트한다.</li>
</ul>

<p>MVC 이론과 비교했을 때, Backbone의 View는 View와 Controller의 역할을 둘 다 떠맡는다. Backbone의 View는 사용자 입력(DOM 이벤트)을 처리하고 Model도 업데이트한다. 게다가 Model 이벤트를 Listen하다가 바뀌면 다시 화면을 업데이트한다. 하지만, 실제로 구현할 때 다른 메소드에 구현할 거라서 이 점은 별로 중요하지 않다. </p>

<h3>Shape View</h3>

<p>Shape Model을 사용하는 Shape View 코드를 살펴보자. 이 View는 Shape을 표현하는 Html 엘리먼트와 그 Html 엘리먼트를 감싸는(Decorate) 'control' 엘리먼트를 관리한다. 'control' 엘리먼트는 사용자가 Shape을 드레그하고, Shape의 크기를 바꾸고, Shape을 삭제하고, Shape의 색을 바꿀 수 있게 해준다.</p>

<pre class="prettyprint"><code>var ShapeView = Backbone.View.extend({
    initialize: function() {
        this.model.bind('change', this.updateView, this);
    },
    render: function() {
        $('#page').append(this.el);
        $(this.el)
            .html('&lt;div class="shape"/&gt;'
                  + '&lt;div class="control delete hide"/&gt;'
                  + '&lt;div class="control change-color hide"/&gt;'
                  + '&lt;div class="control resize hide"/&gt;')
            .css({ position: 'absolute', padding: '10px' });
        this.updateView();
        return this;
    },
    updateView: function() {
        $(this.el).css({
            left:       this.model.get('x'),
            top:        this.model.get('y'),
            width:      this.model.get('width') - 10,
            height:     this.model.get('height') - 10 });
        this.$('.shape').css({ background: this.model.get('color') });
    },
    events: {
        'mousemove'               : 'mousemove',
        'mouseup'                 : 'mouseup',
        'mouseenter .shape'       : 'hoveringStart',
        'mouseleave'              : 'hoveringEnd',
        'mousedown .shape'        : 'draggingStart',
        'mousedown .resize'       : 'resizingStart',
        'mousedown .change-color' : 'changeColor',
        'mousedown .delete'       : 'deleting',
    },
    hoveringStart: function () {
        this.$('.control').removeClass('hide');
    },
    hoveringEnd: function () {
        this.$('.control').addClass('hide');
    },
    draggingStart: function (e) {
        this.dragging = true;
        this.initialX = e.pageX - this.model.get('x');
        this.initialY = e.pageY - this.model.get('y');
        return false; // prevents default behavior
    },
    resizingStart: function() {
        this.resizing = true;
        return false; // prevents default behavior
    },
    changeColor: function() {
        this.model.set({ color: prompt('Enter color value', this.model.get('color')) });
    },
    deleting: function() {
        this.remove();
    },
    mouseup: function () {
        this.dragging = this.resizing = false;
    },
    mousemove: function(e) {
        if (this.dragging) {
            this.model.setTopLeft(e.pageX - this.initialX, e.pageY - this.initialY);
        } else if (this.resizing) {
            this.model.setDim(e.pageX - this.model.get('x'), e.pageY - this.model.get('y'));
        }
    }
});
</code></pre>

<p>코드는 좀 길지만 매우 간단하다. 중요한 것만 짚어보자:</p>

<ul>
<li>initialize는 View가 생성될 때 실행되는 함수다. Model의 이벤트 리스너를 등록하려면 여기서 해야 한다. View에서 Model change 이벤트를 등록한다.</li>
<li>render는 View를 초기화하고 나서 실행된다. 여기서 View에 필요한 Html 엘리먼트를 초기화하고 DOM에 추가한다. View의 Html 엘리먼트를 el 프로퍼티에 할당시켜 놓는다. 이 el 프로퍼티는 Backbone View에서 상속받은 거다. 먼저 '#page'에 el을 추가하고 그다음 줄에서 shape과 control 엘리먼트를 추가한다. 그리고 마지막 줄에서 Model을 View에 적용한다.</li>
<li>View에서 events 해시는 매우 중요하다. 이 부분이 이벤트와 리스너를 연결하는 부분이다. <code>{ 'event selector': 'handler' }</code> 형식으로 정의한다. 예를 들어 <code>{ 'mousedown .shape': 'draggingStart' }</code>는 '.shape' 에 mousedown 이벤트가 Fire되면 draggingStart 메소드를 실행시킨다. 이 events 해시는 사용자 입력을 어떻게 처리할지를 정의하는 것인데 이 부분이 Controller 역할에 해당한다.</li>
</ul>

<p>사실 여기에 기술적인 문제가 조금 있다. 'Basic user input handling' 절에서도 말했지만, Shape Div 그 자체가 아니라 부모인 page 엘리먼트의 mousemove와 mouseup 이벤트를 Listen하고 있어야 더 나은 UX를 얻을 수 있다. 현 코드는 사용자가 마우스를 너무 빨리 움직일 때 부드럽지 못하다. 이 코드는 <a href="http://jsfiddle.net/nakhli/td6Eg/4/">jsfiddle</a>에 구현했다.</p>

<h3>Document View</h3>

<p>먼저 만들었던 Document Model를 위한 DocumentView도 만들어야 한다. 그래야 Shape View를 관리할 수 있다:</p>

<pre class="prettyprint"><code>var DocumentView =  Backbone.View.extend({
    id: 'page',
    views: {},
    initialize: function() {
        this.collection.bind('add', this.added, this);
        this.collection.bind('remove', this.removed, this);
    },
    render: function() {
        return this;
    },
    added: function(m) {
        this.views[m.cid] = new ShapeView({
            model: m,
            id:'view_' + m.cid
        }).render();
    },
    removed: function(m) {
        this.views[m.cid].remove();
        delete this.views[m.cid];
    }
});
</code></pre>

<p>id 프로퍼티는 View에 묶인 DOM의 id다. Backbone은 이 값으로 DOM을 찾아 el 프로퍼티를 설정한다. 이미 html 페이지에 있는 엘리먼트를 사용하기 때문에 render 메소드에서 새로 만들지 않는다.</p>

<p>initailize 메소드에서 Collection View의 add, remove 이벤트 Listener를 등록한다. Add 이벤트에서 Shape Model과 View를 만들고 렌더링한다. Shape View는 모두 views 프로퍼티에서 관리한다. 그리고 remove 이벤트가 발생하면 document에서 해당 Shape을 페이지에서도 삭제하고 views 프로퍼티에서도 삭제한다.</p>

<p>이 코드는 <a href="http://jsfiddle.net/nakhli/td6Eg/4/">jsfiddle</a>에 있다.</p>

<h2>Conclusion</h2>

<p>이 소스는 <a href="https://gist.github.com/1596813">github</a>와 <a href="http://jsfiddle.net/nakhli/td6Eg/5/">jsfiddle</a>에 있다. 그리고 <a href="http://www.javageneration.com/wp-content/uploads/2012/01/editor.html">데모</a>도 있다.</p>

<p>이 튜토리얼은 Backbone.js의 MVC와 이벤트 시스템이 어떻게 생겼는지 보여준다. 앞에서도 언급했지만, 아직 서버와 통신하기, 라우팅에 대해서 다루지 않았다. Backbone.js는 CRUD를 쉽게 처리할 수 있도록 돕는다. 다음 글에서는 이 내용을 다룰 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Git: Global Ignore ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/git-global-ignore.html" />
    <updated>2012-02-09T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/git-global-ignore.html</id>
    <content type="html">
<![CDATA[
<p>GitHub에서 관리하는 <code>.gitignore</code> 패턴 템플릿이 있어 소개한다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/git-global-ignore/ignorelo.png" alt="무시로" title="" /></p>

<h2>gitignore</h2>

<p>파일을 무시하는 패턴을 설정하는 방법은 세 가지이다:</p>

<ol>
<li><code>.git/info/exclude</code>는 해당 저장소에만 적용되고 전송되지 않는다. 그러니까 Clone되지 않고 Push할 수 없다.</li>
<li><code>.gitignore</code>는 해당 저장소에만 적용되지만 전송된다.</li>
<li><code>core.exlcudesfile</code> 설정</li>
</ol>

<p>파일 형식은 모두 같고, 세 파일은 있는 대로 동시에 적용될 수 있다. 우선순위는 나열한 순서대로다.</p>

<p><code>core.exlcudesfile</code> 설정은 다음과 같다:</p>

<pre class="prettyprint"><code>$ git config --global core.excludesfile ~/.global_ignore
</code></pre>

<h2>gitignore 프로젝트</h2>

<p>Github는 친절하게도 '언어 및 환경'마다 권장 gitignore 파일 템플릿을 모아 두었다. GitHub의 <a href="https://github.com/github/gitignore">gitignore 저장소</a>에 가서 Clone하고 필요한 템플릿을 사용해보자.</p>

<p>저장소에는 루트 디렉토리에 있는 것과 <code>Global/</code> 디렉토리에 있는 것으로 나누어져 있는데 Global/ 디렉토리에 있는 것은 'OS-specific, editor-specific'인 것이다.</p>

<p>예를 들어 자바라면 다음과 같이 한다:</p>

<pre class="prettyprint"><code>$ cat Maven.gitignore &gt;&gt; ~/.global_ignore
$ cat Java.gitignore &gt;&gt; ~/.global_ignore
$ cat Global/Eclipse.gitignore &gt;&gt; ~/.global_ignore
$ cat Global/vim.gitignore &gt;&gt; ~/.global_ignore
$ cat Global/OSX.gitignore &gt;&gt; ~/.global_ignore
$ git config --global core.excludesfile ~/.global_ignore
</code></pre>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Ladybucks: A Chrome extension for Starbucks WI-FI ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/ladybucks.html" />
    <updated>2012-02-08T15:00:00Z</updated>
    <id>http://dogfeet.github.com/articles/2012/ladybucks.html</id>
    <content type="html">
<![CDATA[
<p>Ladybucks는 Chrome extension으로 스타벅스에서 WI-FI를 편하게 사용하기 위해 만들었다. 단순히 스타벅스에서 요구하는 정보를 저장했다가 해당 페이지가 뜨면 정해진 페이지 흐름대로 자동으로 입력하고 처리해준다.</p>

<p>이 프로그램은 실제로 한국 Starbucks 매장에서 사용할 수 있지만 JavaScript Example로 만들고 싶었다. 그래서 <code>Chrome Extension</code>에서 <code>BootStrap</code>과 <code>Backbone.js</code>를 사용하는 예제로 참고할 수 있도록 만들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/ladybucks/intro.png" alt="logo" title="" /></p>

<p>Ladybucks는 원래 <a href="https://twitter.com/#!/lethee">@lethee</a>가 Safari 버전으로 만들었고 <a href="https://twitter.com/#!/lnyarl">@lnyarl</a>가 Chrome 버전으로 포팅하였다. 그걸 <a href="http://uniquenoun.tumblr.com">@uniquenoun</a>이 디자인하고 <a href="https://twitter.com/#!/pismute">@pismute</a>가 다시 패키징했다.</p>

<h2>설치하기</h2>

<p>소스는 <a href="https://github.com/pismute/ladybucks">저장소</a>에서 확인할 수 있고 <a href="https://pismute.github.com/ladybucks/ladybucks.cpk">ladybucks.cpk</a>를 내려받는다.</p>

<p>패키지 파일을 Chrome에서 열면 설치할 수 있다.</p>

<h3>사용하기</h3>

<p>'tools/extensions' 메뉴를 클릭해서 extensions 페이지(<code>chrome://settings/extensions</code>)를 열고 Ladybucks Extension의 options을 클릭해서 option 페이지를 연다.</p>

<p><img src="/articles/2012/ladybucks/extensions.png" alt="extentions" title="" /></p>

<p>이 페이지에서 Starbucks Wi-Fi 이용 시 사용할 신상정보(이름, 주민번호)를 입력한다.</p>

<p><img src="/articles/2012/ladybucks/option.png" alt="option" title="" /></p>

<p>그리고 Starbucks에서 Wi-Fi 접속 페이지가 열리면 자동으로 신상정보를 입력하고 클릭해서 Wi-Fi에 연결해 준다.</p>

<p><img src="/articles/2012/ladybucks/success.png" alt="success" title="" /></p>]]>
    </content>
  </entry>
</feed>
