<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[ 개발새발 ]]></title>
  <link href="http://dogfeet.github.com/atom.xml" rel="self" />
  <link href="http://dogfeet.github.com" />
  <updated>2012-07-16T18:36:33.583Z</updated>
  <id>http://dogfeet.github.com</id>
  <author>
    <name>Yongjae Choi</name>
    <email>mage@weaveus.com</email>
  </author>
  <author>
    <name>Changwoo Park</name>
    <email>pismute@gmail.com</email>
  </author>
  <author>
    <name>Sean Lee</name>
    <email>sean@weaveus.com</email>
  </author>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Directory Layout ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-directory-layout.html" />
    <updated>2012-07-15T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-directory-layout.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h3>Base directory</h3>

<p>sbt에서 "base 디렉토리"는 프로젝트가 들어 있는 디렉토리를 말한다. <a href="/articles/2012/sbt-getting-started-hello.html">Hello, World</a> 에서 만든 <code>hello</code> 프로젝트에는 <code>hello/build.sbt</code>와 <code>hello/hw.scala</code> 파일이 있는데 여기서 <code>hello</code> 디렉토리가 base 디렉토리이다.</p>

<h2>Source code</h2>

<p>소스는 <code>hello/hw.scala</code>처럼 프로젝트 base 디렉토리에 넣으면 된다. 하지만 보통은 그냥 넣으면 너무 지저분하기 때문에 정리해서 넣는 규칙이 있다.</p>

<p>sbt는 기본적으로 <a href="http://maven.apache.org/">Maven</a>과 같은 디렉토리 레이아웃을 사용한다(모든 경로는 base 디렉토리를 기준으로 하는 상대 경로다):</p>

<pre><code>src/
  main/
    resources/
       &lt;files to include in main jar here&gt;
    scala/
       &lt;main Scala sources&gt;
    java/
       &lt;main Java sources&gt;
  test/
    resources
       &lt;files to include in test jar here&gt;
    scala/
       &lt;test Scala sources&gt;
    java/
       &lt;test Java sources&gt;
</code></pre>

<p><code>src/</code> 안에 있는 다른 디렉토리와 숨겨진 디렉토리는 무시된다.</p>

<h2>sbt build definition files</h2>

<p><code>build.sbt</code> 파일은 base 디렉토리에 넣지만 다른 sbt 파일은 <code>project</code> 디렉토리를 만들어 넣는다.</p>

<p><code>project</code> 디렉토리에는 <code>.scala</code> 파일을 넣을 수 있고 이 <code>.scala</code> 파일은 <code>.sbt</code> 파일과 함께 빌드를 정의하는데 쓴다. 자세한건 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">.scala Build Definition</a>를 봐라.</p>

<pre><code>build.sbt
project/
  Build.scala
</code></pre>

<p><code>project/</code> 디렉토리 안쪽에도 <code>.sbt</code> 파일을 넣을 수 있지만 base 디렉토리에 있는 <code>.sbt</code> 파일과 다르다. 이점은 몇 가지 사전지식이 필요하기 때문에 <a href="/articles/2012/sbt-getting-started-scala-build-definition.html">나중에</a>에서 설명한다.</p>

<h2>Build products</h2>

<p>기본적으로 <code>target</code> 디렉토리에 파일을(컴파일한 클래스, 패키지한 jar 파일, managed 파일, 캐시, 문서) 생성한다.</p>

<h2>Configuring version control</h2>

<p><code>.gitignore</code> 파일에 <code>target/</code> 디렉토리를 추가한다. 다른 버전관리 시스템도 git처럼 <code>target/</code> 디렉토리를 추가해야 한다:</p>

<pre><code>target/
</code></pre>

<p>이름이 <code>/</code>로 끝났다. <code>/</code> 끝나는 이름은 디렉토리만 매치하겠다는 의미다. 그리고 <code>/</code>로 시작하지 않았기 때문에 base 디렉토리에 있는 <code>target/</code> 뿐만 아니라 <code>project/target</code>처럼 하위 디렉토리 안에 있는 디렉토리도 매치된다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Hello, World ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-hello.html" />
    <updated>2012-07-07T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-hello.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2>소스 코드에 프로젝트 디렉토리 만들기</h2>

<p>어떤 디렉토리에 소스 파일이 하나라도 있으면 그 디렉토리는 sbt 프로젝트라고 할 수 있다. <code>hello</code> 디렉토리를 만들고 그 안에 다음과 같은 <code>hw.scala</code> 파일을 만들어 넣는다:</p>

<pre><code>object Hi {
    def main(args: Array[String]) = println("Hi!")
}
</code></pre>

<p><code>hello</code> 디렉토리에서 sbt를 실행하고 sbt 콘솔에서 <code>run</code>을 실행한다. Linux와 OS X에서는 다음과 같이 실행한다:</p>

<pre><code>$ mkdir hello
$ cd hello
$ echo 'object Hi { def main(args: Array[String]) = println("Hi!") }' &gt; hw.scala
$ sbt
...
&gt; run
...
Hi!
</code></pre>

<p>sbt는 관례에 따라 동작하는 것인데 다음과 같은 것을 찾는다.</p>

<ul>
<li>Base 디렉토리에 있는 소스</li>
<li><code>src/main/scala</code> 또는 <code>src/main/java</code>에 있는 소스</li>
<li><code>src/test/scala</code> 또는 <code>src/test/java</code>에 있는 테스트</li>
<li><code>src/main/resources</code> 또는 src/test/resources`에 있는 데이터 파일</li>
<li><code>lib</code>에 있는 jar 파일</li>
</ul>

<p>sbt는 sbt를 실행하는 데 사용한 Scala 버전으로 프로젝트를 빌드한다.</p>

<p><code>sbt run</code>으로 프로젝트를 실행하거나 <code>sbt console</code> 명령으로 <a href="http://www.scala-lang.org/node/2097">Scala REPL</a>을 연다. <code>sbt console</code>은 프로젝트의 클래스패스에서 실행하는 것이라서 프로젝트 소스를 이용한 Scala 코드를 라이브로 실행 수 있다.</p>

<h2>빌드 정의하기</h2>

<p>프로젝트들은 보통 손으로 설정해줘야 한다. 프로젝트 Base 디렉토리에 <code>build.sbt</code> 파일을 만들고 기본 설정을 한다.</p>

<p>예를 들어, 프로젝트 Base 디렉토리가 <code>hello</code>라면 <code>hello/build.sbt</code> 파일에 다음과 같이 만든다:</p>

<pre><code>name := "hello"

version := "1.0"

scalaVersion := "2.9.1"
</code></pre>

<p>각 아이템 사이에 빈 줄이 있는데 그냥 보기 좋으라고 넣은 것이 아니다. 아이템 사이에는 꼭 빈 줄을 넣어줘야 한다. <a href="/articles/2012/sbt-getting-started-sbt-build-definition.html">.sbt build definition</a>에서 <code>build.sbt</code> 파일을 작성하는 방법을 자세히 배운다.</p>

<p>프로젝트를 jar 파일로 패키지할 거라면 <code>build.sbt</code> 파일에 버전과 이름 정도는 설정할 것이다.</p>

<h2>sbt 버전 설정하기</h2>

<p><code>hello/project/build.properteis</code> 파일에 어떤 버전의 sbt를 사용할지 명시할 수 있다. 다음과 같이 만든다:</p>

<pre><code>sbt.version=0.11.3
</code></pre>

<p>0.10 버전부터는 버전이 올라가도 99% 이상 잘 호환된다. 하지만 <code>project/build.properties</code>에 sbt 버전을 명시하면 혹시 모를 문제를 예방할 수 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ sbt: Getting Started Guide: Setup ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/sbt-getting-started-setup.html" />
    <updated>2012-07-02T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/sbt-getting-started-setup.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="https://github.com/harrah/xsbt/wiki/Getting-Started-Welcome">Getting Started sbt</a>을 번역한 것이다. </p>

<p><img src="http://dogfeet.github.com/articles/2012/sbt/sbt.png" alt="sbt" title="" /></p>

<h2>Overview</h2>

<p>다음과 같은 과정을 거쳐서 sbt 프로젝트를 만든다:</p>

<ul>
<li>sbt를 설치하고 실행할 스크립트를 만든다.</li>
<li><a href="/articles/2012/sbt-getting-started-hello.html">hello-world</a> 프로젝트를 만든다.
<ul><li>프로젝트 디렉토리를 만들고 소스를 넣는다.</li>
<li>어떻게 빌드할지 정의한다.</li></ul></li>
<li><a href="/articles/2012/sbt-getting-started-running.html">running</a>을 통해 sbt를 실행하는 법을 배운다.</li>
<li><a href="/articles/2012/sbt-getting-started-sbt-build-definition.html">.sbt-build-definition</a>에서 어떻게 빌드할지 정의하는 법을 배운다.</li>
</ul>

<h2>sbt 설치</h2>

<p><code>sbt-launch.jar</code> 파일과 실행할 스크립트만 있으면 된다.</p>

<p><em>Note: 다운로드는 <a href="http://www.scala-sbt.org/download.html">다운로드 페이지</a>에서 할 수 있다.</em></p>

<h3>Yum</h3>

<p><a href="http://rpm.typesafe.com">Typesafe Yum 레파지토리</a>에 yum 패키지가 있다. <a href="http://rpm.typesafe.com/typesafe-repo-2.0.0-1.noarch.rpm">레파지토리 rpm 패키지</a>를 설치하면 typesafe yum 레파지토리가 승인된 소스 목록에 추가된다. 그리고 다음과 같이 실행한다:</p>

<pre><code>yum install sbt
</code></pre>

<p>sbt의 최신 버전이 설치된다.</p>

<p><em>Note: 이슈를 발견하면 <a href="https://github.com/sbt/sbt-launcher-package/issues">여기</a>에 신고할 수 있다.</em></p>

<h2>Apt</h2>

<p><a href="http://apt.typesafe.com">Typesafe Debian 레파지토리</a>에 sbt Debian 패키지가 있다. <a href="http://apt.typesafe.com/repo-deb-build-0002.deb">레파지토리 deb 패키지</a>를 설치하면 typesafe debian 레파지토리가 승인된 소스 목록에 추가된다. 그리고 다음과 같이 실행한다:</p>

<pre><code>apt-get install sbt
</code></pre>

<p>sbt의 최신 버전이 설치된다.</p>

<p>sbt 없으면 레파지토리에서 정보를 업데이트한다:</p>

<pre><code>apt-get update
</code></pre>

<p><em>Note: 이슈를 발견하면 <a href="https://github.com/sbt/sbt-launcher-package/issues">여기</a>에 신고할 수 있다.</em></p>

<h2>Gentoo</h2>

<p>공식 소스 안에는 sbt용 ebuild 스크립트가 없다. 하지만 <a href='https://github.com/whiter4bbit/overlays/tree/master/dev-java/sbt-bin'>https://github.com/whiter4bbit/overlays/tree/master/dev-java/sbt-bin</a> 에 sbt를 머지하는 ebuild 스크립트가 있다. 다음과 같이 ebuild 스크립트로 sbt를 머지한다:</p>

<pre><code>mkdir -p /usr/local/portage &amp;&amp; cd /usr/local/portage
git clone git://github.com/whiter4bbit/overlays.git
echo "PORTDIR_OVERLAY=$PORTDIR_OVERLAY /usr/local/portage/overlay" &gt;&gt; /etc/make.conf
emerge sbt-bin
</code></pre>

<h2>Mac</h2>

<p><a href="http://macports.org/">MacPorts</a>로 설치한다:</p>

<pre><code>$ sudo port install sbt
</code></pre>

<p><a href="http://mxcl.github.com/homebrew/">HomeBrew</a>로 설치할 수 있다:</p>

<pre><code>$ brew install sbt
</code></pre>

<p>sbt-launch.jar를 직접 다운로드할 필요 없다:</p>

<h2>Windows</h2>

<p><a href="http://scalasbt.artifactoryonline.com/scalasbt/sbt-native-packages/org/scala-sbt/sbt-launcher/0.11.3/sbt.msi">msi</a>를 다운로드한다:</p>

<p><em>아니면</em></p>

<p><code>sbt.bat</code> 배치 파일을 만든다:</p>

<pre><code>set SCRIPT_DIR=%~dp0
java -Xmx512M -jar "%SCRIPT_DIR%sbt-launch.jar" %*
</code></pre>

<p>그리고 그 디렉토리에 [sbt-launch.jar][] 파일을 넣는다. 커맨드 라인에서 'sbt'라고 실행하려면 PATH 환경 변수에 <code>sbt.bat</code>를 등록해준다.</p>

<h2>Unix</h2>

<p><a href="http://typesafe.artifactoryonline.com/typesafe/ivy-releases/org.scala-sbt/sbt-launch/0.11.3-2/sbt-launch.jar">sbt-launch.jar</a>를 다운로드해서 <code>~/bin</code> 디렉토리에 넣는다.</p>

<p>이 jar 파일을 실행하는 스크립트를 'sbt'라는 이름으로 만들고 <code>~/bin</code> 디렉토리에 넣는다:</p>

<pre><code>java -Xms512M -Xmx1536M -Xss1M -XX:+CMSClassUnloadingEnabled -XX:MaxPermSize=384M -jar `dirname $0`/sbt-launch.jar "$@"
</code></pre>

<p>그리고 스크립트를 실행할 수 있게 만든다:</p>

<pre><code>$ chmod u+x ~/bin/sbt
</code></pre>

<h2>팁, 노트</h2>

<p>문제가 생겨서 <code>sbt</code>가 실행이 안되면 <a href="https://github.com/harrah/xsbt/wiki/Setup-Notes">설치 노트</a>를 확인하라. 터미널 엔코딩, HTTP 프록시, JVM 옵션 등에 대해 나와 있다.</p>

<p>꼼꼼하게 만들어진 쉘 스크립트가 있어서 이 스크립트로 sbt를 설치할 수 있다: <a href='https://github.com/paulp/sbt-extras'>https://github.com/paulp/sbt-extras</a> (루트 디렉토리에 있는 sbt 파일). 이 스크립트로 설치하면 패키지로 설치하는 것처럼 원하는 버전의 sbt를 설치할 수 있다. 설치할 sbt의 버전을 선택한다든지 하는 유용한 옵션이 있다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs에서의 멍키 패칭 ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-monkey-patching.html" />
    <updated>2012-06-23T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-monkey-patching.html</id>
    <content type="html">
<![CDATA[
<p>JavaScript에서 멍키 패칭이 가능할까? 'require'를 어떻게 좀 바꾸면 될 것 같은데, 그런게 가능하긴 할까해서 찾아봤다. 명색이 프로토타입 언어인데 쓸데가 있을지는 둘 째치고 가능할꺼라는 생각이 들었다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-monkey-patching/monkey_patch.jpg" alt="monkey-patch" title="" /></p>

<p>(from <a href='http://geargeeksreview.blogspot.kr/2008/09/milspecmonkey-monkey-patch.html'>http://geargeeksreview.blogspot.kr/2008/09/milspecmonkey-monkey-patch.html</a>)</p>

<h2>require</h2>

<p>소스에서 require를 사용할 수 있는 이유는 다음과 같은 코드로 wrapper되기 때문이다. 다음 코드는 node/src/node.js에 있는(node 소스) 코드다:</p>

<pre><code>NativeModule.wrapper = [
    '(function (exports, require, module, __filename, __dirname) { ',
    '\n});'
];
</code></pre>

<p>소스에서 exports, require, module, __filename, __dirname 변수를 사용할 수 있는 이유는 우리가 구현하는 모듈이 이 wrapper의 바디에 해당되기 때문이다.</p>

<p>모든 모듈은 Module 객체이다. <code>require('fs')</code>라고 호출하면 fs.js를 로드해서 Module 객체 인스턴스로 만들어서 반환한다. <code>node/lib/module.js</code> 코드를 보면 모든 모듈은 Module 객체로 만드는 부분이 있다.</p>

<pre><code>var module = new Module(filename, parent);
</code></pre>

<p>require는 module 객체 자체를 반환하는 것이 아니라 <code>module.exports</code>를 반환한다. 그래서 require로 Module 객체에 접근할 수 없다. </p>

<p>module 객체에는 해당 모듈에 필요한 정보를 담고 있으면서 _cached 프로퍼티에 캐시된다. 실제 module.js 소스를 보자:</p>

<pre><code>var cachedModule = Module._cache[filename];
if (cachedModule) {
    return cachedModule.exports;
}
</code></pre>

<p>require가 호출되면 먼저 _cache에 등록는지 확인하고 캐시한 것을 반환한다. 즉, 해당 모듈 객체는 딱 하나만 만든다. 이 것은 API 문서에도 잘 나와 있다.</p>

<h3>Module.prototype.require</h3>

<p>그럼 require는 어딨는 걸까? 뭘 고쳐야 require 호출을 가로챌 수 있을까? 우리가 호출하는 require는 다음과 같은 위치에 있다:</p>

<pre><code>Module.prototype.require = function(path) {
  return Module._load(path, this);
};
</code></pre>

<p>메인 모듈(실행하는 스크립트)뿐만 아니라 모든 모듈 객체의 prototype에 있는 require를 호출한다. 그리고 저걸 바꿔주는 모듈을 만들면 내가 만든 require 함수가 호출되도록 할 수 있다.</p>

<h2>멍키 패칭</h2>

<p>require 함수를 바꾸는 mp.js 모듈을 만든다:</p>

<pre><code>var Module = require('module');

// orig 함수를 두는 위치는 아무 의미없다--;
// 그냥 prototype._require__에 넣은 것이다. 실제로 사용하려면 문제가 될 수 있다.
Module.prototype.__require__ = Module.prototype.require;
Module.prototype.require = function fevent_require(id) {

    //여기에 멍키 패칭 코드를 넣을 수 있다.
    //fs나 net 모듈 같은 걸 수정할 수 있다.
    console.log('called require');

    return this.__require__(id);
}
</code></pre>

<p>mp.js 모듈을 사용해보자:</p>

<pre><code>require('fs');

require('./mp');

require('fs'); //called require
require('net'); //called require
</code></pre>

<p>잘된다.</p>

<p>그런데 여기서 한가지 의문이 든다. Module.prototype.require를 수정했지만 <code>(function (exports, require, module, __filename, __dirname)</code>라는 wrapper를 통해 파라미터로 넘겨진 require의 레퍼런스는 그대로 인데도 잘 수행된다.</p>

<p>이 wrapper를 통해 넘겨진 함수는 다음과 같다:</p>

<pre><code>var self = this;
//....
function require(path) {
    return self.require(path);
}
</code></pre>

<p>그래서 해당 모듈의 require 함수가 호출되는 것이기 때문에 잘된다.</p>

<p>require 함수를 바꿀 수 있으니 이제 원하는 모듈을 멍키 패칭할 수 있다. 이 방법의 안정성은 좀 더 다듬어야 하고--; 멍키 패칭이 필요한 이유도 아직 없지만--;; 가능하긴 하다는 것을 알아 보았다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ iamport: nodejs ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/iamport-nodejs.html" />
    <updated>2012-06-16T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/iamport-nodejs.html</id>
    <content type="html">
<![CDATA[
<p><a href="/articles/2012/iamport-python.html">iamport: python</a>에서 100개쯤되는 포트를 확인해보려고 포트가 열렸는지 확인하는 프로그램을 python으로 작성했었다. <a href="https://github.com/laverdet/node-fibers">node-fibers</a>를 살펴보면서 iamport를 nodejs로 포팅해봤다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/iamport/iamport.jpg" alt="iamport" title="" /></p>

<p>(from <a href='http://www.portofamsterdam.com/'>http://www.portofamsterdam.com/</a>)</p>

<h2>iamport: CPS</h2>

<p>다음은 포트가 열렸는지 <a href="/articles/2012/by-example-continuation-passing-style-in-javascript.html">CPS</a> 방식으로 확인하는 프로그램이다:</p>

<pre><code>#!/usr/bin/env node

var net = require('net');
var fs = require('fs');

var stime=new Date().getTime();
var done=0;

function tryToConnect( ip, port ){
    done++;

    var socket = net.createConnection(port, ip);

    socket.on('error', function(err){
        console.log( ip + ' ' + port );
    }).on('connect', function(connect) {
        socket.destroy();
    }).on('close', function(had_error){
        done--;

        if(done == 0 ){
            var etime=new Date().getTime();

            console.log( "elapsed(ms) " + (etime - stime)/1000 );
        }
    });
}

fs.readFile(process.argv[2], 'utf-8', function(err, data){
    var lines = data.split('\n');

    lines.forEach(function(line){
        if( line.trim().length &lt; 1 ) return;
        var opts=line.match(/[0-9\.]+/g);

        if( opts &amp;&amp; opts.length &gt; 1 ) {
            tryToConnect(opts[0], opts[1]);
        } else {
            console.log(line);
        }
    });
});
</code></pre>

<p>테스트할 포트 목록은 다음과 같은 파일을 파라미터로 넘겨주면 된다:</p>

<pre><code>127.0.0.1       22
127.0.0.1       21
168.126.63.1    18
18.18.18.18     18
18.18.18.18
74.125.235.180  80
</code></pre>

<p>그러면 입력 값이 잘못 됐거나 열리지 않는, 아무튼 예외가 발생하는 것만 출력한다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport.js port_scan 
18.18.18.18
127.0.0.1 21
127.0.0.1 22
18.18.18.18 18
168.126.63.1 18
elapsed(ms) 21.047
</code></pre>

<h2>iamport: fiber</h2>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>의 Future을 적용한 예이다. 비동기 API를 Wrapping하는 다른 시도도 있지만 그냥 Future를 사용했다:</p>

<pre><code>#!/usr/bin/env node

var net = require('net');
var fs = require('fs');
var Future = require('fibers/future'), wait = Future.wait;

var stime=new Date().getTime();

//api(..., callback(err,data))라는 컨벤션을 따라야 한다.
function tryToConnect( ip, port, callback ){

    var socket = net.createConnection(port, ip);

    socket.on('error', function(err){
        console.log( ip + ' ' + port );
        callback(err, null);
    }).on('connect', function(connect) {
        socket.destroy();
        callback(null, connect);
    });
}

//Function.length를 이용해서 callback 파라미터의 위치를 자동으로 찾는다.
//엄밀히 말하면 마지막 파라미터를 callback으로 가정함
var connect = Future.wrap( tryToConnect );

//readFile의 프로토타입은 readfile( port, [ip], [callback])이고
//fs.readFile은 callback 파라미터의 위치가 동적이기 때문에
//명시적으로 선언한게 아니라 arguments를 이용했다.
//그래서 Function.legnth로 callback의 위치를 알 수 없다.
//두번째 파라미터 2는 callback의 위치를 알려주는 것이다.
var readFile = Future.wrap( fs.readFile, 2 );

Fiber(function(){
    var data = readFile(process.argv[2], 'utf-8').wait();
    var lines = data.split('\n');
    var jobs = [];

    lines.forEach(function(line){
        if( line.trim().length &lt; 1 ) return;

        var opts=line.match(/[0-9\.]+/g);

        if( opts &amp;&amp; opts.length &gt; 1 ) {
            jobs.push( connect(opts[0], opts[1]) );
        } else {
            console.log(line);
        }
    });

    //wait에는 Fiber 객체가 아니라 Future 객체가 필요하다.
    wait(jobs);

    var etime=new Date().getTime();

    console.log( "elapsed(ms) " + (etime - stime)/1000 );
}).run();
</code></pre>

<p><a href="/articles/2012/by-example-continuation-passing-style-in-javascript.html">CPS</a>이나 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>나 성능상에 차이날 이유가 없다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport-fiber.js port_scan 
18.18.18.18
127.0.0.1 21
127.0.0.1 22
168.126.63.1 18
18.18.18.18 18
elapsed(ms) 21.093
</code></pre>

<p>gevent와 같은 구현체가 등장하면 쓸만 할지도 모르겠지만 node에서 Coroutine은 괜한 욕심일지도 모르겠다. 그래도 node-fiber를 좀 더 쉽게 사용할 수 있도록 만들려는 시도들이 있다. <a href="https://github.com/lm1/node-fiberize">fiberize</a>, <a href="https://github.com/lm1/node-fibers-promise">fibers-promise</a>, <a href="https://github.com/0ctave/node-sync">node-sync</a>를 참고하면 node-fiber를 사용하는데 도움이 될 것이다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ nodejs: node-fibers ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/nodejs-fibers.html" />
    <updated>2012-06-09T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/nodejs-fibers.html</id>
    <content type="html">
<![CDATA[
<p>JavaScript는 <a href="/articles/2012/coroutine.html">Coroutine</a>을 지원하지 않기 때문에 외부 모듈이 필요하다. 이 글에서는 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>로 node에서 Coroutine을 어떻게 응용해야 할지 알아본다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/nodejs-fibers/puton-fiber.jpg" alt="fiberware" title="" /></p>

<p>(from <a href='http://www.fiberbaya.blogspot.kr/'>http://www.fiberbaya.blogspot.kr/</a>)</p>

<h2>node-fibers</h2>

<p>nodejs에 포함돼지도 않았고 안정성도 검증돼지 않았지만 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>를 사용하면 Coroutine 뿐만아니라 JavaScript에는 없는 sleep()이라든지 Generator라든지를 만들어 쓸 수 있다.</p>

<p>공식 페이지에 소개된 sleep()을 구현하는 코드를 보자.</p>

<pre><code>var Fiber = require('fibers');

function sleep(ms) {
    var fiber = Fiber.current;
    setTimeout(function() {
        fiber.run(); //ms후에 다시 깨운다.
    }, ms);
    Fiber.yield(); //여기서 멈추고
}

Fiber(function() {
    console.log('wait... ' + new Date);
    sleep(1000);
    console.log('ok... ' + new Date);
}).run();
console.log('back in main');
</code></pre>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>는 강력한 도구지만 실제 힘을 발휘하려면 gevent같은 게 필요하다. 기존 API를 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>을 적용해서 다시 구현할 수는 없다.</p>

<h3>멍키 패칭하고 싶다.</h3>

<p>Python에서는 gevent를 사용하면 IO api와 thread api를 모두 멍키 패칭해주므로 투명하게 Coroutine으로 코드의 가독성을 높일 수 있었다. 하지만, node에서는 쉽지 않다. JavaScript는 플랫폼 전반에 CPS 스타일이 뼛속까지 녹아 있어서 멍키 패칭할 동기 API가 부족하다. 예를 들어, 파일 IO에는(fs 모듈) <code>xxxSync</code> 메소드가 갖춰져 있지만, 소켓 IO에는(net 모듈) 없다.</p>

<p>다시 말해서 gevent 방식이 더 낫다고 생각하지만:</p>

<p>1) 멍키 패칭할 <code>xxxSync</code> 메소드가 필요하고<br />2) 멍키 패칭을 구현한 모듈도 필요하고<br />3) 그러려면 node-fiber가 정식으로 node에 포함되든 JavaScript 표준에 Coroutine이 도입되든 안정성과 지원도 필요하고<br />4) 주렁주렁...궁시렁궁시렁...</p>

<p>gevent의 아이디어를 그대로 node에서 사용할 수는 없다.</p>

<p>멍키 패칭이든 뭐든 기존 API를 Coroutine에서 사용할 수 있도록 해주는 도우미가 필요한데, <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에는 Future라는 게 있다. Future는 Node의 비동기 API를 감싸서(wrap) Cotoutine을 사용할 수 있게 해준다.</p>

<h3>ls.js</h3>

<p>다음 예제는 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에서 Future를 설명하는데 보여주는 것이다. fs.readdir과 fs.stat를 감싸서 순차적으로 사용하는 것을 볼 수 있다:</p>

<pre><code>var Future = require('fibers/future'), wait = Future.wait;
var fs = require('fs');

// This wraps existing functions assuming the last argument of the passed
// function is a callback. The new functions created immediately return a
// future and the future will resolve when the callback is called (which
// happens behind the scenes).
var readdir = Future.wrap(fs.readdir);
var stat = Future.wrap(fs.stat);

Fiber(function() {
    // Get a list of files in the directory
    var fileNames = readdir('.').wait();
    console.log('Found '+ fileNames.length+ ' files');

    // Stat each file
    var stats = [];
    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        stats.push(stat(fileNames[ii]));
    }
    wait(stats);

    // Print file size
    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        console.log(fileNames[ii]+ ': '+ stats[ii].get().size);
    }
}).run();
</code></pre>

<p>이 코드를 CPS 스타일의 코드로 바꾸면 다음과 같다:</p>

<pre><code>var fs = require('fs');

fs.readdir('.', function(err, fileNames){
    console.log('Found '+ fileNames.length+ ' files');

    // Stat each file
    fileNames.forEach(function(fileName){
        fs.stat( fileName, function(err, stat){
            console.log( fileName + ': '+ stat.size);
        });
    });
});
</code></pre>

<p>이 예제에서 알 수 있듯이 node에서는 CPS 스타일을 사용하는 게 더 낫다. 언어에서 <a href="/articles/2012/coroutine.html">Coroutine</a>을 정식 지원하는 것도 아니고 API도 준비돼 있지 않다. 환경이 준비됐다고 가정하고 스케쥴링을 목적으로 하는 것이라면 Coroutine이 더 낫다고 볼 수 있지만 적어도 아직은 node에서 CPS가 더 나을지도...</p>

<p>아무튼 <code>for</code>문을 <code>forEach</code>로 바꿀 수밖에 없다. 예를 들어 다음과 같은 코드는 ii 값이 변하기 때문에 동작하지 않는다:</p>

<pre><code>    for (var ii = 0; ii &lt; fileNames.length; ++ii) {
        fs.stat( fileName[ii], function(err, stat){
            console.log( fileName[ii] + ': '+ stat.size);
        });
    }
</code></pre>

<p>JavaScript의 가장 큰 문제는 매일매일 단련해야 한다는 것 같다. 하루라도 안 하면 잊어버려서 꼭 다음번에 삽질한다.</p>

<h3>Future</h3>

<p>Future는 Node API 컨벤션이 일정한 것을 이용한다. node API는 <code>api(..., callback(err, ...))</code> 형식으로 돼 있기 때문에 이점을 이용한다. callback()으로 결과가 반환될 때까지 yield()시켰다가 callback()이 호출돼서 api 결과를 알게 되면 다시 resume 시킨다.</p>

<p>이 내용은 다음과 같이 생각하면 된다. 다음과 같은 코드를 추상화시킨 것이 future라고 생각하면 된다:</p>

<pre><code>function future_wrap(){
    fiber = fiber.current;

    api(..., callback(err, data){
        fiber.run();
    });

    Fiber.yield();
}
</code></pre>

<p>그러니까 (직접 구현해보지 않았지만) 자체제작 api를 만든다면 표준 컨벤션을 지켜서 구현해야 Future를 사용할 수 있고 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>도 사용하기 쉽다. 아예 api를 <a href="https://github.com/laverdet/node-fibers">node-fibers</a>에 의존하게 하여도 되지만 권하고 싶지 않다.</p>

<p>실제 Future.wrap() 코드를 보면 아예 api를 감싸버린다:</p>

<pre><code>Future.wrap = function(fn, idx) {
    idx = idx === undefined ? fn.length - 1 : idx;
    return function() {
        var args = Array.prototype.slice.call(arguments);
        if (args.length &gt; idx) {
            throw new Error('function expects no more than '+ idx+ ' arguments');
        }
        var future = new Future;
        args[idx] = future.resolver();
        fn.apply(this, args);
        return future;
    };
};
</code></pre>

<p>resolver()가 api 콜백인데 다음과 같이 생겼다:</p>

<pre><code>resolver: function() {
    return function(err, val) {
        if (err) {
            this.throw(err);
        } else {
            this.return(val);
        }
    }.bind(this);
}
</code></pre>

<p><a href="https://github.com/laverdet/node-fibers">node-fibers</a>의 future.js 코드는 흥미롭다. 분석해보면 재밌을 거로 생각하지만 공부했던 것을 잊어버려서(게을러서) 나중으로 미뤄야겠다.</p>

<p>지구가 멸망하기 전에 <code>Secrets of the JavaScript Ninja</code>가 출간되는 날이 오면 그때나 다시 공부하고 분석해봐야겠다.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ iamport: python ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/iamport-python.html" />
    <updated>2012-06-01T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/iamport-python.html</id>
    <content type="html">
<![CDATA[
<p>포트가 열렸는지 확인하는 프로그램을 작성했다. 100개쯤되는 포트를 확인해보라고 해서 만들었는데, 이 참에 gevent를 적용해보았다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/iamport/iamport.jpg" alt="iamport" title="" /></p>

<p>(from <a href='http://www.portofamsterdam.com/'>http://www.portofamsterdam.com/</a>)</p>

<p>주 플랫폼이 Java라서 예전엔 이런일을 groovy로 했었는데 python이 훨씬 쉽다.</p>

<h2>iamport</h2>

<p>다음은 포트가 열렸는지 순차적으로 확인하는 프로그램이다.</p>

<pre><code>#!/usr/bin/env python

import socket
import sys
import time
import re

def tryToConnect( argv ):
    ip=argv[0]
    port=int(argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )

    try:
        sock.connect( (ip, port) )
    except:
        print ip, port

    sock.close()

if __name__ == '__main__':

    stime=time.time()

    file = open(sys.argv[1])

    jobs = []

    while True:
        line = file.readline()

        if not line:
            break

        opts = re.split('\s*', line)

        if len(opts) &gt; 2:
            job = tryToConnect( opts )
            jobs.append( job )
        else:
            print opts[0]

    file.close()

    etime=time.time()

    print 'elapsed %f' % (etime - stime)
</code></pre>

<p>테스트할 포트 목록은 다음과 같은 파일을 파라미터로 넘겨주면 된다:</p>

<pre><code>127.0.0.1       22
127.0.0.1       21
168.126.63.1    18
18.18.18.18     18
18.18.18.18
74.125.235.180  80
</code></pre>

<p>그러면 입력 값이 잘못 됐거나 열리지 않는, 아무튼 예외가 발생하는 것만 출력한다. 실행 결과는 다음과 같다:</p>

<pre><code>$ ./iamport.py port_scan 
127.0.0.1 22
127.0.0.1 21
168.126.63.1 18
18.18.18.18 18
18.18.18.18
elapsed 42.215497
</code></pre>

<p>100개 정도에 한번 해봤는데 27분 걸렸다.</p>

<h2>Coroutine</h2>

<p><a href="/articles/2012/coroutine.html">Coroutine</a>은 정말 유용하다. Python이 처음이라면 다음과 같은 글을 읽는 것이 도움이 된다.</p>

<ul>
<li><a href="http://blog.dahlia.pe.kr/articles/2009/09/15/python-%EC%A0%9C%EB%84%88%EB%A0%88%EC%9D%B4%ED%84%B0%EB%B0%98%EB%B3%B5%EC%9E%90%EC%9D%98-%EB%A7%88%EB%B2%95">Python 제너레이터+반복자의 마법</a></li>
<li><a href="http://pyengine.blogspot.com/2011/07/python-coroutine-1.html">파이썬 코루틴 (python coroutine) - 1</a></li>
<li><a href="http://pyengine.blogspot.com/2011/07/python-coroutine-2.html">파이썬 코루틴 (python coroutine) - 2</a></li>
</ul>

<h2>gevent</h2>

<p>gevent를 이해하려면 eventlet을 알아봐야 하고:</p>

<ul>
<li><a href="http://ricanet.com/new/view.php?id=blog/111007">greenlet은 어떻게 구현했을까?</a></li>
<li><a href="http://blog.gevent.org/2010/02/27/why-gevent/">Comparing gevent to eventlet</a></li>
</ul>

<p>gevent의 적용은 너무 쉽다. 사실 세 줄만 바꿔주면 된다:</p>

<ol>
<li>멍키패칭으로 io api를 비동기+코루틴 방식의 구현체로 바꿔주고.</li>
<li>job들을 등록(spawn)하고서</li>
<li>join으로 다 끝나길 기다리면 된다(테스트는 안해봤지만 join이 호출될때 job이 실제로 시작하는 것 같다).</li>
</ol>

<h3>gevent 버전의 iamport</h3>

<p>아무리 내가 python을 잘 모른다지만 너무 간단하다. 눈이 의심스러울 정도로 간단하다.</p>

<pre><code>#!/usr/bin/env python

import socket
import sys
import time
import re
import gevent
import gevent.monkey

def tryToConnect( argv ):
    ip=argv[0]
    port=int(argv[1])

    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM )

    try:
        sock.connect( (ip, port) )
    except:
        print ip, port

    sock.close()

if __name__ == '__main__':

    stime=time.time()

    #멍키패칭
    gevent.monkey.patch_all()

    file = open(sys.argv[1])

    jobs = []

    while True:
        line = file.readline()

        if not line:
            break

        opts = re.split('\s*', line)

        if len(opts) &gt; 2:
            #job을 spawn
            job = gevent.spawn(tryToConnect, opts )
            jobs.append( job )
        else:
            print opts[0]

    file.close()

    #spawn한 job이 모두 종료할 때까지 join
    gevent.joinall( jobs )

    etime=time.time()

    print 'elapsed %f' % (etime - stime)
</code></pre>

<p>27분 걸렸던게 27초만에 끝났다. 만세.</p>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ Coroutine ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/coroutine.html" />
    <updated>2012-05-26T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/coroutine.html</id>
    <content type="html">
<![CDATA[
<p>이 글은 <a href="http://en.wikipedia.org/wiki/Coroutine">Wikipedia의 Coroutine</a>을 번역한 것이다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/coroutine/source-code.png" alt="coroutine-python" title="" /></p>

<h2>Coroutine</h2>

<p>Coroutine은 컴퓨터 프로그램에서 엔트리 포인트가 여러 개인 Subroutine이다. 그래서 어디서든지 잠시 멈췄다가 다시 이어서 실행할 수 있다. Coroutine은 <a href="http://en.wikipedia.org/wiki/Cooperative_multitasking#Cooperative_multitasking.2Ftime-sharing">cooperative task</a>, <a href="http://en.wikipedia.org/wiki/Iterator">iterator</a>, <a href="http://en.wikipedia.org/wiki/Lazy_evaluation">infinite list</a> and <a href="http://en.wikipedia.org/wiki/Pipeline_" title="software">pipe</a> 같은 것을 구현하기에 좋다.</p>

<p>"Coroutine"이라는 용어는 Melvin Conway가 1963년에 자신의 논문에서 처음 사용했다.</p>

<h2>Subroutine과 비교</h2>

<p>"Subroutine은 Coroutine 중 한 종류에 불과하다" - Donald Knuth]. Subroutine은 한번 실행하면 다 마칠 때까지 계속 실행되고 한번 호출할 때 한번 리턴한다. Coroutine도 이와 비슷하지만, Yield라는 것으로 빠져나오거나 다른 Coroutine을 호출해서 다시 해당 Coroutine이 하던 일을 이어서 할 수 있다.</p>

<p>그리고 Yield 없이 간단하게 Coroutine을 구현할 수도 있다.</p>

<p>언어를 개발할 때 Subroutine을 구현하려면 Subroutine을 실행하기 전에 스택을 하나 만들어야 한다. 하지만, Coroutine은 다른 Coroutine을 호출할 수 있어서 Continuation을 가지고 구현하는 것이 제일 좋다. Continuation은 스택이 여러 개 필요하기 때문에 보통 가비지컬렉터가 있는 언어에서 구현한다. 스택을 캐시해두거나 미리 할당하는 방식으로 좀 쉽게 Coroutine을 구현할 수 있다.</p>

<p>Coroutine이 얼마나 유용한지 보여 줄 수 있는 예제를 하나 보여주겠다. 소비자-생산자 관계인 Coroutine이 두 개 있다고 가정한다. 한쪽은 아이템을 생성해서 큐에 넣고 다른 쪽은 큐에서 아이템을 꺼내서 사용한다. 그리고 한꺼번에 아이템을 추가하거나 삭제해서 성능을 최적화할 수 있다. 이 내용을 코드로 구현하면 다음과 같다:</p>

<pre><code>var q := new queue

coroutine produce
    loop
        while q is not full
            create some new items
            add the items to q
        yield to consume

coroutine consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield to produce
</code></pre>

<p>큐가 다 차거나 다 비워지면 yield 명령어로 컨트롤를 다른 Coroutine에 양보한다. 그러면 그 Coroutine이 바로 시작한다.</p>

<p>이 예제는 멀티 Thread를 설명할 때 사용하는 예제랑 비슷하게 생겼지만, Thread를 두 개 만들지 않는다: 루틴이 돌다가 yield 구문을 만나면 다른 루틴으로 바로 점프한다.</p>

<h2>Coroutine과 Generator</h2>

<p>Generator도 Subroutine보다 넓은(generalisation) 개념이지만 Generator를 처음 볼 땐 Coroutine보다 후져 보인다. Generator는 기본적으로 Iterator 코드를 단순화할 목적으로 사용하기 때문에 Generator의 yield 구문은 다른 Coroutine으로 점프하는 게 아니라 호출한 상위 루틴으로 값을 넘겨준다. 하지만, Generator로 Coroutine을 구현할 수 있다. Generator를 호출하는 상위 루틴을 'Dispatcher'로(엄밀히 말하자면 <a href="http://en.wikipedia.org/wiki/Trampoline_" title="computing">Trampoline</a>) 구현하면 되는데 한 Generator가 반환한 토큰으로 다른 Generator를 실행한다.</p>

<pre><code>var q := new queue

generator produce
    loop
        while q is not full
            create some new items
            add the items to q
        yield consume

generator consume
    loop
        while q is not empty
            remove some items from q
            use the items
        yield produce

subroutine dispatcher
    var d := new dictionary(generator → iterator)
    d[produce] := start produce
    d[consume] := start consume
    var current := produce
    loop
        current := next d[current]
</code></pre>

<p>언어 차원에서 Coroutine을 지원하는 것도 많지만, native Coroutine이 없는 언어에서는 이렇게 많이들 구현한다. 예를 들어, Python 2.5 이전 버전에서는 이와 같은 방법을 사용했다.</p>

<h2>Coroutine의 용도</h2>

<p>Coroutine은 다음과 같은 것을 구현할 때 유용하다:</p>

<ul>
<li>Subroutine 하나로 구현하는 State-Machine에 유용하다.
이 머신의 State는 프로시저의 entry/exit point로 결정한다. 이렇게 하면 좀 더 가독성 높은 코드가 된다.</li>
<li>Concurrency에서 사용하는 Actor 모델에 유용하다. Actor마다 프로시저가 하나 있다(이 프로시저는 다시 여러 개로 나뉜다). 각 Actor는 스스로 스케쥴러에 컨트롤을 반환한다. 그래서 선점형 멀티태스킹 시스템처럼 차례로 실행된다.</li>
<li>Generator는 IO 처리나 자료구조를 Traverse하는 코드에 유용하다.</li>
</ul>

<h2>Coroutine을 지원하는 언어들</h2>

<p>Aikido, AngelScript, BCPL, Pascal, BETA, C#, ChucK, D, Dynamic C, Erlang, F#, Factor, GameMonkey, Go, Haskell, High Level Assembly, JavaScript(since 1.7), Icon, Io, Limbo, Lua, Lucid, µC++, MiniD, Modula-2, Nemerle, Perl(Perl 5 with Coro, Perl 6 native[citation needed]), Prolog, Python(since 2.5), Ruby, Sather, Scheme, Self, Simula-67, Squirrel, 스택less Python, SuperCollider, Tcl(since 8.6), urbiscript</p>

<p>Continuation으로도 Coroutine을 구현할 수 있어서 Continuation을 지원하는 언어라면 Coroutine은 쉽게 구현할 수 있다.</p>

<h2>Coroutine 대용으로 쓸 수 있는 것.</h2>

<p>Coroutine은 원래 assembly 수준 기술이지만 일부 high-level 언어에서만 지원한다. Coroutine을 지원하는 언어는 Simula나 Modula-2가 처음이었고 최근에는 Lua나 Go에서도 지원한다.</p>

<p>2003년 당시에는 C나 그 파생언어들이 인기가 높았다. 하지만, 그 언어들은 언어 자체나 표준 라이브러리에서 Coroutine을 지원하지 않았다. Subroutine이 스택을 사용하기 때문에 어려웠다.</p>

<p>그런 이유로 Coroutine 자체는 구현하기 어렵지 않은데도 쓸 수가 없었다. 이렇게 Coroutine을 못 쓸 때는 State 변수나 플래그 같은 것의 조합으로 내부 상태를 관리하는 Subroutine을 만들어 쓸 수 있다. State 변수가 어떠냐에 따라서 전혀 다른 코드가 수행되는 것을 이용하는 것이다. 아니면 복잡한 switch 구문을 많이 써서 explicit state machine을 만드는 방법도 있다. 그렇지만, 이런 방법은 만들기도 어렵고 관리하기도 어렵다.</p>

<p>Thread는 많이 사용하는 언어에서 Coroutine 대용으로 사용한다. Thread는 동시성(simultaneously)이라는 여러 코드가 동시에 실행할 수 있는 기능을 제공한다. C 환경이나 Native로 Thread를 지원하는 다른 언어에서 널리 쓰인다. 많은 프로그래머가 알고 있고, 구현체도 매우 많고, 문서도 넘쳐나고, 지원도 잘된다. 하지만, Thread는 어려운 문제를 다루고 있어서 좀 더 강력하지만 복잡한 내용을 배워야 한다. 그래서 상대적으로 배우기 어렵다. Coroutine은 별로 알아야 할 게 없다. Thread를 사용하는 것은 소 잡는 칼로 닭 잡는 격이다.</p>

<p>Thread와 Coroutine의 가장 중요한 차이는 Thread는 선점형 스케쥴링이지만 Coroutine은 아니라는 것이다. Thread는 아무 데서나 스케쥴이 변경되고 Concurrent하게 실행한다. Thread를 사용하면 Locking할 때 조심해야 한다. 반대로 Coroutine은 스케줄이 변경되는 곳이 정해져 있고 Concurrent하게 실행되지 않는다. Coroutine은 전체적으로 locking이 필요 없다. 보통 이 특징은 event-driven이나 비동기 방식을 설명할 때도 장점으로 설명하는 특징이다.</p>

<p>그리고 Fiber라는 게 있어서 Coroutine을 구현해 쓸 수 있다. 하지만, Thread와 비교하면 Fiber를 지원하는 시스템은 별로 없다.</p>

<h3>.NET 프레임웤에서 fiber로 Coroutine 구현하기</h3>

<p>.NET 프레임웤 2.0을 개발하면서 Microsoft는 fiber기반 스케줄링을 다룰 수 있도록 CLR(Common Langauge Runtime) 호스팅 API의 설계를 확장했다. 이것은 SQL 서버의 fiber-mode를 사용할 수 있도록 하기 위함이다. 릴리즈할 때에는 시간 제약사항(constraints) 때문에 타스크 스위칭을 지원하는 ICLRTask:SwitchOut을 제거했다. 그래서 타스크를 스위칭에 필요한 fiber API는 현재 .NET 프레임웤에서는 사용할 수 없다.</p>

<h3>Mono에서의 Coroutine</h3>

<p>Mono CLR은 Continuation을 지원하기 때문에 coroutine을 만들 수 있다.</p>

<h3>Java에서의 Coroutine</h3>

<p>Java는 추상화 때문에 Coroutine을 구현하기 어려운데도 구현체가 네 가지나 된다. JVM에서 불가능한 것은 아니다.</p>

<ul>
<li>JVM 수정 버전들. Native로 Coroutine을 지원하도록 JVM을 Patch할 수 있다. Da Vinci JVM에는 해당 패치가 있다.</li>
<li>바이트코드 수정 버전들. Coroutine은 Java 바이트코드를 수정해서 구현할 수도 있다. 컴파일할 때 수정할 수도 있고 실행할 때 수정할 수도 있다. <a href="http://code.google.com/p/coroutines/">Java Coroutine</a> 프로젝트가 있다.</li>
<li>JNI로 구현. 해당 플랫폼용으로 구현된 C 라이브러리로 JVM에서 Coroutine을 사용한다.</li>
<li>Thread를 이용. 무겁디무거운(heavywight) 쓰레드로 Coroutine 라이브러리를 구현할 수도 있다. 성능은 JVM의 Thread 구현체에 따라 다르다.</li>
</ul>

<h3>C에서의 Coroutine</h3>

<p>다양한 시도가 있었는데 구현 정도가 다르다. C에서는 Subroutine과 마크로를 사용해서 Coroutine을 구현한다. 이 방법으로 구현한 것 중에서는 Simon Tatham이 구현한 것이 좋다. Tatham은 주석에서 이 방법의 한계를 잘 설명한다. 이 방법은 아직 논쟁`의 여지가 남아 있지만, 코드를 작성하기도 쉽고, 읽기도 쉽고, 관리하기도 쉽다. Tatham이 말하길 "물론, 이 방법은 책에서 말하는 코딩 규칙에 어긋난다. 하지만, 모든 코딩 규칙은 알고리즘의 명확성을 대가로 문법적 명확성을 얻는 방법들이다. 이 방법을 사용하자고 사장에게 말하면 사장는 분명히 그 직원을 건물 밖으로 드래그해버리라고 경비에게 소리칠 것이다"</p>

<p>Coroutine을 구현하는 좀 더 믿음직한 방법이 있는데, 대신 이식성이 떨어지고 특정 프로세서에서만 사용할 수 있다. 어셈블리 수준에서 Coroutine 컨텍스트를 저장했다가 다시 복원하는 기능이 있는 프로세서에서만 사용할 수 있다. 표준 C 라이브러리에는 setjmp와 longjmp 함수가 있어서 Coroutine 비슷하게 구현할 수 있다. 그런데 Harbison과 Steele은 "setjmp와 longjmp 함수로 구현하는 것은 매우 어렵다고 알려져 있다. 프로그래머는 setjmp와 longjmp에 대해 어떠한 가정도 하지 말하야 한다"라고 말한다. Harbison과 Steele이 말한 주의 사항과 제약 사항들은 무엇을 의미하는 걸까? setjmp와 longjmp를 사용해서 Coroutine을 구현했다 한들 다른 환경으로 옮기면 작동하지 않는다. 더욱 나쁜 것은 잘못 구현한 것들도 적지 않다. setjmp/longjmp는 실제로 스택 하나로 구현하는 거라서 제대로 된 Coroutine을 구현할 수 없다. 스택이 하나뿐이기 때문에 엉뚱한 Coroutine이 스택에 있는 변수를 수정해 버릴 수 있다.</p>

<p>그래서 C에서 스택기반 Coroutine을 구현하려면 스택을 만들고 점프할 수 있는 기능이 필요하다. 세 번째는 특정 머신에서만 동작하는 C로(machine-specific C) 작성하는 방법이다. 이 방법은 Coroutine용 컨텍스트가 지원돼야 한다. POSIX나 <a href="http://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%9C%A0%EB%8B%89%EC%8A%A4_%EA%B7%9C%EA%B2%A9">Single UNIX Specification</a>의 C 라이브러리에는 getcontext, setcontext, makecontext, swapcontext같은 루틴이 있다. setcontext류 함수들은 setjmp/longjmp 함수보다 상당히 강력하다. 하지만, 표준을 준수하는 구현체는 흔치않다. 이 방법의 최대 단점은 Coroutine의 스택 크기가 고정돼 있다는 것이다. 그래서 실행 중에 스택 크기는 커지지 않는다. 그래서 사람들은 스택 오버플로우를 예방하는 차원에서 처음부터 너무 큰 스택을 할당하는 경향이 있다.</p>

<p>표준 라이브러리의 한계 때문에 사람들은 직접 Coroutine 라이브리를 만들어 사용한다. Russ Cox가 만든 libtask라는 게 있는데 꽤 좋다. Native C 라이브러리에 context 함수가 있으면 그냥 그걸 사용하고 그게 아니면 자체적으로 구현한 ARM, PowerPC, Sparc, x86용 라이브러리를 사용한다. 그 외 살펴볼 만한 라이브러리로 libpcl, coro, lthread, libCoroutine, libconcurrency, libcoro가 있다.</p>

<h3>C++에서의 Coroutine</h3>

<ul>
<li>Boost.Coroutine - Giovanni P. Deretta는 "Google Summer of Code 2006" 프로젝트로 이 라이브러리를 만들었다. 이 포터블한 Coroutine 라이브러리는 boost와 C++ 템플릿을 사용해서 만들었다. Boost.Coroutine은 아직 마무리되지 않았고 boost 공식 라이브러리가 아니므로 문서는 boost 싸이트가 아닌 다른 곳에서 호스팅하고 있다.</li>
<li>Mordor - Mozy는 2010년에 C++ Coroutine 라이브러리를 만들었다. 비동기 I/O를 사용하는 순차(sequential) 프로그래밍 모델처럼 사용할 수 있게 하였다.</li>
</ul>

<h3>C#에서의 Coroutine</h3>

<ul>
<li>MindTouch Dream - MindTouch Dream REST 프레임웤은 C# 2.0의 iterator 패턴으로 구현한 Coroutine이 들어 있다.</li>
<li>Caliburn - WPF용 Caliburn 스크린 패턴 프레임웤은 C# 2.0의 iterator를 사용해서 UI 프로그래밍과 비동기 씨나리오를 좀 더 쉽게 구현할 수 있게 하였다.</li>
<li>Power Threading Library - Jeffrey Richter가 만든 Power Threading Library에는 AsyncEnumerator라는 게 있다. 그래서 Coroutine 기반으로 비동기 프로그래밍을 쉽게 할 수 있다.</li>
<li>Sevletat Pieces - Yevhen Bobrov가 만든 Servelat Pieces 프로젝트는 Silverlight WCF 서비스에 비동기를 투명하게(transparent asynchrony) 제공하고 동기 콜을 비동기적으로 호출하는 방법도 제공한다.</li>
<li><a href="http://msdn.microsoft.com/en-us/library/dscyy5s0(VS.80).aspx">13</a> - .NET 프레임웤은 2.0+ 부터 자체적으로 iterator 패턴과 yield 키워드로 coroutine을 제공한다. </li>
</ul>

<h3>Python에서의 Coroutine</h3>

<ul>
<li><a href="http://www.python.org/peps/pep-0342.html">PEP 342</a> - Pythone 2.5에 확장된 Generator를 기반으로 Coroutine 같은 기능을 구현하기 쉬워졌다.</li>
<li><a href="http://codespeak.net/py/0.9.2/greenlet.html">Greenlets</a></li>
<li><a href="http://www.async.com.br/projects/kiwi/api/kiwi.tasklet.html">kiwi tasklets</a></li>
<li><a href="http://pypi.python.org/pypi/multitask">multitask</a></li>
<li><a href="http://chiral.j4cbo.com/trac">chiral</a></li>
<li><a href="http://code.google.com/p/cogen">cogen</a></li>
<li><a href="http://www.kamaelia.org/">Kamaelia</a></li>
<li><a href="https://github.com/ironport/shrapnel/">Shrapnel</a></li>
</ul>

<h3>Ruby에서의 Coroutine</h3>

<ul>
<li>Ruby 1.9은 fiber로 구현한 Coroutine을 지원한다.</li>
<li><a href="http://liber.sourceforge.net/coroutines.rb">Marc De Scheemaecker가 만든 것도 있다</a></li>
</ul>

<h3>Perl에서의 Coroutine</h3>

<ul>
<li><a href="http://search.cpan.org/dist/Coro/">Coro</a></li>
</ul>

<p>Perl 6 부터 Coroutine을 지원한다.</p>

<h3>Smalltalk에서의 Coroutine</h3>

<p>Smalltalk에서는 실행 스택이 First-class citizen이기 때문에 VM이 지원이나 다른 라이브러리 필요없이 Coroutine을 구현할 수 있다.</p>

<h3>Scheme에서의 Coroutine</h3>

<p>Since Scheme provides full support for continuations, the implementation of coroutines is nearly trivial, requiring only that a queue of continuations be maintained.</p>

<h3>Delphi에서의 Coroutine</h3>

<ul>
<li>Bart van der Werf가 만든 <a href="http://www.festra.com/wwwboard/messages/12899.html">Coroutine 함수</a>가 있는데 정말 작고 좋다.</li>
<li>Sergey Antonov는 <a href="http://hallvards.blogspot.com/2007/10/sergey-antonov-implements-yield-for.html">C# Yield를 델파이에서 구현했다</a>.</li>
</ul>

<h3>assembly에서의 Coroutine</h3>

<p>(이 부분은 이해할 수 없군요)</p>

<p>Machine-dependent assembly languages often provide direct methods for coroutine execution. For example, in MACRO-11, the assembly language of the PDP-11 family of minicomputers, the “classic” coroutine switch is effected by the instruction "JSR PC,@(SP)+" (which assembles as octal "004736") which jumps to the address popped from the stack and pushes the current (i.e that of the next) instruction address onto the stack. On VAXen (in Macro-32) the comparable instruction is "JSB @(SP)+" (which assembles as hex "9E 16" as the assembler shows it (with in effect bytes reversed). Even on a Motorola 6809 there is the instruction "JSR [,S++]", which assembles as (hex) "AD F1"; note the "++", as 2 bytes (of address) are popped from the stack. This instruction is much used in the (standard) 'monitor' Assist 09.</p>

<p>Simply calling back the routine whose address is on the top of the stack, does not, of course, exhaust the possibilities in assembly language(s)!</p>

<h2>See also</h2>

<ul>
<li>Unix pipes – 프로그램끼리 통신하는 데 사용하는 pipe도 Coroutine의 한 종류다.</li>
</ul>]]>
    </content>
  </entry>
  <entry>
    <title><![CDATA[ dogfeet-flavored-markdown ]]></title>
    <link href="http://dogfeet.github.com/articles/2012/dogfeet-flavored-markdown.html" />
    <updated>2012-05-19T15:00:00.000Z</updated>
    <id>http://dogfeet.github.com/articles/2012/dogfeet-flavored-markdown.html</id>
    <content type="html">
<![CDATA[
<p>'dogfeet-flavored-markdown'은 Markdown에서 Twitter처럼 <code>@mention</code>, <code>#hash</code>와 같은 표현을 사용하고 싶어서 'github-flavored-markdown'을 수정했다.</p>

<p>아이디어를 정리하고 자료 조사를 끝낸건 3개월 전인데 게으름이 봄바람을 타고와 늦어 졌다.</p>

<p><img src="http://dogfeet.github.com/articles/2012/dogfeet-flavored-markdown/keyboard.png" alt="keyboard" title="" /></p>

<p>이 글을 읽기 전에 <a href="http://github.github.com/github-flavored-markdown/">GitHub의 GitHub-Flavored-Markdown 설명서</a>를 읽어 보는 것이 좋다.</p>

<h2>github-flavored-markdown</h2>

<p>github-flavored-markdown은 다음과 같은 표현을 지원한다.</p>

<pre><code>* SHA: be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a>
* #Num: #1
* User/#Num: mojombo#1
* User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a>
</code></pre>

<p>하지만 실제로 작동하는 것은 '사용자/저장소' 패턴이 명시된 다음의 두 경우 뿐이다:</p>

<ul>
<li>User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a></li>
<li>User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></li>
</ul>

<p>나머지 패턴도 동작하게 하려면 '사용자/저장소' 정보가 필요하다. github-flavored-markdown의 용법은 다음과 같은데 인자로 '사용자/저장소'를 넘겨줄 수 있다:</p>

<pre><code>var ghm = require("github-flavored-markdown")
ghm.parse("I **love** GHM.\n\n#2", "isaacs/npm")
// returns:
// '&lt;p&gt;I &lt;strong&gt;love&lt;/strong&gt; GHM.  '+
// '&lt;a href=\'<a href='http://github.com/isaacs/npm/issues/#issue/2\'&gt;#2&lt;/a&gt;&lt;/p&gt'>http://github.com/isaacs/npm/issues/#issue/2\'&gt;#2&lt;/a&gt;&lt;/p&gt</a>;'
</code></pre>

<p>그러면 나머지 패턴도 해당 저장소에 대한 GitHub 링크가 생성된다:</p>

<ul>
<li>SHA: be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2</li>
<li>User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2</li>
<li><a href="/site/tagmap.html#Num">#Num</a>: <a href="/site/tagmap.html#1">#1</a></li>
<li>User/#Num: mojombo#1</li>
</ul>

<p>하지만 custom 하게 수정이 필요하고, 특히 [Docpad][]의 Markdown 을 수정해서 하드코딩하거나 이 정보를 설정할 수 있도록 수정해야 한다.</p>

<h2>dogfeet-flavored-markdown</h2>

<p>dogfeet-flavored-markdown(이하 DFM)은 DFM에서 '사용자/저장소' 정보가 필요한 나머지 패턴은 삭제했다. 그래서 다음과 같은 패턴만 사용할 수 있다:</p>

<ul>
<li>User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a></li>
<li>User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></li>
</ul>

<p>대신 <code>@mention</code>과 <code>#hash</code>를 추가 했다. 정확한 패턴은 다음과 같다:</p>

<ul>
<li>mention - <code>(^|[ \t]+)@([a-zA-Z0-9]+)</code></li>
<li>hash - <code>(^|[ \t]+)#([ㄱ-ㅎ가-힣a-zA-Z0-9]+)</code></li>
</ul>

<p>다시 말해서 줄 처음에 시작하는 <code>@mention</code>이나 앞에 공백(space, tab)문자가 있는 것만 인식한다.</p>

<p>이 규칙이 중요할 때가 있는데, <code>#</code>으로 Heading을 표현하는 Markdown에서 중요하다. 줄 맨앞에서 <code>#Heading</code>이라고 표현하면 DFM가 처리하는 것이 아니라 showdown 엔진이 처리하기 때문에 링크가 생성되지 않고 <code>&lt;h1&gt;Heading&lt;/h1&gt;</code>이라고 해석된다. 이 것은 해석하는 순서의 문제다.</p>

<p>그리고 <code>&lt;code&gt;</code> 블럭과 <code>&lt;a&gt;</code> 블럭에 있는 것은 무시한다. 간단히 말하면 <code>@mention</code>과 <a href="https://twitter.com/#!/mention의">@mention의</a> 차이이고 <a href="http://twitter.com"><a href="https://twitter.com/#!/twitter">@twitter</a></a>와 <a href="https://twitter.com/#!/twitter">@twitter</a> 의 차이다. 원문은 다음과 같다:</p>

<pre><code>그리고 `&lt;code&gt;` 블럭과 `&lt;a&gt;` 블럭에 있는 것은 무시한다. 간단히 말하면 `@mention`과 @mention의 차이이고 [@twitter](<a href='http://twitter.com)와'>http://twitter.com)와</a> @twitter 의 차이다. 원문은 다음과 같다:
</code></pre>

<h3>예제</h3>

<p>이 것은 코드 블럭이 아니라 잘 된다:</p>

<ul>
<li>User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2</li>
<li>User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a></li>
<li><a href="/site/tagmap.html#Num">#Num</a>: <a href="/site/tagmap.html#1">#1</a></li>
<li>User/#Num: mojombo#1</li>
<li>User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a>, <code><a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a></code></li>
<li><a href="https://twitter.com/#!/pismute">@pismute</a></li>
<li><a href="/site/tagmap.html#EveryoneIsBeautiful">#EveryoneIsBeautiful</a> <code>, #EveryoneIsBeautiful,#EveryoneIsBeautiful</code></li>
<li><a href="/site/tagmap.html#한글">#한글</a> <code>, #한글,#한글</code></li>
</ul>

<p>(이글에서는 <code>#hash</code>는 Twitter가 아니라 이 블로그의 tagmap 페이지로 연결된다.)</p>

<p>다음은 코드 블럭이라 DFM은 동작하지 않는다. 하지만 GFM의 것은 코드 블럭의 것도 처리한다. 다시 말하지만 GFM의 것은 코드 블럭에서도 링크를 생성 하지만 Dogfeet에서 추가한 <code>@mention</code>과  <code>#hash</code>는 코드 블럭에서는 링크를 생성하지 않는다:</p>

<pre><code>* SHA: be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User@SHA ref: mojombo@be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2
* User/Project@SHA: <a href='http://github.com/mojombo/god/commit/be6a8cc1c1ecfe9489fb51e4869af15a13fc2cd2'>mojombo/god@be6a8cc</a>
* #Num: #1
* User/#Num: mojombo#1
* User/Project#Num: <a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a>, `<a href='http://github.com/mojombo/god/issues/#issue/1'>mojombo/god#1</a>`
* @pismute
* #EveryoneIsBeautiful `, #EveryoneIsBeautiful,#EveryoneIsBeautiful`
* #한글 `, #한글,#한글`
</code></pre>

<h3>Coding</h3>

<p>기본적으로 내장된 템플릿은 twitter로 연결된다. 그래서 <code>@mention</code>과 <code>#hash</code>를 클릭하면 twitter로 연결된다. 하지만 바꿀 수 있다.</p>

<pre><code>var templates={
  '@': function(key){ return ['@@', key].join(''); }
  , '#': function(key){ return ['##', key].join(''); }
}
var dfm = require("dogfeet-flavored-markdown");
gfm.parse("I **love** @DFM. #DFM", {templates:templates});
// returns:
// '&lt;p&gt;I &lt;strong&gt;love&lt;/strong&gt; @@DFM. ##DFM'
</code></pre>

<h3>설치</h3>

<p>이 모듈은 npmjs.org에 올릴 계획이 없다. 그러니 다음과 같이 설치해야 한다.</p>

<pre><code>npm install git://github.com/dogfeet/dogfeet-flavored-markdown.git#master
</code></pre>

<h2>Docpad Plugin</h2>

<p>Docpad Plugin을 만들어서 이 블로그에 했다. 다음은 Docpad Plugin이다:</p>

<pre><code># Export Plugin
module.exports = (BasePlugin) -&gt;
    # Define Plugin
    class DogdownPlugin extends BasePlugin
        # Plugin name
        name: 'dogdown'

        # Plugin priority
        priority: 700 

        templates:
            '@': ( key ) -&gt;
                ['&lt;a href="<a href='https://twitter.com/#!/'>https://twitter.com/#!/</a>', key, '"&gt;@', key, '&lt;/a&gt;'].join('')
                #['&lt;a href="<a href='https://github.com/'>https://github.com/</a>', key, '"&gt;@', key, '&lt;/a&gt;'].join('')
            '#': ( key ) -&gt;
                ['&lt;a href="/site/tagmap.html#', key, '"&gt;#', key, '&lt;/a&gt;'].join('')

        # Render some content
        render: (opts,next) -&gt;
            # Prepare
            {inExtension,outExtension,templateData,content} = opts

            # Check our extensions
            if inExtension in ['md','markdown'] and outExtension is 'html'
                # Requires
                markdown = require('dogfeet-flavored-markdown')

                # Render
                opts.content = markdown.parse( content, { templates:@templates } ) 

            # Done, return back to DocPad
            return next()
</code></pre>

<p>templates을 수정해서 단순히 링크를 생성하는 것외에 통계나 문서의 메타 정보도 구할 수 있지만 그리하진 않았다.</p>

<h2>마치며</h2>

<p>이 모듈의 <a href="https://github.com/dogfeet/dogfeet-flavored-markdown">저장소</a>에 올려 두었다.</p>]]>
    </content>
  </entry>
</feed>
