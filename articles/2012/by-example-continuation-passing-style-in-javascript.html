<!DOCTYPE html><html lang="en"><head><!--Meta--><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>#dogfeet - 예제로 설명하는 자바스크립트에서의 Continuation-passing style</title><meta name="description" /><meta name="keywords" /><meta name="author" content="Yongjae Choi" /><!--Icons--><link rel="shortcut icon" href="images/favicon.ico" /><link rel="apple-touch-icon" href="images/apple-touch-icon.png" /><link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png" /><link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png" /><link rel="alternate" type="application/atom+xml" title="개발새발 &raquo; Feed" href="http://feeds.feedburner.com/github/dogfeet" /><!--Shims: IE6-8 support of HTML5 elements--><!--[if lt IE 9]>
        <script async src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><!--Styles--><link rel="stylesheet" href="/css/bootstrap.min.css" media="screen, projection" /><link rel="stylesheet" href="/css/bootstrap-responsive.min.css" media="screen, projection" /><link rel="stylesheet" href="/css/highlight/github.css" media="screen, projection" /><link rel="stylesheet" href="/styles/style.css" media="screen, projection" /><link rel="stylesheet" href="/styles/markdown.css" media="screen, projection" /><!--Scripts--><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script><script src="http://connect.facebook.net/en_US/all.js#xfbml=1"></script><script src="/js/bootstrap.min.js"></script><script src="/scripts/script.js"></script></head><body><!--Topbar--><div class="navbar" navbar-fixed-top><div class="navbar-inner"><div class="container-fluid"><a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></a><a class="brand" href="/">dogfeet</a><div class="nav-collapse"><ul class="nav"><li><a href="/site/tagmap.html">Tagmap</a></li><li><a href="/site/archive.html">Archive</a></li><li><a href="/site/atelier.html">Atelier</a></li><li><a href="http://feeds.feedburner.com/github/dogfeet"><img src="http://forum.tattersite.com/ko/style/Textcube/feed-icon.png" /></a></li></ul><form id="search-form" class="pull-right" action="http://google.com/search" method="get" navbar-search><input type="hidden" name="q" value="site:dogfeet.github.com" /><input type="text" name="q" results="0" placeholder="Search" search-query /></form></div></div></div></div><!--Markup--><div class="container-fluid"><div class="row-fluid"><section class="content" span10><script src="http://platform.twitter.com/widgets.js"></script><script>//facebook
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));

//google plusone
(function() {
  var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
  po.src = 'https://apis.google.com/js/plusone.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
})();
</script><article id="post" typeof="sioc:post" about="/articles/2012/by-example-continuation-passing-style-in-javascript.html" lang="ko-kr" .post .undefined><header><h1 property="dcterms:title">예제로 설명하는 자바스크립트에서의 Continuation-passing style</h1></header><footer class="modern-font" .small-font><span>by <a href="/authors/yongjae-choi.html">Yongjae Choi</a></span>
 | <span property="dc:created">2012 Feb 24</span>
 | <a href="/site/tagmap.html#javascript" class="tag">javascript</a> <a href="/site/tagmap.html#cps" class="tag">CPS</a> <a href="/site/tagmap.html#programming" class="tag">programming</a> <a href="/site/tagmap.html#continuation" class="tag">continuation</a> | <span><a href="/articles/2012/by-example-continuation-passing-style-in-javascript.html#disqus_thread" data-disqus-identifier="/articles/2012/by-example-continuation-passing-style-in-javascript.html"></a></span>
<style rel="stylesheet" media="screen, projection" scoped="scoped">#social-buttons {
  margin-left: 30px;
}</style><div id="social-buttons" class="pull-right"><ul class="unstyled"><li><a class="twitter-share-button" href="https://twitter.com/share" data-url="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html" data-via="lnyarl" data-count="horizontal" data-lang="en">Tweet</a></li><li><div class="g-plusone" data-size="medium" data-href="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html"></div></li><li><div class="fb-like" data-href="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html" data-send="false" data-layout="button_count" data-show-faces="false"></div></li></ul></div></footer><div property="sioc:content"><p><em>이 글은 <a href="http://matt.might.net/articles/by-example-continuation-passing-style/">By example: Continuation-passing style in JavaScript</a>를 번역한 것이다. CPS에 대해 열심히 적어놨는데 간단히 말하자면 함수 호출의 끝에 원래의 context로 돌아가지 않고, 새로이 불릴 함수를 caller가 넘겨주는 프로그래밍 스타일을 말한다.</em>

</p>
<p><img src="/articles/2012/by-example-continuation-passing-style-in-javascript/279433682_23ac618518.jpg" alt="recursive">

</p>
<p>(Photo by <a href="http://www.flickr.com/photos/gadl/279433682/">gadl</a>)

</p>
<p>컨티뉴에이션-패싱 스타일(CPS)은 1970년대에 프로그래밍 스타일의 하나로 생겨났고, 1980, 1990년대에 고급 프로그래밍 언어 컴파일러의 중간 표현으로써 주목받았다.

</p>
<p>이 프로그래밍 스타일은 논 블로킹 시스템(그리고 보통 분산 시스템)에서 다시 조명받기 시작했다.

</p>
<p>내가 박사 과정일 때에 CPS는 비밀무기였다. 그래서 난 CPS를 좋아한다. 아마 그 덕분에 난 2년 정도를 아낄 수 있었고, 끝없는 고통에서 벗어날 수 있었다.

</p>
<p>이 글은 자바스크립트에서의 논 블로킹 프로그래밍 스타일로서의 CPS와 함수형 언어의 중간 형태로서의 CPS, 이렇게 두 가지 관점에서 CPS를 소개하는 글이다.

</p>
<p>주제는 다음과 같다. 

</p>
<ul>
<li>자바스크립트에서의 CPS</li>
<li>Ajax 프로그래밍을 위한 CPS</li>
<li>(node.js에서) 논 블로킹 프로그래밍을 위한 CPS </li>
<li>분산 프로그래밍을 위한 CPS </li>
<li>CPS를 이용해서 예외처리하는 방법 </li>
<li>미니말 Lisp을 위한 CPS 컨버터 </li>
<li><strike>Lisp에서 call/cc 구현하는 방법</strike><sup>이 섹션은 이해가 모자라 제거했다.</sup></li>
<li>자바스크립트에서 call/cc 구현하는 방법 </li>
</ul>
<p>시작하자.

</p>
<h2>'컨티뉴에이션-패싱 스타일'이 뭐야?</h2>
<p>만약 컨티뉴에이션을 지원하는 언어을 사용한다는 것은 프로그래머가 예외와 백트래킹, 스레드, 제네레이터(generator)등의 제어 구조를 추가할 수 있다는 것을 의미한다.

</p>
<p>많은 컨티뉴에이션에 대한 설명은 막연하고 불충분하다. 뭔가 정말 도움이 되는 설명이 필요하다. 이 컨티뉴에이션-패싱 스타일이 바로 그런 것들을 해결해줄 것이다.

</p>
<p>컨티뉴에이션-패싱 스타일은 코드라는 측면에서 컨티뉴에이션과 같다.

</p>
<p>하지만, 다음의 원리만 깨우치면 프로그래머는 컨티뉴에이션-패싱 스타일을 스스로 깨달은 것이나 마찬가지다.

</p>
<pre><code>어떠한 프로시저도 <span class="keyword">caller</span>에 리턴(<span class="keyword">return</span>)하지 않는다.</code></pre>
<p>아래 힌트는 CPS로 프로그래밍하는 데 도움이 된다:

</p>
<pre><code>프로시저는 리턴 값으로 호출 가능한 콜백을 받는다.</code></pre>
<p>프로시저가 caller로 "리턴" 해야 할 때, 프로시저는 return 대신 "현재 컨티뉴에이션(current continuation)" 콜백을 호출한다. (이 콜백은 caller가 넘겨줬다.)

</p>
<p>컨티뉴에이션은 퍼스트-클래스 리턴 포인트(first-class return point)이다.

</p>
<h3>예제: 항등 함수</h3>
<p>항등 함수가 하나 있다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">id</span><span class="params">(x)</span> {</span>
    <span class="keyword">return</span> x ;
}</code></pre>
<p>이 것을 CPS로 하면 다음과 같다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">id</span><span class="params">(x,cc)</span> {</span>
    cc(x) ;
}</code></pre>
<p>가끔 현재 컨티뉴에이션 인자를 ret로 명명해서 코드를 좀 더 명확하게 할 수 있다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">id</span><span class="params">(x,ret)</span> {</span>
    ret(x) ;
}</code></pre>
<h3>예제: 단순무식한 팩토리얼</h3>
<p>아래는 보통의 단순무식한 팩토리얼이다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n)</span> {</span>
    <span class="keyword">if</span>(n == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">1</span> ;
    <span class="keyword">else</span>
        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>) ;
}</code></pre>
<p>그리고 이를 CPS로 작성하면 다음과 같다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n,ret)</span> {</span>
    <span class="keyword">if</span>(n == <span class="number">0</span>)
        ret(<span class="number">1</span>) ;
    <span class="keyword">else</span>
        fact(n-<span class="number">1</span>,<span class="keyword">function</span>(t0) <span class="cell">{ ret(n * t0) }</span>) ;
}</code></pre>
<p>그리고 이 함수를 실제로 "사용"할 때에는 다음과 같이 콜백을 넘겨준다:

</p>
<pre><code><span class="function"><span class="title">fact</span> <span class="params">(<span class="number">5</span>,<span class="keyword">fun</span><span class="function_name">ction</span>(n) <span class="tuple">{
    console.<span class="function_name">log</span>(n); // 콘솔에 <span class="number">120</span>이 출력된다.
}</span>)</code></pre>
<h3>예제: Tail-recursive 팩토리얼</h3>
<p>아래는 tail-recursive 팩토리얼의 구현이다.

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n)</span> {</span>
    <span class="keyword">return</span> tail_fact(n,<span class="number">1</span>) ;
}

<span class="function"><span class="keyword">function</span> <span class="title">tail_fact</span><span class="params">(n,a)</span> {</span>
    <span class="keyword">if</span>(n == <span class="number">0</span>)
        <span class="keyword">return</span> a ;
    <span class="keyword">else</span>
        <span class="keyword">return</span> tail_fact(n-<span class="number">1</span>,n*a) ;
}</code></pre>
<p>그리고 아래는 CPS.

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n,ret)</span> {</span>
    tail_fact(n,<span class="number">1</span>,ret) ;
}

<span class="function"><span class="keyword">function</span> <span class="title">tail_fact</span><span class="params">(n,a,ret)</span> {</span>
    <span class="keyword">if</span>(n == <span class="number">0</span>)
        ret(a) ;
    <span class="keyword">else</span>
        tail_fact(n-<span class="number">1</span>,n*a,ret) ;
}</code></pre>
<h2>CPS와 Ajax</h2>
<p>Ajax는 자바스크립트의 XMLHttpRequest 객체를 이용해 비동기적으로 서버에서 데이터를 가져오는 웹 프로그래밍 기술이다.

</p>
<p>(데이터가 꼭 XML일 필요는 없다.)

</p>
<p>CPS는 Ajax 프로그래밍을 우아하게 하는 방법을 제공한다.

</p>
<p>XMLHttpRequest를 이용하면 블로킹 프로시저인 'fetch(url)'을 작성할 수 있다. 이 프로시저는 url이 가리키는 페이지의 내용을 변수에 담아 문자열로 리턴한다.

</p>
<p>이런 방식의 문제는 자바스크립트가 단일 스레드만 지원하는 언어라는 점이다. 자바스크립트가 블럭되면 그동안 브라우저가 멈춰버린다.

</p>
<p>그러면 사용자 경험이 망가진다.

</p>
<p>더 나은 방식은 프로시저를 'fetch(url, callback)' 형식으로 만드는 것이다. 이 프로시저는 블로킹 되지 않기 때문에, 코드 실행이나 브라우저 렌더링을 막지 않는다. 이 프로시저에는 http 요청이 끝나고 호출되야 할 콜백을 넘겨준다.

</p>
<p>이렇게 코딩하는 과정에서 부분적으로 코딩 스타일이 CPS로 자연스레 변한다.

</p>
<h3>fetch 구현</h3>
<p>콜백 유무에 따라 non-blocking 모드나 블러킹 모드를 스위칭하며 동작하는 fetch는 어렵지 않게 구현할 수 있다:

</p>
<pre><code><span class="comment">/*
 fetch는 클라이언트에서 서버로 리퀘스트를
 보낼 때 블로킹될 수도 있고 안될 수도 있다.

 만약 url만 넘겨주면 프로시저는 블로킹되고
 url이 가리키는 페이지의 내용을 리턴한다.

 만약 onSuccess 콜백이 주어지면 
 프로시저는 논 블로킹이 된다. 
 콜백은 페이지의 내용을 
 인자로 받아 호출될 것이다.

 만약 onFail 콜백까지 주어지면
 요청이나 응답이 실패했을 때에 
 onFail이 fatch 프로시저에 의해서 호출된다.
*/</span>

<span class="function"><span class="keyword">function</span> <span class="title">fetch</span> <span class="params">(url, onSuccess, onFail)</span> {</span>
    <span class="comment">// 콜백을 정의했을 때만 비동기로 작동한다.</span>
    <span class="keyword">var</span> async = onSuccess? <span class="keyword">true</span>: <span class="keyword">false</span>;
    <span class="comment">// (이 라인의 비효율성에 대해 태클 걸지 </span>
    <span class="comment">//  않길 바란다. 이건 중요한 게 아니다.)</span>

    <span class="keyword">var</span> req ; <span class="comment">// XMLHttpRequest 객체.</span>

    <span class="comment">// XMLHttpRequest 콜백:</span>
    <span class="function"><span class="keyword">function</span> <span class="title">rocessReqChange</span><span class="params">()</span> {</span>
        <span class="keyword">if</span>(req.readyState == <span class="number">4</span>) {
            <span class="keyword">if</span>(req.status == <span class="number">200</span>) {
                <span class="keyword">if</span>(onSuccess)
                    onSuccess(req.responseText, url, req);
            } <span class="keyword">else</span> {
                <span class="keyword">if</span>(onFail)
                    onFail(url, req);
            }
        }
    }

    <span class="comment">// XMLHttpRequest 객체를 만든다:</span>
    <span class="keyword">if</span>(window.XMLHttpRequest)
        req =<span class="keyword">new</span> XMLHttpRequest();
    <span class="keyword">elseif</span>(window.ActiveXObject)
        req =<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);

    <span class="comment">// 비동기 모드라면 콜백을 세팅한다:</span>
    <span class="keyword">if</span>(async)
        req.onreadystatechange = processReqChange;

    <span class="comment">// 서버로 요청한다.</span>
    req.open(<span class="string">"GET"</span>, url, async);
    req.send(<span class="keyword">null</span>);

    <span class="comment">// 비동기 모드라면,</span>
    <span class="comment">//  요청 객체를 리턴한다; 아니라면</span>
    <span class="comment">//  응답을 리턴하다.</span>
    <span class="keyword">if</span>(async)
        <span class="keyword">return</span> req ;
    <span class="keyword">else</span>
        <span class="keyword">return</span> req.responseText ;
}</code></pre>
<h3>예제: 데이터 가져오기</h3>
<p>UID의 이름을 가져오는 프로그램이 필요하다고 치고, fetch를 이용해서 두 버전(동기, 비동기)을 다 만들어보자.

</p>
<pre><code>// 요청이 끝날 때까지 블로킹된다:
var someName = fetch(<span class="string">"./1031/name"</span>) <span class="comment">;</span>

document<span class="preprocessor">.write</span> (<span class="string">"someName: "</span>+ someName +<span class="string">"&lt;br>"</span>) <span class="comment">;</span>

// 블로킹되지 않는다:
fetch(<span class="string">"./1030/name"</span>,function(name) {
    document<span class="preprocessor">.getElementById</span>(<span class="string">"name"</span>)<span class="preprocessor">.innerHTML</span> = name <span class="comment">;</span>
}) <span class="comment">;</span></code></pre>
<p>(<a href="http://matt.might.net/articles/by-example-continuation-passing-style/code/client.html">예제</a>)

</p>
<h2>CPS and non-blocking programming</h2>
<p><a href="http://nodejs.org/">node.js</a>는 블로킹 프로시저가 없는 자바스크립트를 위한 고성능, 서버사이드 플랫폼이다. 

</p>
<p>node.js에서는 보통의 블로킹되는 프로시저(e.g. 네트워크, 파일 I/O)가 전부 콜백을 받고 결과는 콜백을 실행하는 것을 반환한다.

</p>
<p>프로그램을 CPS로 변환하는 것으로 node.js 프로그래밍 다운 프로그래밍이 뭔지 살펴보자.

</p>
<h3>예제 : 간단한 웹 서버</h3>
<p>node.js 웹 서버는 파일을 읽는 프로시저에 컨티뉴에이션을 넘긴다. select를 이용하는 것보다 CPS를 이용하는 것이 더 간단한 non-blocking IO이다.

</p>
<pre><code><span class="keyword">var</span> sys = require(<span class="string">'sys'</span>) ;
<span class="keyword">var</span> http = require(<span class="string">'http'</span>) ;
<span class="keyword">var</span> url = require(<span class="string">'url'</span>) ;
<span class="keyword">var</span> fs = require(<span class="string">'fs'</span>) ;

<span class="comment">// 웹 서버 루트 경로:</span>
<span class="keyword">var</span> DocRoot =<span class="string">"./www/"</span>;

<span class="comment">// 콜백을 넘겨주면서 웹 서버를 만든다:</span>
<span class="keyword">var</span> httpd = http.createServer(<span class="keyword">function</span>(req, res) {
    sys.puts(<span class="string">" request: "</span>+ req.url) ;

    <span class="comment">// url 파싱:</span>
    <span class="keyword">var</span> u = url.parse(req.url,<span class="literal">true</span>) ;
    <span class="keyword">var</span> path = u.pathname.split(<span class="string">"/"</span>) ;

    <span class="comment">// 경로에서 .. 를 없앤다.</span>
    <span class="keyword">var</span> localPath = u.pathname ;
    <span class="comment">//  "&lt;dir>/.." => ""</span>
    <span class="keyword">var</span> localPath = localPath.replace(<span class="regexp">/[^/</span>]+\/+[.][.]/g,<span class="string">""</span>) ;
    <span class="comment">//  ".." => "."</span>
    <span class="keyword">var</span> localPath = DocRoot + 
    localPath.replace(<span class="regexp">/[.][.]/g</span>,<span class="string">"."</span>) ;

    sys.puts(<span class="string">" local path: "</span>+ localPath) ;

    <span class="comment">// 요청받은 파일을 읽어서 되돌려 보낸다.</span>
    <span class="comment">// Note: readFile은 현재 컨티뉴에이션을 넘겨받는다.</span>
    fs.readFile(localPath,<span class="keyword">function</span>(err,data) {
        <span class="keyword">var</span> headers = {} ;

        <span class="keyword">if</span>(err) {
            headers[<span class="string">"Content-Type"</span>] =<span class="string">"text/plain"</span>;
            res.writeHead(<span class="number">404</span>, headers);
            res.write(<span class="string">"404 File Not Found\n"</span>) ;
            res.end() ; 
        } <span class="keyword">else</span> {
            <span class="keyword">var</span> mimetype = MIMEType(u.pathname) ;

            <span class="comment">// 만약 'content type'을 못 찾으면</span>
            <span class="comment">// 클라이언트가 알아서 하도록 놔두자.</span>
            <span class="keyword">if</span>(mimetype)
                headers[<span class="string">"Content-Type"</span>] = mimetype ;

            res.writeHead(<span class="number">200</span>, headers) ;
            res.write(data) ;
            res.end() ;
        }
    }) ;
}) ;

<span class="comment">// 확장자와 MIME 타입을 매핑 시킨다:</span>
<span class="keyword">var</span> MIMETypes = {
    <span class="string">"html"</span> :<span class="string">"text/html"</span>,
    <span class="string">"js"</span>   :<span class="string">"text/javascript"</span>,
    <span class="string">"css"</span>  :<span class="string">"text/css"</span>,
    <span class="string">"txt"</span>  :<span class="string">"text/plain"</span>
} ;

<span class="function"><span class="keyword">function</span> <span class="title">MIMEType</span><span class="params">(filename)</span> {</span>
    <span class="keyword">var</span> parsed = filename.match(<span class="regexp">/[.](.*)$/</span>) ;
    <span class="keyword">if</span>(!parsed)
        <span class="keyword">return</span> <span class="literal">false</span>;
    <span class="keyword">var</span> ext = parsed[<span class="number">1</span>] ;
    <span class="keyword">return</span> MIMEType[ext] ;
}

<span class="comment">// 8000번 포트를 리스닝(listening) 포트로 하여 서버를 시작한다:</span>
httpd.listen(<span class="number">8000</span>) ;</code></pre>
<h2>분산 컴퓨팅을 위한 CPS</h2>
<p>CPS를 사용하면 로컬과 분산에서 처리하는 것이 더 간단해진다.

</p>
<p>조합(combination)을 계산해주는 함수인 choose를 작성해보자. 우선 일반적인 방법:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">choose</span> <span class="params">(n,k)</span> {</span>
    <span class="keyword">return</span> fact(n) /
        (fact(k) * fact(n-k)) ;
}</code></pre>
<p>이제 이 코드가 로컬 컴퓨터가 아닌 서버에서 동작해야 하면

</p>
<p>fact 프로시저가 블로킹되어 서버에서 응답이 오기까지 기다리도록 작성할 수도 있지만, 이 방법은 좋지 않다.

</p>
<p>대신 CPS로 choose를 작성해보자:

</p>
<pre><code><span class="title">function</span> choose(n,k,ret) {
    <span class="title">fact</span> (n,  function(factn) {
    <span class="title">fact</span> (n-k,function(factnk) {
    <span class="title">fact</span> (k,  function(factk) {
    <span class="title">ret</span>  (factn / (factnk * factk)) }) }) })
}</code></pre>
<p>이제 비동기적으로 팩토리얼을 계산하는 fact 프로시저 만들기가 쉬워졌다. 아래와 같이 말이다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fact</span><span class="params">(n,ret)</span> {</span>
    fetch (<span class="string">"./fact/"</span>+ n,<span class="keyword">function</span>(res) {
        ret(eval(res))
    }) ;
}</code></pre>
<h2>CPS로 예외처리하기</h2>
<p>프로그램을 CPS로 작성하면, 언어의 표준 예외처리 매커니즘이 쓸모없어진다. 하지만, CPS로 예외처리를 구현하는 것은 어렵지 않다.

</p>
<p>예외처리는 컨티뉴에이션의 특수한 케이스다.

</p>
<p>'현재 예외적 컨티뉴에이션(current exceptional continuation)'을 '현재 컨티뉴에이션(current continuation)'과 함께 던지는 것으로 try/catch 구문을 없앨 수 있다.

</p>
<p>다음 예제는 Exception을 이용해서 팩토리얼 "total" 버전을 정의한다:

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">fact</span> <span class="params">(n)</span> {</span>
    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)
        <span class="keyword">throw</span> <span class="string">"n &lt; 0"</span>;
    <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">0</span>)
        <span class="keyword">return</span> <span class="number">1</span> ;
    <span class="keyword">else</span>
        <span class="keyword">return</span> n * fact(n-<span class="number">1</span>) ;
}

<span class="function"><span class="keyword">function</span> <span class="title">total_fact</span> <span class="params">(n)</span> {</span>
    <span class="keyword">try</span>{
        <span class="keyword">return</span> fact(n) ;
    }<span class="keyword">catch</span>(ex) {
        <span class="keyword">return</span> <span class="literal">false</span>;
    }
}

document.write(<span class="string">"total_fact(10): "</span>+ total_fact(<span class="number">10</span>)) ;
document.write(<span class="string">"total_fact(-1): "</span>+ total_fact(-<span class="number">1</span>)) ;</code></pre>
<p>예외를 처리하는 컨티뉴에이션을 추가해서 throw, try, catch 를 제거할 수 있다:

</p>
<pre><code>function fact (n,<span class="keyword">ret</span>,thro) {
    if(n &lt; <span class="number">0</span>)
        thro (<span class="string">"n &lt; 0"</span>)<span class="comment">;</span>
    else if(n == <span class="number">0</span>)
        <span class="keyword">ret</span>(<span class="number">1</span>)<span class="comment">;</span>
    else
        fact(n-<span class="number">1</span>,
            function(t0) {
                <span class="keyword">ret</span>(n*t0)<span class="comment">;</span>
            }, thro)<span class="comment">;</span>
}

function total_fact (n,<span class="keyword">ret</span>) {
    fact (n,<span class="keyword">ret</span>,
        function(ex) {
            <span class="keyword">ret</span>(false)<span class="comment">;</span>
        })<span class="comment">;</span>
}

total_fact(<span class="number">10</span>,function(res) {
    document<span class="preprocessor">.write</span>(<span class="string">"total_fact(10): "</span>+ res)<span class="comment">;</span>
})<span class="comment">;</span>

total_fact(-<span class="number">1</span>,function(res) {
    document<span class="preprocessor">.write</span>(<span class="string">"total_fact(-1): "</span>+ res)<span class="comment">;</span>
})<span class="comment">;</span></code></pre>
<h2>컴파일에서 CPS</h2>
<p>지난 30년간 CPS는 함수형 언어 컴파일러에서 사용하는 강력한 중간 표현식이었다.

</p>
<p>CPS는 함수의 리턴, 예외, <a href="http://en.wikipedia.org/wiki/Continuation#First-class_continuations">퍼스트-클래스 컨티뉴에이션(first-class continuation)</a>을 제거한다. 함수 호출은 그냥 하나의 점프 명령어로 치환된다.

</p>
<p>다시 말해서, CPS는 컴파일러 대신에 많은 것들을 해결해준다. 

</p>
<h3>람다 계산법을 CPS로 바꾸기</h3>
<p>람다는 보편적인 계산을 할 수 있는 표현식(어플리케이션, 익명함수 변수 레퍼런스)을 가진 Lisp의 축소판이다. 

</p>
<pre><code>exp ::= (expexp)           <span class="comment">; 함수 어플리케이션</span>
    |  (lambda (var) exp)  <span class="comment">; 익명 함수</span>
    |  var                 <span class="comment">; 변수 레퍼런스</span></code></pre>
<p>아래의 코드는 이 언어를 CPS로 변환해주는 도구다:

</p>
<pre><code><span class="list">(<span class="title">define</span><span class="body"> <span class="list">(<span class="title">cps-convert</span><span class="body"> term cont</span>)</span>
    <span class="list">(<span class="title">match</span><span class="body"> term
        [<span class="quoted">`(,f ,e)</span>
            <span class="comment">; =></span>
            <span class="list">(<span class="title">let</span><span class="body"> <span class="list">(<span class="body"><span class="list">(<span class="body">$f <span class="list">(<span class="title">gensym</span><span class="body"> 'f</span>)</span></span>)</span>
                    <span class="list">(<span class="body">$e <span class="list">(<span class="title">gensym</span><span class="body"> 'e</span>)</span></span>)</span></span>)</span>
               <span class="list">(<span class="title">cps-convert</span><span class="body"> f <span class="quoted">`(lambda (,$f)
                    ,(cps-convert e `(lambda (,$e)
                        (,$f ,$e ,cont))))</span></span>)</span></span>)</span>]

        [<span class="quoted">`(lambda (,v) ,e)</span>
            <span class="comment">; =></span>
             <span class="list">(<span class="title">let</span><span class="body"> <span class="list">(<span class="body"><span class="list">(<span class="body">$k <span class="list">(<span class="title">gensym</span><span class="body"> 'k</span>)</span></span>)</span></span>)</span>
               <span class="quoted">`(,cont (lambda (,v ,$k)
                    ,(cps-convert e $k)))</span></span>)</span>]

        [<span class="list">(<span class="body">? symbol?</span>)</span>
            <span class="comment">; =></span>
            <span class="quoted">`(,cont ,term)</span>]</span>)</span></span>)</span>

<span class="list">(<span class="title">define</span><span class="body"> <span class="list">(<span class="title">cps-convert-program</span><span class="body"> term</span>)</span>
    <span class="list">(<span class="title">cps-convert</span><span class="body"> term <span class="quoted">'(lambda (ans) ans)</span></span>)</span></span>)</span></code></pre>
<p>관심 있는 사람은, <a href="http://www.brics.dk/~danvy/">올리비에 댄비(Olivier Danvy)</a>가 효과적인 CPS 변환기에 관한 많은 논문을 써냈으니 참고하길 바란다.

</p>
<h2>JavaScript에서 call/cc 구현하기</h2>
<p>만약 어떤 자바스크립트 코드를 CPS로 바꾸고 싶다면 call/cc는 간단하게 정의할 수 있다.

</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">callcc</span> <span class="params">(f,cc)</span> { </span>
    f(<span class="keyword">function</span>(x,k) <span class="cell">{ cc(x) }</span>,cc)
}</code></pre>
<h2>더 읽어 볼 것</h2>
<ul>
<li><a href="http://www.amazon.com/gp/product/0596101996?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596101996">JavaScript: The Definitive Guide</a>, the best book on JavaScript.</li>
<li><a href="http://www.amazon.com/gp/product/0596517742?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=0596517742">JavaScript: The Good Parts</a>, the only other good JavaScript book.</li>
<li>Andrew Appel's timeless classic <a href="http://www.amazon.com/gp/product/052103311X?ie=UTF8&amp;tag=ucmbread-20&amp;linkCode=as2&amp;camp=1789&amp;creative=390957&amp;creativeASIN=052103311X">Compiling with Continuations</a>.</li>
<li><a href="http://library.readscheme.org/page1.html">The Lambda Papers</a>.</li>
<li>My post <a href="http://matt.might.net/articles/programming-with-continuations--exceptions-backtracking-search-threads-generators-coroutines/">on programming with continuations by example</a>.</li>
<li><a href="http://faculty.cs.byu.edu/~jay/home/">Jay McCarthy</a> et al.'s papers on a continuation-based web-server.</li>
</ul>
</div></article><section id="comments"><h3>Feedback</h3><div class="row"><div id="disqus_thread" class="well span10 offset1"></div>
<script type="text/javascript">
    var disqus_shortname = 'dogfeet-github';
    var disqus_identifier = '/articles/2012/by-example-continuation-passing-style-in-javascript.html';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><div class="well span10 offset1">
  <div class="fb-like" data-href="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html" data-send="true" data-width="450" data-show-faces="true"></div>
    <div class="fb-comments" data-href="http://dogfeet.github.com/articles/2012/by-example-continuation-passing-style-in-javascript.html" data-num-posts="1"></div>
  </div></div></section></section><aside class="sidebar" span2></aside></div><footer class="footer"><p>Copyright &copy; 2008-2012 Dogfeet from coding to pixels, powered by <a href="https://github.com/balupton/docpad">Docpad</a></p></footer></div><!--DISQUS--><script>var disqus_shortname = 'dogfeet-github';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());</script><!--GA--><script>if( 'http://dogfeet.github.com' === 'http://' + window.location.hostname ) {
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27493298-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
}</script></body></html>