<!DOCTYPE html><html lang="en"><head><!--Meta--><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta http-equiv="content-type" content="text/html; charset=utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>#dogfeet - nodejs: modules</title><meta name="description" /><meta name="keywords" /><meta name="author" content="Changwoo Park" /><!--Icons--><link rel="shortcut icon" href="images/favicon.ico" /><link rel="apple-touch-icon" href="images/apple-touch-icon.png" /><link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png" /><link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png" /><link rel="alternate" type="application/atom+xml" title="개발새발 &raquo; Feed" href="http://feeds.feedburner.com/github/dogfeet" /><!--Shims: IE6-8 support of HTML5 elements--><!--[if lt IE 9]>
        <script async src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><!--Styles--><link rel="stylesheet" href="/css/bootstrap.min.css" media="screen, projection" /><link rel="stylesheet" href="/css/bootstrap-responsive.min.css" media="screen, projection" /><link rel="stylesheet" href="/css/highlight/github.css" media="screen, projection" /><link rel="stylesheet" href="/styles/style.css" media="screen, projection" /><link rel="stylesheet" href="/styles/markdown.css" media="screen, projection" /><!--Scripts--><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"></script><script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script><script src="http://connect.facebook.net/en_US/all.js#xfbml=1"></script><script src="/js/bootstrap.min.js"></script><script src="/scripts/script.js"></script></head><body><!--Topbar--><div class="navbar" navbar-fixed-top><div class="navbar-inner"><div class="container-fluid"><a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></a><a class="brand" href="/">dogfeet</a><div class="nav-collapse"><ul class="nav"><li><a href="/site/tagmap.html">Tagmap</a></li><li><a href="/site/archive.html">Archive</a></li><li><a href="/site/atelier.html">Atelier</a></li><li><a href="http://feeds.feedburner.com/github/dogfeet"><img src="http://forum.tattersite.com/ko/style/Textcube/feed-icon.png" /></a></li></ul><form id="search-form" class="pull-right" action="http://google.com/search" method="get" navbar-search><input type="hidden" name="q" value="site:dogfeet.github.com" /><input type="text" name="q" results="0" placeholder="Search" search-query /></form></div></div></div></div><!--Markup--><div class="container-fluid"><div class="row-fluid"><section class="content" span10><script src="http://platform.twitter.com/widgets.js"></script><script>//facebook
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));

//google plusone
(function() {
  var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
  po.src = 'https://apis.google.com/js/plusone.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
})();
</script><article id="post" typeof="sioc:post" about="/articles/2012/nodejs-modules.html" lang="ko-kr" .post .undefined><header><h1 property="dcterms:title">nodejs: modules</h1></header><footer class="modern-font" .small-font><span>by <a href="/authors/changwoo-park.html">Changwoo Park</a></span>
 | <span property="dc:created">2012 May 13</span>
 | <a href="/site/tagmap.html#nodejs" class="tag">nodejs</a> <a href="/site/tagmap.html#doc" class="tag">doc</a> <a href="/site/tagmap.html#module" class="tag">module</a> <a href="/site/tagmap.html#uniquenoun" class="tag">uniquenoun</a> | <span><a href="/articles/2012/nodejs-modules.html#disqus_thread" data-disqus-identifier="/articles/2012/nodejs-modules.html"></a></span>
<style rel="stylesheet" media="screen, projection" scoped="scoped">#social-buttons {
  margin-left: 30px;
}</style><div id="social-buttons" class="pull-right"><ul class="unstyled"><li><a class="twitter-share-button" href="https://twitter.com/share" data-url="http://dogfeet.github.com/articles/2012/nodejs-modules.html" data-via="pismute" data-count="horizontal" data-lang="en">Tweet</a></li><li><div class="g-plusone" data-size="medium" data-href="http://dogfeet.github.com/articles/2012/nodejs-modules.html"></div></li><li><div class="fb-like" data-href="http://dogfeet.github.com/articles/2012/nodejs-modules.html" data-send="false" data-layout="button_count" data-show-faces="false"></div></li></ul></div></footer><div property="sioc:content"><p>읽고, 또 읽고, 또 읽어도 자꾸 까먹는다. 그래서 이번에는 번역을 해보기로 했다. 이 글은 nodejs의 <a href="http://nodejs.org/api/modules.html">modules</a>을 번역한 거다.

</p>
<p><img src="/articles/2012/nodejs-modules/hat-girl.jpg" alt="hat-girl">

</p>
<p>('<a href="http://uniquenoun.tumblr.com/post/21839174721">모자라는 아이</a>' - Jiye Park, 2012)

</p>
<p>이 글의 원문의 SHA값은 <code>1d5b6f2</code>이다. 나중에 버전이 바뀌었을 때 추적하기 위해 남긴다. 헷갈릴 수도 있으니, 번역하기 시작한 시점의 nodejs 안정 버전은 <code>v0.6.14</code>이다.

</p>
<p><a href="https://twitter.com/outsideris">@outsideris</a> 님이 node 번역 프로젝트를 시작하셨습니다. 그래서 그 저장소로 옮겼습니다. 이 글의 최신 버전은 <a href="https://github.com/outsideris/node">그쪽</a>에서 확인하세요.

</p>
<h2>Modules</h2>
<!--
    Stability: 5 - Locked
-->
<!--name=module-->

<p>매우 간단하게 모듈을 로딩할 수 있다. 노드에서는 파일 하나가 모듈 하나다. 예를 들어 <code>foo.js</code> 파일에서 같은 디렉토리에 있는 <code>circle.js</code>를 로드하는 것을 살펴보자.

</p>
<p><code>foo.js</code>:

</p>
<pre><code>var circle = require('./circle.js');
console.log( <span class="attribute">'The</span> area <span class="keyword">of</span> a circle <span class="keyword">of</span> radius <span class="number">4</span> <span class="keyword">is</span> '
           + circle.area(<span class="number">4</span>));</code></pre>
<p><code>circle.js</code>:

</p>
<pre><code>var PI = <span class="transposed_variable">Math.</span>PI;

<span class="transposed_variable">exports.</span>area = <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> {</span>
  <span class="keyword">return</span> PI * r * r;
};

<span class="transposed_variable">exports.</span>circumference = <span class="function"><span class="keyword">function</span> <span class="params">(r)</span> {</span>
  <span class="keyword">return</span> <span class="number">2</span> * PI * r;
};</code></pre>
<p><code>circle.js</code> 모듈은 <code>area()</code>와 <code>circumference()</code>를 Export했다. 뭔가 Export하려면 해당 객체를 <code>exports</code> 객체에 할당한다. <code>exports</code>는 Export하기 위해 사용하는 객체다.

</p>
<p>로컬 변수는 모듈 외부에 노출되지 않는다(private). 이 예제에서 <code>PI</code>는 <code>circle.js</code>에서만 사용할 수 있는 private 변수다.

</p>
<p>이 모듈 시스템은 <code>module</code>이라는 모듈에 구현했다.

</p>
<h3>Cycles</h3>
<!--type=misc-->

<p>두 모듈이 <code>require()</code> 함수로 서로 참조할 때는 한쪽 모듈은 아직 완전히 로딩하지 못한 미완성 모듈을 그냥 반환한다.

</p>
<p>이게 무슨 소리냐 하면:

</p>
<p><code>a.js</code>:

</p>
<pre><code>console.<span class="built_in">log</span>(<span class="comment">'a starting');</span>
exports.done = <span class="literal">false</span>;
var b = require(<span class="comment">'./b.js');</span>
console.<span class="built_in">log</span>(<span class="comment">'in a, b.done = %j', b.done);</span>
exports.done = <span class="literal">true</span>;
console.<span class="built_in">log</span>(<span class="comment">'a done');</span></code></pre>
<p><code>b.js</code>:

</p>
<pre><code>console.<span class="built_in">log</span>(<span class="comment">'b starting');</span>
exports.done = <span class="literal">false</span>;
var a = require(<span class="comment">'./a.js');</span>
console.<span class="built_in">log</span>(<span class="comment">'in b, a.done = %j', a.done);</span>
exports.done = <span class="literal">true</span>;
console.<span class="built_in">log</span>(<span class="comment">'b done');</span></code></pre>
<p><code>main.js</code>:

</p>
<pre><code>console.<span class="built_in">log</span>(<span class="comment">'main starting');</span>
var a = require(<span class="comment">'./a.js');</span>
var b = require(<span class="comment">'./b.js');</span>
console.<span class="built_in">log</span>(<span class="comment">'in main, a.done=%j, b.done=%j', a.done, b.done);</span></code></pre>
<p><code>main.js</code>는 <code>a.js</code>를 로드하고, <code>a.js</code>는 <code>b.js</code>를 로드한다. 여기서 <code>b.js</code>는 다시 <code>a.js</code>를 로드하려고 한다. 무한 루프가 생기지 않도록 아직 미완성인 <code>a.js</code>의 exports 객체를 <code>b.js</code>에 반환해 버린다. 그리고 <code>b.js</code>가 완성되면 <code>a.js</code>에 반환된다.

</p>
<p><code>main.js</code>이 두 모듈을 로드할 때는 이미 둘 다 완성됐다. 이 프로그램의 실행 결과는 다음과 같다:

</p>
<pre><code>$ node main.js
main starting
a starting
b starting
<span class="keyword">in</span> b, a.<span class="keyword">done</span> = <span class="literal">false</span>
b <span class="keyword">done</span>
<span class="keyword">in</span> a, b.<span class="keyword">done</span> = <span class="literal">true</span>
a <span class="keyword">done</span>
<span class="keyword">in</span> main, a.<span class="keyword">done</span>=<span class="literal">true</span>, b.<span class="keyword">done</span>=<span class="literal">true</span></code></pre>
<p>그러니까 꼭 모듈을 서로 참조하게 하여야 하면 계획을 잘 짜야 한다.

</p>
<h3>Core Modules</h3>
<!--type=misc-->

<p>Node 모듈 중에서는 바이너리로 컴파일해야 하는 모듈이 있다. 코어 모듈은 이 문서 곳곳에서 설명한다.

</p>
<p>코어 모듈은 Node 소스코드의 <code>lib/</code> 폴더에 들어 있다.

</p>
<p>모듈을 require하면 항상 코어 모듈이 먼저 로드된다. 예를 들어, <code>require(&#39;http&#39;)</code>로 로드될 것 같은 파일이 있어도 Node에 들어 있는 HTTP 모듈이 반환된다.

</p>
<h3>File Modules</h3>
<!--type=misc-->

<p>입력한 이름으로 파일을 못 찾으면 Node는 그 이름에 <code>.js</code>, <code>.json</code>, <code>.node</code>를 붙이고 해당 파일이 있는지 찾는다.

</p>
<p><code>.js</code> 파일은 JavaScript 텍스트 파일로 Interpret하고 <code>.json</code>은 JSON 텍스트 파일로 Interpret한다. 그리고 <code>.node</code> 파일은 컴파일한 addon 모듈이라서 <code>dlopen</code>으로 로드한다.

</p>
<p>모듈을 절대 경로로 찾을 때는 모듈 이름을 <code>&#39;/&#39;</code>로 시작하면 된다. 예를 들어, <code>require(&#39;home/marco/foo.js&#39;)</code>는 <code>/home/marco/foo.js</code> 파일을 로드한다.

</p>
<p>모듈을 상대 경로로 찾으려면 모듈 이름이 <code>&#39;./&#39;</code>로 시작하면 된다. 즉, <code>foo.js</code>라는 파일에서 <code>require(&#39;./circle&#39;)</code>라고 호출하면 같은 디렉토리에 있는 <code>circle.js</code>를 로드한다.

</p>
<p>'/'이나 './'로 시작하지 않으면 그냥 파일이 아니라 코어 모듈이나 <code>node_modules</code> 폴더에 있는 모듈을 찾는다.

</p>
<p>모듈을 찾지 못하면 <code>require()</code>는 Error를 던진다. 이 에러의 code 프로퍼티의 값은 <code>&#39;MODULE_NOT_FOUND&#39;</code>이다.
(역주 - 어떻게 확인해봐야 할지 모르겠다. 아무튼, <a href="http://git.io/dmzSGw">참고1</a>, <a href="http://git.io/haOtcQ">참고2</a> )

</p>
<h3>Loading from <code>node_modules</code> Folders</h3>
<!--type=misc-->

<p><code>require()</code>에 넘어온 모듈 ID가 네이티브 모듈을 가리키는 것도 아니고, 그 모듈 ID가 <code>&#39;/&#39;</code>, <code>&#39;./&#39;</code>, <code>&#39;../&#39;</code>로 시작하지도 않으면 Node는 그 모듈의 상위 디렉토리에서 찾기 시작한다. 상위 디렉토리에 있는 <code>/node_modules</code>에서 해당 모듈을 찾는다.

</p>
<p>만약 못 찾으면 상위상위 디렉토리에서 찾고, 그래도 못 찾으면 상위상위상위 디렉토리에서 찾는다. 루트 디렉토리에 다다를 때까지 계속 찾는다.

</p>
<p>예를 들어, <code>&#39;home/ry/projects/foo.js&#39;</code>라는 파일에서 <code>requre(&#39;bar.js&#39;)</code>라고 호출하면 다음과 같은 순서로 모듈을 찾는다:

</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>그래서 해당 프로그램만의 의존성을 독립적으로 관리할 수 있다. 다른 프로그램에 영향을 끼치지 않는다.

</p>
<h3>Folders as Modules</h3>
<!--type=misc-->

<p>모듈을 폴더로 관리하면 프로그램과 라이브러리를 묶음으로 관리할 수 있어 편리하다. 마치 한 파일로 된 모듈처럼 취급한다. 모듈이 폴더일 때 <code>require()</code>는 세 가지 방법으로 모듈을 찾는다.

</p>
<p>프로그램 폴더에 <code>package.json</code> 파일을 만들고 main 모듈이 무엇인지 적는다:

</p>
<pre><code>{ "<span class="attribute">name</span>" : <span class="value"><span class="string">"some-library"</span></span>,
  "<span class="attribute">main</span>" : <span class="value"><span class="string">"./lib/some-library.js"</span> </span>}</code></pre>
<p>이 파일이 <code>./some-library</code>라는 폴더에 있다고 하고, <code>require(&#39;./some-library&#39;)</code>를 호출하면 <code>./some-library/lib/some-library.js</code>를 찾아 로드한다.

</p>
<p>Node가 package.json을 읽고 사용하기 때문에 이런 게 가능하다.

</p>
<p>그 디렉토리에 package.json 파일이 없으면 Node는 <code>index.js</code>나 <code>index.node</code> 파일을 찾는다. package.json 파일이 없으면 <code>require(&#39;./some-library&#39;)</code>는 다음과 같은 파일을 로드한다:

</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h3>Caching</h3>
<!--type=misc-->

<p>한 번 로드한 모듈은 계속 캐싱한다. 그래서 <code>require(&#39;foo&#39;)</code>을 여러 번 호출해도 계속 같은 객체를 반환한다. 단, `require('foo')가 계속 같은 파일을 로드할 때만 그렇다.

</p>
<p><code>require(&#39;foo&#39;)</code>를 여러 번 호출해도 해당 모듈 코드는 단 한 번만 호출된다. 그리고 아직 미완성인 객체가 반환될 수 있다는 점까지 더하면 특정 모듈이 서로 의존하고 있어도 성공적으로 로드되는 마법이 이루어진다.

</p>
<p>어떤 코드가 꼭 여러 번 호출돼야 하면 함수 자체를 Export하고 그 함수를 여러 번 호출하라.

</p>
<h4>Module Caching Caveats</h4>
<!--type=misc-->

<p>모듈은 찾은(resolved) 파일 이름을 키로 캐싱한다. <code>node_modules</code> 폴더에서 로딩하는 것이기 때문에 같은 require 코드라도 호출하는 위치에 따라 찾은 파일이 다를 수 있다. 즉, <code>require(&#39;foo&#39;)</code>가 다른 파일을 찾아낸다면 다른 객체를 리턴한다.

</p>
<h3>The <code>module</code> Object</h3>
<!-- type=var -->
<!-- name=module -->

<ul>
<li>{Object}</li>
</ul>
<p>모듈에서 <code>module</code> 변수는 해당 모듈 객체를 가리킨다. 특히 <code>module.exports</code>는 <code>exports</code>와 같은 객체를 가리킨다. <code>module</code>은 글로벌 변수가 아니라 모듈마다 다른 객체를 가리키는 로컬 변수다.

</p>
<h4>module.exports</h4>
<ul>
<li>{Object}</li>
</ul>
<p><code>exports</code> 객체는 Module 시스템이 자동으로 만들어 준다. Export하려는 객체를 <code>module.exports</code>에 할당해서 직접 만든 객체가 반환되게 할 수도 있다. <code>.js</code>라는 모듈을 만들어 보자:

</p>
<pre><code>var <span class="variable">EventEmitter</span> = require('events').<span class="variable">EventEmitter</span>;

module.exports = new <span class="variable">EventEmitter</span>();

// <span class="variable">Do</span> some work, <span class="keyword">and</span> <span class="keyword">after</span> some time emit
// the 'ready' event from the module itself.
<span class="function"><span class="title">setTimeout</span><span class="params">(<span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{
  module.exports.<span class="function_name">emit</span>('ready');
}</span>, <span class="number">1000</span>);</code></pre>
<p>이 모듈은 다음과 같이 사용한다:

</p>
<pre><code>var a = require(<span class="comment">'./a');</span>
a.<span class="keyword">on</span>(<span class="comment">'ready', function() {</span>
  console.<span class="built_in">log</span>(<span class="comment">'module a is ready');</span>
});</code></pre>
<p><code>module.exports</code>에 할당하는 것은 바로 실행되도록 해야 한다. 콜백으로 할당문이 실행되는 것을 미루면 뜻대로 동작하지 않는다. 다음과 같이 하지 마라:

</p>
<p>x.js:

</p>
<pre><code><span class="function"><span class="title">setTimeout</span><span class="params">(<span class="keyword">fun</span><span class="function_name">ction</span>() <span class="tuple">{
  module.exports = <span class="tuple">{ a: <span class="string">"hello"</span> }</span>;
}</span>, <span class="number">0</span>);</code></pre>
<p>y.js:

</p>
<pre><code>var x = require(<span class="string">'./x'</span>);
<span class="transposed_variable">console.</span><span class="built_in">log</span>(<span class="transposed_variable">x.</span>a);</code></pre>
<h4>module.require(id)</h4>
<ul>
<li><code>id</code> {String}</li>
<li>Return: {Object} <code>exports</code> from the resolved module</li>
</ul>
<p><code>module.require</code> 메소드로 모듈을 로드하면 해당 모듈에서 require()를 호출하는 것처럼 모듈을 로드한다.

</p>
<p>이 메소드를 호출하려면 일단 <code>module</code> 객체의 레퍼런스를 얻어야 한다. <code>module</code> 객체의 레퍼런스는 해당 모듈에서만 접근할 수 있고 <code>require()</code>는 <code>module</code>이 아니라 <code>exports</code>를 리턴하기 때문에 해당 모듈에서 module 객체의 레퍼런스를 직접 리턴해야 한다.

</p>
<h4>module.id</h4>
<ul>
<li>{String}</li>
</ul>
<p>모듈 ID인데 보통은 모듈 파일의 전체 경로를 사용한다.

</p>
<h4>module.filename</h4>
<ul>
<li>{String}</li>
</ul>
<p>모듈 파일의 전체 경로(fully resolved filename).

</p>
<h4>module.loaded</h4>
<ul>
<li>{Boolean}</li>
</ul>
<p>모듈이 로드하고 있는 중인지 다 로드했는지를 나타낸다.

</p>
<h4>module.parent</h4>
<ul>
<li>{Module Object}</li>
</ul>
<p>모듈을 require한 모듈을 가리킨다.

</p>
<h4>module.children</h4>
<ul>
<li>{Array}</li>
</ul>
<p>모듈이 require한 모듈 객체를 가리킨다.

</p>
<h3>All Together...</h3>
<!-- type=misc -->

<p><code>require()</code>로 모듈을 찾을 때 정확한 파일 경로가 궁금하면 <code>require.resolve()</code> 함수로 얻어온다.

</p>
<p>require.resolve가 정확히 어떻게 동작하는지 슈도 코드로 살펴보자. 이 슈도 코드는 여태까지 설명한 것을 모두 합쳐 놓은 것이다:

</p>
<pre><code>require(X) from module at path Y
<span class="number">1.</span> <span class="keyword">If</span> X <span class="keyword">is</span> a core module,
   a. return the core module
   b. <span class="keyword">STOP</span>
<span class="number">2.</span> <span class="keyword">If</span> X begins <span class="keyword">with</span> <span class="comment">'./' or '/' or '../'</span>
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
<span class="number">3.</span> LOAD_NODE_MODULES(X, dirname(Y))
<span class="number">4.</span> THROW <span class="string">"not found"</span>

require(X) from module at path Y
<span class="number">1.</span> <span class="keyword">If</span> X <span class="keyword">is</span> a core module,
   a. return the core module
   b. <span class="keyword">STOP</span>
<span class="number">2.</span> <span class="keyword">If</span> X begins <span class="keyword">with</span> <span class="comment">'./' or '/' or '../'</span>
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
<span class="number">3.</span> LOAD_NODE_MODULES(X, dirname(Y))
<span class="number">4.</span> THROW <span class="string">"not found"</span>

LOAD_AS_FILE(X)
<span class="number">1.</span> <span class="keyword">If</span> X <span class="keyword">is</span> a file, load X as JavaScript text.  <span class="keyword">STOP</span>
<span class="number">2.</span> <span class="keyword">If</span> X.js <span class="keyword">is</span> a file, load X.js as JavaScript text.  <span class="keyword">STOP</span>
<span class="number">3.</span> <span class="keyword">If</span> X.node <span class="keyword">is</span> a file, load X.node as binary addon.  <span class="keyword">STOP</span>

LOAD_AS_DIRECTORY(X)
<span class="number">1.</span> <span class="keyword">If</span> X/package.json <span class="keyword">is</span> a file,
   a. Parse X/package.json, <span class="keyword">and</span> look <span class="keyword">for</span> <span class="string">"main"</span> field.
   b. <span class="keyword">let</span> M = X + (json main field)
   c. LOAD_AS_FILE(M)
<span class="number">2.</span> <span class="keyword">If</span> X/index.js <span class="keyword">is</span> a file, load X/index.js as JavaScript text.  <span class="keyword">STOP</span>
<span class="number">3.</span> <span class="keyword">If</span> X/index.node <span class="keyword">is</span> a file, load X/index.node as binary addon.  <span class="keyword">STOP</span>

LOAD_NODE_MODULES(X, START)
<span class="number">1.</span> <span class="keyword">let</span> DIRS=NODE_MODULES_PATHS(START)
<span class="number">2.</span> <span class="keyword">for</span> <span class="keyword">each</span> DIR <span class="keyword">in</span> DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
<span class="number">1.</span> <span class="keyword">let</span> PARTS = path <span class="built_in">split</span>(START)
<span class="number">2.</span> <span class="keyword">let</span> ROOT = index of first instance of <span class="string">"node_modules"</span> <span class="keyword">in</span> PARTS, <span class="keyword">or</span> <span class="number">0</span>
<span class="number">3.</span> <span class="keyword">let</span> I = count of PARTS - <span class="number">1</span>
<span class="number">4.</span> <span class="keyword">let</span> DIRS = []
<span class="number">5.</span> <span class="keyword">while</span> I > ROOT,
   a. <span class="keyword">if</span> PARTS[I] = <span class="string">"node_modules"</span> CONTINUE
   c. DIR = path <span class="built_in">join</span>(PARTS[<span class="number">0</span> .. I] + <span class="string">"node_modules"</span>)
   b. DIRS = DIRS + DIR
   c. <span class="keyword">let</span> I = I - <span class="number">1</span>
<span class="number">6.</span> return DIRS</code></pre>
<h3>Loading from the global folders</h3>
<!-- type=misc -->

<p>Node는 모듈을 못 찾으면 환경변수 <code>NODE_PATH</code>에 등록된 경로에서도 찾는다. 절대경로를 <code>NODE_PATH</code>에 할당하면 되는데 콜론(<code>:</code>)으로 구분해서 절대경로를 여러 개 등록할 수 있다(주의: 윈도우는 세미콜론(<code>;</code>)으로 구분한다).

</p>
<p>그리고 Node는 다른 디렉토리에서도 찾는다:

</p>
<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>
<p><code>$HOME</code>은 사용자의 홈 디렉토리이고 <code>$PREFIX</code>는 노드가 설치된 디렉토리를 말한다.

</p>
<p>왜 그런지 말하자면 길다. 무엇보다 <code>node_modules</code> 폴더를 이용해 모듈을 로컬에 설치하는 것이 좋다. 이 방법이 속도도 더 빠르고 더 안전하다.

</p>
<h3>Accessing the main module</h3>
<!-- type=misc -->

<p>node로 어떤 파일을 실행하면 <code>require.main</code>은 그 파일의 <code>module</code> 객체를 가리킨다. 그래서 Node로 파일을 직접 실행한 건지 아닌지 알 수 있다:

</p>
<pre><code><span class="title">require</span>.main === <span class="module"><span class="keyword">module</span></code></pre>
<p><code>foo.js</code>라는 파일에 이런 게 들어 있다고 하자. 이 구문의 결과는 <code>node foo.js</code>로 실행하면 <code>true</code>이고 <code>require(&#39;./foo&#39;)</code>로 실행하면 <code>false</code>가 된다.

</p>
<p><code>module</code>에는 <code>filename</code> 프로퍼티가 있어서(<code>__filename</code>과 같은 값이다) <code>require.main.filename</code>의 값을 확인하면 처음 실행한 파일을 무엇인지 알 수 있다.

</p>
<h3>Addenda: Package Manager Tips</h3>
<!-- type=misc -->

<p><code>require()</code> 함수는 웬만한 디렉토리면 어디에서나 사용할 수 있다. <code>dpkg</code>, <code>rpm</code> 같은 패키지 매니저처럼 <code>npm</code>도 네이티브 Node 패키지를 아무런 수정 없이 빌드하게 할 수 있다.

</p>
<p>모듈은 <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>에 설치하는 것을 권장한다. 어떤 패키지의 어떤 버전이 설치됐는지 한 눈에 알 수 있어 좋다.

</p>
<p>패키지는 다른 패키지에 의존할 수도 있다. 예를 들어 <code>foo</code> 패키지를 설치하려면 <code>bar</code> 패키지도 설치해야 한다. 그것도 특정 버전의 <code>bar</code> 패키지가 설치돼야 한다. 그리고 <code>bar</code> 패키지도 다른 패키지에 의존할 수 있는데 충돌이 있거나 서로(cycle) 의존할 수도 있다.

</p>
<p>Node는 로드할 모듈을 찾을 때 <code>node_modules</code> 폴더에서 필요한 모듈을 찾는다. 그중에 심볼릭 링크가 있으면 그 링크가 가리키는 모듈도 잘 찾는다. 다음과 같이 모듈을 찾는 매커니즘은 매우 간단하다:

</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - 버전이  1.2.3인 <code>foo</code> 패키지</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - <code>foo</code>가 의존하는 <code>bar</code> 패키지</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - <code>/usr/lib/node/bar/4.3.2/</code>에 대한 심볼릭 링크</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - <code>bar</code>가 의존하는 패키지에 대한 심볼릭 링크</li>
</ul>
<p>그리고 상호 참조나 의존성 충돌이 있어도 모듈을 사용할 수만 있으면 잘 로드한다.

</p>
<p><code>foo</code> 패키지에서 <code>require(&#39;bar&#39;)</code>라고 하면 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>가 가리키는 모듈을 가져온다. 또 그 <code>bar</code> 패키지에서 <code>require(&#39;quux&#39;)</code>라고 호출하면 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>가 가리키는 모듈을 가져온다.

</p>
<p>최적화된 방법으로 모듈을 찾는 방법이 있는데 <code>/usr/lib/node</code> 디렉토리가 아니라 <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>에 모듈을 넣는다. 그러면 Node는 <code>/usr/node_modules</code>이나 <code>/node_modules</code>에서는 모듈을 찾지 않는다.

</p>
<p><code>/usr/lib/node_modules</code> 폴더를 환경 변수 <code>$NODE_PATH</code>에 넣으면 Node REPL에서도 모듈을 사용할 수 있다. <code>require()</code>를 호출한 파일이 있는 곳에서부터 상대경로로 <code>node_modules</code> 폴더에 있는 모듈을 찾기 때문에 패키지는 그 <code>node_modules</code> 폴더 중 한 곳에 넣으면 된다.
</p>
</div></article><section id="related"><h3>Related Posts</h3><div class="alert" alert-info><ul><li><span>Jun 24 2012</span>&raquo;<a href="/articles/2012/nodejs-monkey-patching.html">nodejs에서의 멍키 패칭</a></li><li><span>Jun 17 2012</span>&raquo;<a href="/articles/2012/iamport-nodejs.html">iamport: nodejs</a></li><li><span>Jun 10 2012</span>&raquo;<a href="/articles/2012/nodejs-fibers.html">nodejs: node-fibers</a></li><li><span>May 05 2012</span>&raquo;<a href="/articles/2012/nodejs-npm-config.html">nodejs: npm config</a></li><li><span>Apr 15 2012</span>&raquo;<a href="/articles/2012/nodejs-mocha.html">nodejs: Mocha</a></li><li><span>Feb 25 2012</span>&raquo;<a href="/articles/2012/npm-tricks.html">nodejs: npm-tricks</a></li><li><span>Oct 22 2011</span>&raquo;<a href="/articles/2011/1319251876.html">tav:Brain-free command-line options parser</a></li><li><span>Jul 05 2011</span>&raquo;<a href="/articles/2011/1309906680.html">Felix's Node.js Guide</a></li></ul></div></section><section id="comments"><h3>Feedback</h3><div class="row"><div id="disqus_thread" class="well span10 offset1"></div>
<script type="text/javascript">
    var disqus_shortname = 'dogfeet-github';
    var disqus_identifier = '/articles/2012/nodejs-modules.html';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><div class="well span10 offset1">
  <div class="fb-like" data-href="http://dogfeet.github.com/articles/2012/nodejs-modules.html" data-send="true" data-width="450" data-show-faces="true"></div>
    <div class="fb-comments" data-href="http://dogfeet.github.com/articles/2012/nodejs-modules.html" data-num-posts="1"></div>
  </div></div></section></section><aside class="sidebar" span2></aside></div><footer class="footer"><p>Copyright &copy; 2008-2012 Dogfeet from coding to pixels, powered by <a href="https://github.com/balupton/docpad">Docpad</a></p></footer></div><!--DISQUS--><script>var disqus_shortname = 'dogfeet-github';
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());</script><!--GA--><script>if( 'http://dogfeet.github.com' === 'http://' + window.location.hostname ) {
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27493298-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
}</script></body></html>