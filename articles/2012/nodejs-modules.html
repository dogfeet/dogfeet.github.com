<!DOCTYPE html>
<html lang="en">
<head>

  <meta charset="utf=8"></meta>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"></meta>
  <meta name="viewport" content="width=device-width, initial-scale=1"></meta>

  <title>#dogfeet - nodejs: modules</title>
  <meta name="description"
    content="읽고, 또 읽고, 또 읽어도 자꾸 까먹는다. 그래서 이번에는 번역을 해보기로 했다. 이 글은 nodejs의 modules을 번역한 거다."></meta>
  <meta name="keywords"
    content="nodejs,doc,module,uniquenoun"></meta>
  <meta name="author" content="Changwoo Park"></meta>

  <link rel="shortcut icon" href="images/favicon.ico"></link>
  <link rel="apple-touch-icon" href="images/apple-touch-icon.png"></link>
  <link rel="apple-touch-icon" sizes="72x72"
    href=" ='images/apple-touch-icon-72x72.png"></link>
  <link rel="apple-touch-icon" sizes="114x114"
    href="images/apple-touch-icon-114x114.png"></link>
  <link rel="alternate" type="application/atom+xml"
    title="nodejs: modules &raquo; Feed"
    href="http://feeds.feedburner.com/github/dogfeet"></link>

  <link rel="stylesheet"
    href="/bower_components/bootstrap/dist/css/bootstrap.min.css"
    media="screen, projection"></link>
  <link rel="stylesheet"
    href="/styles/style.css" media="screen, projection"></link>

</head>
<body>
  <nav class="navbar navbar-default navbar-static-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">dogfeet</a>
      </div>
      <div id="navbar" class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/site/archive.html">Archive</a></li>
          <li><a href="/site/tagmap.html">Tagmap</a></li>
        </ul>
        <form id="search-form" class="navbar-form navbar-right" action="http://google.com/search" method="get">
          <input type="hidden" name="q" value="site:dogfeet.github.io"></input>
          <input class="form-control" type="text" name="q" results="0" placeholder="Search..."></input>
        </form>
      </div><!--/.nav-collapse -->
    </div>
  </nav>
  <div class="container">
    <div>
      <link rel="stylesheet" scoped
  href="/styles/github.css"
  media="screen, projection"></link>
<link rel="stylesheet" scoped
  href="/styles/markdown.css"
  media="screen, projection"></link>

<section class="content">
  <article id="post" class="row post " typeof="sioc:post" about="articles/2012/nodejs-modules.html" lang="ko-kr">
    <div class="col-sm-2 small-font">
      <br /><br />
      <p property="dc:created">2012 May 13</p>
      <p class="small-font top-line"> - by<br /><a href="https://twitter.com/pismute/">Changwoo Park</a></p>
      <div id="social-buttons" class="top-line">
        <ul class="unstyled">
          <li><a class="twitter-share-button" href="https://twitter.com/share"
            data-url="http://dogfeet.github.io/articles/2012/nodejs-modules.html" data-via="Changwoo Park"
            data-count="horizontal" data-lang="en">Tweet</a></li>
          <li><div class="g-plusone" data-size="medium" data-href="http://dogfeet.github.io/articles/2012/nodejs-modules.html"></div></li>
          <li><div class="fb-like"
            data-href="http://dogfeet.github.io/articles/2012/nodejs-modules.html" data-send="false"
            data-layout="button_count" data-show-faces="false"></div></li>
        </ul>
      </div>

      <p class="small-font top-line"><a href="/site/tagmap.html#nodejs" class="tag">nodejs</a> <a href="/site/tagmap.html#doc" class="tag">doc</a> <a href="/site/tagmap.html#module" class="tag">module</a> <a href="/site/tagmap.html#uniquenoun" class="tag">uniquenoun</a></p>
    </div>

    <div class="col-sm-10">

      <div property="sioc:content"><h1 id="nodejs-modules">nodejs: modules</h1>
<p>읽고, 또 읽고, 또 읽어도 자꾸 까먹는다. 그래서 이번에는 번역을 해보기로 했다. 이 글은 nodejs의 <a href="http://nodejs.org/api/modules.html">modules</a>을 번역한 거다.</p>
<p><img src="/articles/2012/nodejs-modules/hat-girl.jpg" alt="hat-girl"></p>
<p>(‘<a href="http://uniquenoun.tumblr.com/post/21839174721">모자라는 아이</a>‘ - Jiye Park, 2012)</p>
<p>이 글의 원문의 SHA값은 <code>1d5b6f2</code>이다. 나중에 버전이 바뀌었을 때 추적하기 위해 남긴다. 헷갈릴 수도 있으니, 번역하기 시작한 시점의 nodejs 안정 버전은 <code>v0.6.14</code>이다.</p>
<p>@outsideris 님이 node 번역 프로젝트를 시작하셨습니다. 그래서 그 저장소로 옮겼습니다. 이 글의 최신 버전은 <a href="https://github.com/outsideris/node">그쪽</a>에서 확인하세요.</p>
<h2 id="modules">Modules</h2>
<p>&lt;!--
    Stability: 5 - Locked
--&gt;
&lt;!--name=module--&gt;

</p>
<p>매우 간단하게 모듈을 로딩할 수 있다. 노드에서는 파일 하나가 모듈 하나다. 예를 들어 <code>foo.js</code> 파일에서 같은 디렉토리에 있는 <code>circle.js</code>를 로드하는 것을 살펴보자.</p>
<p><code>foo.js</code>:</p>
<pre><code>var circle = require(&#39;./circle.js&#39;);
console.log( &#39;The area of a circle of radius 4 is &#39;
           + circle.area(4));
</code></pre><p><code>circle.js</code>:</p>
<pre><code>var PI = Math.PI;

exports.area = function (r) {
  return PI * r * r;
};

exports.circumference = function (r) {
  return 2 * PI * r;
};
</code></pre><p><code>circle.js</code> 모듈은 <code>area()</code>와 <code>circumference()</code>를 Export했다. 뭔가 Export하려면 해당 객체를 <code>exports</code> 객체에 할당한다. <code>exports</code>는 Export하기 위해 사용하는 객체다.</p>
<p>로컬 변수는 모듈 외부에 노출되지 않는다(private). 이 예제에서 <code>PI</code>는 <code>circle.js</code>에서만 사용할 수 있는 private 변수다.</p>
<p>이 모듈 시스템은 <code>module</code>이라는 모듈에 구현했다.</p>
<h3 id="cycles">Cycles</h3>
<p>&lt;!--type=misc--&gt;

</p>
<p>두 모듈이 <code>require()</code> 함수로 서로 참조할 때는 한쪽 모듈은 아직 완전히 로딩하지 못한 미완성 모듈을 그냥 반환한다.</p>
<p>이게 무슨 소리냐 하면:</p>
<p><code>a.js</code>:</p>
<pre><code>console.log(&#39;a starting&#39;);
exports.done = false;
var b = require(&#39;./b.js&#39;);
console.log(&#39;in a, b.done = %j&#39;, b.done);
exports.done = true;
console.log(&#39;a done&#39;);
</code></pre><p><code>b.js</code>:</p>
<pre><code>console.log(&#39;b starting&#39;);
exports.done = false;
var a = require(&#39;./a.js&#39;);
console.log(&#39;in b, a.done = %j&#39;, a.done);
exports.done = true;
console.log(&#39;b done&#39;);
</code></pre><p><code>main.js</code>:</p>
<pre><code>console.log(&#39;main starting&#39;);
var a = require(&#39;./a.js&#39;);
var b = require(&#39;./b.js&#39;);
console.log(&#39;in main, a.done=%j, b.done=%j&#39;, a.done, b.done);
</code></pre><p><code>main.js</code>는 <code>a.js</code>를 로드하고, <code>a.js</code>는 <code>b.js</code>를 로드한다. 여기서 <code>b.js</code>는 다시 <code>a.js</code>를 로드하려고 한다. 무한 루프가 생기지 않도록 아직 미완성인 <code>a.js</code>의 exports 객체를 <code>b.js</code>에 반환해 버린다. 그리고 <code>b.js</code>가 완성되면 <code>a.js</code>에 반환된다.</p>
<p><code>main.js</code>이 두 모듈을 로드할 때는 이미 둘 다 완성됐다. 이 프로그램의 실행 결과는 다음과 같다:</p>
<pre><code>$ node main.js
main starting
a starting
b starting
in b, a.done = false
b done
in a, b.done = true
a done
in main, a.done=true, b.done=true
</code></pre><p>그러니까 꼭 모듈을 서로 참조하게 하여야 하면 계획을 잘 짜야 한다.</p>
<h3 id="core-modules">Core Modules</h3>
<p>&lt;!--type=misc--&gt;

</p>
<p>Node 모듈 중에서는 바이너리로 컴파일해야 하는 모듈이 있다. 코어 모듈은 이 문서 곳곳에서 설명한다.</p>
<p>코어 모듈은 Node 소스코드의 <code>lib/</code> 폴더에 들어 있다.</p>
<p>모듈을 require하면 항상 코어 모듈이 먼저 로드된다. 예를 들어, <code>require(&#39;http&#39;)</code>로 로드될 것 같은 파일이 있어도 Node에 들어 있는 HTTP 모듈이 반환된다.</p>
<h3 id="file-modules">File Modules</h3>
<p>&lt;!--type=misc--&gt;

</p>
<p>입력한 이름으로 파일을 못 찾으면 Node는 그 이름에 <code>.js</code>, <code>.json</code>, <code>.node</code>를 붙이고 해당 파일이 있는지 찾는다.</p>
<p><code>.js</code> 파일은 JavaScript 텍스트 파일로 Interpret하고 <code>.json</code>은 JSON 텍스트 파일로 Interpret한다. 그리고 <code>.node</code> 파일은 컴파일한 addon 모듈이라서 <code>dlopen</code>으로 로드한다.</p>
<p>모듈을 절대 경로로 찾을 때는 모듈 이름을 <code>&#39;/&#39;</code>로 시작하면 된다. 예를 들어, <code>require(&#39;home/marco/foo.js&#39;)</code>는 <code>/home/marco/foo.js</code> 파일을 로드한다.</p>
<p>모듈을 상대 경로로 찾으려면 모듈 이름이 <code>&#39;./&#39;</code>로 시작하면 된다. 즉, <code>foo.js</code>라는 파일에서 <code>require(&#39;./circle&#39;)</code>라고 호출하면 같은 디렉토리에 있는 <code>circle.js</code>를 로드한다.</p>
<p>‘/‘이나 ‘./‘로 시작하지 않으면 그냥 파일이 아니라 코어 모듈이나 <code>node_modules</code> 폴더에 있는 모듈을 찾는다.</p>
<p>모듈을 찾지 못하면 <code>require()</code>는 Error를 던진다. 이 에러의 code 프로퍼티의 값은 <code>&#39;MODULE_NOT_FOUND&#39;</code>이다.
(역주 - 어떻게 확인해봐야 할지 모르겠다. 아무튼, <a href="http://git.io/dmzSGw">참고1</a>, <a href="http://git.io/haOtcQ">참고2</a> )</p>
<h3 id="loading-from-node_modules-folders">Loading from <code>node_modules</code> Folders</h3>
<p>&lt;!--type=misc--&gt;

</p>
<p><code>require()</code>에 넘어온 모듈 ID가 네이티브 모듈을 가리키는 것도 아니고, 그 모듈 ID가 <code>&#39;/&#39;</code>, <code>&#39;./&#39;</code>, <code>&#39;../&#39;</code>로 시작하지도 않으면 Node는 그 모듈의 상위 디렉토리에서 찾기 시작한다. 상위 디렉토리에 있는 <code>/node_modules</code>에서 해당 모듈을 찾는다.</p>
<p>만약 못 찾으면 상위상위 디렉토리에서 찾고, 그래도 못 찾으면 상위상위상위 디렉토리에서 찾는다. 루트 디렉토리에 다다를 때까지 계속 찾는다.</p>
<p>예를 들어, <code>&#39;home/ry/projects/foo.js&#39;</code>라는 파일에서 <code>requre(&#39;bar.js&#39;)</code>라고 호출하면 다음과 같은 순서로 모듈을 찾는다:</p>
<ul>
<li><code>/home/ry/projects/node_modules/bar.js</code></li>
<li><code>/home/ry/node_modules/bar.js</code></li>
<li><code>/home/node_modules/bar.js</code></li>
<li><code>/node_modules/bar.js</code></li>
</ul>
<p>그래서 해당 프로그램만의 의존성을 독립적으로 관리할 수 있다. 다른 프로그램에 영향을 끼치지 않는다.</p>
<h3 id="folders-as-modules">Folders as Modules</h3>
<p>&lt;!--type=misc--&gt;

</p>
<p>모듈을 폴더로 관리하면 프로그램과 라이브러리를 묶음으로 관리할 수 있어 편리하다. 마치 한 파일로 된 모듈처럼 취급한다. 모듈이 폴더일 때 <code>require()</code>는 세 가지 방법으로 모듈을 찾는다.</p>
<p>프로그램 폴더에 <code>package.json</code> 파일을 만들고 main 모듈이 무엇인지 적는다:</p>
<pre><code>{ &quot;name&quot; : &quot;some-library&quot;,
  &quot;main&quot; : &quot;./lib/some-library.js&quot; }
</code></pre><p>이 파일이 <code>./some-library</code>라는 폴더에 있다고 하고, <code>require(&#39;./some-library&#39;)</code>를 호출하면 <code>./some-library/lib/some-library.js</code>를 찾아 로드한다.</p>
<p>Node가 package.json을 읽고 사용하기 때문에 이런 게 가능하다.</p>
<p>그 디렉토리에 package.json 파일이 없으면 Node는 <code>index.js</code>나 <code>index.node</code> 파일을 찾는다. package.json 파일이 없으면 <code>require(&#39;./some-library&#39;)</code>는 다음과 같은 파일을 로드한다:</p>
<ul>
<li><code>./some-library/index.js</code></li>
<li><code>./some-library/index.node</code></li>
</ul>
<h3 id="caching">Caching</h3>
<p>&lt;!--type=misc--&gt;

</p>
<p>한 번 로드한 모듈은 계속 캐싱한다. 그래서 <code>require(&#39;foo&#39;)</code>을 여러 번 호출해도 계속 같은 객체를 반환한다. 단, `require(‘foo’)가 계속 같은 파일을 로드할 때만 그렇다.</p>
<p><code>require(&#39;foo&#39;)</code>를 여러 번 호출해도 해당 모듈 코드는 단 한 번만 호출된다. 그리고 아직 미완성인 객체가 반환될 수 있다는 점까지 더하면 특정 모듈이 서로 의존하고 있어도 성공적으로 로드되는 마법이 이루어진다.</p>
<p>어떤 코드가 꼭 여러 번 호출돼야 하면 함수 자체를 Export하고 그 함수를 여러 번 호출하라.</p>
<h4 id="module-caching-caveats">Module Caching Caveats</h4>
<p>&lt;!--type=misc--&gt;

</p>
<p>모듈은 찾은(resolved) 파일 이름을 키로 캐싱한다. <code>node_modules</code> 폴더에서 로딩하는 것이기 때문에 같은 require 코드라도 호출하는 위치에 따라 찾은 파일이 다를 수 있다. 즉, <code>require(&#39;foo&#39;)</code>가 다른 파일을 찾아낸다면 다른 객체를 리턴한다.</p>
<h3 id="the-module-object">The <code>module</code> Object</h3>
<p>&lt;!-- type=var --&gt;
&lt;!-- name=module --&gt;

</p>
<ul>
<li>{Object}</li>
</ul>
<p>모듈에서 <code>module</code> 변수는 해당 모듈 객체를 가리킨다. 특히 <code>module.exports</code>는 <code>exports</code>와 같은 객체를 가리킨다. <code>module</code>은 글로벌 변수가 아니라 모듈마다 다른 객체를 가리키는 로컬 변수다.</p>
<h4 id="module-exports">module.exports</h4>
<ul>
<li>{Object}</li>
</ul>
<p><code>exports</code> 객체는 Module 시스템이 자동으로 만들어 준다. Export하려는 객체를 <code>module.exports</code>에 할당해서 직접 만든 객체가 반환되게 할 수도 있다. <code>.js</code>라는 모듈을 만들어 보자:</p>
<pre><code>var EventEmitter = require(&#39;events&#39;).EventEmitter;

module.exports = new EventEmitter();

// Do some work, and after some time emit
// the &#39;ready&#39; event from the module itself.
setTimeout(function() {
  module.exports.emit(&#39;ready&#39;);
}, 1000);
</code></pre><p>이 모듈은 다음과 같이 사용한다:</p>
<pre><code>var a = require(&#39;./a&#39;);
a.on(&#39;ready&#39;, function() {
  console.log(&#39;module a is ready&#39;);
});
</code></pre><p><code>module.exports</code>에 할당하는 것은 바로 실행되도록 해야 한다. 콜백으로 할당문이 실행되는 것을 미루면 뜻대로 동작하지 않는다. 다음과 같이 하지 마라:</p>
<p>x.js:</p>
<pre><code>setTimeout(function() {
  module.exports = { a: &quot;hello&quot; };
}, 0);
</code></pre><p>y.js:</p>
<pre><code>var x = require(&#39;./x&#39;);
console.log(x.a);
</code></pre><h4 id="module-require-id-">module.require(id)</h4>
<ul>
<li><code>id</code> {String}</li>
<li>Return: {Object} <code>exports</code> from the resolved module</li>
</ul>
<p><code>module.require</code> 메소드로 모듈을 로드하면 해당 모듈에서 require()를 호출하는 것처럼 모듈을 로드한다.</p>
<p>이 메소드를 호출하려면 일단 <code>module</code> 객체의 레퍼런스를 얻어야 한다. <code>module</code> 객체의 레퍼런스는 해당 모듈에서만 접근할 수 있고 <code>require()</code>는 <code>module</code>이 아니라 <code>exports</code>를 리턴하기 때문에 해당 모듈에서 module 객체의 레퍼런스를 직접 리턴해야 한다.</p>
<h4 id="module-id">module.id</h4>
<ul>
<li>{String}</li>
</ul>
<p>모듈 ID인데 보통은 모듈 파일의 전체 경로를 사용한다.</p>
<h4 id="module-filename">module.filename</h4>
<ul>
<li>{String}</li>
</ul>
<p>모듈 파일의 전체 경로(fully resolved filename).</p>
<h4 id="module-loaded">module.loaded</h4>
<ul>
<li>{Boolean}</li>
</ul>
<p>모듈이 로드하고 있는 중인지 다 로드했는지를 나타낸다.</p>
<h4 id="module-parent">module.parent</h4>
<ul>
<li>{Module Object}</li>
</ul>
<p>모듈을 require한 모듈을 가리킨다.</p>
<h4 id="module-children">module.children</h4>
<ul>
<li>{Array}</li>
</ul>
<p>모듈이 require한 모듈 객체를 가리킨다.</p>
<h3 id="all-together-">All Together…</h3>
<p>&lt;!-- type=misc --&gt;

</p>
<p><code>require()</code>로 모듈을 찾을 때 정확한 파일 경로가 궁금하면 <code>require.resolve()</code> 함수로 얻어온다.</p>
<p>require.resolve가 정확히 어떻게 동작하는지 슈도 코드로 살펴보자. 이 슈도 코드는 여태까지 설명한 것을 모두 합쳐 놓은 것이다:</p>
<pre><code>require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with &#39;./&#39; or &#39;/&#39; or &#39;../&#39;
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

require(X) from module at path Y
1. If X is a core module,
   a. return the core module
   b. STOP
2. If X begins with &#39;./&#39; or &#39;/&#39; or &#39;../&#39;
   a. LOAD_AS_FILE(Y + X)
   b. LOAD_AS_DIRECTORY(Y + X)
3. LOAD_NODE_MODULES(X, dirname(Y))
4. THROW &quot;not found&quot;

LOAD_AS_FILE(X)
1. If X is a file, load X as JavaScript text.  STOP
2. If X.js is a file, load X.js as JavaScript text.  STOP
3. If X.node is a file, load X.node as binary addon.  STOP

LOAD_AS_DIRECTORY(X)
1. If X/package.json is a file,
   a. Parse X/package.json, and look for &quot;main&quot; field.
   b. let M = X + (json main field)
   c. LOAD_AS_FILE(M)
2. If X/index.js is a file, load X/index.js as JavaScript text.  STOP
3. If X/index.node is a file, load X/index.node as binary addon.  STOP

LOAD_NODE_MODULES(X, START)
1. let DIRS=NODE_MODULES_PATHS(START)
2. for each DIR in DIRS:
   a. LOAD_AS_FILE(DIR/X)
   b. LOAD_AS_DIRECTORY(DIR/X)

NODE_MODULES_PATHS(START)
1. let PARTS = path split(START)
2. let ROOT = index of first instance of &quot;node_modules&quot; in PARTS, or 0
3. let I = count of PARTS - 1
4. let DIRS = []
5. while I &gt; ROOT,
   a. if PARTS[I] = &quot;node_modules&quot; CONTINUE
   c. DIR = path join(PARTS[0 .. I] + &quot;node_modules&quot;)
   b. DIRS = DIRS + DIR
   c. let I = I - 1
6. return DIRS
</code></pre><h3 id="loading-from-the-global-folders">Loading from the global folders</h3>
<p>&lt;!-- type=misc --&gt;

</p>
<p>Node는 모듈을 못 찾으면 환경변수 <code>NODE_PATH</code>에 등록된 경로에서도 찾는다. 절대경로를 <code>NODE_PATH</code>에 할당하면 되는데 콜론(<code>:</code>)으로 구분해서 절대경로를 여러 개 등록할 수 있다(주의: 윈도우는 세미콜론(<code>;</code>)으로 구분한다).</p>
<p>그리고 Node는 다른 디렉토리에서도 찾는다:</p>
<ul>
<li>1: <code>$HOME/.node_modules</code></li>
<li>2: <code>$HOME/.node_libraries</code></li>
<li>3: <code>$PREFIX/lib/node</code></li>
</ul>
<p><code>$HOME</code>은 사용자의 홈 디렉토리이고 <code>$PREFIX</code>는 노드가 설치된 디렉토리를 말한다.</p>
<p>왜 그런지 말하자면 길다. 무엇보다 <code>node_modules</code> 폴더를 이용해 모듈을 로컬에 설치하는 것이 좋다. 이 방법이 속도도 더 빠르고 더 안전하다.</p>
<h3 id="accessing-the-main-module">Accessing the main module</h3>
<p>&lt;!-- type=misc --&gt;

</p>
<p>node로 어떤 파일을 실행하면 <code>require.main</code>은 그 파일의 <code>module</code> 객체를 가리킨다. 그래서 Node로 파일을 직접 실행한 건지 아닌지 알 수 있다:</p>
<pre><code>require.main === module
</code></pre><p><code>foo.js</code>라는 파일에 이런 게 들어 있다고 하자. 이 구문의 결과는 <code>node foo.js</code>로 실행하면 <code>true</code>이고 <code>require(&#39;./foo&#39;)</code>로 실행하면 <code>false</code>가 된다.</p>
<p><code>module</code>에는 <code>filename</code> 프로퍼티가 있어서(<code>__filename</code>과 같은 값이다) <code>require.main.filename</code>의 값을 확인하면 처음 실행한 파일을 무엇인지 알 수 있다.</p>
<h3 id="addenda-package-manager-tips">Addenda: Package Manager Tips</h3>
<p>&lt;!-- type=misc --&gt;

</p>
<p><code>require()</code> 함수는 웬만한 디렉토리면 어디에서나 사용할 수 있다. <code>dpkg</code>, <code>rpm</code> 같은 패키지 매니저처럼 <code>npm</code>도 네이티브 Node 패키지를 아무런 수정 없이 빌드하게 할 수 있다.</p>
<p>모듈은 <code>/usr/lib/node/&lt;some-package&gt;/&lt;some-version&gt;</code>에 설치하는 것을 권장한다. 어떤 패키지의 어떤 버전이 설치됐는지 한 눈에 알 수 있어 좋다.</p>
<p>패키지는 다른 패키지에 의존할 수도 있다. 예를 들어 <code>foo</code> 패키지를 설치하려면 <code>bar</code> 패키지도 설치해야 한다. 그것도 특정 버전의 <code>bar</code> 패키지가 설치돼야 한다. 그리고 <code>bar</code> 패키지도 다른 패키지에 의존할 수 있는데 충돌이 있거나 서로(cycle) 의존할 수도 있다.</p>
<p>Node는 로드할 모듈을 찾을 때 <code>node_modules</code> 폴더에서 필요한 모듈을 찾는다. 그중에 심볼릭 링크가 있으면 그 링크가 가리키는 모듈도 잘 찾는다. 다음과 같이 모듈을 찾는 매커니즘은 매우 간단하다:</p>
<ul>
<li><code>/usr/lib/node/foo/1.2.3/</code> - 버전이  1.2.3인 <code>foo</code> 패키지</li>
<li><code>/usr/lib/node/bar/4.3.2/</code> - <code>foo</code>가 의존하는 <code>bar</code> 패키지</li>
<li><code>/usr/lib/node/foo/1.2.3/node_modules/bar</code> - <code>/usr/lib/node/bar/4.3.2/</code>에 대한 심볼릭 링크</li>
<li><code>/usr/lib/node/bar/4.3.2/node_modules/*</code> - <code>bar</code>가 의존하는 패키지에 대한 심볼릭 링크</li>
</ul>
<p>그리고 상호 참조나 의존성 충돌이 있어도 모듈을 사용할 수만 있으면 잘 로드한다.</p>
<p><code>foo</code> 패키지에서 <code>require(&#39;bar&#39;)</code>라고 하면 <code>/usr/lib/node/foo/1.2.3/node_modules/bar</code>가 가리키는 모듈을 가져온다. 또 그 <code>bar</code> 패키지에서 <code>require(&#39;quux&#39;)</code>라고 호출하면 <code>/usr/lib/node/bar/4.3.2/node_modules/quux</code>가 가리키는 모듈을 가져온다.</p>
<p>최적화된 방법으로 모듈을 찾는 방법이 있는데 <code>/usr/lib/node</code> 디렉토리가 아니라 <code>/usr/lib/node_modules/&lt;name&gt;/&lt;version&gt;</code>에 모듈을 넣는다. 그러면 Node는 <code>/usr/node_modules</code>이나 <code>/node_modules</code>에서는 모듈을 찾지 않는다.</p>
<p><code>/usr/lib/node_modules</code> 폴더를 환경 변수 <code>$NODE_PATH</code>에 넣으면 Node REPL에서도 모듈을 사용할 수 있다. <code>require()</code>를 호출한 파일이 있는 곳에서부터 상대경로로 <code>node_modules</code> 폴더에 있는 모듈을 찾기 때문에 패키지는 그 <code>node_modules</code> 폴더 중 한 곳에 넣으면 된다.</p>
</div>
    </div>
  </article>
</section>

<div id="fb-root"></div>
<script src="//connect.facebook.net/en_US/all.js#xfbml=1"></script>
<script src="http://platform.twitter.com/widgets.js"></script>
<script src="https://apis.google.com/js/plusone.js"></script>

    </div>
    <footer class="footer"><p>Copyright &copy; 2008+ Dogfeet from coding to pixels</p></footer>
  </div>

  <script src="/bower_components/jquery/dist/jquery.js"></script>
  <script src="/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>
  <script src="/scripts/script.js"></script>

  <script>
    if( 'http://dogfeet.github.io/' === 'http://' + window.location.hostname ) {
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-27493298-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    }
  </script>
</body>
</html>
