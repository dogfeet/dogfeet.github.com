<!DOCTYPE html>
<html lang="en">
  <head>
<!--Meta-->
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>#dogfeet - Promise</title>
    <meta name="description" content="수박 겉핥기 식이라 부끄럽지만 Promise에 대해 정리해보았다." />
    <meta name="keywords" content="javascript,promise,then,q,when,aync" />
    <meta name="author" content="Yongjae Choi" />
<!--Icons-->
    <link rel="shortcut icon" href="images/favicon.ico" />
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png" />
    <link rel="alternate" type="application/atom+xml" title="개발새발 &raquo; Feed" href="http://feeds.feedburner.com/github/dogfeet" />
<!--Shims: IE6-8 support of HTML5 elements-->
<!--[if lt IE 9]>
        <script async src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
<!--Styles-->
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.0/css/bootstrap-combined.min.css" media="screen, projection" />
    <link rel="stylesheet" href="/css/highlight/github.css" media="screen, projection" />
    <link rel="stylesheet" href="/styles/style.css" media="screen, projection" />
    <link rel="stylesheet" href="/styles/markdown.css" media="screen, projection" />
<!--Scripts-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.0/jquery.min.js"></script>
    <script src="http://cdnjs.cloudflare.com/ajax/libs/modernizr/2.0.6/modernizr.min.js"></script>
    <script src="http://connect.facebook.net/en_US/all.js#xfbml=1"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.2.0/js/bootstrap.min.js"></script>
    <script src="http://twitter.github.com/bootstrap/assets/js/bootstrap-collapse.js"></script>
    <script src="/scripts/script.js"></script>
  </head>
  <body>
<!--Topbar-->
    <div class="navbar navbar-static-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="btn btn-navbar pull-right" data-toggle="collapse" data-target=".nav-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </a>
          <a class="brand" href="/">dogfeet</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li>
                <a href="/site/tagmap.html">Tagmap</a>
              </li>
              <li>
                <a href="/site/archive.html">Archive</a>
              </li>
              <li>
                <a href="/site/atelier.html">Atelier</a>
              </li>
              <li>
                <a href="http://feeds.feedburner.com/github/dogfeet">
                  <img src="http://forum.tattersite.com/ko/style/Textcube/feed-icon.png" />
                </a>
              </li>
            </ul>
            <form id="search-form" class="pull-right navbar-search" action="http://google.com/search" method="get">
              <input type="hidden" name="q" value="site:dogfeet.github.io" />
              <input type="text" name="q" results="0" placeholder="Search" search-query />
            </form>
          </div>
        </div>
      </div>
    </div>
<!--Markup-->
    <div class="container">
      <div>
        <script src="http://platform.twitter.com/widgets.js"></script>
<script>
  //facebook
(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) {return;}
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));

//google plusone
(function() {
  var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
  po.src = 'https://apis.google.com/js/plusone.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
})();

</script>
<section class="content">
  <article id="post" class="post undefined" typeof="sioc:post" about="/articles/2013/promise.html" lang="ko-kr">
    <div class="row">
      <div class="span2 muted modern-font small-font">
        <span property="dc:created">
          2013 Dec 18 &raquo;
        </span>
      </div>
      <div class="span10">
        <h1 property="dcterms:title">Promise</h1>
      </div>
    </div>
    <div class="row">
      <div class="offset2 span10 modern-font small-font muted">
<span>&nbsp; by <a href="https://twitter.com/lnyarl/">Yongjae Choi</a></span>
 | <a href="/site/tagmap.html#javascript" class="tag">javascript</a> <a href="/site/tagmap.html#promise" class="tag">promise</a> <a href="/site/tagmap.html#then" class="tag">then</a> <a href="/site/tagmap.html#q" class="tag">q</a> <a href="/site/tagmap.html#when" class="tag">when</a> <a href="/site/tagmap.html#aync" class="tag">aync</a>      </div>
    </div>
    <div class="row">
      <div class="offset2 span10">
<br/>        <style rel="stylesheet" media="screen, projection" scoped="scoped">
          #social-buttons {
  margin-left: 30px;
}
        </style>
        <div id="social-buttons" class="pull-right">
          <ul class="unstyled">
            <li>
              <a class="twitter-share-button" href="https://twitter.com/share" data-url="http://dogfeet.github.io/articles/2013/promise.html" data-via="lnyarl" data-count="horizontal" data-lang="en">Tweet</a>
            </li>
            <li>
              <div class="g-plusone" data-size="medium" data-href="http://dogfeet.github.io/articles/2013/promise.html"></div>
            </li>
            <li>
              <div class="fb-like" data-href="http://dogfeet.github.io/articles/2013/promise.html" data-send="false" data-layout="button_count" data-show-faces="false"></div>
            </li>
          </ul>
        </div>
        <div property="sioc:content">
          <p>수박 겉핥기 식이라 부끄럽지만 Promise에 대해 정리해보았다.</p>

<p><img src="/articles/2013/promise/promise.jpg" alt=""/><br/>
(무극(2006) - 점점 이 이미지 찾기에 더 많은 시간을 쏟는다-_-)</p>

<h2>Promise?</h2>

<p>promise는 자바스크립트에서 사용하는 비동기 연산의 최종 결과를 나타내는 객체이다. 비동기 함수를 호출했을때에 promise에 그 결과가 담긴다고 생각하면 편하다. 이를 이용하면 평소에 해왔던 비동기 코드를 더 높은 레벨의 추상화 객체로 다룰 수 있다. 그리고 일단 callback hell을 어느 정도 정리할 수있다. 코드를 먼저 보자.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> promise = doSomethingAync();
promise.then(onFulfilled, onRejected);
</code></pre>
<p>비동기 함수는 promise를 리턴하고 promise 객체의 then 메서드를 이용해 비동기 요청이 끝났을 때의 어떤 일을 할지 정의한다. onFulfilled는 정상적으로 비동기 함수가 끝났을 때 실행되고 onRejected는 비동기 함수가 비정상적으로 끝났을 때 실행된다. </p>

<p>이 글에서는 위에서 말한 정상종료와 비정상종료를 각각 <em>fulfilled</em>과 <em>rejected</em>라는 표현으로 쓸 것이다. 약속(promise)이 지켜지거나(fulfilled) 안지켜지는(rejected) 것을 모티브로 삼으면 될 것이다. 비동기는 나중에 작업을 완료하겠다는 하나의 약속이니까.</p>

<p>promise는 자바스크립트 언어 차원에서 지원하는 기능이 아니다. 여러 사람의 제안과 협의로 구현 스펙이 만들어졌고 지금은 <a href="https://github.com/kriskowal/q">q</a>나 <a href="https://github.com/cujojs/when">when</a>등을 사용하고 있다. nodejs는 물론 브라우저에서도 사용할 수 있다. JQuery에서도 promise를 지원한다.</p>

<p>주절주절 이야기를 할 예정인데 만약 &lsquo;아 됐고 사용법이나 알려줘'라는 생각이시라면 <code>Then</code> 섹션으로 곧바로 이동하길 바란다.</p>

<h2>Callback Hell</h2>

<p>promise는 어찌보면 사용하기 어렵다. 비동기의 결과를 저장한다는 개념도 이상하고 사용법도 혼란스러울 수 있는 여지가 많다. 물론 이는 익숙함의 문제다. 그렇다고 첫 만남의 어색함이 줄어드는 것은 아니다. 그럼 이런걸 왜 괜히 만들어서 사용하는 걸까.</p>

<p>모두 익숙하겠지만 자바스크립트의 세계에서는 <a href="/articles/2012/by-example-continuation-passing-style-in-javascript.html">CPS</a>를 이용해 비동기 요청을 처리한다. 쉽게 말해서 비동기 함수의 뒤쪽에 콜백 함수를 넘겨 콜백 함수를 응답이 왔을 때 핸들러로 사용한다. 이는 동작 방식을 이해하기 어렵지 않고 사용하기도 어렵지 않다. 그런것 처럼 보였다-_-</p>

<p>Callback Hell 이란게 있다. 중첩된 콜백은 코드를 이해하기 어렵게 만들고 변수의 scope가 믹스되어 사이드 이펙트가 생기기 쉽다. 관리되지 않는 자유로움이란 면에서도 코드는 스파게티가 되어가지만 무엇보다 자바스크립트는 이런 스타일을 강제하고 있다. <a href="http://callbackhell.com/">Callback Hell</a>사이트에서는 이런 문제를 어떻게 간단하게 만드는가에 대한 설명이 나온다.</p>

<p>Promise를 사용하면 이러한 문제를 꽤나 깔끔하게 해결할 수 있다. 간단한 예제를 보자. </p>
<pre><code class="lang-javascript">readFile(<span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> {</span>
  <span class="keyword">if</span> (err) <span class="keyword">return</span> console.error(err);
  console.log(data);
});
</code></pre>
<p>위 코드는 파일을 읽어서 에러가 있으면 에러를 출력하고 아니면 파일 안의 데이터를 출력하는 코드이다. nodejs 프로그래밍을 하면 흔히 볼 수있는 스타일이다. 만약 readFile함수가 promise를 리턴하면 다음과 같이 쓸 수 있다.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> promise = readFile();
promise.then(console.log, console.error);
</code></pre>
<p>극단적으로 간략화된 예제라서 신뢰성이 없어보이지만 핸들러안에서 if를 이용해 에러를 처리하고 만약 핸들러 안에서 다시 비동기 처리를 한다면? 비동기 처리를 세 번정도 중첩해보면 '지금 난 어디인가 이것은 무엇인가&rsquo; 소리가 절로 나온다. Promise는 이러한 복잡성을 꽤 잘 해결해준다.</p>

<h2>Then</h2>

<p>Promise객체는 then이라는 메서드를 가지고있다.(가지고 있어야 한다. 스펙이다.) then은 promise의 결과를 처리하기 위해 사용한다. 표현을 헷갈리면 안된다. <code>비동기 함수</code>는 <code>Promise</code>를 리턴하고 <code>Promise</code>는 <code>then</code>메서드를 이용해 비동기 처리의 결과를 조작할 수 있다. (여담이지만 promise 스펙에서는 then이라는 메서드가 정의된 객체를 thenable이라고 표현한다. 자바의 Runnable 인터페이스같은 느낌이다.)</p>

<p>then은 다음과 같이 생겼다.</p>
<pre><code class="lang-javascript">promise.then(onFulfilled, onRejected)
</code></pre>
<p>그리고 then의 특성은 다음과 같다.</p>

<ul>
<li>onFulfilled와 onRejected는 모두 함수다. 함수가 아니라면 그냥 무시된다. (딱히 에러가 나거나 하진 않는다.)</li>
<li>onFulfilled와 onRejected는 선택사항이다. 둘 다 인자로 넘겨도 되고 하나만 넘겨도 된다. 만약 onRejected만 넘기려면 <code>promise.then(null, onRejected)</code>와 같이 사용해야 한다.</li>
<li>onFulfilled는 promise가 fullfilled되면 실행된다. promise의 값은 onFulfilled의 첫번째 인자로 들어온다.</li>
<li>onRejected는 promise가 rejected되면 실행된다. 이 함수의 첫번째 인자로는 실패 원인이 들어온다.</li>
<li>둘 중 한 함수는 반드시 실행된다. 그리고 두 번 실행되지 않는다.</li>
<li>then메서드는 promise를 리턴한다.</li>
</ul>

<p>뭔가 복잡하다. 쉽게 말하자면 비동기 함수가 성공했을 때 부를 콜백 함수와 실패했을 때 부를 콜백 함수를 등록해두고 제때제때(성공하거나 실패했을때 - 어쨌든 둘 중 하나는 될꺼아닌가) 콜백 함수를 호출한다는 이야기다. <a href="http://promises-aplus.github.io/promises-spec/">스펙</a>을 보면 더 자세하게 적혀있지만 여기선 이 정도로 만족하자. 물론 fulfilled된다, rejected된다 라는 표현에는 익숙해져야 한다. fulfilled와 rejected의 판단기준은 각 비동기 함수마다 다르다. 파일을 읽는 함수라면 파일을 정상적으로 다 읽었을 때 fulfilled될것이고 그 외의 상황에서는 rejected가 될 것이다. http요청을 보내는 함수라면 응답이 정상적으로 왔을 때 fulfilled될 것이다. 예제로는 위에 적었던 파일 읽기가 좋겠다.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> promise = readFile();
promise.then(console.log, console.error);
</code></pre>
<p>console.log는 onFulfilled 함수고 console.error는 onRejected함수이다. 파일을 읽는데에 성공을 했으면 console.log가 실행되고 그 결과값인 파일 내용이 console.log의 첫 인자로 들어간다. 결국 파일의 내용이 화면에 찍힐 것이다. 파일을 읽는데에 실패했다면 promise가 이행되지 않고 에러의 원인이 console.error로 콘솔에 출력된다.</p>

<p>then메서드가 promise를 리턴한다는 말이 무슨 말인지 헷갈릴 수 있겠다. 비동기 요청을 이미 끝냈는데 다시 비동기 상태를 담는 promise가 왜 필요할까. callback hell 섹션에서 이야기 했던 중첩된 비동기 요청을 처리할 때에 이게 좋다. 이에 대해 이야기 해보자.</p>

<h3>Chaining</h3>

<p><em>then은 promise를 리턴한다.</em> 따라서 다음과 같은 코드가 가능하다.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> promise = readFile();
<span class="keyword">var</span> promise2 = promise.then(readAnotherFile, console.error);
promise2.then(console.log, console.error);
</code></pre>
<p>then은 언제나 promise를 리턴하므로 이에 대해 then을 더 호출할 수 있다. 깔끔하게 고쳐보자.</p>
<pre><code class="lang-javascript"><span class="keyword">var</span> promise = readFile();
promise
    .then(readAnotherFile, console.error)
    .then(console.log, console.error);
</code></pre>
<p>보기 편해졌다. 이렇게 중첩이 가능하다. 물론 다음과 같이 scope가 다른 곳에서도 promise는 동작한다.</p>
<pre><code class="lang-javascript"><span class="function"><span class="keyword">function</span> <span class="title">myfunction</span><span class="params">()</span> {</span>
  <span class="keyword">var</span> promise = readFile();
  <span class="keyword">return</span> promise.then(readAnotherFile, console.error);
}

thisIsPromise = myfunction();
thisIsPromise.then(console.log, console.error);
</code></pre>
<h4>핸들러의 리턴</h4>

<p>Chaining 과 관련해서 중요한 Then의 특징에 대해 알아보자. 일반적으로 promise는 비동기 함수가 리턴한 것을 곧바로 사용한다. 하지만 여러개의 promise가 중첩되어 사용할때는 then이 리턴한 promise를 사용할 때도 있다. 이런 경우가 생각보다 흔히 발생하므로 알아두면 좋다.</p>
<pre><code class="lang-javascript">promise2 = promise1.then(onFulfilled, onRejected);
</code></pre>
<p>위와 같은 코드가 있을 때 promise2는 다음과 같이 행동한다.</p>

<ul>
<li>onFulfilled나 onRejected가 예외를 던지면 promise2는 reject된다.</li>
<li>onFulfilled가 함수가 아닐 때 promise1이 filfilled되면 promise2는 항상 fulfilled된다.</li>
<li>onRejected가 함수가 아닐 때 promise1이 rejected되면 promise2는 항상 rejected된다.</li>
<li>onFulfilled나 onRejected가 어떤 값, x를 리턴하면 다음을 수행한다.

<ul>
<li>x가 promise라면 promise2는 x가 된다. (정확히는 promise2는 x처럼 행동한다. 즉, x가 fulfilled되면 promise2도 fulfilled되고 x가 rejected되면 promise2도 rejected된다. 실제로 promsie2와 x가 같은 객체라면 promise2는 reject된다.)</li>
<li>x가 thenable하다면 promise2는 x가 된다. (정확히는 promise2가 x처럼 행동한다. x.then은 첫번째 인자로 fulfilled 핸들러, 두 번째 인자로 rejected 핸들러를 전달받고 이 함수들을 호출해 promise2를 fulfilled 시키거나 rejected 시킨다.)</li>
<li>x가 그 외의 값이라면 promise2는 x를 인자로 fulfilled된다.(즉, fulfilled핸들러가 실행되고 그 핸들로의 첫번째 인자로 x가 넘어간다.)</li>
</ul></li>
</ul>

<p>&hellip; 써놓고 보니 복잡하다-_-) 여기에 추가적으로 thenable에 대한 이야기도 있지만 더 복잡해져서 뺀다. 요약하자면, fulfilled나 rejected핸들러에서 리턴한 값이 thenable이면 마치 promise2가 핸들러인것 처럼 동작한다. 아니면 promise2는 보통 fulfilled되고 예외가 발생하면 rejected된다.</p>

<p>세련되게 서술하는건 힘들구나. 예제가 더 쉽다.</p>
<pre><code class="lang-javascript">promise1 = readFile(<span class="string">"foo.txt"</span>);
promise1
    .then(<span class="keyword">function</span>(result) { <span class="keyword">return</span> result; })
    .then(<span class="keyword">function</span>(val) { console.log(val); });
</code></pre>
<p>위 코드에서 promise1이 fulfilled되면 result의 값이 출력된다. 첫 번째 then의 리턴 값(result)이 두 번째 then의 인자로 들어가기 때문이다. 이는 윗 섹션에서 다루었다.</p>
<pre><code class="lang-javascript">promise1 = readFile(<span class="string">"foo.txt"</span>);
promise1
    .then(<span class="keyword">function</span>(result) { <span class="keyword">return</span> writeFile(result); }) <span class="comment">// writeFile은 promise를 리턴한다.</span>
    .then(<span class="keyword">function</span>() { console.log(<span class="string">"ok"</span>); }, <span class="keyword">function</span>() { console.error(<span class="string">"fail"</span>); }); <span class="comment">// 이 then은 writeFile이 리턴한 promise에 맞물려 작동한다.</span>
</code></pre>
<p>위 코드는 writeFile이 promise를 리턴하므로 첫 번째 then의 fulfilled 핸들러가 promise를 리턴한다. 이때 두번째 then은 writeFile이 리턴한 promise가 해결이 되어야 실행된다. 즉 파일을 성공적으로 파일을 썼다면 ok가 출력되고, 실패했다면 &ldquo;fail&quot;이 출력된다. 만약 readFile이 실패했다면 promise1은 rejected되고 그 이후에 물려있는 then또한 rejected된다.(이유는 첫번째 then에 rejected 핸들러가 없기 때문이다.)</p>

<p>promise1의 핸들러에서 thenable 객체를 리턴하는 경우는 다음과 같다.</p>
<pre><code class="lang-javascript">thenable = {
  then : <span class="keyword">function</span>(onFulfilled, onRejected) {
    <span class="keyword">var</span> result = doSomething();

    <span class="keyword">if</span>(result) onFulfilled(<span class="string">"thenable success"</span>); <span class="comment">// 1. 이 onFulfilled는 `3`에서 첫번째 인자로 넘어가는 함수이다.</span>
    <span class="keyword">else</span> onRejected(e);
  }
};

promise1 = readFile(<span class="string">"foobar.txt"</span>)
  .then(<span class="function"><span class="keyword">function</span> <span class="params">(content)</span> {</span>
    console.log(<span class="string">"read ok"</span>);
    <span class="keyword">return</span> thenable;  <span class="comment">// 2. promise1은 thenable객체처럼 행동한다.</span>
  }, <span class="keyword">function</span>(reason) {
    console.log(<span class="string">"read fail : "</span>, reason);
  });

promsie2 = promise1
  .then(<span class="keyword">function</span>(message) { <span class="comment">// 3. 이 then은 thenable 객체의 then 메서드이다.</span>
    console.log(<span class="string">"promiese2 ok : "</span> + message);
  },
  <span class="keyword">function</span>(reason) {
    console.log(<span class="string">"promise2 fail : "</span> + reason);
  });
</code></pre>
<p>파일을 읽는 것이 성공했을 때 위 코드의 실행결과는</p>
<pre><code><span class="title">read</span> ok
<span class="title">promise2</span> ok : thenable success
</code></pre>
<p>가 된다.</p>

<h3>에러 핸들링</h3>

<p>여기까지 따라왔으면 에러핸들링은 어렵지 않다. fulfilled핸들러든 rejected든 실행될 때 예외가 발생하면 연결된 promise는 rejected된다.</p>
<pre><code class="lang-javascript">promise1 = ayncFunction();
promise1
  .then(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    <span class="keyword">if</span> (!data) <span class="keyword">throw</span> <span class="string">"no data"</span>;
  })
  .then(<span class="literal">null</span>, console.error);
</code></pre>
<p>위 코드는 첫번째 then에서 data가 없으면 예외를 던지고 연결되어 있는 then은 rejected되어 &quot;no data&quot;가 콘솔에 출력된다. 이 코드는 아래의 코드와 같다.</p>
<pre><code class="lang-javascript"><span class="keyword">try</span> {
  syncFunction();
} <span class="keyword">catch</span> (err) {
  console.error(err);
}
</code></pre>
<p>에러를 무시하고 싶으면 아래와 같이 하면 된다.</p>
<pre><code class="lang-javascript"><span class="keyword">try</span> {
  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'never will know this happened'</span>)
} <span class="keyword">catch</span> (e) {}
</code></pre><pre><code class="lang-javascript">readFile()
  .then(<span class="function"><span class="keyword">function</span> <span class="params">(data)</span> {</span>
    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'never will know this happened'</span>)
  })
</code></pre>
<p>위 두 코드는 모두 에러를 무시하는 코드이다. fulfilled나 rejected핸들러의 예외는 모두 promise의 제어 흐름에만 영향을 준다.</p>

<h2>결론</h2>

<p>이 프로그래밍 모델이 얼마나 많이 사용되고 널리 퍼졌는지 잘 모르겠다. 난 이제서야 사용하기 시작했고 공부겸 정리를 해본것이다. 많이 사용될수록 요구사항도 더 늘어날 수 있고 때문에 복잡해지고 지금 눈에 보이지 않는 문제들이 더 드러날수도 있다. 얼마나 복잡성을 잘 컨트롤 할지는 두고봐야하지만 우선은 괜찮다고 판단해서 지금 글을 쓴것이다.</p>

<p>또 다른 재미있는 메타포를 가진 모델이 나오면 좋을 것 같다.</p>

<h2>참고</h2>

<p><a href="http://howtonode.org/promises">http://howtonode.org/promises</a> : 영어가 부담스럽지 않다면 꼭 읽어보시길 바랍니다.<br/>
<a href="http://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/">http://strongloop.com/strongblog/promises-in-node-js-with-q-an-alternative-to-callbacks/</a> : promise와 q에 대해 설명이 잘 되어있다.<br/>
<a href="http://promises-aplus.github.io/promises-spec/">http://promises-aplus.github.io/promises-spec/</a> : promise의 명세서.<br/>
<a href="http://callbackhell.com/">http://callbackhell.com/</a> : Callback의 부정적인 사용법 모음</p>

        </div>
      </div>
    </div>
  </article>
</section>

      </div>
      <footer class="footer">
        <p>Copyright &copy; 2008-2013 Dogfeet from coding to pixels</p>
      </footer>
    </div>
<!--GA-->
    <script>
      if( 'http://dogfeet.github.io' === 'http://' + window.location.hostname ) {
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27493298-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
}
    </script>
  </body>
</html>
